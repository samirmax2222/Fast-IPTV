import {
  CHANNEL_SET_USER_AGENT,
  DataService,
  getExtensionFromUrl
} from "./chunk-T3L6IA2A.js";
import {
  __commonJS,
  __spreadProps,
  __spreadValues,
  __toESM,
  ɵsetClassDebugInfo,
  ɵɵNgOnChangesFeature,
  ɵɵStandaloneFeature,
  ɵɵdefineComponent,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵloadQuery,
  ɵɵqueryRefresh,
  ɵɵtext,
  ɵɵviewQuery
} from "./chunk-UIAHAIJK.js";

// node_modules/.pnpm/global@4.4.0/node_modules/global/window.js
var require_window = __commonJS({
  "node_modules/.pnpm/global@4.4.0/node_modules/global/window.js"(exports, module) {
    var win;
    if (typeof window !== "undefined") {
      win = window;
    } else if (typeof global !== "undefined") {
      win = global;
    } else if (typeof self !== "undefined") {
      win = self;
    } else {
      win = {};
    }
    module.exports = win;
  }
});

// node_modules/.pnpm/dom-walk@0.1.2/node_modules/dom-walk/index.js
var require_dom_walk = __commonJS({
  "node_modules/.pnpm/dom-walk@0.1.2/node_modules/dom-walk/index.js"(exports, module) {
    var slice = Array.prototype.slice;
    module.exports = iterativelyWalk;
    function iterativelyWalk(nodes, cb) {
      if (!("length" in nodes)) {
        nodes = [nodes];
      }
      nodes = slice.call(nodes);
      while (nodes.length) {
        var node = nodes.shift(), ret = cb(node);
        if (ret) {
          return ret;
        }
        if (node.childNodes && node.childNodes.length) {
          nodes = slice.call(node.childNodes).concat(nodes);
        }
      }
    }
  }
});

// node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/dom-comment.js
var require_dom_comment = __commonJS({
  "node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/dom-comment.js"(exports, module) {
    module.exports = Comment;
    function Comment(data, owner) {
      if (!(this instanceof Comment)) {
        return new Comment(data, owner);
      }
      this.data = data;
      this.nodeValue = data;
      this.length = data.length;
      this.ownerDocument = owner || null;
    }
    Comment.prototype.nodeType = 8;
    Comment.prototype.nodeName = "#comment";
    Comment.prototype.toString = function _Comment_toString() {
      return "[object Comment]";
    };
  }
});

// node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/dom-text.js
var require_dom_text = __commonJS({
  "node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/dom-text.js"(exports, module) {
    module.exports = DOMText;
    function DOMText(value, owner) {
      if (!(this instanceof DOMText)) {
        return new DOMText(value);
      }
      this.data = value || "";
      this.length = this.data.length;
      this.ownerDocument = owner || null;
    }
    DOMText.prototype.type = "DOMTextNode";
    DOMText.prototype.nodeType = 3;
    DOMText.prototype.nodeName = "#text";
    DOMText.prototype.toString = function _Text_toString() {
      return this.data;
    };
    DOMText.prototype.replaceData = function replaceData(index, length, value) {
      var current = this.data;
      var left = current.substring(0, index);
      var right = current.substring(index + length, current.length);
      this.data = left + value + right;
      this.length = this.data.length;
    };
  }
});

// node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/event/dispatch-event.js
var require_dispatch_event = __commonJS({
  "node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/event/dispatch-event.js"(exports, module) {
    module.exports = dispatchEvent;
    function dispatchEvent(ev) {
      var elem = this;
      var type2 = ev.type;
      if (!ev.target) {
        ev.target = elem;
      }
      if (!elem.listeners) {
        elem.listeners = {};
      }
      var listeners = elem.listeners[type2];
      if (listeners) {
        return listeners.forEach(function(listener) {
          ev.currentTarget = elem;
          if (typeof listener === "function") {
            listener(ev);
          } else {
            listener.handleEvent(ev);
          }
        });
      }
      if (elem.parentNode) {
        elem.parentNode.dispatchEvent(ev);
      }
    }
  }
});

// node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/event/add-event-listener.js
var require_add_event_listener = __commonJS({
  "node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/event/add-event-listener.js"(exports, module) {
    module.exports = addEventListener;
    function addEventListener(type2, listener) {
      var elem = this;
      if (!elem.listeners) {
        elem.listeners = {};
      }
      if (!elem.listeners[type2]) {
        elem.listeners[type2] = [];
      }
      if (elem.listeners[type2].indexOf(listener) === -1) {
        elem.listeners[type2].push(listener);
      }
    }
  }
});

// node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/event/remove-event-listener.js
var require_remove_event_listener = __commonJS({
  "node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/event/remove-event-listener.js"(exports, module) {
    module.exports = removeEventListener;
    function removeEventListener(type2, listener) {
      var elem = this;
      if (!elem.listeners) {
        return;
      }
      if (!elem.listeners[type2]) {
        return;
      }
      var list = elem.listeners[type2];
      var index = list.indexOf(listener);
      if (index !== -1) {
        list.splice(index, 1);
      }
    }
  }
});

// node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/serialize.js
var require_serialize = __commonJS({
  "node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/serialize.js"(exports, module) {
    module.exports = serializeNode;
    var voidElements = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"];
    function serializeNode(node) {
      switch (node.nodeType) {
        case 3:
          return escapeText(node.data);
        case 8:
          return "<!--" + node.data + "-->";
        default:
          return serializeElement(node);
      }
    }
    function serializeElement(elem) {
      var strings = [];
      var tagname = elem.tagName;
      if (elem.namespaceURI === "http://www.w3.org/1999/xhtml") {
        tagname = tagname.toLowerCase();
      }
      strings.push("<" + tagname + properties(elem) + datasetify(elem));
      if (voidElements.indexOf(tagname) > -1) {
        strings.push(" />");
      } else {
        strings.push(">");
        if (elem.childNodes.length) {
          strings.push.apply(strings, elem.childNodes.map(serializeNode));
        } else if (elem.textContent || elem.innerText) {
          strings.push(escapeText(elem.textContent || elem.innerText));
        } else if (elem.innerHTML) {
          strings.push(elem.innerHTML);
        }
        strings.push("</" + tagname + ">");
      }
      return strings.join("");
    }
    function isProperty(elem, key) {
      var type2 = typeof elem[key];
      if (key === "style" && Object.keys(elem.style).length > 0) {
        return true;
      }
      return elem.hasOwnProperty(key) && (type2 === "string" || type2 === "boolean" || type2 === "number") && key !== "nodeName" && key !== "className" && key !== "tagName" && key !== "textContent" && key !== "innerText" && key !== "namespaceURI" && key !== "innerHTML";
    }
    function stylify(styles) {
      if (typeof styles === "string") return styles;
      var attr = "";
      Object.keys(styles).forEach(function(key) {
        var value = styles[key];
        key = key.replace(/[A-Z]/g, function(c) {
          return "-" + c.toLowerCase();
        });
        attr += key + ":" + value + ";";
      });
      return attr;
    }
    function datasetify(elem) {
      var ds = elem.dataset;
      var props = [];
      for (var key in ds) {
        props.push({
          name: "data-" + key,
          value: ds[key]
        });
      }
      return props.length ? stringify(props) : "";
    }
    function stringify(list) {
      var attributes = [];
      list.forEach(function(tuple) {
        var name = tuple.name;
        var value = tuple.value;
        if (name === "style") {
          value = stylify(value);
        }
        attributes.push(name + '="' + escapeAttributeValue(value) + '"');
      });
      return attributes.length ? " " + attributes.join(" ") : "";
    }
    function properties(elem) {
      var props = [];
      for (var key in elem) {
        if (isProperty(elem, key)) {
          props.push({
            name: key,
            value: elem[key]
          });
        }
      }
      for (var ns in elem._attributes) {
        for (var attribute in elem._attributes[ns]) {
          var prop = elem._attributes[ns][attribute];
          var name = (prop.prefix ? prop.prefix + ":" : "") + attribute;
          props.push({
            name,
            value: prop.value
          });
        }
      }
      if (elem.className) {
        props.push({
          name: "class",
          value: elem.className
        });
      }
      return props.length ? stringify(props) : "";
    }
    function escapeText(s) {
      var str = "";
      if (typeof s === "string") {
        str = s;
      } else if (s) {
        str = s.toString();
      }
      return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    function escapeAttributeValue(str) {
      return escapeText(str).replace(/"/g, "&quot;");
    }
  }
});

// node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/dom-element.js
var require_dom_element = __commonJS({
  "node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/dom-element.js"(exports, module) {
    var domWalk = require_dom_walk();
    var dispatchEvent = require_dispatch_event();
    var addEventListener = require_add_event_listener();
    var removeEventListener = require_remove_event_listener();
    var serializeNode = require_serialize();
    var htmlns = "http://www.w3.org/1999/xhtml";
    module.exports = DOMElement;
    function DOMElement(tagName, owner, namespace) {
      if (!(this instanceof DOMElement)) {
        return new DOMElement(tagName);
      }
      var ns = namespace === void 0 ? htmlns : namespace || null;
      this.tagName = ns === htmlns ? String(tagName).toUpperCase() : tagName;
      this.nodeName = this.tagName;
      this.className = "";
      this.dataset = {};
      this.childNodes = [];
      this.parentNode = null;
      this.style = {};
      this.ownerDocument = owner || null;
      this.namespaceURI = ns;
      this._attributes = {};
      if (this.tagName === "INPUT") {
        this.type = "text";
      }
    }
    DOMElement.prototype.type = "DOMElement";
    DOMElement.prototype.nodeType = 1;
    DOMElement.prototype.appendChild = function _Element_appendChild(child) {
      if (child.parentNode) {
        child.parentNode.removeChild(child);
      }
      this.childNodes.push(child);
      child.parentNode = this;
      return child;
    };
    DOMElement.prototype.replaceChild = function _Element_replaceChild(elem, needle) {
      if (elem.parentNode) {
        elem.parentNode.removeChild(elem);
      }
      var index = this.childNodes.indexOf(needle);
      needle.parentNode = null;
      this.childNodes[index] = elem;
      elem.parentNode = this;
      return needle;
    };
    DOMElement.prototype.removeChild = function _Element_removeChild(elem) {
      var index = this.childNodes.indexOf(elem);
      this.childNodes.splice(index, 1);
      elem.parentNode = null;
      return elem;
    };
    DOMElement.prototype.insertBefore = function _Element_insertBefore(elem, needle) {
      if (elem.parentNode) {
        elem.parentNode.removeChild(elem);
      }
      var index = needle === null || needle === void 0 ? -1 : this.childNodes.indexOf(needle);
      if (index > -1) {
        this.childNodes.splice(index, 0, elem);
      } else {
        this.childNodes.push(elem);
      }
      elem.parentNode = this;
      return elem;
    };
    DOMElement.prototype.setAttributeNS = function _Element_setAttributeNS(namespace, name, value) {
      var prefix = null;
      var localName = name;
      var colonPosition = name.indexOf(":");
      if (colonPosition > -1) {
        prefix = name.substr(0, colonPosition);
        localName = name.substr(colonPosition + 1);
      }
      if (this.tagName === "INPUT" && name === "type") {
        this.type = value;
      } else {
        var attributes = this._attributes[namespace] || (this._attributes[namespace] = {});
        attributes[localName] = {
          value,
          prefix
        };
      }
    };
    DOMElement.prototype.getAttributeNS = function _Element_getAttributeNS(namespace, name) {
      var attributes = this._attributes[namespace];
      var value = attributes && attributes[name] && attributes[name].value;
      if (this.tagName === "INPUT" && name === "type") {
        return this.type;
      }
      if (typeof value !== "string") {
        return null;
      }
      return value;
    };
    DOMElement.prototype.removeAttributeNS = function _Element_removeAttributeNS(namespace, name) {
      var attributes = this._attributes[namespace];
      if (attributes) {
        delete attributes[name];
      }
    };
    DOMElement.prototype.hasAttributeNS = function _Element_hasAttributeNS(namespace, name) {
      var attributes = this._attributes[namespace];
      return !!attributes && name in attributes;
    };
    DOMElement.prototype.setAttribute = function _Element_setAttribute(name, value) {
      return this.setAttributeNS(null, name, value);
    };
    DOMElement.prototype.getAttribute = function _Element_getAttribute(name) {
      return this.getAttributeNS(null, name);
    };
    DOMElement.prototype.removeAttribute = function _Element_removeAttribute(name) {
      return this.removeAttributeNS(null, name);
    };
    DOMElement.prototype.hasAttribute = function _Element_hasAttribute(name) {
      return this.hasAttributeNS(null, name);
    };
    DOMElement.prototype.removeEventListener = removeEventListener;
    DOMElement.prototype.addEventListener = addEventListener;
    DOMElement.prototype.dispatchEvent = dispatchEvent;
    DOMElement.prototype.focus = function _Element_focus() {
      return void 0;
    };
    DOMElement.prototype.toString = function _Element_toString() {
      return serializeNode(this);
    };
    DOMElement.prototype.getElementsByClassName = function _Element_getElementsByClassName(classNames) {
      var classes = classNames.split(" ");
      var elems = [];
      domWalk(this, function(node) {
        if (node.nodeType === 1) {
          var nodeClassName = node.className || "";
          var nodeClasses = nodeClassName.split(" ");
          if (classes.every(function(item) {
            return nodeClasses.indexOf(item) !== -1;
          })) {
            elems.push(node);
          }
        }
      });
      return elems;
    };
    DOMElement.prototype.getElementsByTagName = function _Element_getElementsByTagName(tagName) {
      tagName = tagName.toLowerCase();
      var elems = [];
      domWalk(this.childNodes, function(node) {
        if (node.nodeType === 1 && (tagName === "*" || node.tagName.toLowerCase() === tagName)) {
          elems.push(node);
        }
      });
      return elems;
    };
    DOMElement.prototype.contains = function _Element_contains(element) {
      return domWalk(this, function(node) {
        return element === node;
      }) || false;
    };
  }
});

// node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/dom-fragment.js
var require_dom_fragment = __commonJS({
  "node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/dom-fragment.js"(exports, module) {
    var DOMElement = require_dom_element();
    module.exports = DocumentFragment;
    function DocumentFragment(owner) {
      if (!(this instanceof DocumentFragment)) {
        return new DocumentFragment();
      }
      this.childNodes = [];
      this.parentNode = null;
      this.ownerDocument = owner || null;
    }
    DocumentFragment.prototype.type = "DocumentFragment";
    DocumentFragment.prototype.nodeType = 11;
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.appendChild = DOMElement.prototype.appendChild;
    DocumentFragment.prototype.replaceChild = DOMElement.prototype.replaceChild;
    DocumentFragment.prototype.removeChild = DOMElement.prototype.removeChild;
    DocumentFragment.prototype.toString = function _DocumentFragment_toString() {
      return this.childNodes.map(function(node) {
        return String(node);
      }).join("");
    };
  }
});

// node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/event.js
var require_event = __commonJS({
  "node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/event.js"(exports, module) {
    module.exports = Event2;
    function Event2(family) {
    }
    Event2.prototype.initEvent = function _Event_initEvent(type2, bubbles, cancelable) {
      this.type = type2;
      this.bubbles = bubbles;
      this.cancelable = cancelable;
    };
    Event2.prototype.preventDefault = function _Event_preventDefault() {
    };
  }
});

// node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/document.js
var require_document = __commonJS({
  "node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/document.js"(exports, module) {
    var domWalk = require_dom_walk();
    var Comment = require_dom_comment();
    var DOMText = require_dom_text();
    var DOMElement = require_dom_element();
    var DocumentFragment = require_dom_fragment();
    var Event2 = require_event();
    var dispatchEvent = require_dispatch_event();
    var addEventListener = require_add_event_listener();
    var removeEventListener = require_remove_event_listener();
    module.exports = Document;
    function Document() {
      if (!(this instanceof Document)) {
        return new Document();
      }
      this.head = this.createElement("head");
      this.body = this.createElement("body");
      this.documentElement = this.createElement("html");
      this.documentElement.appendChild(this.head);
      this.documentElement.appendChild(this.body);
      this.childNodes = [this.documentElement];
      this.nodeType = 9;
    }
    var proto = Document.prototype;
    proto.createTextNode = function createTextNode(value) {
      return new DOMText(value, this);
    };
    proto.createElementNS = function createElementNS(namespace, tagName) {
      var ns = namespace === null ? null : String(namespace);
      return new DOMElement(tagName, this, ns);
    };
    proto.createElement = function createElement(tagName) {
      return new DOMElement(tagName, this);
    };
    proto.createDocumentFragment = function createDocumentFragment() {
      return new DocumentFragment(this);
    };
    proto.createEvent = function createEvent(family) {
      return new Event2(family);
    };
    proto.createComment = function createComment(data) {
      return new Comment(data, this);
    };
    proto.getElementById = function getElementById(id) {
      id = String(id);
      var result = domWalk(this.childNodes, function(node) {
        if (String(node.id) === id) {
          return node;
        }
      });
      return result || null;
    };
    proto.getElementsByClassName = DOMElement.prototype.getElementsByClassName;
    proto.getElementsByTagName = DOMElement.prototype.getElementsByTagName;
    proto.contains = DOMElement.prototype.contains;
    proto.removeEventListener = removeEventListener;
    proto.addEventListener = addEventListener;
    proto.dispatchEvent = dispatchEvent;
  }
});

// (disabled):node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/index.js
var require_min_document = __commonJS({
  "(disabled):node_modules/.pnpm/min-document@2.19.0/node_modules/min-document/index.js"(exports, module) {
    var Document = require_document();
    module.exports = new Document();
  }
});

// node_modules/.pnpm/global@4.4.0/node_modules/global/document.js
var require_document2 = __commonJS({
  "node_modules/.pnpm/global@4.4.0/node_modules/global/document.js"(exports, module) {
    var topLevel = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : {};
    var minDoc = require_min_document();
    var doccy;
    if (typeof document !== "undefined") {
      doccy = document;
    } else {
      doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"];
      if (!doccy) {
        doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"] = minDoc;
      }
    }
    module.exports = doccy;
  }
});

// node_modules/.pnpm/keycode@2.2.1/node_modules/keycode/index.js
var require_keycode = __commonJS({
  "node_modules/.pnpm/keycode@2.2.1/node_modules/keycode/index.js"(exports, module) {
    function keyCode(searchInput) {
      if (searchInput && "object" === typeof searchInput) {
        var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;
        if (hasKeyCode) searchInput = hasKeyCode;
      }
      if ("number" === typeof searchInput) return names[searchInput];
      var search = String(searchInput);
      var foundNamedKey = codes[search.toLowerCase()];
      if (foundNamedKey) return foundNamedKey;
      var foundNamedKey = aliases[search.toLowerCase()];
      if (foundNamedKey) return foundNamedKey;
      if (search.length === 1) return search.charCodeAt(0);
      return void 0;
    }
    keyCode.isEventKey = function isEventKey(event, nameOrCode) {
      if (event && "object" === typeof event) {
        var keyCode2 = event.which || event.keyCode || event.charCode;
        if (keyCode2 === null || keyCode2 === void 0) {
          return false;
        }
        if (typeof nameOrCode === "string") {
          var foundNamedKey = codes[nameOrCode.toLowerCase()];
          if (foundNamedKey) {
            return foundNamedKey === keyCode2;
          }
          var foundNamedKey = aliases[nameOrCode.toLowerCase()];
          if (foundNamedKey) {
            return foundNamedKey === keyCode2;
          }
        } else if (typeof nameOrCode === "number") {
          return nameOrCode === keyCode2;
        }
        return false;
      }
    };
    exports = module.exports = keyCode;
    var codes = exports.code = exports.codes = {
      "backspace": 8,
      "tab": 9,
      "enter": 13,
      "shift": 16,
      "ctrl": 17,
      "alt": 18,
      "pause/break": 19,
      "caps lock": 20,
      "esc": 27,
      "space": 32,
      "page up": 33,
      "page down": 34,
      "end": 35,
      "home": 36,
      "left": 37,
      "up": 38,
      "right": 39,
      "down": 40,
      "insert": 45,
      "delete": 46,
      "command": 91,
      "left command": 91,
      "right command": 93,
      "numpad *": 106,
      "numpad +": 107,
      "numpad -": 109,
      "numpad .": 110,
      "numpad /": 111,
      "num lock": 144,
      "scroll lock": 145,
      "my computer": 182,
      "my calculator": 183,
      ";": 186,
      "=": 187,
      ",": 188,
      "-": 189,
      ".": 190,
      "/": 191,
      "`": 192,
      "[": 219,
      "\\": 220,
      "]": 221,
      "'": 222
    };
    var aliases = exports.aliases = {
      "windows": 91,
      "\u21E7": 16,
      "\u2325": 18,
      "\u2303": 17,
      "\u2318": 91,
      "ctl": 17,
      "control": 17,
      "option": 18,
      "pause": 19,
      "break": 19,
      "caps": 20,
      "return": 13,
      "escape": 27,
      "spc": 32,
      "spacebar": 32,
      "pgup": 33,
      "pgdn": 34,
      "ins": 45,
      "del": 46,
      "cmd": 91
    };
    for (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32;
    for (i = 48; i < 58; i++) codes[i - 48] = i;
    var i;
    for (i = 1; i < 13; i++) codes["f" + i] = i + 111;
    for (i = 0; i < 10; i++) codes["numpad " + i] = i + 96;
    var names = exports.names = exports.title = {};
    for (i in codes) names[codes[i]] = i;
    for (alias in aliases) {
      codes[alias] = aliases[alias];
    }
    var alias;
  }
});

// node_modules/.pnpm/safe-json-parse@4.0.0/node_modules/safe-json-parse/tuple.js
var require_tuple = __commonJS({
  "node_modules/.pnpm/safe-json-parse@4.0.0/node_modules/safe-json-parse/tuple.js"(exports, module) {
    module.exports = SafeParseTuple;
    function SafeParseTuple(obj, reviver) {
      var json;
      var error = null;
      try {
        json = JSON.parse(obj, reviver);
      } catch (err) {
        error = err;
      }
      return [error, json];
    }
  }
});

// node_modules/.pnpm/@babel+runtime@7.27.0/node_modules/@babel/runtime/helpers/extends.js
var require_extends = __commonJS({
  "node_modules/.pnpm/@babel+runtime@7.27.0/node_modules/@babel/runtime/helpers/extends.js"(exports, module) {
    function _extends3() {
      return module.exports = _extends3 = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n[r2] = t2[r2]);
        }
        return n;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _extends3.apply(null, arguments);
    }
    module.exports = _extends3, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/.pnpm/is-function@1.0.2/node_modules/is-function/index.js
var require_is_function = __commonJS({
  "node_modules/.pnpm/is-function@1.0.2/node_modules/is-function/index.js"(exports, module) {
    module.exports = isFunction;
    var toString2 = Object.prototype.toString;
    function isFunction(fn) {
      if (!fn) {
        return false;
      }
      var string = toString2.call(fn);
      return string === "[object Function]" || typeof fn === "function" && string !== "[object RegExp]" || typeof window !== "undefined" && // IE8 and below
      (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
    }
  }
});

// node_modules/.pnpm/@videojs+xhr@2.6.0/node_modules/@videojs/xhr/lib/http-handler.js
var require_http_handler = __commonJS({
  "node_modules/.pnpm/@videojs+xhr@2.6.0/node_modules/@videojs/xhr/lib/http-handler.js"(exports, module) {
    "use strict";
    var window7 = require_window();
    var httpResponseHandler = function httpResponseHandler2(callback2, decodeResponseBody) {
      if (decodeResponseBody === void 0) {
        decodeResponseBody = false;
      }
      return function(err, response, responseBody) {
        if (err) {
          callback2(err);
          return;
        }
        if (response.statusCode >= 400 && response.statusCode <= 599) {
          var cause = responseBody;
          if (decodeResponseBody) {
            if (window7.TextDecoder) {
              var charset = getCharset(response.headers && response.headers["content-type"]);
              try {
                cause = new TextDecoder(charset).decode(responseBody);
              } catch (e) {
              }
            } else {
              cause = String.fromCharCode.apply(null, new Uint8Array(responseBody));
            }
          }
          callback2({
            cause
          });
          return;
        }
        callback2(null, responseBody);
      };
    };
    function getCharset(contentTypeHeader) {
      if (contentTypeHeader === void 0) {
        contentTypeHeader = "";
      }
      return contentTypeHeader.toLowerCase().split(";").reduce(function(charset, contentType) {
        var _contentType$split = contentType.split("="), type2 = _contentType$split[0], value = _contentType$split[1];
        if (type2.trim() === "charset") {
          return value.trim();
        }
        return charset;
      }, "utf-8");
    }
    module.exports = httpResponseHandler;
  }
});

// node_modules/.pnpm/@videojs+xhr@2.6.0/node_modules/@videojs/xhr/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/@videojs+xhr@2.6.0/node_modules/@videojs/xhr/lib/index.js"(exports, module) {
    "use strict";
    var window7 = require_window();
    var _extends3 = require_extends();
    var isFunction = require_is_function();
    createXHR.httpHandler = require_http_handler();
    var parseHeaders = function parseHeaders2(headers) {
      var result = {};
      if (!headers) {
        return result;
      }
      headers.trim().split("\n").forEach(function(row) {
        var index = row.indexOf(":");
        var key = row.slice(0, index).trim().toLowerCase();
        var value = row.slice(index + 1).trim();
        if (typeof result[key] === "undefined") {
          result[key] = value;
        } else if (Array.isArray(result[key])) {
          result[key].push(value);
        } else {
          result[key] = [result[key], value];
        }
      });
      return result;
    };
    module.exports = createXHR;
    module.exports.default = createXHR;
    createXHR.XMLHttpRequest = window7.XMLHttpRequest || noop4;
    createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window7.XDomainRequest;
    forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
      createXHR[method === "delete" ? "del" : method] = function(uri, options, callback2) {
        options = initParams(uri, options, callback2);
        options.method = method.toUpperCase();
        return _createXHR(options);
      };
    });
    function forEachArray(array, iterator) {
      for (var i = 0; i < array.length; i++) {
        iterator(array[i]);
      }
    }
    function isEmpty(obj) {
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) return false;
      }
      return true;
    }
    function initParams(uri, options, callback2) {
      var params = uri;
      if (isFunction(options)) {
        callback2 = options;
        if (typeof uri === "string") {
          params = {
            uri
          };
        }
      } else {
        params = _extends3({}, options, {
          uri
        });
      }
      params.callback = callback2;
      return params;
    }
    function createXHR(uri, options, callback2) {
      options = initParams(uri, options, callback2);
      return _createXHR(options);
    }
    function _createXHR(options) {
      if (typeof options.callback === "undefined") {
        throw new Error("callback argument missing");
      }
      var called = false;
      var callback2 = function cbOnce(err, response, body2) {
        if (!called) {
          called = true;
          options.callback(err, response, body2);
        }
      };
      function readystatechange() {
        if (xhr.readyState === 4) {
          setTimeout(loadFunc, 0);
        }
      }
      function getBody() {
        var body2 = void 0;
        if (xhr.response) {
          body2 = xhr.response;
        } else {
          body2 = xhr.responseText || getXml(xhr);
        }
        if (isJson) {
          try {
            body2 = JSON.parse(body2);
          } catch (e) {
          }
        }
        return body2;
      }
      function errorFunc(evt) {
        clearTimeout(timeoutTimer);
        if (!(evt instanceof Error)) {
          evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"));
        }
        evt.statusCode = 0;
        return callback2(evt, failureResponse);
      }
      function loadFunc() {
        if (aborted) return;
        var status2;
        clearTimeout(timeoutTimer);
        if (options.useXDR && xhr.status === void 0) {
          status2 = 200;
        } else {
          status2 = xhr.status === 1223 ? 204 : xhr.status;
        }
        var response = failureResponse;
        var err = null;
        if (status2 !== 0) {
          response = {
            body: getBody(),
            statusCode: status2,
            method,
            headers: {},
            url: uri,
            rawRequest: xhr
          };
          if (xhr.getAllResponseHeaders) {
            response.headers = parseHeaders(xhr.getAllResponseHeaders());
          }
        } else {
          err = new Error("Internal XMLHttpRequest Error");
        }
        return callback2(err, response, response.body);
      }
      var xhr = options.xhr || null;
      if (!xhr) {
        if (options.cors || options.useXDR) {
          xhr = new createXHR.XDomainRequest();
        } else {
          xhr = new createXHR.XMLHttpRequest();
        }
      }
      var key;
      var aborted;
      var uri = xhr.url = options.uri || options.url;
      var method = xhr.method = options.method || "GET";
      var body = options.body || options.data;
      var headers = xhr.headers = options.headers || {};
      var sync = !!options.sync;
      var isJson = false;
      var timeoutTimer;
      var failureResponse = {
        body: void 0,
        headers: {},
        statusCode: 0,
        method,
        url: uri,
        rawRequest: xhr
      };
      if ("json" in options && options.json !== false) {
        isJson = true;
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json");
        if (method !== "GET" && method !== "HEAD") {
          headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json");
          body = JSON.stringify(options.json === true ? body : options.json);
        }
      }
      xhr.onreadystatechange = readystatechange;
      xhr.onload = loadFunc;
      xhr.onerror = errorFunc;
      xhr.onprogress = function() {
      };
      xhr.onabort = function() {
        aborted = true;
      };
      xhr.ontimeout = errorFunc;
      xhr.open(method, uri, !sync, options.username, options.password);
      if (!sync) {
        xhr.withCredentials = !!options.withCredentials;
      }
      if (!sync && options.timeout > 0) {
        timeoutTimer = setTimeout(function() {
          if (aborted) return;
          aborted = true;
          xhr.abort("timeout");
          var e = new Error("XMLHttpRequest timeout");
          e.code = "ETIMEDOUT";
          errorFunc(e);
        }, options.timeout);
      }
      if (xhr.setRequestHeader) {
        for (key in headers) {
          if (headers.hasOwnProperty(key)) {
            xhr.setRequestHeader(key, headers[key]);
          }
        }
      } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object");
      }
      if ("responseType" in options) {
        xhr.responseType = options.responseType;
      }
      if ("beforeSend" in options && typeof options.beforeSend === "function") {
        options.beforeSend(xhr);
      }
      xhr.send(body || null);
      return xhr;
    }
    function getXml(xhr) {
      try {
        if (xhr.responseType === "document") {
          return xhr.responseXML;
        }
        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
        if (xhr.responseType === "" && !firefoxBugTakenEffect) {
          return xhr.responseXML;
        }
      } catch (e) {
      }
      return null;
    }
    function noop4() {
    }
  }
});

// node_modules/.pnpm/videojs-vtt.js@0.15.5/node_modules/videojs-vtt.js/lib/vtt.js
var require_vtt = __commonJS({
  "node_modules/.pnpm/videojs-vtt.js@0.15.5/node_modules/videojs-vtt.js/lib/vtt.js"(exports, module) {
    var document3 = require_document2();
    var _objCreate = Object.create || /* @__PURE__ */ function() {
      function F() {
      }
      return function(o) {
        if (arguments.length !== 1) {
          throw new Error("Object.create shim only accepts one parameter.");
        }
        F.prototype = o;
        return new F();
      };
    }();
    function ParsingError(errorData, message) {
      this.name = "ParsingError";
      this.code = errorData.code;
      this.message = message || errorData.message;
    }
    ParsingError.prototype = _objCreate(Error.prototype);
    ParsingError.prototype.constructor = ParsingError;
    ParsingError.Errors = {
      BadSignature: {
        code: 0,
        message: "Malformed WebVTT signature."
      },
      BadTimeStamp: {
        code: 1,
        message: "Malformed time stamp."
      }
    };
    function parseTimeStamp2(input) {
      function computeSeconds(h, m2, s, f) {
        return (h | 0) * 3600 + (m2 | 0) * 60 + (s | 0) + (f | 0) / 1e3;
      }
      var m = input.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/);
      if (!m) {
        return null;
      }
      if (m[3]) {
        return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]);
      } else if (m[1] > 59) {
        return computeSeconds(m[1], m[2], 0, m[4]);
      } else {
        return computeSeconds(0, m[1], m[2], m[4]);
      }
    }
    function Settings2() {
      this.values = _objCreate(null);
    }
    Settings2.prototype = {
      // Only accept the first assignment to any key.
      set: function(k, v) {
        if (!this.get(k) && v !== "") {
          this.values[k] = v;
        }
      },
      // Return the value for a key, or a default value.
      // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
      // a number of possible default values as properties where 'defaultKey' is
      // the key of the property that will be chosen; otherwise it's assumed to be
      // a single value.
      get: function(k, dflt, defaultKey) {
        if (defaultKey) {
          return this.has(k) ? this.values[k] : dflt[defaultKey];
        }
        return this.has(k) ? this.values[k] : dflt;
      },
      // Check whether we have a value for a key.
      has: function(k) {
        return k in this.values;
      },
      // Accept a setting if its one of the given alternatives.
      alt: function(k, v, a) {
        for (var n = 0; n < a.length; ++n) {
          if (v === a[n]) {
            this.set(k, v);
            break;
          }
        }
      },
      // Accept a setting if its a valid (signed) integer.
      integer: function(k, v) {
        if (/^-?\d+$/.test(v)) {
          this.set(k, parseInt(v, 10));
        }
      },
      // Accept a setting if its a valid percentage.
      percent: function(k, v) {
        var m;
        if (m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
          v = parseFloat(v);
          if (v >= 0 && v <= 100) {
            this.set(k, v);
            return true;
          }
        }
        return false;
      }
    };
    function parseOptions2(input, callback2, keyValueDelim, groupDelim) {
      var groups = groupDelim ? input.split(groupDelim) : [input];
      for (var i in groups) {
        if (typeof groups[i] !== "string") {
          continue;
        }
        var kv = groups[i].split(keyValueDelim);
        if (kv.length !== 2) {
          continue;
        }
        var k = kv[0].trim();
        var v = kv[1].trim();
        callback2(k, v);
      }
    }
    function parseCue2(input, cue, regionList) {
      var oInput = input;
      function consumeTimeStamp() {
        var ts2 = parseTimeStamp2(input);
        if (ts2 === null) {
          throw new ParsingError(ParsingError.Errors.BadTimeStamp, "Malformed timestamp: " + oInput);
        }
        input = input.replace(/^[^\sa-zA-Z-]+/, "");
        return ts2;
      }
      function consumeCueSettings(input2, cue2) {
        var settings = new Settings2();
        parseOptions2(input2, function(k, v) {
          switch (k) {
            case "region":
              for (var i = regionList.length - 1; i >= 0; i--) {
                if (regionList[i].id === v) {
                  settings.set(k, regionList[i].region);
                  break;
                }
              }
              break;
            case "vertical":
              settings.alt(k, v, ["rl", "lr"]);
              break;
            case "line":
              var vals = v.split(","), vals0 = vals[0];
              settings.integer(k, vals0);
              settings.percent(k, vals0) ? settings.set("snapToLines", false) : null;
              settings.alt(k, vals0, ["auto"]);
              if (vals.length === 2) {
                settings.alt("lineAlign", vals[1], ["start", "center", "end"]);
              }
              break;
            case "position":
              vals = v.split(",");
              settings.percent(k, vals[0]);
              if (vals.length === 2) {
                settings.alt("positionAlign", vals[1], ["start", "center", "end"]);
              }
              break;
            case "size":
              settings.percent(k, v);
              break;
            case "align":
              settings.alt(k, v, ["start", "center", "end", "left", "right"]);
              break;
          }
        }, /:/, /\s/);
        cue2.region = settings.get("region", null);
        cue2.vertical = settings.get("vertical", "");
        try {
          cue2.line = settings.get("line", "auto");
        } catch (e) {
        }
        cue2.lineAlign = settings.get("lineAlign", "start");
        cue2.snapToLines = settings.get("snapToLines", true);
        cue2.size = settings.get("size", 100);
        try {
          cue2.align = settings.get("align", "center");
        } catch (e) {
          cue2.align = settings.get("align", "middle");
        }
        try {
          cue2.position = settings.get("position", "auto");
        } catch (e) {
          cue2.position = settings.get("position", {
            start: 0,
            left: 0,
            center: 50,
            middle: 50,
            end: 100,
            right: 100
          }, cue2.align);
        }
        cue2.positionAlign = settings.get("positionAlign", {
          start: "start",
          left: "start",
          center: "center",
          middle: "center",
          end: "end",
          right: "end"
        }, cue2.align);
      }
      function skipWhitespace() {
        input = input.replace(/^\s+/, "");
      }
      skipWhitespace();
      cue.startTime = consumeTimeStamp();
      skipWhitespace();
      if (input.substr(0, 3) !== "-->") {
        throw new ParsingError(ParsingError.Errors.BadTimeStamp, "Malformed time stamp (time stamps must be separated by '-->'): " + oInput);
      }
      input = input.substr(3);
      skipWhitespace();
      cue.endTime = consumeTimeStamp();
      skipWhitespace();
      consumeCueSettings(input, cue);
    }
    var TEXTAREA_ELEMENT = document3.createElement && document3.createElement("textarea");
    var TAG_NAME = {
      c: "span",
      i: "i",
      b: "b",
      u: "u",
      ruby: "ruby",
      rt: "rt",
      v: "span",
      lang: "span"
    };
    var DEFAULT_COLOR_CLASS = {
      white: "rgba(255,255,255,1)",
      lime: "rgba(0,255,0,1)",
      cyan: "rgba(0,255,255,1)",
      red: "rgba(255,0,0,1)",
      yellow: "rgba(255,255,0,1)",
      magenta: "rgba(255,0,255,1)",
      blue: "rgba(0,0,255,1)",
      black: "rgba(0,0,0,1)"
    };
    var TAG_ANNOTATION = {
      v: "title",
      lang: "lang"
    };
    var NEEDS_PARENT = {
      rt: "ruby"
    };
    function parseContent(window7, input) {
      function nextToken() {
        if (!input) {
          return null;
        }
        function consume(result) {
          input = input.substr(result.length);
          return result;
        }
        var m2 = input.match(/^([^<]*)(<[^>]*>?)?/);
        return consume(m2[1] ? m2[1] : m2[2]);
      }
      function unescape2(s) {
        TEXTAREA_ELEMENT.innerHTML = s;
        s = TEXTAREA_ELEMENT.textContent;
        TEXTAREA_ELEMENT.textContent = "";
        return s;
      }
      function shouldAdd(current2, element) {
        return !NEEDS_PARENT[element.localName] || NEEDS_PARENT[element.localName] === current2.localName;
      }
      function createElement(type2, annotation) {
        var tagName = TAG_NAME[type2];
        if (!tagName) {
          return null;
        }
        var element = window7.document.createElement(tagName);
        var name = TAG_ANNOTATION[type2];
        if (name && annotation) {
          element[name] = annotation.trim();
        }
        return element;
      }
      var rootDiv = window7.document.createElement("div"), current = rootDiv, t2, tagStack = [];
      while ((t2 = nextToken()) !== null) {
        if (t2[0] === "<") {
          if (t2[1] === "/") {
            if (tagStack.length && tagStack[tagStack.length - 1] === t2.substr(2).replace(">", "")) {
              tagStack.pop();
              current = current.parentNode;
            }
            continue;
          }
          var ts2 = parseTimeStamp2(t2.substr(1, t2.length - 2));
          var node;
          if (ts2) {
            node = window7.document.createProcessingInstruction("timestamp", ts2);
            current.appendChild(node);
            continue;
          }
          var m = t2.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
          if (!m) {
            continue;
          }
          node = createElement(m[1], m[3]);
          if (!node) {
            continue;
          }
          if (!shouldAdd(current, node)) {
            continue;
          }
          if (m[2]) {
            var classes = m[2].split(".");
            classes.forEach(function(cl) {
              var bgColor = /^bg_/.test(cl);
              var colorName = bgColor ? cl.slice(3) : cl;
              if (DEFAULT_COLOR_CLASS.hasOwnProperty(colorName)) {
                var propName = bgColor ? "background-color" : "color";
                var propValue = DEFAULT_COLOR_CLASS[colorName];
                node.style[propName] = propValue;
              }
            });
            node.className = classes.join(" ");
          }
          tagStack.push(m[1]);
          current.appendChild(node);
          current = node;
          continue;
        }
        current.appendChild(window7.document.createTextNode(unescape2(t2)));
      }
      return rootDiv;
    }
    var strongRTLRanges = [[1470, 1470], [1472, 1472], [1475, 1475], [1478, 1478], [1488, 1514], [1520, 1524], [1544, 1544], [1547, 1547], [1549, 1549], [1563, 1563], [1566, 1610], [1645, 1647], [1649, 1749], [1765, 1766], [1774, 1775], [1786, 1805], [1807, 1808], [1810, 1839], [1869, 1957], [1969, 1969], [1984, 2026], [2036, 2037], [2042, 2042], [2048, 2069], [2074, 2074], [2084, 2084], [2088, 2088], [2096, 2110], [2112, 2136], [2142, 2142], [2208, 2208], [2210, 2220], [8207, 8207], [64285, 64285], [64287, 64296], [64298, 64310], [64312, 64316], [64318, 64318], [64320, 64321], [64323, 64324], [64326, 64449], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65020], [65136, 65140], [65142, 65276], [67584, 67589], [67592, 67592], [67594, 67637], [67639, 67640], [67644, 67644], [67647, 67669], [67671, 67679], [67840, 67867], [67872, 67897], [67903, 67903], [67968, 68023], [68030, 68031], [68096, 68096], [68112, 68115], [68117, 68119], [68121, 68147], [68160, 68167], [68176, 68184], [68192, 68223], [68352, 68405], [68416, 68437], [68440, 68466], [68472, 68479], [68608, 68680], [126464, 126467], [126469, 126495], [126497, 126498], [126500, 126500], [126503, 126503], [126505, 126514], [126516, 126519], [126521, 126521], [126523, 126523], [126530, 126530], [126535, 126535], [126537, 126537], [126539, 126539], [126541, 126543], [126545, 126546], [126548, 126548], [126551, 126551], [126553, 126553], [126555, 126555], [126557, 126557], [126559, 126559], [126561, 126562], [126564, 126564], [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], [126590, 126590], [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [1114109, 1114109]];
    function isStrongRTLChar(charCode) {
      for (var i = 0; i < strongRTLRanges.length; i++) {
        var currentRange = strongRTLRanges[i];
        if (charCode >= currentRange[0] && charCode <= currentRange[1]) {
          return true;
        }
      }
      return false;
    }
    function determineBidi(cueDiv) {
      var nodeStack = [], text = "", charCode;
      if (!cueDiv || !cueDiv.childNodes) {
        return "ltr";
      }
      function pushNodes(nodeStack2, node) {
        for (var i2 = node.childNodes.length - 1; i2 >= 0; i2--) {
          nodeStack2.push(node.childNodes[i2]);
        }
      }
      function nextTextNode(nodeStack2) {
        if (!nodeStack2 || !nodeStack2.length) {
          return null;
        }
        var node = nodeStack2.pop(), text2 = node.textContent || node.innerText;
        if (text2) {
          var m = text2.match(/^.*(\n|\r)/);
          if (m) {
            nodeStack2.length = 0;
            return m[0];
          }
          return text2;
        }
        if (node.tagName === "ruby") {
          return nextTextNode(nodeStack2);
        }
        if (node.childNodes) {
          pushNodes(nodeStack2, node);
          return nextTextNode(nodeStack2);
        }
      }
      pushNodes(nodeStack, cueDiv);
      while (text = nextTextNode(nodeStack)) {
        for (var i = 0; i < text.length; i++) {
          charCode = text.charCodeAt(i);
          if (isStrongRTLChar(charCode)) {
            return "rtl";
          }
        }
      }
      return "ltr";
    }
    function computeLinePos(cue) {
      if (typeof cue.line === "number" && (cue.snapToLines || cue.line >= 0 && cue.line <= 100)) {
        return cue.line;
      }
      if (!cue.track || !cue.track.textTrackList || !cue.track.textTrackList.mediaElement) {
        return -1;
      }
      var track = cue.track, trackList = track.textTrackList, count = 0;
      for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {
        if (trackList[i].mode === "showing") {
          count++;
        }
      }
      return ++count * -1;
    }
    function StyleBox() {
    }
    StyleBox.prototype.applyStyles = function(styles, div) {
      div = div || this.div;
      for (var prop in styles) {
        if (styles.hasOwnProperty(prop)) {
          div.style[prop] = styles[prop];
        }
      }
    };
    StyleBox.prototype.formatStyle = function(val, unit) {
      return val === 0 ? 0 : val + unit;
    };
    function CueStyleBox(window7, cue, styleOptions) {
      StyleBox.call(this);
      this.cue = cue;
      this.cueDiv = parseContent(window7, cue.text);
      var styles = {
        color: "rgba(255, 255, 255, 1)",
        backgroundColor: "rgba(0, 0, 0, 0.8)",
        position: "relative",
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        display: "inline",
        writingMode: cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl",
        unicodeBidi: "plaintext"
      };
      this.applyStyles(styles, this.cueDiv);
      this.div = window7.document.createElement("div");
      styles = {
        direction: determineBidi(this.cueDiv),
        writingMode: cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl",
        unicodeBidi: "plaintext",
        textAlign: cue.align === "middle" ? "center" : cue.align,
        font: styleOptions.font,
        whiteSpace: "pre-line",
        position: "absolute"
      };
      this.applyStyles(styles);
      this.div.appendChild(this.cueDiv);
      var textPos = 0;
      switch (cue.positionAlign) {
        case "start":
        case "line-left":
          textPos = cue.position;
          break;
        case "center":
          textPos = cue.position - cue.size / 2;
          break;
        case "end":
        case "line-right":
          textPos = cue.position - cue.size;
          break;
      }
      if (cue.vertical === "") {
        this.applyStyles({
          left: this.formatStyle(textPos, "%"),
          width: this.formatStyle(cue.size, "%")
        });
      } else {
        this.applyStyles({
          top: this.formatStyle(textPos, "%"),
          height: this.formatStyle(cue.size, "%")
        });
      }
      this.move = function(box) {
        this.applyStyles({
          top: this.formatStyle(box.top, "px"),
          bottom: this.formatStyle(box.bottom, "px"),
          left: this.formatStyle(box.left, "px"),
          right: this.formatStyle(box.right, "px"),
          height: this.formatStyle(box.height, "px"),
          width: this.formatStyle(box.width, "px")
        });
      };
    }
    CueStyleBox.prototype = _objCreate(StyleBox.prototype);
    CueStyleBox.prototype.constructor = CueStyleBox;
    function BoxPosition(obj) {
      var lh, height2, width2, top;
      if (obj.div) {
        height2 = obj.div.offsetHeight;
        width2 = obj.div.offsetWidth;
        top = obj.div.offsetTop;
        var rects = (rects = obj.div.childNodes) && (rects = rects[0]) && rects.getClientRects && rects.getClientRects();
        obj = obj.div.getBoundingClientRect();
        lh = rects ? Math.max(rects[0] && rects[0].height || 0, obj.height / rects.length) : 0;
      }
      this.left = obj.left;
      this.right = obj.right;
      this.top = obj.top || top;
      this.height = obj.height || height2;
      this.bottom = obj.bottom || top + (obj.height || height2);
      this.width = obj.width || width2;
      this.lineHeight = lh !== void 0 ? lh : obj.lineHeight;
    }
    BoxPosition.prototype.move = function(axis, toMove) {
      toMove = toMove !== void 0 ? toMove : this.lineHeight;
      switch (axis) {
        case "+x":
          this.left += toMove;
          this.right += toMove;
          break;
        case "-x":
          this.left -= toMove;
          this.right -= toMove;
          break;
        case "+y":
          this.top += toMove;
          this.bottom += toMove;
          break;
        case "-y":
          this.top -= toMove;
          this.bottom -= toMove;
          break;
      }
    };
    BoxPosition.prototype.overlaps = function(b2) {
      return this.left < b2.right && this.right > b2.left && this.top < b2.bottom && this.bottom > b2.top;
    };
    BoxPosition.prototype.overlapsAny = function(boxes) {
      for (var i = 0; i < boxes.length; i++) {
        if (this.overlaps(boxes[i])) {
          return true;
        }
      }
      return false;
    };
    BoxPosition.prototype.within = function(container) {
      return this.top >= container.top && this.bottom <= container.bottom && this.left >= container.left && this.right <= container.right;
    };
    BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {
      switch (axis) {
        case "+x":
          return this.left < container.left;
        case "-x":
          return this.right > container.right;
        case "+y":
          return this.top < container.top;
        case "-y":
          return this.bottom > container.bottom;
      }
    };
    BoxPosition.prototype.intersectPercentage = function(b2) {
      var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)), y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)), intersectArea = x * y;
      return intersectArea / (this.height * this.width);
    };
    BoxPosition.prototype.toCSSCompatValues = function(reference) {
      return {
        top: this.top - reference.top,
        bottom: reference.bottom - this.bottom,
        left: this.left - reference.left,
        right: reference.right - this.right,
        height: this.height,
        width: this.width
      };
    };
    BoxPosition.getSimpleBoxPosition = function(obj) {
      var height2 = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;
      var width2 = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;
      var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;
      obj = obj.div ? obj.div.getBoundingClientRect() : obj.tagName ? obj.getBoundingClientRect() : obj;
      var ret = {
        left: obj.left,
        right: obj.right,
        top: obj.top || top,
        height: obj.height || height2,
        bottom: obj.bottom || top + (obj.height || height2),
        width: obj.width || width2
      };
      return ret;
    };
    function moveBoxToLinePosition(window7, styleBox, containerBox, boxPositions) {
      function findBestPosition(b, axis2) {
        var bestPosition2, specifiedPosition = new BoxPosition(b), percentage = 1;
        for (var i = 0; i < axis2.length; i++) {
          while (b.overlapsOppositeAxis(containerBox, axis2[i]) || b.within(containerBox) && b.overlapsAny(boxPositions)) {
            b.move(axis2[i]);
          }
          if (b.within(containerBox)) {
            return b;
          }
          var p = b.intersectPercentage(containerBox);
          if (percentage > p) {
            bestPosition2 = new BoxPosition(b);
            percentage = p;
          }
          b = new BoxPosition(specifiedPosition);
        }
        return bestPosition2 || specifiedPosition;
      }
      var boxPosition = new BoxPosition(styleBox), cue = styleBox.cue, linePos = computeLinePos(cue), axis = [];
      if (cue.snapToLines) {
        var size;
        switch (cue.vertical) {
          case "":
            axis = ["+y", "-y"];
            size = "height";
            break;
          case "rl":
            axis = ["+x", "-x"];
            size = "width";
            break;
          case "lr":
            axis = ["-x", "+x"];
            size = "width";
            break;
        }
        var step = boxPosition.lineHeight, position = step * Math.round(linePos), maxPosition = containerBox[size] + step, initialAxis = axis[0];
        if (Math.abs(position) > maxPosition) {
          position = position < 0 ? -1 : 1;
          position *= Math.ceil(maxPosition / step) * step;
        }
        if (linePos < 0) {
          position += cue.vertical === "" ? containerBox.height : containerBox.width;
          axis = axis.reverse();
        }
        boxPosition.move(initialAxis, position);
      } else {
        var calculatedPercentage = boxPosition.lineHeight / containerBox.height * 100;
        switch (cue.lineAlign) {
          case "center":
            linePos -= calculatedPercentage / 2;
            break;
          case "end":
            linePos -= calculatedPercentage;
            break;
        }
        switch (cue.vertical) {
          case "":
            styleBox.applyStyles({
              top: styleBox.formatStyle(linePos, "%")
            });
            break;
          case "rl":
            styleBox.applyStyles({
              left: styleBox.formatStyle(linePos, "%")
            });
            break;
          case "lr":
            styleBox.applyStyles({
              right: styleBox.formatStyle(linePos, "%")
            });
            break;
        }
        axis = ["+y", "-x", "+x", "-y"];
        boxPosition = new BoxPosition(styleBox);
      }
      var bestPosition = findBestPosition(boxPosition, axis);
      styleBox.move(bestPosition.toCSSCompatValues(containerBox));
    }
    function WebVTT2() {
    }
    WebVTT2.StringDecoder = function() {
      return {
        decode: function(data) {
          if (!data) {
            return "";
          }
          if (typeof data !== "string") {
            throw new Error("Error - expected string data.");
          }
          return decodeURIComponent(encodeURIComponent(data));
        }
      };
    };
    WebVTT2.convertCueToDOMTree = function(window7, cuetext) {
      if (!window7 || !cuetext) {
        return null;
      }
      return parseContent(window7, cuetext);
    };
    var FONT_SIZE_PERCENT = 0.05;
    var FONT_STYLE = "sans-serif";
    var CUE_BACKGROUND_PADDING = "1.5%";
    WebVTT2.processCues = function(window7, cues, overlay) {
      if (!window7 || !cues || !overlay) {
        return null;
      }
      while (overlay.firstChild) {
        overlay.removeChild(overlay.firstChild);
      }
      var paddedOverlay = window7.document.createElement("div");
      paddedOverlay.style.position = "absolute";
      paddedOverlay.style.left = "0";
      paddedOverlay.style.right = "0";
      paddedOverlay.style.top = "0";
      paddedOverlay.style.bottom = "0";
      paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
      overlay.appendChild(paddedOverlay);
      function shouldCompute(cues2) {
        for (var i2 = 0; i2 < cues2.length; i2++) {
          if (cues2[i2].hasBeenReset || !cues2[i2].displayState) {
            return true;
          }
        }
        return false;
      }
      if (!shouldCompute(cues)) {
        for (var i = 0; i < cues.length; i++) {
          paddedOverlay.appendChild(cues[i].displayState);
        }
        return;
      }
      var boxPositions = [], containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay), fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
      var styleOptions = {
        font: fontSize + "px " + FONT_STYLE
      };
      (function() {
        var styleBox, cue;
        for (var i2 = 0; i2 < cues.length; i2++) {
          cue = cues[i2];
          styleBox = new CueStyleBox(window7, cue, styleOptions);
          paddedOverlay.appendChild(styleBox.div);
          moveBoxToLinePosition(window7, styleBox, containerBox, boxPositions);
          cue.displayState = styleBox.div;
          boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
        }
      })();
    };
    WebVTT2.Parser = function(window7, vttjs, decoder2) {
      if (!decoder2) {
        decoder2 = vttjs;
        vttjs = {};
      }
      if (!vttjs) {
        vttjs = {};
      }
      this.window = window7;
      this.vttjs = vttjs;
      this.state = "INITIAL";
      this.buffer = "";
      this.decoder = decoder2 || new TextDecoder("utf8");
      this.regionList = [];
    };
    WebVTT2.Parser.prototype = {
      // If the error is a ParsingError then report it to the consumer if
      // possible. If it's not a ParsingError then throw it like normal.
      reportOrThrowError: function(e) {
        if (e instanceof ParsingError) {
          this.onparsingerror && this.onparsingerror(e);
        } else {
          throw e;
        }
      },
      parse: function(data) {
        var self2 = this;
        if (data) {
          self2.buffer += self2.decoder.decode(data, {
            stream: true
          });
        }
        function collectNextLine() {
          var buffer = self2.buffer;
          var pos = 0;
          while (pos < buffer.length && buffer[pos] !== "\r" && buffer[pos] !== "\n") {
            ++pos;
          }
          var line2 = buffer.substr(0, pos);
          if (buffer[pos] === "\r") {
            ++pos;
          }
          if (buffer[pos] === "\n") {
            ++pos;
          }
          self2.buffer = buffer.substr(pos);
          return line2;
        }
        function parseRegion(input) {
          var settings = new Settings2();
          parseOptions2(input, function(k, v) {
            switch (k) {
              case "id":
                settings.set(k, v);
                break;
              case "width":
                settings.percent(k, v);
                break;
              case "lines":
                settings.integer(k, v);
                break;
              case "regionanchor":
              case "viewportanchor":
                var xy = v.split(",");
                if (xy.length !== 2) {
                  break;
                }
                var anchor = new Settings2();
                anchor.percent("x", xy[0]);
                anchor.percent("y", xy[1]);
                if (!anchor.has("x") || !anchor.has("y")) {
                  break;
                }
                settings.set(k + "X", anchor.get("x"));
                settings.set(k + "Y", anchor.get("y"));
                break;
              case "scroll":
                settings.alt(k, v, ["up"]);
                break;
            }
          }, /=/, /\s/);
          if (settings.has("id")) {
            var region = new (self2.vttjs.VTTRegion || self2.window.VTTRegion)();
            region.width = settings.get("width", 100);
            region.lines = settings.get("lines", 3);
            region.regionAnchorX = settings.get("regionanchorX", 0);
            region.regionAnchorY = settings.get("regionanchorY", 100);
            region.viewportAnchorX = settings.get("viewportanchorX", 0);
            region.viewportAnchorY = settings.get("viewportanchorY", 100);
            region.scroll = settings.get("scroll", "");
            self2.onregion && self2.onregion(region);
            self2.regionList.push({
              id: settings.get("id"),
              region
            });
          }
        }
        function parseTimestampMap(input) {
          var settings = new Settings2();
          parseOptions2(input, function(k, v) {
            switch (k) {
              case "MPEGT":
                settings.integer(k + "S", v);
                break;
              case "LOCA":
                settings.set(k + "L", parseTimeStamp2(v));
                break;
            }
          }, /[^\d]:/, /,/);
          self2.ontimestampmap && self2.ontimestampmap({
            "MPEGTS": settings.get("MPEGTS"),
            "LOCAL": settings.get("LOCAL")
          });
        }
        function parseHeader2(input) {
          if (input.match(/X-TIMESTAMP-MAP/)) {
            parseOptions2(input, function(k, v) {
              switch (k) {
                case "X-TIMESTAMP-MAP":
                  parseTimestampMap(v);
                  break;
              }
            }, /=/);
          } else {
            parseOptions2(input, function(k, v) {
              switch (k) {
                case "Region":
                  parseRegion(v);
                  break;
              }
            }, /:/);
          }
        }
        try {
          var line;
          if (self2.state === "INITIAL") {
            if (!/\r\n|\n/.test(self2.buffer)) {
              return this;
            }
            line = collectNextLine();
            var m = line.match(/^WEBVTT([ \t].*)?$/);
            if (!m || !m[0]) {
              throw new ParsingError(ParsingError.Errors.BadSignature);
            }
            self2.state = "HEADER";
          }
          var alreadyCollectedLine = false;
          while (self2.buffer) {
            if (!/\r\n|\n/.test(self2.buffer)) {
              return this;
            }
            if (!alreadyCollectedLine) {
              line = collectNextLine();
            } else {
              alreadyCollectedLine = false;
            }
            switch (self2.state) {
              case "HEADER":
                if (/:/.test(line)) {
                  parseHeader2(line);
                } else if (!line) {
                  self2.state = "ID";
                }
                continue;
              case "NOTE":
                if (!line) {
                  self2.state = "ID";
                }
                continue;
              case "ID":
                if (/^NOTE($|[ \t])/.test(line)) {
                  self2.state = "NOTE";
                  break;
                }
                if (!line) {
                  continue;
                }
                self2.cue = new (self2.vttjs.VTTCue || self2.window.VTTCue)(0, 0, "");
                try {
                  self2.cue.align = "center";
                } catch (e) {
                  self2.cue.align = "middle";
                }
                self2.state = "CUE";
                if (line.indexOf("-->") === -1) {
                  self2.cue.id = line;
                  continue;
                }
              case "CUE":
                try {
                  parseCue2(line, self2.cue, self2.regionList);
                } catch (e) {
                  self2.reportOrThrowError(e);
                  self2.cue = null;
                  self2.state = "BADCUE";
                  continue;
                }
                self2.state = "CUETEXT";
                continue;
              case "CUETEXT":
                var hasSubstring = line.indexOf("-->") !== -1;
                if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                  self2.oncue && self2.oncue(self2.cue);
                  self2.cue = null;
                  self2.state = "ID";
                  continue;
                }
                if (self2.cue.text) {
                  self2.cue.text += "\n";
                }
                self2.cue.text += line.replace(/\u2028/g, "\n").replace(/u2029/g, "\n");
                continue;
              case "BADCUE":
                if (!line) {
                  self2.state = "ID";
                }
                continue;
            }
          }
        } catch (e) {
          self2.reportOrThrowError(e);
          if (self2.state === "CUETEXT" && self2.cue && self2.oncue) {
            self2.oncue(self2.cue);
          }
          self2.cue = null;
          self2.state = self2.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
        }
        return this;
      },
      flush: function() {
        var self2 = this;
        try {
          self2.buffer += self2.decoder.decode();
          if (self2.cue || self2.state === "HEADER") {
            self2.buffer += "\n\n";
            self2.parse();
          }
          if (self2.state === "INITIAL") {
            throw new ParsingError(ParsingError.Errors.BadSignature);
          }
        } catch (e) {
          self2.reportOrThrowError(e);
        }
        self2.onflush && self2.onflush();
        return this;
      }
    };
    module.exports = WebVTT2;
  }
});

// node_modules/.pnpm/videojs-vtt.js@0.15.5/node_modules/videojs-vtt.js/lib/vttcue.js
var require_vttcue = __commonJS({
  "node_modules/.pnpm/videojs-vtt.js@0.15.5/node_modules/videojs-vtt.js/lib/vttcue.js"(exports, module) {
    var autoKeyword = "auto";
    var directionSetting = {
      "": 1,
      "lr": 1,
      "rl": 1
    };
    var alignSetting = {
      "start": 1,
      "center": 1,
      "end": 1,
      "left": 1,
      "right": 1,
      "auto": 1,
      "line-left": 1,
      "line-right": 1
    };
    function findDirectionSetting(value) {
      if (typeof value !== "string") {
        return false;
      }
      var dir = directionSetting[value.toLowerCase()];
      return dir ? value.toLowerCase() : false;
    }
    function findAlignSetting(value) {
      if (typeof value !== "string") {
        return false;
      }
      var align = alignSetting[value.toLowerCase()];
      return align ? value.toLowerCase() : false;
    }
    function VTTCue2(startTime, endTime, text) {
      this.hasBeenReset = false;
      var _id = "";
      var _pauseOnExit = false;
      var _startTime = startTime;
      var _endTime = endTime;
      var _text = text;
      var _region = null;
      var _vertical = "";
      var _snapToLines = true;
      var _line = "auto";
      var _lineAlign = "start";
      var _position = "auto";
      var _positionAlign = "auto";
      var _size = 100;
      var _align = "center";
      Object.defineProperties(this, {
        "id": {
          enumerable: true,
          get: function() {
            return _id;
          },
          set: function(value) {
            _id = "" + value;
          }
        },
        "pauseOnExit": {
          enumerable: true,
          get: function() {
            return _pauseOnExit;
          },
          set: function(value) {
            _pauseOnExit = !!value;
          }
        },
        "startTime": {
          enumerable: true,
          get: function() {
            return _startTime;
          },
          set: function(value) {
            if (typeof value !== "number") {
              throw new TypeError("Start time must be set to a number.");
            }
            _startTime = value;
            this.hasBeenReset = true;
          }
        },
        "endTime": {
          enumerable: true,
          get: function() {
            return _endTime;
          },
          set: function(value) {
            if (typeof value !== "number") {
              throw new TypeError("End time must be set to a number.");
            }
            _endTime = value;
            this.hasBeenReset = true;
          }
        },
        "text": {
          enumerable: true,
          get: function() {
            return _text;
          },
          set: function(value) {
            _text = "" + value;
            this.hasBeenReset = true;
          }
        },
        "region": {
          enumerable: true,
          get: function() {
            return _region;
          },
          set: function(value) {
            _region = value;
            this.hasBeenReset = true;
          }
        },
        "vertical": {
          enumerable: true,
          get: function() {
            return _vertical;
          },
          set: function(value) {
            var setting = findDirectionSetting(value);
            if (setting === false) {
              throw new SyntaxError("Vertical: an invalid or illegal direction string was specified.");
            }
            _vertical = setting;
            this.hasBeenReset = true;
          }
        },
        "snapToLines": {
          enumerable: true,
          get: function() {
            return _snapToLines;
          },
          set: function(value) {
            _snapToLines = !!value;
            this.hasBeenReset = true;
          }
        },
        "line": {
          enumerable: true,
          get: function() {
            return _line;
          },
          set: function(value) {
            if (typeof value !== "number" && value !== autoKeyword) {
              throw new SyntaxError("Line: an invalid number or illegal string was specified.");
            }
            _line = value;
            this.hasBeenReset = true;
          }
        },
        "lineAlign": {
          enumerable: true,
          get: function() {
            return _lineAlign;
          },
          set: function(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              console.warn("lineAlign: an invalid or illegal string was specified.");
            } else {
              _lineAlign = setting;
              this.hasBeenReset = true;
            }
          }
        },
        "position": {
          enumerable: true,
          get: function() {
            return _position;
          },
          set: function(value) {
            if (value < 0 || value > 100) {
              throw new Error("Position must be between 0 and 100.");
            }
            _position = value;
            this.hasBeenReset = true;
          }
        },
        "positionAlign": {
          enumerable: true,
          get: function() {
            return _positionAlign;
          },
          set: function(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              console.warn("positionAlign: an invalid or illegal string was specified.");
            } else {
              _positionAlign = setting;
              this.hasBeenReset = true;
            }
          }
        },
        "size": {
          enumerable: true,
          get: function() {
            return _size;
          },
          set: function(value) {
            if (value < 0 || value > 100) {
              throw new Error("Size must be between 0 and 100.");
            }
            _size = value;
            this.hasBeenReset = true;
          }
        },
        "align": {
          enumerable: true,
          get: function() {
            return _align;
          },
          set: function(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              throw new SyntaxError("align: an invalid or illegal alignment string was specified.");
            }
            _align = setting;
            this.hasBeenReset = true;
          }
        }
      });
      this.displayState = void 0;
    }
    VTTCue2.prototype.getCueAsHTML = function() {
      return WebVTT.convertCueToDOMTree(window, this.text);
    };
    module.exports = VTTCue2;
  }
});

// node_modules/.pnpm/videojs-vtt.js@0.15.5/node_modules/videojs-vtt.js/lib/vttregion.js
var require_vttregion = __commonJS({
  "node_modules/.pnpm/videojs-vtt.js@0.15.5/node_modules/videojs-vtt.js/lib/vttregion.js"(exports, module) {
    var scrollSetting = {
      "": true,
      "up": true
    };
    function findScrollSetting(value) {
      if (typeof value !== "string") {
        return false;
      }
      var scroll = scrollSetting[value.toLowerCase()];
      return scroll ? value.toLowerCase() : false;
    }
    function isValidPercentValue(value) {
      return typeof value === "number" && value >= 0 && value <= 100;
    }
    function VTTRegion() {
      var _width = 100;
      var _lines = 3;
      var _regionAnchorX = 0;
      var _regionAnchorY = 100;
      var _viewportAnchorX = 0;
      var _viewportAnchorY = 100;
      var _scroll = "";
      Object.defineProperties(this, {
        "width": {
          enumerable: true,
          get: function() {
            return _width;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("Width must be between 0 and 100.");
            }
            _width = value;
          }
        },
        "lines": {
          enumerable: true,
          get: function() {
            return _lines;
          },
          set: function(value) {
            if (typeof value !== "number") {
              throw new TypeError("Lines must be set to a number.");
            }
            _lines = value;
          }
        },
        "regionAnchorY": {
          enumerable: true,
          get: function() {
            return _regionAnchorY;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("RegionAnchorX must be between 0 and 100.");
            }
            _regionAnchorY = value;
          }
        },
        "regionAnchorX": {
          enumerable: true,
          get: function() {
            return _regionAnchorX;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("RegionAnchorY must be between 0 and 100.");
            }
            _regionAnchorX = value;
          }
        },
        "viewportAnchorY": {
          enumerable: true,
          get: function() {
            return _viewportAnchorY;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("ViewportAnchorY must be between 0 and 100.");
            }
            _viewportAnchorY = value;
          }
        },
        "viewportAnchorX": {
          enumerable: true,
          get: function() {
            return _viewportAnchorX;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("ViewportAnchorX must be between 0 and 100.");
            }
            _viewportAnchorX = value;
          }
        },
        "scroll": {
          enumerable: true,
          get: function() {
            return _scroll;
          },
          set: function(value) {
            var setting = findScrollSetting(value);
            if (setting === false) {
              console.warn("Scroll: an invalid or illegal string was specified.");
            } else {
              _scroll = setting;
            }
          }
        }
      });
    }
    module.exports = VTTRegion;
  }
});

// node_modules/.pnpm/videojs-vtt.js@0.15.5/node_modules/videojs-vtt.js/lib/browser-index.js
var require_browser_index = __commonJS({
  "node_modules/.pnpm/videojs-vtt.js@0.15.5/node_modules/videojs-vtt.js/lib/browser-index.js"(exports, module) {
    var window7 = require_window();
    var vttjs = module.exports = {
      WebVTT: require_vtt(),
      VTTCue: require_vttcue(),
      VTTRegion: require_vttregion()
    };
    window7.vttjs = vttjs;
    window7.WebVTT = vttjs.WebVTT;
    var cueShim = vttjs.VTTCue;
    var regionShim = vttjs.VTTRegion;
    var nativeVTTCue = window7.VTTCue;
    var nativeVTTRegion = window7.VTTRegion;
    vttjs.shim = function() {
      window7.VTTCue = cueShim;
      window7.VTTRegion = regionShim;
    };
    vttjs.restore = function() {
      window7.VTTCue = nativeVTTCue;
      window7.VTTRegion = nativeVTTRegion;
    };
    if (!window7.VTTCue) {
      vttjs.shim();
    }
  }
});

// node_modules/.pnpm/url-toolkit@2.2.5/node_modules/url-toolkit/src/url-toolkit.js
var require_url_toolkit = __commonJS({
  "node_modules/.pnpm/url-toolkit@2.2.5/node_modules/url-toolkit/src/url-toolkit.js"(exports, module) {
    (function(root) {
      var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
      var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
      var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
      var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
      var URLToolkit2 = {
        // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
        // E.g
        // With opts.alwaysNormalize = false (default, spec compliant)
        // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
        // With opts.alwaysNormalize = true (not spec compliant)
        // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
        buildAbsoluteURL: function(baseURL, relativeURL, opts) {
          opts = opts || {};
          baseURL = baseURL.trim();
          relativeURL = relativeURL.trim();
          if (!relativeURL) {
            if (!opts.alwaysNormalize) {
              return baseURL;
            }
            var basePartsForNormalise = URLToolkit2.parseURL(baseURL);
            if (!basePartsForNormalise) {
              throw new Error("Error trying to parse base URL.");
            }
            basePartsForNormalise.path = URLToolkit2.normalizePath(basePartsForNormalise.path);
            return URLToolkit2.buildURLFromParts(basePartsForNormalise);
          }
          var relativeParts = URLToolkit2.parseURL(relativeURL);
          if (!relativeParts) {
            throw new Error("Error trying to parse relative URL.");
          }
          if (relativeParts.scheme) {
            if (!opts.alwaysNormalize) {
              return relativeURL;
            }
            relativeParts.path = URLToolkit2.normalizePath(relativeParts.path);
            return URLToolkit2.buildURLFromParts(relativeParts);
          }
          var baseParts = URLToolkit2.parseURL(baseURL);
          if (!baseParts) {
            throw new Error("Error trying to parse base URL.");
          }
          if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== "/") {
            var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
            baseParts.netLoc = pathParts[1];
            baseParts.path = pathParts[2];
          }
          if (baseParts.netLoc && !baseParts.path) {
            baseParts.path = "/";
          }
          var builtParts = {
            // 2c) Otherwise, the embedded URL inherits the scheme of
            // the base URL.
            scheme: baseParts.scheme,
            netLoc: relativeParts.netLoc,
            path: null,
            params: relativeParts.params,
            query: relativeParts.query,
            fragment: relativeParts.fragment
          };
          if (!relativeParts.netLoc) {
            builtParts.netLoc = baseParts.netLoc;
            if (relativeParts.path[0] !== "/") {
              if (!relativeParts.path) {
                builtParts.path = baseParts.path;
                if (!relativeParts.params) {
                  builtParts.params = baseParts.params;
                  if (!relativeParts.query) {
                    builtParts.query = baseParts.query;
                  }
                }
              } else {
                var baseURLPath = baseParts.path;
                var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf("/") + 1) + relativeParts.path;
                builtParts.path = URLToolkit2.normalizePath(newPath);
              }
            }
          }
          if (builtParts.path === null) {
            builtParts.path = opts.alwaysNormalize ? URLToolkit2.normalizePath(relativeParts.path) : relativeParts.path;
          }
          return URLToolkit2.buildURLFromParts(builtParts);
        },
        parseURL: function(url) {
          var parts = URL_REGEX.exec(url);
          if (!parts) {
            return null;
          }
          return {
            scheme: parts[1] || "",
            netLoc: parts[2] || "",
            path: parts[3] || "",
            params: parts[4] || "",
            query: parts[5] || "",
            fragment: parts[6] || ""
          };
        },
        normalizePath: function(path) {
          path = path.split("").reverse().join("").replace(SLASH_DOT_REGEX, "");
          while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, "")).length) {
          }
          return path.split("").reverse().join("");
        },
        buildURLFromParts: function(parts) {
          return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
        }
      };
      if (typeof exports === "object" && typeof module === "object") module.exports = URLToolkit2;
      else if (typeof define === "function" && define.amd) define([], function() {
        return URLToolkit2;
      });
      else if (typeof exports === "object") exports["URLToolkit"] = URLToolkit2;
      else root["URLToolkit"] = URLToolkit2;
    })(exports);
  }
});

// node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = __commonJS({
  "node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/conventions.js"(exports) {
    "use strict";
    function find(list, predicate, ac) {
      if (ac === void 0) {
        ac = Array.prototype;
      }
      if (list && typeof ac.find === "function") {
        return ac.find.call(list, predicate);
      }
      for (var i = 0; i < list.length; i++) {
        if (Object.prototype.hasOwnProperty.call(list, i)) {
          var item = list[i];
          if (predicate.call(void 0, item, i, list)) {
            return item;
          }
        }
      }
    }
    function freeze(object, oc) {
      if (oc === void 0) {
        oc = Object;
      }
      return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
    }
    var MIME_TYPE = freeze({
      /**
       * `text/html`, the only mime type that triggers treating an XML document as HTML.
       *
       * @see DOMParser.SupportedType.isHTML
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
       */
      HTML: "text/html",
      /**
       * Helper method to check a mime type if it indicates an HTML document
       *
       * @param {string} [value]
       * @returns {boolean}
       *
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
      isHTML: function(value) {
        return value === MIME_TYPE.HTML;
      },
      /**
       * `application/xml`, the standard mime type for XML documents.
       *
       * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
       * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_APPLICATION: "application/xml",
      /**
       * `text/html`, an alias for `application/xml`.
       *
       * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
       * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_TEXT: "text/xml",
      /**
       * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
       * but is parsed as an XML document.
       *
       * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
       * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
       */
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      /**
       * `image/svg+xml`,
       *
       * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
       * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
       * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
       */
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var NAMESPACE = freeze({
      /**
       * The XHTML namespace.
       *
       * @see http://www.w3.org/1999/xhtml
       */
      HTML: "http://www.w3.org/1999/xhtml",
      /**
       * Checks if `uri` equals `NAMESPACE.HTML`.
       *
       * @param {string} [uri]
       *
       * @see NAMESPACE.HTML
       */
      isHTML: function(uri) {
        return uri === NAMESPACE.HTML;
      },
      /**
       * The SVG namespace.
       *
       * @see http://www.w3.org/2000/svg
       */
      SVG: "http://www.w3.org/2000/svg",
      /**
       * The `xml:` namespace.
       *
       * @see http://www.w3.org/XML/1998/namespace
       */
      XML: "http://www.w3.org/XML/1998/namespace",
      /**
       * The `xmlns:` namespace
       *
       * @see https://www.w3.org/2000/xmlns/
       */
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    exports.find = find;
    exports.freeze = freeze;
    exports.MIME_TYPE = MIME_TYPE;
    exports.NAMESPACE = NAMESPACE;
  }
});

// node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = __commonJS({
  "node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/dom.js"(exports) {
    var conventions = require_conventions();
    var find = conventions.find;
    var NAMESPACE = conventions.NAMESPACE;
    function notEmptyString(input) {
      return input !== "";
    }
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    function orderedSetReducer(current, element) {
      if (!current.hasOwnProperty(element)) {
        current[element] = true;
      }
      return current;
    }
    function toOrderedSet(input) {
      if (!input) return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    function copy(src, dest) {
      for (var p in src) {
        if (Object.prototype.hasOwnProperty.call(src, p)) {
          dest[p] = src[p];
        }
      }
    }
    function _extends3(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        let t3 = function() {
        };
        var t2 = t3;
        ;
        t3.prototype = Super.prototype;
        t3 = new t3();
        copy(pt, t3);
        Class.prototype = pt = t3;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var ExceptionCode = {};
    var ExceptionMessage = {};
    var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
    var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
    var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
    var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
    var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
    var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
    var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
    var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
    var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
    var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
    var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
    var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
    function DOMException2(code, message) {
      if (message instanceof Error) {
        var error = message;
      } else {
        error = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException2);
      }
      error.code = code;
      if (message) this.message = this.message + ": " + message;
      return error;
    }
    DOMException2.prototype = Error.prototype;
    copy(ExceptionCode, DOMException2);
    function NodeList() {
    }
    NodeList.prototype = {
      /**
       * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
       * @standard level1
       */
      length: 0,
      /**
       * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
       * @standard level1
       * @param index  unsigned long
       *   Index into the collection.
       * @return Node
       * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
       */
      item: function(index) {
        return index >= 0 && index < this.length ? this[index] : null;
      },
      toString: function(isHTML, nodeFilter) {
        for (var buf = [], i = 0; i < this.length; i++) {
          serializeToString(this[i], buf, isHTML, nodeFilter);
        }
        return buf.join("");
      },
      /**
       * @private
       * @param {function (Node):boolean} predicate
       * @returns {Node[]}
       */
      filter: function(predicate) {
        return Array.prototype.filter.call(this, predicate);
      },
      /**
       * @private
       * @param {Node} item
       * @returns {number}
       */
      indexOf: function(item) {
        return Array.prototype.indexOf.call(this, item);
      }
    };
    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc !== inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        if (!list.$$length || ls.length < list.$$length) {
          for (var i = ls.length; i in list; i++) {
            if (Object.prototype.hasOwnProperty.call(list, i)) {
              delete list[i];
            }
          }
        }
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i) {
      _updateLiveList(this);
      return this[i] || null;
    };
    _extends3(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    function _findNodeIndex(list, node) {
      var i = list.length;
      while (i--) {
        if (list[i] === node) {
          return i;
        }
      }
    }
    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }
    function _removeNamedNode(el, list, attr) {
      var i = _findNodeIndex(list, attr);
      if (i >= 0) {
        var lastIndex = list.length - 1;
        while (i < lastIndex) {
          list[i] = list[++i];
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw new DOMException2(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function(key) {
        var i = this.length;
        while (i--) {
          var attr = this[i];
          if (attr.nodeName == key) {
            return attr;
          }
        }
      },
      setNamedItem: function(attr) {
        var el = attr.ownerElement;
        if (el && el != this._ownerElement) {
          throw new DOMException2(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      setNamedItemNS: function(attr) {
        var el = attr.ownerElement, oldAttr;
        if (el && el != this._ownerElement) {
          throw new DOMException2(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      removeNamedItem: function(key) {
        var attr = this.getNamedItem(key);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
      //for level2
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function(namespaceURI, localName) {
        var i = this.length;
        while (i--) {
          var node = this[i];
          if (node.localName == localName && node.namespaceURI == namespaceURI) {
            return node;
          }
        }
        return null;
      }
    };
    function DOMImplementation() {
    }
    DOMImplementation.prototype = {
      /**
       * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
       * The different implementations fairly diverged in what kind of features were reported.
       * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
       *
       * @deprecated It is deprecated and modern browsers return true in all cases.
       *
       * @param {string} feature
       * @param {string} [version]
       * @returns {boolean} always true
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
       * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
       */
      hasFeature: function(feature, version5) {
        return true;
      },
      /**
       * Creates an XML Document object of the specified type with its document element.
       *
       * __It behaves slightly different from the description in the living standard__:
       * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
       * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string|null} namespaceURI
       * @param {string} qualifiedName
       * @param {DocumentType=null} doctype
       * @returns {Document}
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root);
        }
        return doc;
      },
      /**
       * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
       *
       * __This behavior is slightly different from the in the specs__:
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string} qualifiedName
       * @param {string} [publicId]
       * @param {string} [systemId]
       * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
       * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocumentType: function(qualifiedName, publicId, systemId) {
        var node = new DocumentType();
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";
        return node;
      }
    };
    function Node() {
    }
    Node.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      // Modified in DOM Level 2:
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      // Modified in DOM Level 2:
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      // Introduced in DOM Level 2:
      isSupported: function(feature, version5) {
        return this.ownerDocument.implementation.hasFeature(feature, version5);
      },
      // Introduced in DOM Level 2:
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      /**
       * Look up the prefix associated to the given namespace URI, starting from this node.
       * **The default namespace declarations are ignored by this method.**
       * See Namespace Prefix Lookup for details on the algorithm used by this method.
       *
       * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
       *
       * @param {string | null} namespaceURI
       * @returns {string | null}
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
       * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
       * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
       * @see https://github.com/xmldom/xmldom/issues/322
       */
      lookupPrefix: function(namespaceURI) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            for (var n in map) {
              if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
                return n;
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      lookupNamespaceURI: function(prefix) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            if (prefix in map) {
              if (Object.prototype.hasOwnProperty.call(map, prefix)) {
                return map[prefix];
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      }
    };
    function _xmlEncoder(c) {
      return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
    }
    copy(NodeType, Node);
    copy(NodeType, Node.prototype);
    function _visitNode(node, callback2) {
      if (callback2(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback2)) {
            return true;
          }
        } while (node = node.nextSibling);
      }
    }
    function Document() {
      this.ownerDocument = this;
    }
    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    function _onRemoveAttribute(doc, el, newAttr, remove2) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    function _onUpdateChild(doc, el, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var cs = el.childNodes;
        if (newChild) {
          cs[cs.length++] = newChild;
        } else {
          var child = el.firstChild;
          var i = 0;
          while (child) {
            cs[i++] = child;
            child = child.nextSibling;
          }
          cs.length = i;
          delete cs[cs.length];
        }
      }
    }
    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next = child.nextSibling;
      if (previous) {
        previous.nextSibling = next;
      } else {
        parentNode.firstChild = next;
      }
      if (next) {
        next.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      child.parentNode = null;
      child.previousSibling = null;
      child.nextSibling = null;
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }
    function hasValidParentNodeType(node) {
      return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
    }
    function hasInsertableNodeType(node) {
      return node && (isElementNode(node) || isTextNode2(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
    }
    function isDocTypeNode(node) {
      return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
    }
    function isElementNode(node) {
      return node && node.nodeType === Node.ELEMENT_NODE;
    }
    function isTextNode2(node) {
      return node && node.nodeType === Node.TEXT_NODE;
    }
    function isElementInsertionPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function isElementReplacementPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      function hasElementChildThatIsNotChild(node) {
        return isElementNode(node) && node !== child;
      }
      if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function assertPreInsertionValidity1to5(parent, node, child) {
      if (!hasValidParentNodeType(parent)) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
      }
      if (child && child.parentNode !== parent) {
        throw new DOMException2(NOT_FOUND_ERR, "child not in parent");
      }
      if (
        // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
        !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
        // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
        // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
        // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
        isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE
      ) {
        throw new DOMException2(HIERARCHY_REQUEST_ERR, "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType);
      }
    }
    function assertPreInsertionValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode2)) {
          throw new DOMException2(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
          throw new DOMException2(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementInsertionPossible(parent, child)) {
          throw new DOMException2(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        if (find(parentChildNodes, isDocTypeNode)) {
          throw new DOMException2(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException2(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
        if (!child && parentElementChild) {
          throw new DOMException2(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
        }
      }
    }
    function assertPreReplacementValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode2)) {
          throw new DOMException2(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
          throw new DOMException2(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementReplacementPossible(parent, child)) {
          throw new DOMException2(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        let hasDoctypeChildThatIsNotChild2 = function(node2) {
          return isDocTypeNode(node2) && node2 !== child;
        };
        var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
        if (find(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
          throw new DOMException2(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException2(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
      }
    }
    function _insertBefore(parent, node, child, _inDocumentAssertion) {
      assertPreInsertionValidity1to5(parent, node, child);
      if (parent.nodeType === Node.DOCUMENT_NODE) {
        (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
      }
      var cp = node.parentNode;
      if (cp) {
        cp.removeChild(node);
      }
      if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = node.firstChild;
        if (newFirst == null) {
          return node;
        }
        var newLast = node.lastChild;
      } else {
        newFirst = newLast = node;
      }
      var pre = child ? child.previousSibling : parent.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = child;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parent.firstChild = newFirst;
      }
      if (child == null) {
        parent.lastChild = newLast;
      } else {
        child.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parent;
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parent.ownerDocument || parent, parent);
      if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
        node.firstChild = node.lastChild = null;
      }
      return node;
    }
    function _appendSingleChild(parentNode, newChild) {
      if (newChild.parentNode) {
        newChild.parentNode.removeChild(newChild);
      }
      newChild.parentNode = parentNode;
      newChild.previousSibling = parentNode.lastChild;
      newChild.nextSibling = null;
      if (newChild.previousSibling) {
        newChild.previousSibling.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      return newChild;
    }
    Document.prototype = {
      //implementation : null,
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      /**
       * The DocumentType node of the document.
       *
       * @readonly
       * @type DocumentType
       */
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        _insertBefore(this, newChild, refChild);
        newChild.ownerDocument = this;
        if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return newChild;
      },
      removeChild: function(oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        newChild.ownerDocument = this;
        if (oldChild) {
          this.removeChild(oldChild);
        }
        if (isElementNode(newChild)) {
          this.documentElement = newChild;
        }
      },
      // Introduced in DOM Level 2:
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      // Introduced in DOM Level 2:
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },
      /**
       * The `getElementsByClassName` method of `Document` interface returns an array-like object
       * of all child elements which have **all** of the given class name(s).
       *
       * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
       *
       *
       * Warning: This is a live LiveNodeList.
       * Changes in the DOM will reflect in the array as the changes occur.
       * If an element selected by this array no longer qualifies for the selector,
       * it will automatically be removed. Be aware of this for iteration purposes.
       *
       * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
       */
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base.documentElement, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                if (nodeClassNames) {
                  var matches = classNames === nodeClassNames;
                  if (!matches) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches) {
                    ls.push(node);
                  }
                }
              }
            });
          }
          return ls;
        });
      },
      //document factory method:
      createElement: function(tagName) {
        var node = new Element();
        node.ownerDocument = this;
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      createDocumentFragment: function() {
        var node = new DocumentFragment();
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      createTextNode: function(data) {
        var node = new Text();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createComment: function(data) {
        var node = new Comment();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createCDATASection: function(data) {
        var node = new CDATASection();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createProcessingInstruction: function(target, data) {
        var node = new ProcessingInstruction();
        node.ownerDocument = this;
        node.tagName = node.nodeName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      createAttribute: function(name) {
        var node = new Attr();
        node.ownerDocument = this;
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      createEntityReference: function(name) {
        var node = new EntityReference();
        node.ownerDocument = this;
        node.nodeName = name;
        return node;
      },
      // Introduced in DOM Level 2:
      createElementNS: function(namespaceURI, qualifiedName) {
        var node = new Element();
        var pl = qualifiedName.split(":");
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = namespaceURI;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        attrs._ownerElement = node;
        return node;
      },
      // Introduced in DOM Level 2:
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var node = new Attr();
        var pl = qualifiedName.split(":");
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.namespaceURI = namespaceURI;
        node.specified = true;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        return node;
      }
    };
    _extends3(Document, Node);
    function Element() {
      this._nsMap = {};
    }
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function(name) {
        return this.getAttributeNode(name) != null;
      },
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr && attr.value || "";
      },
      getAttributeNode: function(name) {
        return this.attributes.getNamedItem(name);
      },
      setAttribute: function(name, value) {
        var attr = this.ownerDocument.createAttribute(name);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },
      //four real opeartion method
      appendChild: function(newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      //get real attribute name,and remove it by removeAttributeNode
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr && attr.value || "";
      },
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      getElementsByTagName: function(tagName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
    _extends3(Element, Node);
    function Attr() {
    }
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends3(Attr, Node);
    function CharacterData() {
    }
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function(newChild) {
        throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
      },
      deleteData: function(offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function(offset, count, text) {
        var start2 = this.data.substring(0, offset);
        var end = this.data.substring(offset + count);
        text = start2 + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends3(CharacterData, Node);
    function Text() {
    }
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends3(Text, CharacterData);
    function Comment() {
    }
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends3(Comment, CharacterData);
    function CDATASection() {
    }
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends3(CDATASection, CharacterData);
    function DocumentType() {
    }
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends3(DocumentType, Node);
    function Notation() {
    }
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends3(Notation, Node);
    function Entity() {
    }
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends3(Entity, Node);
    function EntityReference() {
    }
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends3(EntityReference, Node);
    function DocumentFragment() {
    }
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends3(DocumentFragment, Node);
    function ProcessingInstruction() {
    }
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends3(ProcessingInstruction, Node);
    function XMLSerializer() {
    }
    XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
      return nodeSerializeToString.call(node, isHtml, nodeFilter);
    };
    Node.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(isHtml, nodeFilter) {
      var buf = [];
      var refNode = this.nodeType == 9 && this.documentElement || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix == null) {
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          var visibleNamespaces = [
            {
              namespace: uri,
              prefix: null
            }
            //{namespace:uri,prefix:''}
          ];
        }
      }
      serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
        return false;
      }
      var i = visibleNamespaces.length;
      while (i--) {
        var ns = visibleNamespaces[i];
        if (ns.prefix === prefix) {
          return ns.namespace !== uri;
        }
      }
      return true;
    }
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(" ", qualifiedName, '="', value.replace(/[<&"]/g, _xmlEncoder), '"');
    }
    function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
      }
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            for (var ai = 0; ai < attrs.length; ai++) {
              if (attrs.item(ai).name === "xmlns") {
                defaultNS = attrs.item(ai).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({
                prefix: attr.localName,
                namespace: attr.value
              });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({
                prefix: "",
                namespace: attr.value
              });
            }
          }
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({
                prefix,
                namespace: uri
              });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({
              prefix,
              namespace: uri
            });
          }
          if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
            buf.push(">");
            if (isHTML && /^script$/i.test(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          } else {
            buf.push("/>");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          return buf.push(node.data.replace(/[<&]/g, _xmlEncoder).replace(/]]>/g, "]]&gt;"));
        case CDATA_SECTION_NODE:
          return buf.push("<![CDATA[", node.data, "]]>");
        case COMMENT_NODE:
          return buf.push("<!--", node.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push("<!DOCTYPE ", node.name);
          if (pubid) {
            buf.push(" PUBLIC ", pubid);
            if (sysid && sysid != ".") {
              buf.push(" ", sysid);
            }
            buf.push(">");
          } else if (sysid && sysid != ".") {
            buf.push(" SYSTEM ", sysid, ">");
          } else {
            var sub = node.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        default:
          buf.push("??", node.nodeName);
      }
    }
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor();
      for (var n in node) {
        if (Object.prototype.hasOwnProperty.call(node, n)) {
          var v = node[n];
          if (typeof v != "object") {
            if (v != node2[n]) {
              node2[n] = v;
            }
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i = 0; i < len; i++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
          }
          break;
          ;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function __set__(object, key, value) {
      object[key] = value;
    }
    try {
      if (Object.defineProperty) {
        let getTextContent3 = function(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent3(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        };
        getTextContent2 = getTextContent3;
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node.prototype, "textContent", {
          get: function() {
            return getTextContent3(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = function(object, key, value) {
          object["$$" + key] = value;
        };
      }
    } catch (e) {
    }
    var getTextContent2;
    exports.DocumentType = DocumentType;
    exports.DOMException = DOMException2;
    exports.DOMImplementation = DOMImplementation;
    exports.Element = Element;
    exports.Node = Node;
    exports.NodeList = NodeList;
    exports.XMLSerializer = XMLSerializer;
  }
});

// node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = __commonJS({
  "node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/entities.js"(exports) {
    "use strict";
    var freeze = require_conventions().freeze;
    exports.XML_ENTITIES = freeze({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    });
    exports.HTML_ENTITIES = freeze({
      Aacute: "\xC1",
      aacute: "\xE1",
      Abreve: "\u0102",
      abreve: "\u0103",
      ac: "\u223E",
      acd: "\u223F",
      acE: "\u223E\u0333",
      Acirc: "\xC2",
      acirc: "\xE2",
      acute: "\xB4",
      Acy: "\u0410",
      acy: "\u0430",
      AElig: "\xC6",
      aelig: "\xE6",
      af: "\u2061",
      Afr: "\u{1D504}",
      afr: "\u{1D51E}",
      Agrave: "\xC0",
      agrave: "\xE0",
      alefsym: "\u2135",
      aleph: "\u2135",
      Alpha: "\u0391",
      alpha: "\u03B1",
      Amacr: "\u0100",
      amacr: "\u0101",
      amalg: "\u2A3F",
      AMP: "&",
      amp: "&",
      And: "\u2A53",
      and: "\u2227",
      andand: "\u2A55",
      andd: "\u2A5C",
      andslope: "\u2A58",
      andv: "\u2A5A",
      ang: "\u2220",
      ange: "\u29A4",
      angle: "\u2220",
      angmsd: "\u2221",
      angmsdaa: "\u29A8",
      angmsdab: "\u29A9",
      angmsdac: "\u29AA",
      angmsdad: "\u29AB",
      angmsdae: "\u29AC",
      angmsdaf: "\u29AD",
      angmsdag: "\u29AE",
      angmsdah: "\u29AF",
      angrt: "\u221F",
      angrtvb: "\u22BE",
      angrtvbd: "\u299D",
      angsph: "\u2222",
      angst: "\xC5",
      angzarr: "\u237C",
      Aogon: "\u0104",
      aogon: "\u0105",
      Aopf: "\u{1D538}",
      aopf: "\u{1D552}",
      ap: "\u2248",
      apacir: "\u2A6F",
      apE: "\u2A70",
      ape: "\u224A",
      apid: "\u224B",
      apos: "'",
      ApplyFunction: "\u2061",
      approx: "\u2248",
      approxeq: "\u224A",
      Aring: "\xC5",
      aring: "\xE5",
      Ascr: "\u{1D49C}",
      ascr: "\u{1D4B6}",
      Assign: "\u2254",
      ast: "*",
      asymp: "\u2248",
      asympeq: "\u224D",
      Atilde: "\xC3",
      atilde: "\xE3",
      Auml: "\xC4",
      auml: "\xE4",
      awconint: "\u2233",
      awint: "\u2A11",
      backcong: "\u224C",
      backepsilon: "\u03F6",
      backprime: "\u2035",
      backsim: "\u223D",
      backsimeq: "\u22CD",
      Backslash: "\u2216",
      Barv: "\u2AE7",
      barvee: "\u22BD",
      Barwed: "\u2306",
      barwed: "\u2305",
      barwedge: "\u2305",
      bbrk: "\u23B5",
      bbrktbrk: "\u23B6",
      bcong: "\u224C",
      Bcy: "\u0411",
      bcy: "\u0431",
      bdquo: "\u201E",
      becaus: "\u2235",
      Because: "\u2235",
      because: "\u2235",
      bemptyv: "\u29B0",
      bepsi: "\u03F6",
      bernou: "\u212C",
      Bernoullis: "\u212C",
      Beta: "\u0392",
      beta: "\u03B2",
      beth: "\u2136",
      between: "\u226C",
      Bfr: "\u{1D505}",
      bfr: "\u{1D51F}",
      bigcap: "\u22C2",
      bigcirc: "\u25EF",
      bigcup: "\u22C3",
      bigodot: "\u2A00",
      bigoplus: "\u2A01",
      bigotimes: "\u2A02",
      bigsqcup: "\u2A06",
      bigstar: "\u2605",
      bigtriangledown: "\u25BD",
      bigtriangleup: "\u25B3",
      biguplus: "\u2A04",
      bigvee: "\u22C1",
      bigwedge: "\u22C0",
      bkarow: "\u290D",
      blacklozenge: "\u29EB",
      blacksquare: "\u25AA",
      blacktriangle: "\u25B4",
      blacktriangledown: "\u25BE",
      blacktriangleleft: "\u25C2",
      blacktriangleright: "\u25B8",
      blank: "\u2423",
      blk12: "\u2592",
      blk14: "\u2591",
      blk34: "\u2593",
      block: "\u2588",
      bne: "=\u20E5",
      bnequiv: "\u2261\u20E5",
      bNot: "\u2AED",
      bnot: "\u2310",
      Bopf: "\u{1D539}",
      bopf: "\u{1D553}",
      bot: "\u22A5",
      bottom: "\u22A5",
      bowtie: "\u22C8",
      boxbox: "\u29C9",
      boxDL: "\u2557",
      boxDl: "\u2556",
      boxdL: "\u2555",
      boxdl: "\u2510",
      boxDR: "\u2554",
      boxDr: "\u2553",
      boxdR: "\u2552",
      boxdr: "\u250C",
      boxH: "\u2550",
      boxh: "\u2500",
      boxHD: "\u2566",
      boxHd: "\u2564",
      boxhD: "\u2565",
      boxhd: "\u252C",
      boxHU: "\u2569",
      boxHu: "\u2567",
      boxhU: "\u2568",
      boxhu: "\u2534",
      boxminus: "\u229F",
      boxplus: "\u229E",
      boxtimes: "\u22A0",
      boxUL: "\u255D",
      boxUl: "\u255C",
      boxuL: "\u255B",
      boxul: "\u2518",
      boxUR: "\u255A",
      boxUr: "\u2559",
      boxuR: "\u2558",
      boxur: "\u2514",
      boxV: "\u2551",
      boxv: "\u2502",
      boxVH: "\u256C",
      boxVh: "\u256B",
      boxvH: "\u256A",
      boxvh: "\u253C",
      boxVL: "\u2563",
      boxVl: "\u2562",
      boxvL: "\u2561",
      boxvl: "\u2524",
      boxVR: "\u2560",
      boxVr: "\u255F",
      boxvR: "\u255E",
      boxvr: "\u251C",
      bprime: "\u2035",
      Breve: "\u02D8",
      breve: "\u02D8",
      brvbar: "\xA6",
      Bscr: "\u212C",
      bscr: "\u{1D4B7}",
      bsemi: "\u204F",
      bsim: "\u223D",
      bsime: "\u22CD",
      bsol: "\\",
      bsolb: "\u29C5",
      bsolhsub: "\u27C8",
      bull: "\u2022",
      bullet: "\u2022",
      bump: "\u224E",
      bumpE: "\u2AAE",
      bumpe: "\u224F",
      Bumpeq: "\u224E",
      bumpeq: "\u224F",
      Cacute: "\u0106",
      cacute: "\u0107",
      Cap: "\u22D2",
      cap: "\u2229",
      capand: "\u2A44",
      capbrcup: "\u2A49",
      capcap: "\u2A4B",
      capcup: "\u2A47",
      capdot: "\u2A40",
      CapitalDifferentialD: "\u2145",
      caps: "\u2229\uFE00",
      caret: "\u2041",
      caron: "\u02C7",
      Cayleys: "\u212D",
      ccaps: "\u2A4D",
      Ccaron: "\u010C",
      ccaron: "\u010D",
      Ccedil: "\xC7",
      ccedil: "\xE7",
      Ccirc: "\u0108",
      ccirc: "\u0109",
      Cconint: "\u2230",
      ccups: "\u2A4C",
      ccupssm: "\u2A50",
      Cdot: "\u010A",
      cdot: "\u010B",
      cedil: "\xB8",
      Cedilla: "\xB8",
      cemptyv: "\u29B2",
      cent: "\xA2",
      CenterDot: "\xB7",
      centerdot: "\xB7",
      Cfr: "\u212D",
      cfr: "\u{1D520}",
      CHcy: "\u0427",
      chcy: "\u0447",
      check: "\u2713",
      checkmark: "\u2713",
      Chi: "\u03A7",
      chi: "\u03C7",
      cir: "\u25CB",
      circ: "\u02C6",
      circeq: "\u2257",
      circlearrowleft: "\u21BA",
      circlearrowright: "\u21BB",
      circledast: "\u229B",
      circledcirc: "\u229A",
      circleddash: "\u229D",
      CircleDot: "\u2299",
      circledR: "\xAE",
      circledS: "\u24C8",
      CircleMinus: "\u2296",
      CirclePlus: "\u2295",
      CircleTimes: "\u2297",
      cirE: "\u29C3",
      cire: "\u2257",
      cirfnint: "\u2A10",
      cirmid: "\u2AEF",
      cirscir: "\u29C2",
      ClockwiseContourIntegral: "\u2232",
      CloseCurlyDoubleQuote: "\u201D",
      CloseCurlyQuote: "\u2019",
      clubs: "\u2663",
      clubsuit: "\u2663",
      Colon: "\u2237",
      colon: ":",
      Colone: "\u2A74",
      colone: "\u2254",
      coloneq: "\u2254",
      comma: ",",
      commat: "@",
      comp: "\u2201",
      compfn: "\u2218",
      complement: "\u2201",
      complexes: "\u2102",
      cong: "\u2245",
      congdot: "\u2A6D",
      Congruent: "\u2261",
      Conint: "\u222F",
      conint: "\u222E",
      ContourIntegral: "\u222E",
      Copf: "\u2102",
      copf: "\u{1D554}",
      coprod: "\u2210",
      Coproduct: "\u2210",
      COPY: "\xA9",
      copy: "\xA9",
      copysr: "\u2117",
      CounterClockwiseContourIntegral: "\u2233",
      crarr: "\u21B5",
      Cross: "\u2A2F",
      cross: "\u2717",
      Cscr: "\u{1D49E}",
      cscr: "\u{1D4B8}",
      csub: "\u2ACF",
      csube: "\u2AD1",
      csup: "\u2AD0",
      csupe: "\u2AD2",
      ctdot: "\u22EF",
      cudarrl: "\u2938",
      cudarrr: "\u2935",
      cuepr: "\u22DE",
      cuesc: "\u22DF",
      cularr: "\u21B6",
      cularrp: "\u293D",
      Cup: "\u22D3",
      cup: "\u222A",
      cupbrcap: "\u2A48",
      CupCap: "\u224D",
      cupcap: "\u2A46",
      cupcup: "\u2A4A",
      cupdot: "\u228D",
      cupor: "\u2A45",
      cups: "\u222A\uFE00",
      curarr: "\u21B7",
      curarrm: "\u293C",
      curlyeqprec: "\u22DE",
      curlyeqsucc: "\u22DF",
      curlyvee: "\u22CE",
      curlywedge: "\u22CF",
      curren: "\xA4",
      curvearrowleft: "\u21B6",
      curvearrowright: "\u21B7",
      cuvee: "\u22CE",
      cuwed: "\u22CF",
      cwconint: "\u2232",
      cwint: "\u2231",
      cylcty: "\u232D",
      Dagger: "\u2021",
      dagger: "\u2020",
      daleth: "\u2138",
      Darr: "\u21A1",
      dArr: "\u21D3",
      darr: "\u2193",
      dash: "\u2010",
      Dashv: "\u2AE4",
      dashv: "\u22A3",
      dbkarow: "\u290F",
      dblac: "\u02DD",
      Dcaron: "\u010E",
      dcaron: "\u010F",
      Dcy: "\u0414",
      dcy: "\u0434",
      DD: "\u2145",
      dd: "\u2146",
      ddagger: "\u2021",
      ddarr: "\u21CA",
      DDotrahd: "\u2911",
      ddotseq: "\u2A77",
      deg: "\xB0",
      Del: "\u2207",
      Delta: "\u0394",
      delta: "\u03B4",
      demptyv: "\u29B1",
      dfisht: "\u297F",
      Dfr: "\u{1D507}",
      dfr: "\u{1D521}",
      dHar: "\u2965",
      dharl: "\u21C3",
      dharr: "\u21C2",
      DiacriticalAcute: "\xB4",
      DiacriticalDot: "\u02D9",
      DiacriticalDoubleAcute: "\u02DD",
      DiacriticalGrave: "`",
      DiacriticalTilde: "\u02DC",
      diam: "\u22C4",
      Diamond: "\u22C4",
      diamond: "\u22C4",
      diamondsuit: "\u2666",
      diams: "\u2666",
      die: "\xA8",
      DifferentialD: "\u2146",
      digamma: "\u03DD",
      disin: "\u22F2",
      div: "\xF7",
      divide: "\xF7",
      divideontimes: "\u22C7",
      divonx: "\u22C7",
      DJcy: "\u0402",
      djcy: "\u0452",
      dlcorn: "\u231E",
      dlcrop: "\u230D",
      dollar: "$",
      Dopf: "\u{1D53B}",
      dopf: "\u{1D555}",
      Dot: "\xA8",
      dot: "\u02D9",
      DotDot: "\u20DC",
      doteq: "\u2250",
      doteqdot: "\u2251",
      DotEqual: "\u2250",
      dotminus: "\u2238",
      dotplus: "\u2214",
      dotsquare: "\u22A1",
      doublebarwedge: "\u2306",
      DoubleContourIntegral: "\u222F",
      DoubleDot: "\xA8",
      DoubleDownArrow: "\u21D3",
      DoubleLeftArrow: "\u21D0",
      DoubleLeftRightArrow: "\u21D4",
      DoubleLeftTee: "\u2AE4",
      DoubleLongLeftArrow: "\u27F8",
      DoubleLongLeftRightArrow: "\u27FA",
      DoubleLongRightArrow: "\u27F9",
      DoubleRightArrow: "\u21D2",
      DoubleRightTee: "\u22A8",
      DoubleUpArrow: "\u21D1",
      DoubleUpDownArrow: "\u21D5",
      DoubleVerticalBar: "\u2225",
      DownArrow: "\u2193",
      Downarrow: "\u21D3",
      downarrow: "\u2193",
      DownArrowBar: "\u2913",
      DownArrowUpArrow: "\u21F5",
      DownBreve: "\u0311",
      downdownarrows: "\u21CA",
      downharpoonleft: "\u21C3",
      downharpoonright: "\u21C2",
      DownLeftRightVector: "\u2950",
      DownLeftTeeVector: "\u295E",
      DownLeftVector: "\u21BD",
      DownLeftVectorBar: "\u2956",
      DownRightTeeVector: "\u295F",
      DownRightVector: "\u21C1",
      DownRightVectorBar: "\u2957",
      DownTee: "\u22A4",
      DownTeeArrow: "\u21A7",
      drbkarow: "\u2910",
      drcorn: "\u231F",
      drcrop: "\u230C",
      Dscr: "\u{1D49F}",
      dscr: "\u{1D4B9}",
      DScy: "\u0405",
      dscy: "\u0455",
      dsol: "\u29F6",
      Dstrok: "\u0110",
      dstrok: "\u0111",
      dtdot: "\u22F1",
      dtri: "\u25BF",
      dtrif: "\u25BE",
      duarr: "\u21F5",
      duhar: "\u296F",
      dwangle: "\u29A6",
      DZcy: "\u040F",
      dzcy: "\u045F",
      dzigrarr: "\u27FF",
      Eacute: "\xC9",
      eacute: "\xE9",
      easter: "\u2A6E",
      Ecaron: "\u011A",
      ecaron: "\u011B",
      ecir: "\u2256",
      Ecirc: "\xCA",
      ecirc: "\xEA",
      ecolon: "\u2255",
      Ecy: "\u042D",
      ecy: "\u044D",
      eDDot: "\u2A77",
      Edot: "\u0116",
      eDot: "\u2251",
      edot: "\u0117",
      ee: "\u2147",
      efDot: "\u2252",
      Efr: "\u{1D508}",
      efr: "\u{1D522}",
      eg: "\u2A9A",
      Egrave: "\xC8",
      egrave: "\xE8",
      egs: "\u2A96",
      egsdot: "\u2A98",
      el: "\u2A99",
      Element: "\u2208",
      elinters: "\u23E7",
      ell: "\u2113",
      els: "\u2A95",
      elsdot: "\u2A97",
      Emacr: "\u0112",
      emacr: "\u0113",
      empty: "\u2205",
      emptyset: "\u2205",
      EmptySmallSquare: "\u25FB",
      emptyv: "\u2205",
      EmptyVerySmallSquare: "\u25AB",
      emsp: "\u2003",
      emsp13: "\u2004",
      emsp14: "\u2005",
      ENG: "\u014A",
      eng: "\u014B",
      ensp: "\u2002",
      Eogon: "\u0118",
      eogon: "\u0119",
      Eopf: "\u{1D53C}",
      eopf: "\u{1D556}",
      epar: "\u22D5",
      eparsl: "\u29E3",
      eplus: "\u2A71",
      epsi: "\u03B5",
      Epsilon: "\u0395",
      epsilon: "\u03B5",
      epsiv: "\u03F5",
      eqcirc: "\u2256",
      eqcolon: "\u2255",
      eqsim: "\u2242",
      eqslantgtr: "\u2A96",
      eqslantless: "\u2A95",
      Equal: "\u2A75",
      equals: "=",
      EqualTilde: "\u2242",
      equest: "\u225F",
      Equilibrium: "\u21CC",
      equiv: "\u2261",
      equivDD: "\u2A78",
      eqvparsl: "\u29E5",
      erarr: "\u2971",
      erDot: "\u2253",
      Escr: "\u2130",
      escr: "\u212F",
      esdot: "\u2250",
      Esim: "\u2A73",
      esim: "\u2242",
      Eta: "\u0397",
      eta: "\u03B7",
      ETH: "\xD0",
      eth: "\xF0",
      Euml: "\xCB",
      euml: "\xEB",
      euro: "\u20AC",
      excl: "!",
      exist: "\u2203",
      Exists: "\u2203",
      expectation: "\u2130",
      ExponentialE: "\u2147",
      exponentiale: "\u2147",
      fallingdotseq: "\u2252",
      Fcy: "\u0424",
      fcy: "\u0444",
      female: "\u2640",
      ffilig: "\uFB03",
      fflig: "\uFB00",
      ffllig: "\uFB04",
      Ffr: "\u{1D509}",
      ffr: "\u{1D523}",
      filig: "\uFB01",
      FilledSmallSquare: "\u25FC",
      FilledVerySmallSquare: "\u25AA",
      fjlig: "fj",
      flat: "\u266D",
      fllig: "\uFB02",
      fltns: "\u25B1",
      fnof: "\u0192",
      Fopf: "\u{1D53D}",
      fopf: "\u{1D557}",
      ForAll: "\u2200",
      forall: "\u2200",
      fork: "\u22D4",
      forkv: "\u2AD9",
      Fouriertrf: "\u2131",
      fpartint: "\u2A0D",
      frac12: "\xBD",
      frac13: "\u2153",
      frac14: "\xBC",
      frac15: "\u2155",
      frac16: "\u2159",
      frac18: "\u215B",
      frac23: "\u2154",
      frac25: "\u2156",
      frac34: "\xBE",
      frac35: "\u2157",
      frac38: "\u215C",
      frac45: "\u2158",
      frac56: "\u215A",
      frac58: "\u215D",
      frac78: "\u215E",
      frasl: "\u2044",
      frown: "\u2322",
      Fscr: "\u2131",
      fscr: "\u{1D4BB}",
      gacute: "\u01F5",
      Gamma: "\u0393",
      gamma: "\u03B3",
      Gammad: "\u03DC",
      gammad: "\u03DD",
      gap: "\u2A86",
      Gbreve: "\u011E",
      gbreve: "\u011F",
      Gcedil: "\u0122",
      Gcirc: "\u011C",
      gcirc: "\u011D",
      Gcy: "\u0413",
      gcy: "\u0433",
      Gdot: "\u0120",
      gdot: "\u0121",
      gE: "\u2267",
      ge: "\u2265",
      gEl: "\u2A8C",
      gel: "\u22DB",
      geq: "\u2265",
      geqq: "\u2267",
      geqslant: "\u2A7E",
      ges: "\u2A7E",
      gescc: "\u2AA9",
      gesdot: "\u2A80",
      gesdoto: "\u2A82",
      gesdotol: "\u2A84",
      gesl: "\u22DB\uFE00",
      gesles: "\u2A94",
      Gfr: "\u{1D50A}",
      gfr: "\u{1D524}",
      Gg: "\u22D9",
      gg: "\u226B",
      ggg: "\u22D9",
      gimel: "\u2137",
      GJcy: "\u0403",
      gjcy: "\u0453",
      gl: "\u2277",
      gla: "\u2AA5",
      glE: "\u2A92",
      glj: "\u2AA4",
      gnap: "\u2A8A",
      gnapprox: "\u2A8A",
      gnE: "\u2269",
      gne: "\u2A88",
      gneq: "\u2A88",
      gneqq: "\u2269",
      gnsim: "\u22E7",
      Gopf: "\u{1D53E}",
      gopf: "\u{1D558}",
      grave: "`",
      GreaterEqual: "\u2265",
      GreaterEqualLess: "\u22DB",
      GreaterFullEqual: "\u2267",
      GreaterGreater: "\u2AA2",
      GreaterLess: "\u2277",
      GreaterSlantEqual: "\u2A7E",
      GreaterTilde: "\u2273",
      Gscr: "\u{1D4A2}",
      gscr: "\u210A",
      gsim: "\u2273",
      gsime: "\u2A8E",
      gsiml: "\u2A90",
      Gt: "\u226B",
      GT: ">",
      gt: ">",
      gtcc: "\u2AA7",
      gtcir: "\u2A7A",
      gtdot: "\u22D7",
      gtlPar: "\u2995",
      gtquest: "\u2A7C",
      gtrapprox: "\u2A86",
      gtrarr: "\u2978",
      gtrdot: "\u22D7",
      gtreqless: "\u22DB",
      gtreqqless: "\u2A8C",
      gtrless: "\u2277",
      gtrsim: "\u2273",
      gvertneqq: "\u2269\uFE00",
      gvnE: "\u2269\uFE00",
      Hacek: "\u02C7",
      hairsp: "\u200A",
      half: "\xBD",
      hamilt: "\u210B",
      HARDcy: "\u042A",
      hardcy: "\u044A",
      hArr: "\u21D4",
      harr: "\u2194",
      harrcir: "\u2948",
      harrw: "\u21AD",
      Hat: "^",
      hbar: "\u210F",
      Hcirc: "\u0124",
      hcirc: "\u0125",
      hearts: "\u2665",
      heartsuit: "\u2665",
      hellip: "\u2026",
      hercon: "\u22B9",
      Hfr: "\u210C",
      hfr: "\u{1D525}",
      HilbertSpace: "\u210B",
      hksearow: "\u2925",
      hkswarow: "\u2926",
      hoarr: "\u21FF",
      homtht: "\u223B",
      hookleftarrow: "\u21A9",
      hookrightarrow: "\u21AA",
      Hopf: "\u210D",
      hopf: "\u{1D559}",
      horbar: "\u2015",
      HorizontalLine: "\u2500",
      Hscr: "\u210B",
      hscr: "\u{1D4BD}",
      hslash: "\u210F",
      Hstrok: "\u0126",
      hstrok: "\u0127",
      HumpDownHump: "\u224E",
      HumpEqual: "\u224F",
      hybull: "\u2043",
      hyphen: "\u2010",
      Iacute: "\xCD",
      iacute: "\xED",
      ic: "\u2063",
      Icirc: "\xCE",
      icirc: "\xEE",
      Icy: "\u0418",
      icy: "\u0438",
      Idot: "\u0130",
      IEcy: "\u0415",
      iecy: "\u0435",
      iexcl: "\xA1",
      iff: "\u21D4",
      Ifr: "\u2111",
      ifr: "\u{1D526}",
      Igrave: "\xCC",
      igrave: "\xEC",
      ii: "\u2148",
      iiiint: "\u2A0C",
      iiint: "\u222D",
      iinfin: "\u29DC",
      iiota: "\u2129",
      IJlig: "\u0132",
      ijlig: "\u0133",
      Im: "\u2111",
      Imacr: "\u012A",
      imacr: "\u012B",
      image: "\u2111",
      ImaginaryI: "\u2148",
      imagline: "\u2110",
      imagpart: "\u2111",
      imath: "\u0131",
      imof: "\u22B7",
      imped: "\u01B5",
      Implies: "\u21D2",
      in: "\u2208",
      incare: "\u2105",
      infin: "\u221E",
      infintie: "\u29DD",
      inodot: "\u0131",
      Int: "\u222C",
      int: "\u222B",
      intcal: "\u22BA",
      integers: "\u2124",
      Integral: "\u222B",
      intercal: "\u22BA",
      Intersection: "\u22C2",
      intlarhk: "\u2A17",
      intprod: "\u2A3C",
      InvisibleComma: "\u2063",
      InvisibleTimes: "\u2062",
      IOcy: "\u0401",
      iocy: "\u0451",
      Iogon: "\u012E",
      iogon: "\u012F",
      Iopf: "\u{1D540}",
      iopf: "\u{1D55A}",
      Iota: "\u0399",
      iota: "\u03B9",
      iprod: "\u2A3C",
      iquest: "\xBF",
      Iscr: "\u2110",
      iscr: "\u{1D4BE}",
      isin: "\u2208",
      isindot: "\u22F5",
      isinE: "\u22F9",
      isins: "\u22F4",
      isinsv: "\u22F3",
      isinv: "\u2208",
      it: "\u2062",
      Itilde: "\u0128",
      itilde: "\u0129",
      Iukcy: "\u0406",
      iukcy: "\u0456",
      Iuml: "\xCF",
      iuml: "\xEF",
      Jcirc: "\u0134",
      jcirc: "\u0135",
      Jcy: "\u0419",
      jcy: "\u0439",
      Jfr: "\u{1D50D}",
      jfr: "\u{1D527}",
      jmath: "\u0237",
      Jopf: "\u{1D541}",
      jopf: "\u{1D55B}",
      Jscr: "\u{1D4A5}",
      jscr: "\u{1D4BF}",
      Jsercy: "\u0408",
      jsercy: "\u0458",
      Jukcy: "\u0404",
      jukcy: "\u0454",
      Kappa: "\u039A",
      kappa: "\u03BA",
      kappav: "\u03F0",
      Kcedil: "\u0136",
      kcedil: "\u0137",
      Kcy: "\u041A",
      kcy: "\u043A",
      Kfr: "\u{1D50E}",
      kfr: "\u{1D528}",
      kgreen: "\u0138",
      KHcy: "\u0425",
      khcy: "\u0445",
      KJcy: "\u040C",
      kjcy: "\u045C",
      Kopf: "\u{1D542}",
      kopf: "\u{1D55C}",
      Kscr: "\u{1D4A6}",
      kscr: "\u{1D4C0}",
      lAarr: "\u21DA",
      Lacute: "\u0139",
      lacute: "\u013A",
      laemptyv: "\u29B4",
      lagran: "\u2112",
      Lambda: "\u039B",
      lambda: "\u03BB",
      Lang: "\u27EA",
      lang: "\u27E8",
      langd: "\u2991",
      langle: "\u27E8",
      lap: "\u2A85",
      Laplacetrf: "\u2112",
      laquo: "\xAB",
      Larr: "\u219E",
      lArr: "\u21D0",
      larr: "\u2190",
      larrb: "\u21E4",
      larrbfs: "\u291F",
      larrfs: "\u291D",
      larrhk: "\u21A9",
      larrlp: "\u21AB",
      larrpl: "\u2939",
      larrsim: "\u2973",
      larrtl: "\u21A2",
      lat: "\u2AAB",
      lAtail: "\u291B",
      latail: "\u2919",
      late: "\u2AAD",
      lates: "\u2AAD\uFE00",
      lBarr: "\u290E",
      lbarr: "\u290C",
      lbbrk: "\u2772",
      lbrace: "{",
      lbrack: "[",
      lbrke: "\u298B",
      lbrksld: "\u298F",
      lbrkslu: "\u298D",
      Lcaron: "\u013D",
      lcaron: "\u013E",
      Lcedil: "\u013B",
      lcedil: "\u013C",
      lceil: "\u2308",
      lcub: "{",
      Lcy: "\u041B",
      lcy: "\u043B",
      ldca: "\u2936",
      ldquo: "\u201C",
      ldquor: "\u201E",
      ldrdhar: "\u2967",
      ldrushar: "\u294B",
      ldsh: "\u21B2",
      lE: "\u2266",
      le: "\u2264",
      LeftAngleBracket: "\u27E8",
      LeftArrow: "\u2190",
      Leftarrow: "\u21D0",
      leftarrow: "\u2190",
      LeftArrowBar: "\u21E4",
      LeftArrowRightArrow: "\u21C6",
      leftarrowtail: "\u21A2",
      LeftCeiling: "\u2308",
      LeftDoubleBracket: "\u27E6",
      LeftDownTeeVector: "\u2961",
      LeftDownVector: "\u21C3",
      LeftDownVectorBar: "\u2959",
      LeftFloor: "\u230A",
      leftharpoondown: "\u21BD",
      leftharpoonup: "\u21BC",
      leftleftarrows: "\u21C7",
      LeftRightArrow: "\u2194",
      Leftrightarrow: "\u21D4",
      leftrightarrow: "\u2194",
      leftrightarrows: "\u21C6",
      leftrightharpoons: "\u21CB",
      leftrightsquigarrow: "\u21AD",
      LeftRightVector: "\u294E",
      LeftTee: "\u22A3",
      LeftTeeArrow: "\u21A4",
      LeftTeeVector: "\u295A",
      leftthreetimes: "\u22CB",
      LeftTriangle: "\u22B2",
      LeftTriangleBar: "\u29CF",
      LeftTriangleEqual: "\u22B4",
      LeftUpDownVector: "\u2951",
      LeftUpTeeVector: "\u2960",
      LeftUpVector: "\u21BF",
      LeftUpVectorBar: "\u2958",
      LeftVector: "\u21BC",
      LeftVectorBar: "\u2952",
      lEg: "\u2A8B",
      leg: "\u22DA",
      leq: "\u2264",
      leqq: "\u2266",
      leqslant: "\u2A7D",
      les: "\u2A7D",
      lescc: "\u2AA8",
      lesdot: "\u2A7F",
      lesdoto: "\u2A81",
      lesdotor: "\u2A83",
      lesg: "\u22DA\uFE00",
      lesges: "\u2A93",
      lessapprox: "\u2A85",
      lessdot: "\u22D6",
      lesseqgtr: "\u22DA",
      lesseqqgtr: "\u2A8B",
      LessEqualGreater: "\u22DA",
      LessFullEqual: "\u2266",
      LessGreater: "\u2276",
      lessgtr: "\u2276",
      LessLess: "\u2AA1",
      lesssim: "\u2272",
      LessSlantEqual: "\u2A7D",
      LessTilde: "\u2272",
      lfisht: "\u297C",
      lfloor: "\u230A",
      Lfr: "\u{1D50F}",
      lfr: "\u{1D529}",
      lg: "\u2276",
      lgE: "\u2A91",
      lHar: "\u2962",
      lhard: "\u21BD",
      lharu: "\u21BC",
      lharul: "\u296A",
      lhblk: "\u2584",
      LJcy: "\u0409",
      ljcy: "\u0459",
      Ll: "\u22D8",
      ll: "\u226A",
      llarr: "\u21C7",
      llcorner: "\u231E",
      Lleftarrow: "\u21DA",
      llhard: "\u296B",
      lltri: "\u25FA",
      Lmidot: "\u013F",
      lmidot: "\u0140",
      lmoust: "\u23B0",
      lmoustache: "\u23B0",
      lnap: "\u2A89",
      lnapprox: "\u2A89",
      lnE: "\u2268",
      lne: "\u2A87",
      lneq: "\u2A87",
      lneqq: "\u2268",
      lnsim: "\u22E6",
      loang: "\u27EC",
      loarr: "\u21FD",
      lobrk: "\u27E6",
      LongLeftArrow: "\u27F5",
      Longleftarrow: "\u27F8",
      longleftarrow: "\u27F5",
      LongLeftRightArrow: "\u27F7",
      Longleftrightarrow: "\u27FA",
      longleftrightarrow: "\u27F7",
      longmapsto: "\u27FC",
      LongRightArrow: "\u27F6",
      Longrightarrow: "\u27F9",
      longrightarrow: "\u27F6",
      looparrowleft: "\u21AB",
      looparrowright: "\u21AC",
      lopar: "\u2985",
      Lopf: "\u{1D543}",
      lopf: "\u{1D55D}",
      loplus: "\u2A2D",
      lotimes: "\u2A34",
      lowast: "\u2217",
      lowbar: "_",
      LowerLeftArrow: "\u2199",
      LowerRightArrow: "\u2198",
      loz: "\u25CA",
      lozenge: "\u25CA",
      lozf: "\u29EB",
      lpar: "(",
      lparlt: "\u2993",
      lrarr: "\u21C6",
      lrcorner: "\u231F",
      lrhar: "\u21CB",
      lrhard: "\u296D",
      lrm: "\u200E",
      lrtri: "\u22BF",
      lsaquo: "\u2039",
      Lscr: "\u2112",
      lscr: "\u{1D4C1}",
      Lsh: "\u21B0",
      lsh: "\u21B0",
      lsim: "\u2272",
      lsime: "\u2A8D",
      lsimg: "\u2A8F",
      lsqb: "[",
      lsquo: "\u2018",
      lsquor: "\u201A",
      Lstrok: "\u0141",
      lstrok: "\u0142",
      Lt: "\u226A",
      LT: "<",
      lt: "<",
      ltcc: "\u2AA6",
      ltcir: "\u2A79",
      ltdot: "\u22D6",
      lthree: "\u22CB",
      ltimes: "\u22C9",
      ltlarr: "\u2976",
      ltquest: "\u2A7B",
      ltri: "\u25C3",
      ltrie: "\u22B4",
      ltrif: "\u25C2",
      ltrPar: "\u2996",
      lurdshar: "\u294A",
      luruhar: "\u2966",
      lvertneqq: "\u2268\uFE00",
      lvnE: "\u2268\uFE00",
      macr: "\xAF",
      male: "\u2642",
      malt: "\u2720",
      maltese: "\u2720",
      Map: "\u2905",
      map: "\u21A6",
      mapsto: "\u21A6",
      mapstodown: "\u21A7",
      mapstoleft: "\u21A4",
      mapstoup: "\u21A5",
      marker: "\u25AE",
      mcomma: "\u2A29",
      Mcy: "\u041C",
      mcy: "\u043C",
      mdash: "\u2014",
      mDDot: "\u223A",
      measuredangle: "\u2221",
      MediumSpace: "\u205F",
      Mellintrf: "\u2133",
      Mfr: "\u{1D510}",
      mfr: "\u{1D52A}",
      mho: "\u2127",
      micro: "\xB5",
      mid: "\u2223",
      midast: "*",
      midcir: "\u2AF0",
      middot: "\xB7",
      minus: "\u2212",
      minusb: "\u229F",
      minusd: "\u2238",
      minusdu: "\u2A2A",
      MinusPlus: "\u2213",
      mlcp: "\u2ADB",
      mldr: "\u2026",
      mnplus: "\u2213",
      models: "\u22A7",
      Mopf: "\u{1D544}",
      mopf: "\u{1D55E}",
      mp: "\u2213",
      Mscr: "\u2133",
      mscr: "\u{1D4C2}",
      mstpos: "\u223E",
      Mu: "\u039C",
      mu: "\u03BC",
      multimap: "\u22B8",
      mumap: "\u22B8",
      nabla: "\u2207",
      Nacute: "\u0143",
      nacute: "\u0144",
      nang: "\u2220\u20D2",
      nap: "\u2249",
      napE: "\u2A70\u0338",
      napid: "\u224B\u0338",
      napos: "\u0149",
      napprox: "\u2249",
      natur: "\u266E",
      natural: "\u266E",
      naturals: "\u2115",
      nbsp: "\xA0",
      nbump: "\u224E\u0338",
      nbumpe: "\u224F\u0338",
      ncap: "\u2A43",
      Ncaron: "\u0147",
      ncaron: "\u0148",
      Ncedil: "\u0145",
      ncedil: "\u0146",
      ncong: "\u2247",
      ncongdot: "\u2A6D\u0338",
      ncup: "\u2A42",
      Ncy: "\u041D",
      ncy: "\u043D",
      ndash: "\u2013",
      ne: "\u2260",
      nearhk: "\u2924",
      neArr: "\u21D7",
      nearr: "\u2197",
      nearrow: "\u2197",
      nedot: "\u2250\u0338",
      NegativeMediumSpace: "\u200B",
      NegativeThickSpace: "\u200B",
      NegativeThinSpace: "\u200B",
      NegativeVeryThinSpace: "\u200B",
      nequiv: "\u2262",
      nesear: "\u2928",
      nesim: "\u2242\u0338",
      NestedGreaterGreater: "\u226B",
      NestedLessLess: "\u226A",
      NewLine: "\n",
      nexist: "\u2204",
      nexists: "\u2204",
      Nfr: "\u{1D511}",
      nfr: "\u{1D52B}",
      ngE: "\u2267\u0338",
      nge: "\u2271",
      ngeq: "\u2271",
      ngeqq: "\u2267\u0338",
      ngeqslant: "\u2A7E\u0338",
      nges: "\u2A7E\u0338",
      nGg: "\u22D9\u0338",
      ngsim: "\u2275",
      nGt: "\u226B\u20D2",
      ngt: "\u226F",
      ngtr: "\u226F",
      nGtv: "\u226B\u0338",
      nhArr: "\u21CE",
      nharr: "\u21AE",
      nhpar: "\u2AF2",
      ni: "\u220B",
      nis: "\u22FC",
      nisd: "\u22FA",
      niv: "\u220B",
      NJcy: "\u040A",
      njcy: "\u045A",
      nlArr: "\u21CD",
      nlarr: "\u219A",
      nldr: "\u2025",
      nlE: "\u2266\u0338",
      nle: "\u2270",
      nLeftarrow: "\u21CD",
      nleftarrow: "\u219A",
      nLeftrightarrow: "\u21CE",
      nleftrightarrow: "\u21AE",
      nleq: "\u2270",
      nleqq: "\u2266\u0338",
      nleqslant: "\u2A7D\u0338",
      nles: "\u2A7D\u0338",
      nless: "\u226E",
      nLl: "\u22D8\u0338",
      nlsim: "\u2274",
      nLt: "\u226A\u20D2",
      nlt: "\u226E",
      nltri: "\u22EA",
      nltrie: "\u22EC",
      nLtv: "\u226A\u0338",
      nmid: "\u2224",
      NoBreak: "\u2060",
      NonBreakingSpace: "\xA0",
      Nopf: "\u2115",
      nopf: "\u{1D55F}",
      Not: "\u2AEC",
      not: "\xAC",
      NotCongruent: "\u2262",
      NotCupCap: "\u226D",
      NotDoubleVerticalBar: "\u2226",
      NotElement: "\u2209",
      NotEqual: "\u2260",
      NotEqualTilde: "\u2242\u0338",
      NotExists: "\u2204",
      NotGreater: "\u226F",
      NotGreaterEqual: "\u2271",
      NotGreaterFullEqual: "\u2267\u0338",
      NotGreaterGreater: "\u226B\u0338",
      NotGreaterLess: "\u2279",
      NotGreaterSlantEqual: "\u2A7E\u0338",
      NotGreaterTilde: "\u2275",
      NotHumpDownHump: "\u224E\u0338",
      NotHumpEqual: "\u224F\u0338",
      notin: "\u2209",
      notindot: "\u22F5\u0338",
      notinE: "\u22F9\u0338",
      notinva: "\u2209",
      notinvb: "\u22F7",
      notinvc: "\u22F6",
      NotLeftTriangle: "\u22EA",
      NotLeftTriangleBar: "\u29CF\u0338",
      NotLeftTriangleEqual: "\u22EC",
      NotLess: "\u226E",
      NotLessEqual: "\u2270",
      NotLessGreater: "\u2278",
      NotLessLess: "\u226A\u0338",
      NotLessSlantEqual: "\u2A7D\u0338",
      NotLessTilde: "\u2274",
      NotNestedGreaterGreater: "\u2AA2\u0338",
      NotNestedLessLess: "\u2AA1\u0338",
      notni: "\u220C",
      notniva: "\u220C",
      notnivb: "\u22FE",
      notnivc: "\u22FD",
      NotPrecedes: "\u2280",
      NotPrecedesEqual: "\u2AAF\u0338",
      NotPrecedesSlantEqual: "\u22E0",
      NotReverseElement: "\u220C",
      NotRightTriangle: "\u22EB",
      NotRightTriangleBar: "\u29D0\u0338",
      NotRightTriangleEqual: "\u22ED",
      NotSquareSubset: "\u228F\u0338",
      NotSquareSubsetEqual: "\u22E2",
      NotSquareSuperset: "\u2290\u0338",
      NotSquareSupersetEqual: "\u22E3",
      NotSubset: "\u2282\u20D2",
      NotSubsetEqual: "\u2288",
      NotSucceeds: "\u2281",
      NotSucceedsEqual: "\u2AB0\u0338",
      NotSucceedsSlantEqual: "\u22E1",
      NotSucceedsTilde: "\u227F\u0338",
      NotSuperset: "\u2283\u20D2",
      NotSupersetEqual: "\u2289",
      NotTilde: "\u2241",
      NotTildeEqual: "\u2244",
      NotTildeFullEqual: "\u2247",
      NotTildeTilde: "\u2249",
      NotVerticalBar: "\u2224",
      npar: "\u2226",
      nparallel: "\u2226",
      nparsl: "\u2AFD\u20E5",
      npart: "\u2202\u0338",
      npolint: "\u2A14",
      npr: "\u2280",
      nprcue: "\u22E0",
      npre: "\u2AAF\u0338",
      nprec: "\u2280",
      npreceq: "\u2AAF\u0338",
      nrArr: "\u21CF",
      nrarr: "\u219B",
      nrarrc: "\u2933\u0338",
      nrarrw: "\u219D\u0338",
      nRightarrow: "\u21CF",
      nrightarrow: "\u219B",
      nrtri: "\u22EB",
      nrtrie: "\u22ED",
      nsc: "\u2281",
      nsccue: "\u22E1",
      nsce: "\u2AB0\u0338",
      Nscr: "\u{1D4A9}",
      nscr: "\u{1D4C3}",
      nshortmid: "\u2224",
      nshortparallel: "\u2226",
      nsim: "\u2241",
      nsime: "\u2244",
      nsimeq: "\u2244",
      nsmid: "\u2224",
      nspar: "\u2226",
      nsqsube: "\u22E2",
      nsqsupe: "\u22E3",
      nsub: "\u2284",
      nsubE: "\u2AC5\u0338",
      nsube: "\u2288",
      nsubset: "\u2282\u20D2",
      nsubseteq: "\u2288",
      nsubseteqq: "\u2AC5\u0338",
      nsucc: "\u2281",
      nsucceq: "\u2AB0\u0338",
      nsup: "\u2285",
      nsupE: "\u2AC6\u0338",
      nsupe: "\u2289",
      nsupset: "\u2283\u20D2",
      nsupseteq: "\u2289",
      nsupseteqq: "\u2AC6\u0338",
      ntgl: "\u2279",
      Ntilde: "\xD1",
      ntilde: "\xF1",
      ntlg: "\u2278",
      ntriangleleft: "\u22EA",
      ntrianglelefteq: "\u22EC",
      ntriangleright: "\u22EB",
      ntrianglerighteq: "\u22ED",
      Nu: "\u039D",
      nu: "\u03BD",
      num: "#",
      numero: "\u2116",
      numsp: "\u2007",
      nvap: "\u224D\u20D2",
      nVDash: "\u22AF",
      nVdash: "\u22AE",
      nvDash: "\u22AD",
      nvdash: "\u22AC",
      nvge: "\u2265\u20D2",
      nvgt: ">\u20D2",
      nvHarr: "\u2904",
      nvinfin: "\u29DE",
      nvlArr: "\u2902",
      nvle: "\u2264\u20D2",
      nvlt: "<\u20D2",
      nvltrie: "\u22B4\u20D2",
      nvrArr: "\u2903",
      nvrtrie: "\u22B5\u20D2",
      nvsim: "\u223C\u20D2",
      nwarhk: "\u2923",
      nwArr: "\u21D6",
      nwarr: "\u2196",
      nwarrow: "\u2196",
      nwnear: "\u2927",
      Oacute: "\xD3",
      oacute: "\xF3",
      oast: "\u229B",
      ocir: "\u229A",
      Ocirc: "\xD4",
      ocirc: "\xF4",
      Ocy: "\u041E",
      ocy: "\u043E",
      odash: "\u229D",
      Odblac: "\u0150",
      odblac: "\u0151",
      odiv: "\u2A38",
      odot: "\u2299",
      odsold: "\u29BC",
      OElig: "\u0152",
      oelig: "\u0153",
      ofcir: "\u29BF",
      Ofr: "\u{1D512}",
      ofr: "\u{1D52C}",
      ogon: "\u02DB",
      Ograve: "\xD2",
      ograve: "\xF2",
      ogt: "\u29C1",
      ohbar: "\u29B5",
      ohm: "\u03A9",
      oint: "\u222E",
      olarr: "\u21BA",
      olcir: "\u29BE",
      olcross: "\u29BB",
      oline: "\u203E",
      olt: "\u29C0",
      Omacr: "\u014C",
      omacr: "\u014D",
      Omega: "\u03A9",
      omega: "\u03C9",
      Omicron: "\u039F",
      omicron: "\u03BF",
      omid: "\u29B6",
      ominus: "\u2296",
      Oopf: "\u{1D546}",
      oopf: "\u{1D560}",
      opar: "\u29B7",
      OpenCurlyDoubleQuote: "\u201C",
      OpenCurlyQuote: "\u2018",
      operp: "\u29B9",
      oplus: "\u2295",
      Or: "\u2A54",
      or: "\u2228",
      orarr: "\u21BB",
      ord: "\u2A5D",
      order: "\u2134",
      orderof: "\u2134",
      ordf: "\xAA",
      ordm: "\xBA",
      origof: "\u22B6",
      oror: "\u2A56",
      orslope: "\u2A57",
      orv: "\u2A5B",
      oS: "\u24C8",
      Oscr: "\u{1D4AA}",
      oscr: "\u2134",
      Oslash: "\xD8",
      oslash: "\xF8",
      osol: "\u2298",
      Otilde: "\xD5",
      otilde: "\xF5",
      Otimes: "\u2A37",
      otimes: "\u2297",
      otimesas: "\u2A36",
      Ouml: "\xD6",
      ouml: "\xF6",
      ovbar: "\u233D",
      OverBar: "\u203E",
      OverBrace: "\u23DE",
      OverBracket: "\u23B4",
      OverParenthesis: "\u23DC",
      par: "\u2225",
      para: "\xB6",
      parallel: "\u2225",
      parsim: "\u2AF3",
      parsl: "\u2AFD",
      part: "\u2202",
      PartialD: "\u2202",
      Pcy: "\u041F",
      pcy: "\u043F",
      percnt: "%",
      period: ".",
      permil: "\u2030",
      perp: "\u22A5",
      pertenk: "\u2031",
      Pfr: "\u{1D513}",
      pfr: "\u{1D52D}",
      Phi: "\u03A6",
      phi: "\u03C6",
      phiv: "\u03D5",
      phmmat: "\u2133",
      phone: "\u260E",
      Pi: "\u03A0",
      pi: "\u03C0",
      pitchfork: "\u22D4",
      piv: "\u03D6",
      planck: "\u210F",
      planckh: "\u210E",
      plankv: "\u210F",
      plus: "+",
      plusacir: "\u2A23",
      plusb: "\u229E",
      pluscir: "\u2A22",
      plusdo: "\u2214",
      plusdu: "\u2A25",
      pluse: "\u2A72",
      PlusMinus: "\xB1",
      plusmn: "\xB1",
      plussim: "\u2A26",
      plustwo: "\u2A27",
      pm: "\xB1",
      Poincareplane: "\u210C",
      pointint: "\u2A15",
      Popf: "\u2119",
      popf: "\u{1D561}",
      pound: "\xA3",
      Pr: "\u2ABB",
      pr: "\u227A",
      prap: "\u2AB7",
      prcue: "\u227C",
      prE: "\u2AB3",
      pre: "\u2AAF",
      prec: "\u227A",
      precapprox: "\u2AB7",
      preccurlyeq: "\u227C",
      Precedes: "\u227A",
      PrecedesEqual: "\u2AAF",
      PrecedesSlantEqual: "\u227C",
      PrecedesTilde: "\u227E",
      preceq: "\u2AAF",
      precnapprox: "\u2AB9",
      precneqq: "\u2AB5",
      precnsim: "\u22E8",
      precsim: "\u227E",
      Prime: "\u2033",
      prime: "\u2032",
      primes: "\u2119",
      prnap: "\u2AB9",
      prnE: "\u2AB5",
      prnsim: "\u22E8",
      prod: "\u220F",
      Product: "\u220F",
      profalar: "\u232E",
      profline: "\u2312",
      profsurf: "\u2313",
      prop: "\u221D",
      Proportion: "\u2237",
      Proportional: "\u221D",
      propto: "\u221D",
      prsim: "\u227E",
      prurel: "\u22B0",
      Pscr: "\u{1D4AB}",
      pscr: "\u{1D4C5}",
      Psi: "\u03A8",
      psi: "\u03C8",
      puncsp: "\u2008",
      Qfr: "\u{1D514}",
      qfr: "\u{1D52E}",
      qint: "\u2A0C",
      Qopf: "\u211A",
      qopf: "\u{1D562}",
      qprime: "\u2057",
      Qscr: "\u{1D4AC}",
      qscr: "\u{1D4C6}",
      quaternions: "\u210D",
      quatint: "\u2A16",
      quest: "?",
      questeq: "\u225F",
      QUOT: '"',
      quot: '"',
      rAarr: "\u21DB",
      race: "\u223D\u0331",
      Racute: "\u0154",
      racute: "\u0155",
      radic: "\u221A",
      raemptyv: "\u29B3",
      Rang: "\u27EB",
      rang: "\u27E9",
      rangd: "\u2992",
      range: "\u29A5",
      rangle: "\u27E9",
      raquo: "\xBB",
      Rarr: "\u21A0",
      rArr: "\u21D2",
      rarr: "\u2192",
      rarrap: "\u2975",
      rarrb: "\u21E5",
      rarrbfs: "\u2920",
      rarrc: "\u2933",
      rarrfs: "\u291E",
      rarrhk: "\u21AA",
      rarrlp: "\u21AC",
      rarrpl: "\u2945",
      rarrsim: "\u2974",
      Rarrtl: "\u2916",
      rarrtl: "\u21A3",
      rarrw: "\u219D",
      rAtail: "\u291C",
      ratail: "\u291A",
      ratio: "\u2236",
      rationals: "\u211A",
      RBarr: "\u2910",
      rBarr: "\u290F",
      rbarr: "\u290D",
      rbbrk: "\u2773",
      rbrace: "}",
      rbrack: "]",
      rbrke: "\u298C",
      rbrksld: "\u298E",
      rbrkslu: "\u2990",
      Rcaron: "\u0158",
      rcaron: "\u0159",
      Rcedil: "\u0156",
      rcedil: "\u0157",
      rceil: "\u2309",
      rcub: "}",
      Rcy: "\u0420",
      rcy: "\u0440",
      rdca: "\u2937",
      rdldhar: "\u2969",
      rdquo: "\u201D",
      rdquor: "\u201D",
      rdsh: "\u21B3",
      Re: "\u211C",
      real: "\u211C",
      realine: "\u211B",
      realpart: "\u211C",
      reals: "\u211D",
      rect: "\u25AD",
      REG: "\xAE",
      reg: "\xAE",
      ReverseElement: "\u220B",
      ReverseEquilibrium: "\u21CB",
      ReverseUpEquilibrium: "\u296F",
      rfisht: "\u297D",
      rfloor: "\u230B",
      Rfr: "\u211C",
      rfr: "\u{1D52F}",
      rHar: "\u2964",
      rhard: "\u21C1",
      rharu: "\u21C0",
      rharul: "\u296C",
      Rho: "\u03A1",
      rho: "\u03C1",
      rhov: "\u03F1",
      RightAngleBracket: "\u27E9",
      RightArrow: "\u2192",
      Rightarrow: "\u21D2",
      rightarrow: "\u2192",
      RightArrowBar: "\u21E5",
      RightArrowLeftArrow: "\u21C4",
      rightarrowtail: "\u21A3",
      RightCeiling: "\u2309",
      RightDoubleBracket: "\u27E7",
      RightDownTeeVector: "\u295D",
      RightDownVector: "\u21C2",
      RightDownVectorBar: "\u2955",
      RightFloor: "\u230B",
      rightharpoondown: "\u21C1",
      rightharpoonup: "\u21C0",
      rightleftarrows: "\u21C4",
      rightleftharpoons: "\u21CC",
      rightrightarrows: "\u21C9",
      rightsquigarrow: "\u219D",
      RightTee: "\u22A2",
      RightTeeArrow: "\u21A6",
      RightTeeVector: "\u295B",
      rightthreetimes: "\u22CC",
      RightTriangle: "\u22B3",
      RightTriangleBar: "\u29D0",
      RightTriangleEqual: "\u22B5",
      RightUpDownVector: "\u294F",
      RightUpTeeVector: "\u295C",
      RightUpVector: "\u21BE",
      RightUpVectorBar: "\u2954",
      RightVector: "\u21C0",
      RightVectorBar: "\u2953",
      ring: "\u02DA",
      risingdotseq: "\u2253",
      rlarr: "\u21C4",
      rlhar: "\u21CC",
      rlm: "\u200F",
      rmoust: "\u23B1",
      rmoustache: "\u23B1",
      rnmid: "\u2AEE",
      roang: "\u27ED",
      roarr: "\u21FE",
      robrk: "\u27E7",
      ropar: "\u2986",
      Ropf: "\u211D",
      ropf: "\u{1D563}",
      roplus: "\u2A2E",
      rotimes: "\u2A35",
      RoundImplies: "\u2970",
      rpar: ")",
      rpargt: "\u2994",
      rppolint: "\u2A12",
      rrarr: "\u21C9",
      Rrightarrow: "\u21DB",
      rsaquo: "\u203A",
      Rscr: "\u211B",
      rscr: "\u{1D4C7}",
      Rsh: "\u21B1",
      rsh: "\u21B1",
      rsqb: "]",
      rsquo: "\u2019",
      rsquor: "\u2019",
      rthree: "\u22CC",
      rtimes: "\u22CA",
      rtri: "\u25B9",
      rtrie: "\u22B5",
      rtrif: "\u25B8",
      rtriltri: "\u29CE",
      RuleDelayed: "\u29F4",
      ruluhar: "\u2968",
      rx: "\u211E",
      Sacute: "\u015A",
      sacute: "\u015B",
      sbquo: "\u201A",
      Sc: "\u2ABC",
      sc: "\u227B",
      scap: "\u2AB8",
      Scaron: "\u0160",
      scaron: "\u0161",
      sccue: "\u227D",
      scE: "\u2AB4",
      sce: "\u2AB0",
      Scedil: "\u015E",
      scedil: "\u015F",
      Scirc: "\u015C",
      scirc: "\u015D",
      scnap: "\u2ABA",
      scnE: "\u2AB6",
      scnsim: "\u22E9",
      scpolint: "\u2A13",
      scsim: "\u227F",
      Scy: "\u0421",
      scy: "\u0441",
      sdot: "\u22C5",
      sdotb: "\u22A1",
      sdote: "\u2A66",
      searhk: "\u2925",
      seArr: "\u21D8",
      searr: "\u2198",
      searrow: "\u2198",
      sect: "\xA7",
      semi: ";",
      seswar: "\u2929",
      setminus: "\u2216",
      setmn: "\u2216",
      sext: "\u2736",
      Sfr: "\u{1D516}",
      sfr: "\u{1D530}",
      sfrown: "\u2322",
      sharp: "\u266F",
      SHCHcy: "\u0429",
      shchcy: "\u0449",
      SHcy: "\u0428",
      shcy: "\u0448",
      ShortDownArrow: "\u2193",
      ShortLeftArrow: "\u2190",
      shortmid: "\u2223",
      shortparallel: "\u2225",
      ShortRightArrow: "\u2192",
      ShortUpArrow: "\u2191",
      shy: "\xAD",
      Sigma: "\u03A3",
      sigma: "\u03C3",
      sigmaf: "\u03C2",
      sigmav: "\u03C2",
      sim: "\u223C",
      simdot: "\u2A6A",
      sime: "\u2243",
      simeq: "\u2243",
      simg: "\u2A9E",
      simgE: "\u2AA0",
      siml: "\u2A9D",
      simlE: "\u2A9F",
      simne: "\u2246",
      simplus: "\u2A24",
      simrarr: "\u2972",
      slarr: "\u2190",
      SmallCircle: "\u2218",
      smallsetminus: "\u2216",
      smashp: "\u2A33",
      smeparsl: "\u29E4",
      smid: "\u2223",
      smile: "\u2323",
      smt: "\u2AAA",
      smte: "\u2AAC",
      smtes: "\u2AAC\uFE00",
      SOFTcy: "\u042C",
      softcy: "\u044C",
      sol: "/",
      solb: "\u29C4",
      solbar: "\u233F",
      Sopf: "\u{1D54A}",
      sopf: "\u{1D564}",
      spades: "\u2660",
      spadesuit: "\u2660",
      spar: "\u2225",
      sqcap: "\u2293",
      sqcaps: "\u2293\uFE00",
      sqcup: "\u2294",
      sqcups: "\u2294\uFE00",
      Sqrt: "\u221A",
      sqsub: "\u228F",
      sqsube: "\u2291",
      sqsubset: "\u228F",
      sqsubseteq: "\u2291",
      sqsup: "\u2290",
      sqsupe: "\u2292",
      sqsupset: "\u2290",
      sqsupseteq: "\u2292",
      squ: "\u25A1",
      Square: "\u25A1",
      square: "\u25A1",
      SquareIntersection: "\u2293",
      SquareSubset: "\u228F",
      SquareSubsetEqual: "\u2291",
      SquareSuperset: "\u2290",
      SquareSupersetEqual: "\u2292",
      SquareUnion: "\u2294",
      squarf: "\u25AA",
      squf: "\u25AA",
      srarr: "\u2192",
      Sscr: "\u{1D4AE}",
      sscr: "\u{1D4C8}",
      ssetmn: "\u2216",
      ssmile: "\u2323",
      sstarf: "\u22C6",
      Star: "\u22C6",
      star: "\u2606",
      starf: "\u2605",
      straightepsilon: "\u03F5",
      straightphi: "\u03D5",
      strns: "\xAF",
      Sub: "\u22D0",
      sub: "\u2282",
      subdot: "\u2ABD",
      subE: "\u2AC5",
      sube: "\u2286",
      subedot: "\u2AC3",
      submult: "\u2AC1",
      subnE: "\u2ACB",
      subne: "\u228A",
      subplus: "\u2ABF",
      subrarr: "\u2979",
      Subset: "\u22D0",
      subset: "\u2282",
      subseteq: "\u2286",
      subseteqq: "\u2AC5",
      SubsetEqual: "\u2286",
      subsetneq: "\u228A",
      subsetneqq: "\u2ACB",
      subsim: "\u2AC7",
      subsub: "\u2AD5",
      subsup: "\u2AD3",
      succ: "\u227B",
      succapprox: "\u2AB8",
      succcurlyeq: "\u227D",
      Succeeds: "\u227B",
      SucceedsEqual: "\u2AB0",
      SucceedsSlantEqual: "\u227D",
      SucceedsTilde: "\u227F",
      succeq: "\u2AB0",
      succnapprox: "\u2ABA",
      succneqq: "\u2AB6",
      succnsim: "\u22E9",
      succsim: "\u227F",
      SuchThat: "\u220B",
      Sum: "\u2211",
      sum: "\u2211",
      sung: "\u266A",
      Sup: "\u22D1",
      sup: "\u2283",
      sup1: "\xB9",
      sup2: "\xB2",
      sup3: "\xB3",
      supdot: "\u2ABE",
      supdsub: "\u2AD8",
      supE: "\u2AC6",
      supe: "\u2287",
      supedot: "\u2AC4",
      Superset: "\u2283",
      SupersetEqual: "\u2287",
      suphsol: "\u27C9",
      suphsub: "\u2AD7",
      suplarr: "\u297B",
      supmult: "\u2AC2",
      supnE: "\u2ACC",
      supne: "\u228B",
      supplus: "\u2AC0",
      Supset: "\u22D1",
      supset: "\u2283",
      supseteq: "\u2287",
      supseteqq: "\u2AC6",
      supsetneq: "\u228B",
      supsetneqq: "\u2ACC",
      supsim: "\u2AC8",
      supsub: "\u2AD4",
      supsup: "\u2AD6",
      swarhk: "\u2926",
      swArr: "\u21D9",
      swarr: "\u2199",
      swarrow: "\u2199",
      swnwar: "\u292A",
      szlig: "\xDF",
      Tab: "	",
      target: "\u2316",
      Tau: "\u03A4",
      tau: "\u03C4",
      tbrk: "\u23B4",
      Tcaron: "\u0164",
      tcaron: "\u0165",
      Tcedil: "\u0162",
      tcedil: "\u0163",
      Tcy: "\u0422",
      tcy: "\u0442",
      tdot: "\u20DB",
      telrec: "\u2315",
      Tfr: "\u{1D517}",
      tfr: "\u{1D531}",
      there4: "\u2234",
      Therefore: "\u2234",
      therefore: "\u2234",
      Theta: "\u0398",
      theta: "\u03B8",
      thetasym: "\u03D1",
      thetav: "\u03D1",
      thickapprox: "\u2248",
      thicksim: "\u223C",
      ThickSpace: "\u205F\u200A",
      thinsp: "\u2009",
      ThinSpace: "\u2009",
      thkap: "\u2248",
      thksim: "\u223C",
      THORN: "\xDE",
      thorn: "\xFE",
      Tilde: "\u223C",
      tilde: "\u02DC",
      TildeEqual: "\u2243",
      TildeFullEqual: "\u2245",
      TildeTilde: "\u2248",
      times: "\xD7",
      timesb: "\u22A0",
      timesbar: "\u2A31",
      timesd: "\u2A30",
      tint: "\u222D",
      toea: "\u2928",
      top: "\u22A4",
      topbot: "\u2336",
      topcir: "\u2AF1",
      Topf: "\u{1D54B}",
      topf: "\u{1D565}",
      topfork: "\u2ADA",
      tosa: "\u2929",
      tprime: "\u2034",
      TRADE: "\u2122",
      trade: "\u2122",
      triangle: "\u25B5",
      triangledown: "\u25BF",
      triangleleft: "\u25C3",
      trianglelefteq: "\u22B4",
      triangleq: "\u225C",
      triangleright: "\u25B9",
      trianglerighteq: "\u22B5",
      tridot: "\u25EC",
      trie: "\u225C",
      triminus: "\u2A3A",
      TripleDot: "\u20DB",
      triplus: "\u2A39",
      trisb: "\u29CD",
      tritime: "\u2A3B",
      trpezium: "\u23E2",
      Tscr: "\u{1D4AF}",
      tscr: "\u{1D4C9}",
      TScy: "\u0426",
      tscy: "\u0446",
      TSHcy: "\u040B",
      tshcy: "\u045B",
      Tstrok: "\u0166",
      tstrok: "\u0167",
      twixt: "\u226C",
      twoheadleftarrow: "\u219E",
      twoheadrightarrow: "\u21A0",
      Uacute: "\xDA",
      uacute: "\xFA",
      Uarr: "\u219F",
      uArr: "\u21D1",
      uarr: "\u2191",
      Uarrocir: "\u2949",
      Ubrcy: "\u040E",
      ubrcy: "\u045E",
      Ubreve: "\u016C",
      ubreve: "\u016D",
      Ucirc: "\xDB",
      ucirc: "\xFB",
      Ucy: "\u0423",
      ucy: "\u0443",
      udarr: "\u21C5",
      Udblac: "\u0170",
      udblac: "\u0171",
      udhar: "\u296E",
      ufisht: "\u297E",
      Ufr: "\u{1D518}",
      ufr: "\u{1D532}",
      Ugrave: "\xD9",
      ugrave: "\xF9",
      uHar: "\u2963",
      uharl: "\u21BF",
      uharr: "\u21BE",
      uhblk: "\u2580",
      ulcorn: "\u231C",
      ulcorner: "\u231C",
      ulcrop: "\u230F",
      ultri: "\u25F8",
      Umacr: "\u016A",
      umacr: "\u016B",
      uml: "\xA8",
      UnderBar: "_",
      UnderBrace: "\u23DF",
      UnderBracket: "\u23B5",
      UnderParenthesis: "\u23DD",
      Union: "\u22C3",
      UnionPlus: "\u228E",
      Uogon: "\u0172",
      uogon: "\u0173",
      Uopf: "\u{1D54C}",
      uopf: "\u{1D566}",
      UpArrow: "\u2191",
      Uparrow: "\u21D1",
      uparrow: "\u2191",
      UpArrowBar: "\u2912",
      UpArrowDownArrow: "\u21C5",
      UpDownArrow: "\u2195",
      Updownarrow: "\u21D5",
      updownarrow: "\u2195",
      UpEquilibrium: "\u296E",
      upharpoonleft: "\u21BF",
      upharpoonright: "\u21BE",
      uplus: "\u228E",
      UpperLeftArrow: "\u2196",
      UpperRightArrow: "\u2197",
      Upsi: "\u03D2",
      upsi: "\u03C5",
      upsih: "\u03D2",
      Upsilon: "\u03A5",
      upsilon: "\u03C5",
      UpTee: "\u22A5",
      UpTeeArrow: "\u21A5",
      upuparrows: "\u21C8",
      urcorn: "\u231D",
      urcorner: "\u231D",
      urcrop: "\u230E",
      Uring: "\u016E",
      uring: "\u016F",
      urtri: "\u25F9",
      Uscr: "\u{1D4B0}",
      uscr: "\u{1D4CA}",
      utdot: "\u22F0",
      Utilde: "\u0168",
      utilde: "\u0169",
      utri: "\u25B5",
      utrif: "\u25B4",
      uuarr: "\u21C8",
      Uuml: "\xDC",
      uuml: "\xFC",
      uwangle: "\u29A7",
      vangrt: "\u299C",
      varepsilon: "\u03F5",
      varkappa: "\u03F0",
      varnothing: "\u2205",
      varphi: "\u03D5",
      varpi: "\u03D6",
      varpropto: "\u221D",
      vArr: "\u21D5",
      varr: "\u2195",
      varrho: "\u03F1",
      varsigma: "\u03C2",
      varsubsetneq: "\u228A\uFE00",
      varsubsetneqq: "\u2ACB\uFE00",
      varsupsetneq: "\u228B\uFE00",
      varsupsetneqq: "\u2ACC\uFE00",
      vartheta: "\u03D1",
      vartriangleleft: "\u22B2",
      vartriangleright: "\u22B3",
      Vbar: "\u2AEB",
      vBar: "\u2AE8",
      vBarv: "\u2AE9",
      Vcy: "\u0412",
      vcy: "\u0432",
      VDash: "\u22AB",
      Vdash: "\u22A9",
      vDash: "\u22A8",
      vdash: "\u22A2",
      Vdashl: "\u2AE6",
      Vee: "\u22C1",
      vee: "\u2228",
      veebar: "\u22BB",
      veeeq: "\u225A",
      vellip: "\u22EE",
      Verbar: "\u2016",
      verbar: "|",
      Vert: "\u2016",
      vert: "|",
      VerticalBar: "\u2223",
      VerticalLine: "|",
      VerticalSeparator: "\u2758",
      VerticalTilde: "\u2240",
      VeryThinSpace: "\u200A",
      Vfr: "\u{1D519}",
      vfr: "\u{1D533}",
      vltri: "\u22B2",
      vnsub: "\u2282\u20D2",
      vnsup: "\u2283\u20D2",
      Vopf: "\u{1D54D}",
      vopf: "\u{1D567}",
      vprop: "\u221D",
      vrtri: "\u22B3",
      Vscr: "\u{1D4B1}",
      vscr: "\u{1D4CB}",
      vsubnE: "\u2ACB\uFE00",
      vsubne: "\u228A\uFE00",
      vsupnE: "\u2ACC\uFE00",
      vsupne: "\u228B\uFE00",
      Vvdash: "\u22AA",
      vzigzag: "\u299A",
      Wcirc: "\u0174",
      wcirc: "\u0175",
      wedbar: "\u2A5F",
      Wedge: "\u22C0",
      wedge: "\u2227",
      wedgeq: "\u2259",
      weierp: "\u2118",
      Wfr: "\u{1D51A}",
      wfr: "\u{1D534}",
      Wopf: "\u{1D54E}",
      wopf: "\u{1D568}",
      wp: "\u2118",
      wr: "\u2240",
      wreath: "\u2240",
      Wscr: "\u{1D4B2}",
      wscr: "\u{1D4CC}",
      xcap: "\u22C2",
      xcirc: "\u25EF",
      xcup: "\u22C3",
      xdtri: "\u25BD",
      Xfr: "\u{1D51B}",
      xfr: "\u{1D535}",
      xhArr: "\u27FA",
      xharr: "\u27F7",
      Xi: "\u039E",
      xi: "\u03BE",
      xlArr: "\u27F8",
      xlarr: "\u27F5",
      xmap: "\u27FC",
      xnis: "\u22FB",
      xodot: "\u2A00",
      Xopf: "\u{1D54F}",
      xopf: "\u{1D569}",
      xoplus: "\u2A01",
      xotime: "\u2A02",
      xrArr: "\u27F9",
      xrarr: "\u27F6",
      Xscr: "\u{1D4B3}",
      xscr: "\u{1D4CD}",
      xsqcup: "\u2A06",
      xuplus: "\u2A04",
      xutri: "\u25B3",
      xvee: "\u22C1",
      xwedge: "\u22C0",
      Yacute: "\xDD",
      yacute: "\xFD",
      YAcy: "\u042F",
      yacy: "\u044F",
      Ycirc: "\u0176",
      ycirc: "\u0177",
      Ycy: "\u042B",
      ycy: "\u044B",
      yen: "\xA5",
      Yfr: "\u{1D51C}",
      yfr: "\u{1D536}",
      YIcy: "\u0407",
      yicy: "\u0457",
      Yopf: "\u{1D550}",
      yopf: "\u{1D56A}",
      Yscr: "\u{1D4B4}",
      yscr: "\u{1D4CE}",
      YUcy: "\u042E",
      yucy: "\u044E",
      Yuml: "\u0178",
      yuml: "\xFF",
      Zacute: "\u0179",
      zacute: "\u017A",
      Zcaron: "\u017D",
      zcaron: "\u017E",
      Zcy: "\u0417",
      zcy: "\u0437",
      Zdot: "\u017B",
      zdot: "\u017C",
      zeetrf: "\u2128",
      ZeroWidthSpace: "\u200B",
      Zeta: "\u0396",
      zeta: "\u03B6",
      Zfr: "\u2128",
      zfr: "\u{1D537}",
      ZHcy: "\u0416",
      zhcy: "\u0436",
      zigrarr: "\u21DD",
      Zopf: "\u2124",
      zopf: "\u{1D56B}",
      Zscr: "\u{1D4B5}",
      zscr: "\u{1D4CF}",
      zwj: "\u200D",
      zwnj: "\u200C"
    });
    exports.entityMap = exports.HTML_ENTITIES;
  }
});

// node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/sax.js
var require_sax = __commonJS({
  "node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/sax.js"(exports) {
    var NAMESPACE = require_conventions().NAMESPACE;
    var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
    var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
    }
    ParseError.prototype = new Error();
    ParseError.prototype.name = ParseError.name;
    function XMLReader() {
    }
    XMLReader.prototype = {
      parse: function(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = {});
        parse3(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);
        domBuilder.endDocument();
      }
    };
    function parse3(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a2) {
        var k = a2.slice(1, -1);
        if (k in entityMap) {
          return entityMap[k];
        } else if (k.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a2);
          return a2;
        }
      }
      function appendText(end2) {
        if (end2 > start2) {
          var xt = source.substring(start2, end2).replace(/&#?\w+;/g, entityReplacer);
          locator && position(start2);
          domBuilder.characters(xt, 0, end2 - start2);
          start2 = end2;
        }
      }
      function position(p, m) {
        while (p >= lineEnd && (m = linePattern.exec(source))) {
          lineStart = m.index;
          lineEnd = lineStart + m[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p - lineStart + 1;
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.*(?:\r\n?|\n)|.*$/g;
      var locator = domBuilder.locator;
      var parseStack = [{
        currentNSMap: defaultNSMapCopy
      }];
      var closeMap = {};
      var start2 = 0;
      while (true) {
        try {
          var tagStart = source.indexOf("<", start2);
          if (tagStart < 0) {
            if (!source.substr(start2).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source.substr(start2));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start2) {
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case "/":
              var end = source.indexOf(">", tagStart + 3);
              var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
              var config = parseStack.pop();
              if (end < 0) {
                tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                end = tagStart + 1 + tagName.length;
              } else if (tagName.match(/\s</)) {
                tagName = tagName.replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                end = tagStart + 1 + tagName.length;
              }
              var localNSMap = config.localNSMap;
              var endMatch = config.tagName == tagName;
              var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
              if (endIgnoreCaseMach) {
                domBuilder.endElement(config.uri, config.localName, tagName);
                if (localNSMap) {
                  for (var prefix in localNSMap) {
                    if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                      domBuilder.endPrefixMapping(prefix);
                    }
                  }
                }
                if (!endMatch) {
                  errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                }
              } else {
                parseStack.push(config);
              }
              end++;
              break;
            case "?":
              locator && position(tagStart);
              end = parseInstruction(source, tagStart, domBuilder);
              break;
            case "!":
              locator && position(tagStart);
              end = parseDCC(source, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
              var len = el.length;
              if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                el.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning("unclosed xml attribute");
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i = 0; i < len; i++) {
                  var a = el[i];
                  position(a.offset);
                  a.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
              }
              if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
              } else {
                end++;
              }
          }
        } catch (e) {
          if (e instanceof ParseError) {
            throw e;
          }
          errorHandler.error("element parse error: " + e);
          end = -1;
        }
        if (end > start2) {
          start2 = end;
        } else {
          appendText(Math.max(tagStart, start2) + 1);
        }
      }
    }
    function copyLocator(f, t2) {
      t2.lineNumber = f.lineNumber;
      t2.columnNumber = f.columnNumber;
      return t2;
    }
    function parseElementStartPart(source, start2, el, currentNSMap, entityReplacer, errorHandler) {
      function addAttribute(qname, value2, startIndex) {
        if (el.attributeNames.hasOwnProperty(qname)) {
          errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        el.addValue(qname, value2, startIndex);
      }
      var attrName;
      var value;
      var p = ++start2;
      var s = S_TAG;
      while (true) {
        var c = source.charAt(p);
        switch (c) {
          case "=":
            if (s === S_ATTR) {
              attrName = source.slice(start2, p);
              s = S_EQ;
            } else if (s === S_ATTR_SPACE) {
              s = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s === S_EQ || s === S_ATTR) {
              if (s === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start2, p);
              }
              start2 = p + 1;
              p = source.indexOf(c, start2);
              if (p > 0) {
                value = source.slice(start2, p).replace(/&#?\w+;/g, entityReplacer);
                addAttribute(attrName, value, start2 - 1);
                s = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c + "' match");
              }
            } else if (s == S_ATTR_NOQUOT_VALUE) {
              value = source.slice(start2, p).replace(/&#?\w+;/g, entityReplacer);
              addAttribute(attrName, value, start2);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
              start2 = p + 1;
              s = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start2, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s = S_TAG_CLOSE;
                el.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                break;
              case S_ATTR_SPACE:
                el.closed = true;
                break;
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s == S_TAG) {
              el.setTagName(source.slice(start2, p));
            }
            return p;
          case ">":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start2, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                value = source.slice(start2, p);
                if (value.slice(-1) === "/") {
                  el.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!');
                  addAttribute(attrName, value.replace(/&#?\w+;/g, entityReplacer), start2);
                } else {
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                  }
                  addAttribute(value, value, start2);
                }
                break;
              case S_EQ:
                throw new Error("attribute value missed!!");
            }
            return p;
          case "\x80":
            c = " ";
          default:
            if (c <= " ") {
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start2, p));
                  s = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source.slice(start2, p);
                  s = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source.slice(start2, p).replace(/&#?\w+;/g, entityReplacer);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  addAttribute(attrName, value, start2);
                case S_ATTR_END:
                  s = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s) {
                case S_ATTR_SPACE:
                  var tagName = el.tagName;
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start2);
                  start2 = p;
                  s = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s = S_ATTR;
                  start2 = p;
                  break;
                case S_EQ:
                  s = S_ATTR_NOQUOT_VALUE;
                  start2 = p;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p++;
      }
    }
    function appendElement(el, domBuilder, currentNSMap) {
      var tagName = el.tagName;
      var localNSMap = null;
      var i = el.length;
      while (i--) {
        var a = el[i];
        var qName = a.qName;
        var value = a.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = a.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = {};
            _copy(currentNSMap, currentNSMap = {});
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i = el.length;
      while (i--) {
        a = el[i];
        var prefix = a.prefix;
        if (prefix) {
          if (prefix === "xml") {
            a.uri = NAMESPACE.XML;
          }
          if (prefix !== "xmlns") {
            a.uri = currentNSMap[prefix || ""];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el.localName = tagName;
      }
      var ns = el.uri = currentNSMap[prefix || ""];
      domBuilder.startElement(ns, localName, tagName, el);
      if (el.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
              domBuilder.endPrefixMapping(prefix);
            }
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        return true;
      }
    }
    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
      }
      return elStartEnd + 1;
    }
    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
      var pos = closeMap[tagName];
      if (pos == null) {
        pos = source.lastIndexOf("</" + tagName + ">");
        if (pos < elStartEnd) {
          pos = source.lastIndexOf("</" + tagName);
        }
        closeMap[tagName] = pos;
      }
      return pos < elStartEnd;
    }
    function _copy(source, target) {
      for (var n in source) {
        if (Object.prototype.hasOwnProperty.call(source, n)) {
          target[n] = source[n];
        }
      }
    }
    function parseDCC(source, start2, domBuilder, errorHandler) {
      var next = source.charAt(start2 + 2);
      switch (next) {
        case "-":
          if (source.charAt(start2 + 3) === "-") {
            var end = source.indexOf("-->", start2 + 4);
            if (end > start2) {
              domBuilder.comment(source, start2 + 4, end - start2 - 4);
              return end + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            return -1;
          }
        default:
          if (source.substr(start2 + 3, 6) == "CDATA[") {
            var end = source.indexOf("]]>", start2 + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source, start2 + 9, end - start2 - 9);
            domBuilder.endCDATA();
            return end + 3;
          }
          var matchs = split(source, start2);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name = matchs[1][0];
            var pubid = false;
            var sysid = false;
            if (len > 3) {
              if (/^public$/i.test(matchs[2][0])) {
                pubid = matchs[3][0];
                sysid = len > 4 && matchs[4][0];
              } else if (/^system$/i.test(matchs[2][0])) {
                sysid = matchs[3][0];
              }
            }
            var lastMatch = matchs[len - 1];
            domBuilder.startDTD(name, pubid, sysid);
            domBuilder.endDTD();
            return lastMatch.index + lastMatch[0].length;
          }
      }
      return -1;
    }
    function parseInstruction(source, start2, domBuilder) {
      var end = source.indexOf("?>", start2);
      if (end) {
        var match = source.substring(start2, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match) {
          var len = match[0].length;
          domBuilder.processingInstruction(match[1], match[2]);
          return end + 2;
        } else {
          return -1;
        }
      }
      return -1;
    }
    function ElementAttributes() {
      this.attributeNames = {};
    }
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = {
          qName,
          value,
          offset
        };
      },
      length: 0,
      getLocalName: function(i) {
        return this[i].localName;
      },
      getLocator: function(i) {
        return this[i].locator;
      },
      getQName: function(i) {
        return this[i].qName;
      },
      getURI: function(i) {
        return this[i].uri;
      },
      getValue: function(i) {
        return this[i].value;
      }
      //	,getIndex:function(uri, localName)){
      //		if(localName){
      //
      //		}else{
      //			var qName = uri
      //		}
      //	},
      //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
      //	getType:function(uri,localName){}
      //	getType:function(i){},
    };
    function split(source, start2) {
      var match;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start2;
      reg.exec(source);
      while (match = reg.exec(source)) {
        buf.push(match);
        if (match[1]) return buf;
      }
    }
    exports.XMLReader = XMLReader;
    exports.ParseError = ParseError;
  }
});

// node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = __commonJS({
  "node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports) {
    var conventions = require_conventions();
    var dom = require_dom();
    var entities = require_entities();
    var sax = require_sax();
    var DOMImplementation = dom.DOMImplementation;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = sax.ParseError;
    var XMLReader = sax.XMLReader;
    function DOMParser3(options) {
      this.options = options || {
        locator: {}
      };
    }
    DOMParser3.prototype.parseFromString = function(source, mimeType) {
      var options = this.options;
      var sax2 = new XMLReader();
      var domBuilder = options.domBuilder || new DOMHandler();
      var errorHandler = options.errorHandler;
      var locator = options.locator;
      var defaultNSMap = options.xmlns || {};
      var isHTML = /\/x?html?$/.test(mimeType);
      var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
      if (locator) {
        domBuilder.setDocumentLocator(locator);
      }
      sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax2.domBuilder = options.domBuilder || domBuilder;
      if (isHTML) {
        defaultNSMap[""] = NAMESPACE.HTML;
      }
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      if (source && typeof source === "string") {
        sax2.parse(source, defaultNSMap, entityMap);
      } else {
        sax2.errorHandler.error("invalid doc source");
      }
      return domBuilder.doc;
    };
    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {};
      var isCallback = errorImpl instanceof Function;
      locator = locator || {};
      function build(key) {
        var fn = errorImpl[key];
        if (!fn && isCallback) {
          fn = errorImpl.length == 2 ? function(msg) {
            errorImpl(key, msg);
          } : errorImpl;
        }
        errorHandler[key] = fn && function(msg) {
          fn("[xmldom " + key + "]	" + msg + _locator(locator));
        } || function() {
        };
      }
      build("warning");
      build("error");
      build("fatalError");
      return errorHandler;
    }
    function DOMHandler() {
      this.cdata = false;
    }
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      startDocument: function() {
        this.doc = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.doc.documentURI = this.locator.systemId;
        }
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;
        this.locator && position(this.locator, el);
        for (var i = 0; i < len; i++) {
          var namespaceURI = attrs.getURI(i);
          var value = attrs.getValue(i);
          var qName = attrs.getQName(i);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i), attr);
          attr.value = attr.nodeValue = value;
          el.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        var current = this.currentElement;
        var tagName = current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {
      },
      endPrefixMapping: function(prefix) {
      },
      processingInstruction: function(target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch, start2, length) {
      },
      characters: function(chars, start2, length) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(locator) {
        if (this.locator = locator) {
          locator.lineNumber = 0;
        }
      },
      //LexicalHandler
      comment: function(chars, start2, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      /**
       * @see org.xml.sax.ErrorHandler
       * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
       */
      warning: function(error) {
        console.warn("[xmldom warning]	" + error, _locator(this.locator));
      },
      error: function(error) {
        console.error("[xmldom error]	" + error, _locator(this.locator));
      },
      fatalError: function(error) {
        throw new ParseError(error, this.locator);
      }
    };
    function _locator(l) {
      if (l) {
        return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
      }
    }
    function _toString(chars, start2, length) {
      if (typeof chars == "string") {
        return chars.substr(start2, length);
      } else {
        if (chars.length >= start2 + length || start2) {
          return new java.lang.String(chars, start2, length) + "";
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
      DOMHandler.prototype[key] = function() {
        return null;
      };
    });
    function appendElement(hander, node) {
      if (!hander.currentElement) {
        hander.doc.appendChild(node);
      } else {
        hander.currentElement.appendChild(node);
      }
    }
    exports.__DOMHandler = DOMHandler;
    exports.DOMParser = DOMParser3;
    exports.DOMImplementation = dom.DOMImplementation;
    exports.XMLSerializer = dom.XMLSerializer;
  }
});

// node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/.pnpm/@xmldom+xmldom@0.7.13/node_modules/@xmldom/xmldom/lib/index.js"(exports) {
    var dom = require_dom();
    exports.DOMImplementation = dom.DOMImplementation;
    exports.XMLSerializer = dom.XMLSerializer;
    exports.DOMParser = require_dom_parser().DOMParser;
  }
});

// node_modules/.pnpm/mux.js@6.0.1/node_modules/mux.js/lib/utils/numbers.js
var require_numbers = __commonJS({
  "node_modules/.pnpm/mux.js@6.0.1/node_modules/mux.js/lib/utils/numbers.js"(exports, module) {
    var MAX_UINT32 = Math.pow(2, 32);
    var getUint64 = function(uint8) {
      var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
      var value;
      if (dv.getBigUint64) {
        value = dv.getBigUint64(0);
        if (value < Number.MAX_SAFE_INTEGER) {
          return Number(value);
        }
        return value;
      }
      return dv.getUint32(0) * MAX_UINT32 + dv.getUint32(4);
    };
    module.exports = {
      getUint64,
      MAX_UINT32
    };
  }
});

// node_modules/.pnpm/mux.js@6.0.1/node_modules/mux.js/lib/tools/parse-sidx.js
var require_parse_sidx = __commonJS({
  "node_modules/.pnpm/mux.js@6.0.1/node_modules/mux.js/lib/tools/parse-sidx.js"(exports, module) {
    var getUint64 = require_numbers().getUint64;
    var parseSidx2 = function(data) {
      var view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
        version: data[0],
        flags: new Uint8Array(data.subarray(1, 4)),
        references: [],
        referenceId: view.getUint32(4),
        timescale: view.getUint32(8)
      }, i = 12;
      if (result.version === 0) {
        result.earliestPresentationTime = view.getUint32(i);
        result.firstOffset = view.getUint32(i + 4);
        i += 8;
      } else {
        result.earliestPresentationTime = getUint64(data.subarray(i));
        result.firstOffset = getUint64(data.subarray(i + 8));
        i += 16;
      }
      i += 2;
      var referenceCount = view.getUint16(i);
      i += 2;
      for (; referenceCount > 0; i += 12, referenceCount--) {
        result.references.push({
          referenceType: (data[i] & 128) >>> 7,
          referencedSize: view.getUint32(i) & 2147483647,
          subsegmentDuration: view.getUint32(i + 4),
          startsWithSap: !!(data[i + 8] & 128),
          sapType: (data[i + 8] & 112) >>> 4,
          sapDeltaTime: view.getUint32(i + 8) & 268435455
        });
      }
      return result;
    };
    module.exports = parseSidx2;
  }
});

// node_modules/.pnpm/mux.js@6.0.1/node_modules/mux.js/lib/utils/clock.js
var require_clock = __commonJS({
  "node_modules/.pnpm/mux.js@6.0.1/node_modules/mux.js/lib/utils/clock.js"(exports, module) {
    var ONE_SECOND_IN_TS2 = 9e4;
    var secondsToVideoTs;
    var secondsToAudioTs;
    var videoTsToSeconds;
    var audioTsToSeconds;
    var audioTsToVideoTs;
    var videoTsToAudioTs;
    var metadataTsToSeconds;
    secondsToVideoTs = function(seconds) {
      return seconds * ONE_SECOND_IN_TS2;
    };
    secondsToAudioTs = function(seconds, sampleRate) {
      return seconds * sampleRate;
    };
    videoTsToSeconds = function(timestamp) {
      return timestamp / ONE_SECOND_IN_TS2;
    };
    audioTsToSeconds = function(timestamp, sampleRate) {
      return timestamp / sampleRate;
    };
    audioTsToVideoTs = function(timestamp, sampleRate) {
      return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));
    };
    videoTsToAudioTs = function(timestamp, sampleRate) {
      return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);
    };
    metadataTsToSeconds = function(timestamp, timelineStartPts, keepOriginalTimestamps) {
      return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
    };
    module.exports = {
      ONE_SECOND_IN_TS: ONE_SECOND_IN_TS2,
      secondsToVideoTs,
      secondsToAudioTs,
      videoTsToSeconds,
      audioTsToSeconds,
      audioTsToVideoTs,
      videoTsToAudioTs,
      metadataTsToSeconds
    };
  }
});

// node_modules/.pnpm/hls.js@1.4.12/node_modules/hls.js/dist/hls.mjs
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var urlToolkit = {
  exports: {}
};
(function(module, exports) {
  (function(root) {
    var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
    var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
    var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
    var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
    var URLToolkit2 = {
      // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
      // E.g
      // With opts.alwaysNormalize = false (default, spec compliant)
      // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
      // With opts.alwaysNormalize = true (not spec compliant)
      // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
      buildAbsoluteURL: function(baseURL, relativeURL, opts) {
        opts = opts || {};
        baseURL = baseURL.trim();
        relativeURL = relativeURL.trim();
        if (!relativeURL) {
          if (!opts.alwaysNormalize) {
            return baseURL;
          }
          var basePartsForNormalise = URLToolkit2.parseURL(baseURL);
          if (!basePartsForNormalise) {
            throw new Error("Error trying to parse base URL.");
          }
          basePartsForNormalise.path = URLToolkit2.normalizePath(basePartsForNormalise.path);
          return URLToolkit2.buildURLFromParts(basePartsForNormalise);
        }
        var relativeParts = URLToolkit2.parseURL(relativeURL);
        if (!relativeParts) {
          throw new Error("Error trying to parse relative URL.");
        }
        if (relativeParts.scheme) {
          if (!opts.alwaysNormalize) {
            return relativeURL;
          }
          relativeParts.path = URLToolkit2.normalizePath(relativeParts.path);
          return URLToolkit2.buildURLFromParts(relativeParts);
        }
        var baseParts = URLToolkit2.parseURL(baseURL);
        if (!baseParts) {
          throw new Error("Error trying to parse base URL.");
        }
        if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== "/") {
          var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
          baseParts.netLoc = pathParts[1];
          baseParts.path = pathParts[2];
        }
        if (baseParts.netLoc && !baseParts.path) {
          baseParts.path = "/";
        }
        var builtParts = {
          // 2c) Otherwise, the embedded URL inherits the scheme of
          // the base URL.
          scheme: baseParts.scheme,
          netLoc: relativeParts.netLoc,
          path: null,
          params: relativeParts.params,
          query: relativeParts.query,
          fragment: relativeParts.fragment
        };
        if (!relativeParts.netLoc) {
          builtParts.netLoc = baseParts.netLoc;
          if (relativeParts.path[0] !== "/") {
            if (!relativeParts.path) {
              builtParts.path = baseParts.path;
              if (!relativeParts.params) {
                builtParts.params = baseParts.params;
                if (!relativeParts.query) {
                  builtParts.query = baseParts.query;
                }
              }
            } else {
              var baseURLPath = baseParts.path;
              var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf("/") + 1) + relativeParts.path;
              builtParts.path = URLToolkit2.normalizePath(newPath);
            }
          }
        }
        if (builtParts.path === null) {
          builtParts.path = opts.alwaysNormalize ? URLToolkit2.normalizePath(relativeParts.path) : relativeParts.path;
        }
        return URLToolkit2.buildURLFromParts(builtParts);
      },
      parseURL: function(url) {
        var parts = URL_REGEX.exec(url);
        if (!parts) {
          return null;
        }
        return {
          scheme: parts[1] || "",
          netLoc: parts[2] || "",
          path: parts[3] || "",
          params: parts[4] || "",
          query: parts[5] || "",
          fragment: parts[6] || ""
        };
      },
      normalizePath: function(path) {
        path = path.split("").reverse().join("").replace(SLASH_DOT_REGEX, "");
        while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, "")).length) {
        }
        return path.split("").reverse().join("");
      },
      buildURLFromParts: function(parts) {
        return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
      }
    };
    module.exports = URLToolkit2;
  })();
})(urlToolkit);
var urlToolkitExports = urlToolkit.exports;
function ownKeys(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var isFiniteNumber = Number.isFinite || function(value) {
  return typeof value === "number" && isFinite(value);
};
var Events = /* @__PURE__ */ function(Events3) {
  Events3["MEDIA_ATTACHING"] = "hlsMediaAttaching";
  Events3["MEDIA_ATTACHED"] = "hlsMediaAttached";
  Events3["MEDIA_DETACHING"] = "hlsMediaDetaching";
  Events3["MEDIA_DETACHED"] = "hlsMediaDetached";
  Events3["BUFFER_RESET"] = "hlsBufferReset";
  Events3["BUFFER_CODECS"] = "hlsBufferCodecs";
  Events3["BUFFER_CREATED"] = "hlsBufferCreated";
  Events3["BUFFER_APPENDING"] = "hlsBufferAppending";
  Events3["BUFFER_APPENDED"] = "hlsBufferAppended";
  Events3["BUFFER_EOS"] = "hlsBufferEos";
  Events3["BUFFER_FLUSHING"] = "hlsBufferFlushing";
  Events3["BUFFER_FLUSHED"] = "hlsBufferFlushed";
  Events3["MANIFEST_LOADING"] = "hlsManifestLoading";
  Events3["MANIFEST_LOADED"] = "hlsManifestLoaded";
  Events3["MANIFEST_PARSED"] = "hlsManifestParsed";
  Events3["LEVEL_SWITCHING"] = "hlsLevelSwitching";
  Events3["LEVEL_SWITCHED"] = "hlsLevelSwitched";
  Events3["LEVEL_LOADING"] = "hlsLevelLoading";
  Events3["LEVEL_LOADED"] = "hlsLevelLoaded";
  Events3["LEVEL_UPDATED"] = "hlsLevelUpdated";
  Events3["LEVEL_PTS_UPDATED"] = "hlsLevelPtsUpdated";
  Events3["LEVELS_UPDATED"] = "hlsLevelsUpdated";
  Events3["AUDIO_TRACKS_UPDATED"] = "hlsAudioTracksUpdated";
  Events3["AUDIO_TRACK_SWITCHING"] = "hlsAudioTrackSwitching";
  Events3["AUDIO_TRACK_SWITCHED"] = "hlsAudioTrackSwitched";
  Events3["AUDIO_TRACK_LOADING"] = "hlsAudioTrackLoading";
  Events3["AUDIO_TRACK_LOADED"] = "hlsAudioTrackLoaded";
  Events3["SUBTITLE_TRACKS_UPDATED"] = "hlsSubtitleTracksUpdated";
  Events3["SUBTITLE_TRACKS_CLEARED"] = "hlsSubtitleTracksCleared";
  Events3["SUBTITLE_TRACK_SWITCH"] = "hlsSubtitleTrackSwitch";
  Events3["SUBTITLE_TRACK_LOADING"] = "hlsSubtitleTrackLoading";
  Events3["SUBTITLE_TRACK_LOADED"] = "hlsSubtitleTrackLoaded";
  Events3["SUBTITLE_FRAG_PROCESSED"] = "hlsSubtitleFragProcessed";
  Events3["CUES_PARSED"] = "hlsCuesParsed";
  Events3["NON_NATIVE_TEXT_TRACKS_FOUND"] = "hlsNonNativeTextTracksFound";
  Events3["INIT_PTS_FOUND"] = "hlsInitPtsFound";
  Events3["FRAG_LOADING"] = "hlsFragLoading";
  Events3["FRAG_LOAD_EMERGENCY_ABORTED"] = "hlsFragLoadEmergencyAborted";
  Events3["FRAG_LOADED"] = "hlsFragLoaded";
  Events3["FRAG_DECRYPTED"] = "hlsFragDecrypted";
  Events3["FRAG_PARSING_INIT_SEGMENT"] = "hlsFragParsingInitSegment";
  Events3["FRAG_PARSING_USERDATA"] = "hlsFragParsingUserdata";
  Events3["FRAG_PARSING_METADATA"] = "hlsFragParsingMetadata";
  Events3["FRAG_PARSED"] = "hlsFragParsed";
  Events3["FRAG_BUFFERED"] = "hlsFragBuffered";
  Events3["FRAG_CHANGED"] = "hlsFragChanged";
  Events3["FPS_DROP"] = "hlsFpsDrop";
  Events3["FPS_DROP_LEVEL_CAPPING"] = "hlsFpsDropLevelCapping";
  Events3["ERROR"] = "hlsError";
  Events3["DESTROYING"] = "hlsDestroying";
  Events3["KEY_LOADING"] = "hlsKeyLoading";
  Events3["KEY_LOADED"] = "hlsKeyLoaded";
  Events3["LIVE_BACK_BUFFER_REACHED"] = "hlsLiveBackBufferReached";
  Events3["BACK_BUFFER_REACHED"] = "hlsBackBufferReached";
  return Events3;
}({});
var ErrorTypes = /* @__PURE__ */ function(ErrorTypes2) {
  ErrorTypes2["NETWORK_ERROR"] = "networkError";
  ErrorTypes2["MEDIA_ERROR"] = "mediaError";
  ErrorTypes2["KEY_SYSTEM_ERROR"] = "keySystemError";
  ErrorTypes2["MUX_ERROR"] = "muxError";
  ErrorTypes2["OTHER_ERROR"] = "otherError";
  return ErrorTypes2;
}({});
var ErrorDetails = /* @__PURE__ */ function(ErrorDetails2) {
  ErrorDetails2["KEY_SYSTEM_NO_KEYS"] = "keySystemNoKeys";
  ErrorDetails2["KEY_SYSTEM_NO_ACCESS"] = "keySystemNoAccess";
  ErrorDetails2["KEY_SYSTEM_NO_SESSION"] = "keySystemNoSession";
  ErrorDetails2["KEY_SYSTEM_NO_CONFIGURED_LICENSE"] = "keySystemNoConfiguredLicense";
  ErrorDetails2["KEY_SYSTEM_LICENSE_REQUEST_FAILED"] = "keySystemLicenseRequestFailed";
  ErrorDetails2["KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED"] = "keySystemServerCertificateRequestFailed";
  ErrorDetails2["KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED"] = "keySystemServerCertificateUpdateFailed";
  ErrorDetails2["KEY_SYSTEM_SESSION_UPDATE_FAILED"] = "keySystemSessionUpdateFailed";
  ErrorDetails2["KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED"] = "keySystemStatusOutputRestricted";
  ErrorDetails2["KEY_SYSTEM_STATUS_INTERNAL_ERROR"] = "keySystemStatusInternalError";
  ErrorDetails2["MANIFEST_LOAD_ERROR"] = "manifestLoadError";
  ErrorDetails2["MANIFEST_LOAD_TIMEOUT"] = "manifestLoadTimeOut";
  ErrorDetails2["MANIFEST_PARSING_ERROR"] = "manifestParsingError";
  ErrorDetails2["MANIFEST_INCOMPATIBLE_CODECS_ERROR"] = "manifestIncompatibleCodecsError";
  ErrorDetails2["LEVEL_EMPTY_ERROR"] = "levelEmptyError";
  ErrorDetails2["LEVEL_LOAD_ERROR"] = "levelLoadError";
  ErrorDetails2["LEVEL_LOAD_TIMEOUT"] = "levelLoadTimeOut";
  ErrorDetails2["LEVEL_PARSING_ERROR"] = "levelParsingError";
  ErrorDetails2["LEVEL_SWITCH_ERROR"] = "levelSwitchError";
  ErrorDetails2["AUDIO_TRACK_LOAD_ERROR"] = "audioTrackLoadError";
  ErrorDetails2["AUDIO_TRACK_LOAD_TIMEOUT"] = "audioTrackLoadTimeOut";
  ErrorDetails2["SUBTITLE_LOAD_ERROR"] = "subtitleTrackLoadError";
  ErrorDetails2["SUBTITLE_TRACK_LOAD_TIMEOUT"] = "subtitleTrackLoadTimeOut";
  ErrorDetails2["FRAG_LOAD_ERROR"] = "fragLoadError";
  ErrorDetails2["FRAG_LOAD_TIMEOUT"] = "fragLoadTimeOut";
  ErrorDetails2["FRAG_DECRYPT_ERROR"] = "fragDecryptError";
  ErrorDetails2["FRAG_PARSING_ERROR"] = "fragParsingError";
  ErrorDetails2["FRAG_GAP"] = "fragGap";
  ErrorDetails2["REMUX_ALLOC_ERROR"] = "remuxAllocError";
  ErrorDetails2["KEY_LOAD_ERROR"] = "keyLoadError";
  ErrorDetails2["KEY_LOAD_TIMEOUT"] = "keyLoadTimeOut";
  ErrorDetails2["BUFFER_ADD_CODEC_ERROR"] = "bufferAddCodecError";
  ErrorDetails2["BUFFER_INCOMPATIBLE_CODECS_ERROR"] = "bufferIncompatibleCodecsError";
  ErrorDetails2["BUFFER_APPEND_ERROR"] = "bufferAppendError";
  ErrorDetails2["BUFFER_APPENDING_ERROR"] = "bufferAppendingError";
  ErrorDetails2["BUFFER_STALLED_ERROR"] = "bufferStalledError";
  ErrorDetails2["BUFFER_FULL_ERROR"] = "bufferFullError";
  ErrorDetails2["BUFFER_SEEK_OVER_HOLE"] = "bufferSeekOverHole";
  ErrorDetails2["BUFFER_NUDGE_ON_STALL"] = "bufferNudgeOnStall";
  ErrorDetails2["INTERNAL_EXCEPTION"] = "internalException";
  ErrorDetails2["INTERNAL_ABORTED"] = "aborted";
  ErrorDetails2["UNKNOWN"] = "unknown";
  return ErrorDetails2;
}({});
var noop = function noop2() {
};
var fakeLogger = {
  trace: noop,
  debug: noop,
  log: noop,
  warn: noop,
  info: noop,
  error: noop
};
var exportedLogger = fakeLogger;
function consolePrintFn(type2) {
  const func = self.console[type2];
  if (func) {
    return func.bind(self.console, `[${type2}] >`);
  }
  return noop;
}
function exportLoggerFunctions(debugConfig, ...functions) {
  functions.forEach(function(type2) {
    exportedLogger[type2] = debugConfig[type2] ? debugConfig[type2].bind(debugConfig) : consolePrintFn(type2);
  });
}
function enableLogs(debugConfig, id) {
  if (self.console && debugConfig === true || typeof debugConfig === "object") {
    exportLoggerFunctions(
      debugConfig,
      // Remove out from list here to hard-disable a log-level
      // 'trace',
      "debug",
      "log",
      "info",
      "warn",
      "error"
    );
    try {
      exportedLogger.log(`Debug logs enabled for "${id}" in hls.js version ${"1.4.12"}`);
    } catch (e) {
      exportedLogger = fakeLogger;
    }
  } else {
    exportedLogger = fakeLogger;
  }
}
var logger = exportedLogger;
var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
var ATTR_LIST_REGEX = /(.+?)=(".*?"|.*?)(?:,|$)/g;
var AttrList = class _AttrList {
  constructor(attrs) {
    if (typeof attrs === "string") {
      attrs = _AttrList.parseAttrList(attrs);
    }
    for (const attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        if (attr.substring(0, 2) === "X-") {
          this.clientAttrs = this.clientAttrs || [];
          this.clientAttrs.push(attr);
        }
        this[attr] = attrs[attr];
      }
    }
  }
  decimalInteger(attrName) {
    const intValue = parseInt(this[attrName], 10);
    if (intValue > Number.MAX_SAFE_INTEGER) {
      return Infinity;
    }
    return intValue;
  }
  hexadecimalInteger(attrName) {
    if (this[attrName]) {
      let stringValue = (this[attrName] || "0x").slice(2);
      stringValue = (stringValue.length & 1 ? "0" : "") + stringValue;
      const value = new Uint8Array(stringValue.length / 2);
      for (let i = 0; i < stringValue.length / 2; i++) {
        value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
      }
      return value;
    } else {
      return null;
    }
  }
  hexadecimalIntegerAsNumber(attrName) {
    const intValue = parseInt(this[attrName], 16);
    if (intValue > Number.MAX_SAFE_INTEGER) {
      return Infinity;
    }
    return intValue;
  }
  decimalFloatingPoint(attrName) {
    return parseFloat(this[attrName]);
  }
  optionalFloat(attrName, defaultValue) {
    const value = this[attrName];
    return value ? parseFloat(value) : defaultValue;
  }
  enumeratedString(attrName) {
    return this[attrName];
  }
  bool(attrName) {
    return this[attrName] === "YES";
  }
  decimalResolution(attrName) {
    const res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
    if (res === null) {
      return void 0;
    }
    return {
      width: parseInt(res[1], 10),
      height: parseInt(res[2], 10)
    };
  }
  static parseAttrList(input) {
    let match;
    const attrs = {};
    const quote = '"';
    ATTR_LIST_REGEX.lastIndex = 0;
    while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
      let value = match[2];
      if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
        value = value.slice(1, -1);
      }
      const name = match[1].trim();
      attrs[name] = value;
    }
    return attrs;
  }
};
function isDateRangeCueAttribute(attrName) {
  return attrName !== "ID" && attrName !== "CLASS" && attrName !== "START-DATE" && attrName !== "DURATION" && attrName !== "END-DATE" && attrName !== "END-ON-NEXT";
}
function isSCTE35Attribute(attrName) {
  return attrName === "SCTE35-OUT" || attrName === "SCTE35-IN";
}
var DateRange = class {
  constructor(dateRangeAttr, dateRangeWithSameId) {
    this.attr = void 0;
    this._startDate = void 0;
    this._endDate = void 0;
    this._badValueForSameId = void 0;
    if (dateRangeWithSameId) {
      const previousAttr = dateRangeWithSameId.attr;
      for (const key in previousAttr) {
        if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {
          logger.warn(`DATERANGE tag attribute: "${key}" does not match for tags with ID: "${dateRangeAttr.ID}"`);
          this._badValueForSameId = key;
          break;
        }
      }
      dateRangeAttr = _extends(new AttrList({}), previousAttr, dateRangeAttr);
    }
    this.attr = dateRangeAttr;
    this._startDate = new Date(dateRangeAttr["START-DATE"]);
    if ("END-DATE" in this.attr) {
      const endDate = new Date(this.attr["END-DATE"]);
      if (isFiniteNumber(endDate.getTime())) {
        this._endDate = endDate;
      }
    }
  }
  get id() {
    return this.attr.ID;
  }
  get class() {
    return this.attr.CLASS;
  }
  get startDate() {
    return this._startDate;
  }
  get endDate() {
    if (this._endDate) {
      return this._endDate;
    }
    const duration5 = this.duration;
    if (duration5 !== null) {
      return new Date(this._startDate.getTime() + duration5 * 1e3);
    }
    return null;
  }
  get duration() {
    if ("DURATION" in this.attr) {
      const duration5 = this.attr.decimalFloatingPoint("DURATION");
      if (isFiniteNumber(duration5)) {
        return duration5;
      }
    } else if (this._endDate) {
      return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
    }
    return null;
  }
  get plannedDuration() {
    if ("PLANNED-DURATION" in this.attr) {
      return this.attr.decimalFloatingPoint("PLANNED-DURATION");
    }
    return null;
  }
  get endOnNext() {
    return this.attr.bool("END-ON-NEXT");
  }
  get isValid() {
    return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);
  }
};
var LoadStats = class {
  constructor() {
    this.aborted = false;
    this.loaded = 0;
    this.retry = 0;
    this.total = 0;
    this.chunkCount = 0;
    this.bwEstimate = 0;
    this.loading = {
      start: 0,
      first: 0,
      end: 0
    };
    this.parsing = {
      start: 0,
      end: 0
    };
    this.buffering = {
      start: 0,
      first: 0,
      end: 0
    };
  }
};
var ElementaryStreamTypes = {
  AUDIO: "audio",
  VIDEO: "video",
  AUDIOVIDEO: "audiovideo"
};
var BaseSegment = class {
  // baseurl is the URL to the playlist
  // relurl is the portion of the URL that comes from inside the playlist.
  // Holds the types of data this fragment supports
  constructor(baseurl) {
    this._byteRange = null;
    this._url = null;
    this.baseurl = void 0;
    this.relurl = void 0;
    this.elementaryStreams = {
      [ElementaryStreamTypes.AUDIO]: null,
      [ElementaryStreamTypes.VIDEO]: null,
      [ElementaryStreamTypes.AUDIOVIDEO]: null
    };
    this.baseurl = baseurl;
  }
  // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array
  setByteRange(value, previous) {
    const params = value.split("@", 2);
    const byteRange = [];
    if (params.length === 1) {
      byteRange[0] = previous ? previous.byteRangeEndOffset : 0;
    } else {
      byteRange[0] = parseInt(params[1]);
    }
    byteRange[1] = parseInt(params[0]) + byteRange[0];
    this._byteRange = byteRange;
  }
  get byteRange() {
    if (!this._byteRange) {
      return [];
    }
    return this._byteRange;
  }
  get byteRangeStartOffset() {
    return this.byteRange[0];
  }
  get byteRangeEndOffset() {
    return this.byteRange[1];
  }
  get url() {
    if (!this._url && this.baseurl && this.relurl) {
      this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {
        alwaysNormalize: true
      });
    }
    return this._url || "";
  }
  set url(value) {
    this._url = value;
  }
};
var Fragment = class extends BaseSegment {
  // EXTINF has to be present for a m3u8 to be considered valid
  // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'
  // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption
  // core difference from the private field _decryptdata is the lack of the initialized IV
  // _decryptdata will set the IV for this segment based on the segment number in the fragment
  // A string representing the fragment type
  // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading
  // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading
  // The level/track index to which the fragment belongs
  // The continuity counter of the fragment
  // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.
  // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.
  // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.
  // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.
  // The start time of the fragment, as listed in the manifest. Updated after transmux complete.
  // Set by `updateFragPTSDTS` in level-helper
  // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.
  // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.
  // Load/parse timing information
  // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered
  // #EXTINF  segment title
  // The Media Initialization Section for this segment
  // Fragment is the last fragment in the media playlist
  // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded
  constructor(type2, baseurl) {
    super(baseurl);
    this._decryptdata = null;
    this.rawProgramDateTime = null;
    this.programDateTime = null;
    this.tagList = [];
    this.duration = 0;
    this.sn = 0;
    this.levelkeys = void 0;
    this.type = void 0;
    this.loader = null;
    this.keyLoader = null;
    this.level = -1;
    this.cc = 0;
    this.startPTS = void 0;
    this.endPTS = void 0;
    this.startDTS = void 0;
    this.endDTS = void 0;
    this.start = 0;
    this.deltaPTS = void 0;
    this.maxStartPTS = void 0;
    this.minEndPTS = void 0;
    this.stats = new LoadStats();
    this.urlId = 0;
    this.data = void 0;
    this.bitrateTest = false;
    this.title = null;
    this.initSegment = null;
    this.endList = void 0;
    this.gap = void 0;
    this.type = type2;
  }
  get decryptdata() {
    const {
      levelkeys
    } = this;
    if (!levelkeys && !this._decryptdata) {
      return null;
    }
    if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
      const key = this.levelkeys.identity;
      if (key) {
        this._decryptdata = key.getDecryptData(this.sn);
      } else {
        const keyFormats = Object.keys(this.levelkeys);
        if (keyFormats.length === 1) {
          return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);
        }
      }
    }
    return this._decryptdata;
  }
  get end() {
    return this.start + this.duration;
  }
  get endProgramDateTime() {
    if (this.programDateTime === null) {
      return null;
    }
    if (!isFiniteNumber(this.programDateTime)) {
      return null;
    }
    const duration5 = !isFiniteNumber(this.duration) ? 0 : this.duration;
    return this.programDateTime + duration5 * 1e3;
  }
  get encrypted() {
    var _this$_decryptdata;
    if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {
      return true;
    } else if (this.levelkeys) {
      const keyFormats = Object.keys(this.levelkeys);
      const len = keyFormats.length;
      if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {
        return true;
      }
    }
    return false;
  }
  setKeyFormat(keyFormat) {
    if (this.levelkeys) {
      const key = this.levelkeys[keyFormat];
      if (key && !this._decryptdata) {
        this._decryptdata = key.getDecryptData(this.sn);
      }
    }
  }
  abortRequests() {
    var _this$loader, _this$keyLoader;
    (_this$loader = this.loader) == null ? void 0 : _this$loader.abort();
    (_this$keyLoader = this.keyLoader) == null ? void 0 : _this$keyLoader.abort();
  }
  setElementaryStreamInfo(type2, startPTS, endPTS, startDTS, endDTS, partial = false) {
    const {
      elementaryStreams
    } = this;
    const info = elementaryStreams[type2];
    if (!info) {
      elementaryStreams[type2] = {
        startPTS,
        endPTS,
        startDTS,
        endDTS,
        partial
      };
      return;
    }
    info.startPTS = Math.min(info.startPTS, startPTS);
    info.endPTS = Math.max(info.endPTS, endPTS);
    info.startDTS = Math.min(info.startDTS, startDTS);
    info.endDTS = Math.max(info.endDTS, endDTS);
  }
  clearElementaryStreamInfo() {
    const {
      elementaryStreams
    } = this;
    elementaryStreams[ElementaryStreamTypes.AUDIO] = null;
    elementaryStreams[ElementaryStreamTypes.VIDEO] = null;
    elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;
  }
};
var Part = class extends BaseSegment {
  constructor(partAttrs, frag, baseurl, index, previous) {
    super(baseurl);
    this.fragOffset = 0;
    this.duration = 0;
    this.gap = false;
    this.independent = false;
    this.relurl = void 0;
    this.fragment = void 0;
    this.index = void 0;
    this.stats = new LoadStats();
    this.duration = partAttrs.decimalFloatingPoint("DURATION");
    this.gap = partAttrs.bool("GAP");
    this.independent = partAttrs.bool("INDEPENDENT");
    this.relurl = partAttrs.enumeratedString("URI");
    this.fragment = frag;
    this.index = index;
    const byteRange = partAttrs.enumeratedString("BYTERANGE");
    if (byteRange) {
      this.setByteRange(byteRange, previous);
    }
    if (previous) {
      this.fragOffset = previous.fragOffset + previous.duration;
    }
  }
  get start() {
    return this.fragment.start + this.fragOffset;
  }
  get end() {
    return this.start + this.duration;
  }
  get loaded() {
    const {
      elementaryStreams
    } = this;
    return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);
  }
};
var DEFAULT_TARGET_DURATION = 10;
var LevelDetails = class {
  // Manifest reload synchronization
  constructor(baseUrl) {
    this.PTSKnown = false;
    this.alignedSliding = false;
    this.averagetargetduration = void 0;
    this.endCC = 0;
    this.endSN = 0;
    this.fragments = void 0;
    this.fragmentHint = void 0;
    this.partList = null;
    this.dateRanges = void 0;
    this.live = true;
    this.ageHeader = 0;
    this.advancedDateTime = void 0;
    this.updated = true;
    this.advanced = true;
    this.availabilityDelay = void 0;
    this.misses = 0;
    this.startCC = 0;
    this.startSN = 0;
    this.startTimeOffset = null;
    this.targetduration = 0;
    this.totalduration = 0;
    this.type = null;
    this.url = void 0;
    this.m3u8 = "";
    this.version = null;
    this.canBlockReload = false;
    this.canSkipUntil = 0;
    this.canSkipDateRanges = false;
    this.skippedSegments = 0;
    this.recentlyRemovedDateranges = void 0;
    this.partHoldBack = 0;
    this.holdBack = 0;
    this.partTarget = 0;
    this.preloadHint = void 0;
    this.renditionReports = void 0;
    this.tuneInGoal = 0;
    this.deltaUpdateFailed = void 0;
    this.driftStartTime = 0;
    this.driftEndTime = 0;
    this.driftStart = 0;
    this.driftEnd = 0;
    this.encryptedFragments = void 0;
    this.playlistParsingError = null;
    this.variableList = null;
    this.hasVariableRefs = false;
    this.fragments = [];
    this.encryptedFragments = [];
    this.dateRanges = {};
    this.url = baseUrl;
  }
  reloaded(previous) {
    if (!previous) {
      this.advanced = true;
      this.updated = true;
      return;
    }
    const partSnDiff = this.lastPartSn - previous.lastPartSn;
    const partIndexDiff = this.lastPartIndex - previous.lastPartIndex;
    this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff || !this.live;
    this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;
    if (this.updated || this.advanced) {
      this.misses = Math.floor(previous.misses * 0.6);
    } else {
      this.misses = previous.misses + 1;
    }
    this.availabilityDelay = previous.availabilityDelay;
  }
  get hasProgramDateTime() {
    if (this.fragments.length) {
      return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);
    }
    return false;
  }
  get levelTargetDuration() {
    return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;
  }
  get drift() {
    const runTime = this.driftEndTime - this.driftStartTime;
    if (runTime > 0) {
      const runDuration = this.driftEnd - this.driftStart;
      return runDuration * 1e3 / runTime;
    }
    return 1;
  }
  get edge() {
    return this.partEnd || this.fragmentEnd;
  }
  get partEnd() {
    var _this$partList;
    if ((_this$partList = this.partList) != null && _this$partList.length) {
      return this.partList[this.partList.length - 1].end;
    }
    return this.fragmentEnd;
  }
  get fragmentEnd() {
    var _this$fragments;
    if ((_this$fragments = this.fragments) != null && _this$fragments.length) {
      return this.fragments[this.fragments.length - 1].end;
    }
    return 0;
  }
  get age() {
    if (this.advancedDateTime) {
      return Math.max(Date.now() - this.advancedDateTime, 0) / 1e3;
    }
    return 0;
  }
  get lastPartIndex() {
    var _this$partList2;
    if ((_this$partList2 = this.partList) != null && _this$partList2.length) {
      return this.partList[this.partList.length - 1].index;
    }
    return -1;
  }
  get lastPartSn() {
    var _this$partList3;
    if ((_this$partList3 = this.partList) != null && _this$partList3.length) {
      return this.partList[this.partList.length - 1].fragment.sn;
    }
    return this.endSN;
  }
};
function base64Decode(base64encodedStr) {
  return Uint8Array.from(atob(base64encodedStr), (c) => c.charCodeAt(0));
}
function getKeyIdBytes(str) {
  const keyIdbytes = strToUtf8array(str).subarray(0, 16);
  const paddedkeyIdbytes = new Uint8Array(16);
  paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);
  return paddedkeyIdbytes;
}
function changeEndianness(keyId) {
  const swap = function swap2(array, from3, to) {
    const cur = array[from3];
    array[from3] = array[to];
    array[to] = cur;
  };
  swap(keyId, 0, 3);
  swap(keyId, 1, 2);
  swap(keyId, 4, 5);
  swap(keyId, 6, 7);
}
function convertDataUriToArrayBytes(uri) {
  const colonsplit = uri.split(":");
  let keydata = null;
  if (colonsplit[0] === "data" && colonsplit.length === 2) {
    const semicolonsplit = colonsplit[1].split(";");
    const commasplit = semicolonsplit[semicolonsplit.length - 1].split(",");
    if (commasplit.length === 2) {
      const isbase64 = commasplit[0] === "base64";
      const data = commasplit[1];
      if (isbase64) {
        semicolonsplit.splice(-1, 1);
        keydata = base64Decode(data);
      } else {
        keydata = getKeyIdBytes(data);
      }
    }
  }
  return keydata;
}
function strToUtf8array(str) {
  return Uint8Array.from(unescape(encodeURIComponent(str)), (c) => c.charCodeAt(0));
}
var KeySystems = {
  CLEARKEY: "org.w3.clearkey",
  FAIRPLAY: "com.apple.fps",
  PLAYREADY: "com.microsoft.playready",
  WIDEVINE: "com.widevine.alpha"
};
var KeySystemFormats = {
  CLEARKEY: "org.w3.clearkey",
  FAIRPLAY: "com.apple.streamingkeydelivery",
  PLAYREADY: "com.microsoft.playready",
  WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
};
function keySystemFormatToKeySystemDomain(format) {
  switch (format) {
    case KeySystemFormats.FAIRPLAY:
      return KeySystems.FAIRPLAY;
    case KeySystemFormats.PLAYREADY:
      return KeySystems.PLAYREADY;
    case KeySystemFormats.WIDEVINE:
      return KeySystems.WIDEVINE;
    case KeySystemFormats.CLEARKEY:
      return KeySystems.CLEARKEY;
  }
}
var KeySystemIds = {
  WIDEVINE: "edef8ba979d64acea3c827dcd51d21ed"
};
function keySystemIdToKeySystemDomain(systemId) {
  if (systemId === KeySystemIds.WIDEVINE) {
    return KeySystems.WIDEVINE;
  }
}
function keySystemDomainToKeySystemFormat(keySystem) {
  switch (keySystem) {
    case KeySystems.FAIRPLAY:
      return KeySystemFormats.FAIRPLAY;
    case KeySystems.PLAYREADY:
      return KeySystemFormats.PLAYREADY;
    case KeySystems.WIDEVINE:
      return KeySystemFormats.WIDEVINE;
    case KeySystems.CLEARKEY:
      return KeySystemFormats.CLEARKEY;
  }
}
function getKeySystemsForConfig(config) {
  const {
    drmSystems,
    widevineLicenseUrl
  } = config;
  const keySystemsToAttempt = drmSystems ? [KeySystems.FAIRPLAY, KeySystems.WIDEVINE, KeySystems.PLAYREADY, KeySystems.CLEARKEY].filter((keySystem) => !!drmSystems[keySystem]) : [];
  if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {
    keySystemsToAttempt.push(KeySystems.WIDEVINE);
  }
  return keySystemsToAttempt;
}
var requestMediaKeySystemAccess = function() {
  if (typeof self !== "undefined" && self.navigator && self.navigator.requestMediaKeySystemAccess) {
    return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);
  } else {
    return null;
  }
}();
function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {
  let initDataTypes;
  switch (keySystem) {
    case KeySystems.FAIRPLAY:
      initDataTypes = ["cenc", "sinf"];
      break;
    case KeySystems.WIDEVINE:
    case KeySystems.PLAYREADY:
      initDataTypes = ["cenc"];
      break;
    case KeySystems.CLEARKEY:
      initDataTypes = ["cenc", "keyids"];
      break;
    default:
      throw new Error(`Unknown key-system: ${keySystem}`);
  }
  return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);
}
function createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {
  const baseConfig = {
    initDataTypes,
    persistentState: drmSystemOptions.persistentState || "not-allowed",
    distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || "not-allowed",
    sessionTypes: drmSystemOptions.sessionTypes || [drmSystemOptions.sessionType || "temporary"],
    audioCapabilities: audioCodecs.map((codec) => ({
      contentType: `audio/mp4; codecs="${codec}"`,
      robustness: drmSystemOptions.audioRobustness || "",
      encryptionScheme: drmSystemOptions.audioEncryptionScheme || null
    })),
    videoCapabilities: videoCodecs.map((codec) => ({
      contentType: `video/mp4; codecs="${codec}"`,
      robustness: drmSystemOptions.videoRobustness || "",
      encryptionScheme: drmSystemOptions.videoEncryptionScheme || null
    }))
  };
  return [baseConfig];
}
function sliceUint8(array, start2, end) {
  return Uint8Array.prototype.slice ? array.slice(start2, end) : new Uint8Array(Array.prototype.slice.call(array, start2, end));
}
var isHeader$2 = (data, offset) => {
  if (offset + 10 <= data.length) {
    if (data[offset] === 73 && data[offset + 1] === 68 && data[offset + 2] === 51) {
      if (data[offset + 3] < 255 && data[offset + 4] < 255) {
        if (data[offset + 6] < 128 && data[offset + 7] < 128 && data[offset + 8] < 128 && data[offset + 9] < 128) {
          return true;
        }
      }
    }
  }
  return false;
};
var isFooter = (data, offset) => {
  if (offset + 10 <= data.length) {
    if (data[offset] === 51 && data[offset + 1] === 68 && data[offset + 2] === 73) {
      if (data[offset + 3] < 255 && data[offset + 4] < 255) {
        if (data[offset + 6] < 128 && data[offset + 7] < 128 && data[offset + 8] < 128 && data[offset + 9] < 128) {
          return true;
        }
      }
    }
  }
  return false;
};
var getID3Data = (data, offset) => {
  const front = offset;
  let length = 0;
  while (isHeader$2(data, offset)) {
    length += 10;
    const size = readSize(data, offset + 6);
    length += size;
    if (isFooter(data, offset + 10)) {
      length += 10;
    }
    offset += length;
  }
  if (length > 0) {
    return data.subarray(front, front + length);
  }
  return void 0;
};
var readSize = (data, offset) => {
  let size = 0;
  size = (data[offset] & 127) << 21;
  size |= (data[offset + 1] & 127) << 14;
  size |= (data[offset + 2] & 127) << 7;
  size |= data[offset + 3] & 127;
  return size;
};
var canParse$2 = (data, offset) => {
  return isHeader$2(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;
};
var getTimeStamp = (data) => {
  const frames = getID3Frames(data);
  for (let i = 0; i < frames.length; i++) {
    const frame = frames[i];
    if (isTimeStampFrame(frame)) {
      return readTimeStamp(frame);
    }
  }
  return void 0;
};
var isTimeStampFrame = (frame) => {
  return frame && frame.key === "PRIV" && frame.info === "com.apple.streaming.transportStreamTimestamp";
};
var getFrameData = (data) => {
  const type2 = String.fromCharCode(data[0], data[1], data[2], data[3]);
  const size = readSize(data, 4);
  const offset = 10;
  return {
    type: type2,
    size,
    data: data.subarray(offset, offset + size)
  };
};
var getID3Frames = (id3Data) => {
  let offset = 0;
  const frames = [];
  while (isHeader$2(id3Data, offset)) {
    const size = readSize(id3Data, offset + 6);
    offset += 10;
    const end = offset + size;
    while (offset + 8 < end) {
      const frameData = getFrameData(id3Data.subarray(offset));
      const frame = decodeFrame(frameData);
      if (frame) {
        frames.push(frame);
      }
      offset += frameData.size + 10;
    }
    if (isFooter(id3Data, offset)) {
      offset += 10;
    }
  }
  return frames;
};
var decodeFrame = (frame) => {
  if (frame.type === "PRIV") {
    return decodePrivFrame(frame);
  } else if (frame.type[0] === "W") {
    return decodeURLFrame(frame);
  }
  return decodeTextFrame(frame);
};
var decodePrivFrame = (frame) => {
  if (frame.size < 2) {
    return void 0;
  }
  const owner = utf8ArrayToStr(frame.data, true);
  const privateData = new Uint8Array(frame.data.subarray(owner.length + 1));
  return {
    key: frame.type,
    info: owner,
    data: privateData.buffer
  };
};
var decodeTextFrame = (frame) => {
  if (frame.size < 2) {
    return void 0;
  }
  if (frame.type === "TXXX") {
    let index = 1;
    const description = utf8ArrayToStr(frame.data.subarray(index), true);
    index += description.length + 1;
    const value = utf8ArrayToStr(frame.data.subarray(index));
    return {
      key: frame.type,
      info: description,
      data: value
    };
  }
  const text = utf8ArrayToStr(frame.data.subarray(1));
  return {
    key: frame.type,
    data: text
  };
};
var decodeURLFrame = (frame) => {
  if (frame.type === "WXXX") {
    if (frame.size < 2) {
      return void 0;
    }
    let index = 1;
    const description = utf8ArrayToStr(frame.data.subarray(index), true);
    index += description.length + 1;
    const value = utf8ArrayToStr(frame.data.subarray(index));
    return {
      key: frame.type,
      info: description,
      data: value
    };
  }
  const url = utf8ArrayToStr(frame.data);
  return {
    key: frame.type,
    data: url
  };
};
var readTimeStamp = (timeStampFrame) => {
  if (timeStampFrame.data.byteLength === 8) {
    const data = new Uint8Array(timeStampFrame.data);
    const pts33Bit = data[3] & 1;
    let timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
    timestamp /= 45;
    if (pts33Bit) {
      timestamp += 4772185884e-2;
    }
    return Math.round(timestamp);
  }
  return void 0;
};
var utf8ArrayToStr = (array, exitOnNull = false) => {
  const decoder2 = getTextDecoder();
  if (decoder2) {
    const decoded = decoder2.decode(array);
    if (exitOnNull) {
      const idx = decoded.indexOf("\0");
      return idx !== -1 ? decoded.substring(0, idx) : decoded;
    }
    return decoded.replace(/\0/g, "");
  }
  const len = array.length;
  let c;
  let char2;
  let char3;
  let out = "";
  let i = 0;
  while (i < len) {
    c = array[i++];
    if (c === 0 && exitOnNull) {
      return out;
    } else if (c === 0 || c === 3) {
      continue;
    }
    switch (c >> 4) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        out += String.fromCharCode(c);
        break;
      case 12:
      case 13:
        char2 = array[i++];
        out += String.fromCharCode((c & 31) << 6 | char2 & 63);
        break;
      case 14:
        char2 = array[i++];
        char3 = array[i++];
        out += String.fromCharCode((c & 15) << 12 | (char2 & 63) << 6 | (char3 & 63) << 0);
        break;
    }
  }
  return out;
};
var decoder;
function getTextDecoder() {
  if (!decoder && typeof self.TextDecoder !== "undefined") {
    decoder = new self.TextDecoder("utf-8");
  }
  return decoder;
}
var Hex = {
  hexDump: function(array) {
    let str = "";
    for (let i = 0; i < array.length; i++) {
      let h = array[i].toString(16);
      if (h.length < 2) {
        h = "0" + h;
      }
      str += h;
    }
    return str;
  }
};
var UINT32_MAX$1 = Math.pow(2, 32) - 1;
var push = [].push;
var RemuxerTrackIdConfig = {
  video: 1,
  audio: 2,
  id3: 3,
  text: 4
};
function bin2str(data) {
  return String.fromCharCode.apply(null, data);
}
function readUint16(buffer, offset) {
  const val = buffer[offset] << 8 | buffer[offset + 1];
  return val < 0 ? 65536 + val : val;
}
function readUint32(buffer, offset) {
  const val = readSint32(buffer, offset);
  return val < 0 ? 4294967296 + val : val;
}
function readSint32(buffer, offset) {
  return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
}
function writeUint32(buffer, offset, value) {
  buffer[offset] = value >> 24;
  buffer[offset + 1] = value >> 16 & 255;
  buffer[offset + 2] = value >> 8 & 255;
  buffer[offset + 3] = value & 255;
}
function findBox(data, path) {
  const results = [];
  if (!path.length) {
    return results;
  }
  const end = data.byteLength;
  for (let i = 0; i < end; ) {
    const size = readUint32(data, i);
    const type2 = bin2str(data.subarray(i + 4, i + 8));
    const endbox = size > 1 ? i + size : end;
    if (type2 === path[0]) {
      if (path.length === 1) {
        results.push(data.subarray(i + 8, endbox));
      } else {
        const subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));
        if (subresults.length) {
          push.apply(results, subresults);
        }
      }
    }
    i = endbox;
  }
  return results;
}
function parseSegmentIndex(sidx) {
  const references = [];
  const version5 = sidx[0];
  let index = 8;
  const timescale2 = readUint32(sidx, index);
  index += 4;
  const earliestPresentationTime = 0;
  const firstOffset = 0;
  if (version5 === 0) {
    index += 8;
  } else {
    index += 16;
  }
  index += 2;
  let startByte = sidx.length + firstOffset;
  const referencesCount = readUint16(sidx, index);
  index += 2;
  for (let i = 0; i < referencesCount; i++) {
    let referenceIndex = index;
    const referenceInfo = readUint32(sidx, referenceIndex);
    referenceIndex += 4;
    const referenceSize = referenceInfo & 2147483647;
    const referenceType = (referenceInfo & 2147483648) >>> 31;
    if (referenceType === 1) {
      logger.warn("SIDX has hierarchical references (not supported)");
      return null;
    }
    const subsegmentDuration = readUint32(sidx, referenceIndex);
    referenceIndex += 4;
    references.push({
      referenceSize,
      subsegmentDuration,
      // unscaled
      info: {
        duration: subsegmentDuration / timescale2,
        start: startByte,
        end: startByte + referenceSize - 1
      }
    });
    startByte += referenceSize;
    referenceIndex += 4;
    index = referenceIndex;
  }
  return {
    earliestPresentationTime,
    timescale: timescale2,
    version: version5,
    referencesCount,
    references
  };
}
function parseInitSegment(initSegment) {
  const result = [];
  const traks = findBox(initSegment, ["moov", "trak"]);
  for (let i = 0; i < traks.length; i++) {
    const trak = traks[i];
    const tkhd = findBox(trak, ["tkhd"])[0];
    if (tkhd) {
      let version5 = tkhd[0];
      let index = version5 === 0 ? 12 : 20;
      const trackId = readUint32(tkhd, index);
      const mdhd = findBox(trak, ["mdia", "mdhd"])[0];
      if (mdhd) {
        version5 = mdhd[0];
        index = version5 === 0 ? 12 : 20;
        const timescale2 = readUint32(mdhd, index);
        const hdlr = findBox(trak, ["mdia", "hdlr"])[0];
        if (hdlr) {
          const hdlrType = bin2str(hdlr.subarray(8, 12));
          const type2 = {
            soun: ElementaryStreamTypes.AUDIO,
            vide: ElementaryStreamTypes.VIDEO
          }[hdlrType];
          if (type2) {
            const stsd = findBox(trak, ["mdia", "minf", "stbl", "stsd"])[0];
            let codec;
            if (stsd) {
              codec = bin2str(stsd.subarray(12, 16));
            }
            result[trackId] = {
              timescale: timescale2,
              type: type2
            };
            result[type2] = {
              timescale: timescale2,
              id: trackId,
              codec
            };
          }
        }
      }
    }
  }
  const trex = findBox(initSegment, ["moov", "mvex", "trex"]);
  trex.forEach((trex2) => {
    const trackId = readUint32(trex2, 4);
    const track = result[trackId];
    if (track) {
      track.default = {
        duration: readUint32(trex2, 12),
        flags: readUint32(trex2, 20)
      };
    }
  });
  return result;
}
function patchEncyptionData(initSegment, decryptdata) {
  if (!initSegment || !decryptdata) {
    return initSegment;
  }
  const keyId = decryptdata.keyId;
  if (keyId && decryptdata.isCommonEncryption) {
    const traks = findBox(initSegment, ["moov", "trak"]);
    traks.forEach((trak) => {
      const stsd = findBox(trak, ["mdia", "minf", "stbl", "stsd"])[0];
      const sampleEntries = stsd.subarray(8);
      let encBoxes = findBox(sampleEntries, ["enca"]);
      const isAudio = encBoxes.length > 0;
      if (!isAudio) {
        encBoxes = findBox(sampleEntries, ["encv"]);
      }
      encBoxes.forEach((enc) => {
        const encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);
        const sinfBoxes = findBox(encBoxChildren, ["sinf"]);
        sinfBoxes.forEach((sinf) => {
          const tenc = parseSinf(sinf);
          if (tenc) {
            const tencKeyId = tenc.subarray(8, 24);
            if (!tencKeyId.some((b) => b !== 0)) {
              logger.log(`[eme] Patching keyId in 'enc${isAudio ? "a" : "v"}>sinf>>tenc' box: ${Hex.hexDump(tencKeyId)} -> ${Hex.hexDump(keyId)}`);
              tenc.set(keyId, 8);
            }
          }
        });
      });
    });
  }
  return initSegment;
}
function parseSinf(sinf) {
  const schm = findBox(sinf, ["schm"])[0];
  if (schm) {
    const scheme = bin2str(schm.subarray(4, 8));
    if (scheme === "cbcs" || scheme === "cenc") {
      return findBox(sinf, ["schi", "tenc"])[0];
    }
  }
  logger.error(`[eme] missing 'schm' box`);
  return null;
}
function getStartDTS(initData, fmp4) {
  return findBox(fmp4, ["moof", "traf"]).reduce((result, traf) => {
    const tfdt = findBox(traf, ["tfdt"])[0];
    const version5 = tfdt[0];
    const start2 = findBox(traf, ["tfhd"]).reduce((result2, tfhd) => {
      const id = readUint32(tfhd, 4);
      const track = initData[id];
      if (track) {
        let baseTime = readUint32(tfdt, 4);
        if (version5 === 1) {
          if (baseTime === UINT32_MAX$1) {
            logger.warn(`[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time`);
            return result2;
          }
          baseTime *= UINT32_MAX$1 + 1;
          baseTime += readUint32(tfdt, 8);
        }
        const scale = track.timescale || 9e4;
        const startTime = baseTime / scale;
        if (isFinite(startTime) && (result2 === null || startTime < result2)) {
          return startTime;
        }
      }
      return result2;
    }, null);
    if (start2 !== null && isFinite(start2) && (result === null || start2 < result)) {
      return start2;
    }
    return result;
  }, null);
}
function getDuration(data, initData) {
  let rawDuration = 0;
  let videoDuration = 0;
  let audioDuration = 0;
  const trafs = findBox(data, ["moof", "traf"]);
  for (let i = 0; i < trafs.length; i++) {
    const traf = trafs[i];
    const tfhd = findBox(traf, ["tfhd"])[0];
    const id = readUint32(tfhd, 4);
    const track = initData[id];
    if (!track) {
      continue;
    }
    const trackDefault = track.default;
    const tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);
    let sampleDuration = trackDefault == null ? void 0 : trackDefault.duration;
    if (tfhdFlags & 8) {
      if (tfhdFlags & 2) {
        sampleDuration = readUint32(tfhd, 12);
      } else {
        sampleDuration = readUint32(tfhd, 8);
      }
    }
    const timescale2 = track.timescale || 9e4;
    const truns = findBox(traf, ["trun"]);
    for (let j = 0; j < truns.length; j++) {
      rawDuration = computeRawDurationFromSamples(truns[j]);
      if (!rawDuration && sampleDuration) {
        const sampleCount = readUint32(truns[j], 4);
        rawDuration = sampleDuration * sampleCount;
      }
      if (track.type === ElementaryStreamTypes.VIDEO) {
        videoDuration += rawDuration / timescale2;
      } else if (track.type === ElementaryStreamTypes.AUDIO) {
        audioDuration += rawDuration / timescale2;
      }
    }
  }
  if (videoDuration === 0 && audioDuration === 0) {
    let sidxDuration = 0;
    const sidxs = findBox(data, ["sidx"]);
    for (let i = 0; i < sidxs.length; i++) {
      const sidx = parseSegmentIndex(sidxs[i]);
      if (sidx != null && sidx.references) {
        sidxDuration += sidx.references.reduce((dur, ref) => dur + ref.info.duration || 0, 0);
      }
    }
    return sidxDuration;
  }
  if (videoDuration) {
    return videoDuration;
  }
  return audioDuration;
}
function computeRawDurationFromSamples(trun) {
  const flags = readUint32(trun, 0);
  let offset = 8;
  if (flags & 1) {
    offset += 4;
  }
  if (flags & 4) {
    offset += 4;
  }
  let duration5 = 0;
  const sampleCount = readUint32(trun, 4);
  for (let i = 0; i < sampleCount; i++) {
    if (flags & 256) {
      const sampleDuration = readUint32(trun, offset);
      duration5 += sampleDuration;
      offset += 4;
    }
    if (flags & 512) {
      offset += 4;
    }
    if (flags & 1024) {
      offset += 4;
    }
    if (flags & 2048) {
      offset += 4;
    }
  }
  return duration5;
}
function offsetStartDTS(initData, fmp4, timeOffset) {
  findBox(fmp4, ["moof", "traf"]).forEach((traf) => {
    findBox(traf, ["tfhd"]).forEach((tfhd) => {
      const id = readUint32(tfhd, 4);
      const track = initData[id];
      if (!track) {
        return;
      }
      const timescale2 = track.timescale || 9e4;
      findBox(traf, ["tfdt"]).forEach((tfdt) => {
        const version5 = tfdt[0];
        let baseMediaDecodeTime = readUint32(tfdt, 4);
        if (version5 === 0) {
          baseMediaDecodeTime -= timeOffset * timescale2;
          baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
          writeUint32(tfdt, 4, baseMediaDecodeTime);
        } else {
          baseMediaDecodeTime *= Math.pow(2, 32);
          baseMediaDecodeTime += readUint32(tfdt, 8);
          baseMediaDecodeTime -= timeOffset * timescale2;
          baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
          const upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX$1 + 1));
          const lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX$1 + 1));
          writeUint32(tfdt, 4, upper);
          writeUint32(tfdt, 8, lower);
        }
      });
    });
  });
}
function segmentValidRange(data) {
  const segmentedRange = {
    valid: null,
    remainder: null
  };
  const moofs = findBox(data, ["moof"]);
  if (!moofs) {
    return segmentedRange;
  } else if (moofs.length < 2) {
    segmentedRange.remainder = data;
    return segmentedRange;
  }
  const last = moofs[moofs.length - 1];
  segmentedRange.valid = sliceUint8(data, 0, last.byteOffset - 8);
  segmentedRange.remainder = sliceUint8(data, last.byteOffset - 8);
  return segmentedRange;
}
function appendUint8Array(data1, data2) {
  const temp = new Uint8Array(data1.length + data2.length);
  temp.set(data1);
  temp.set(data2, data1.length);
  return temp;
}
function parseSamples(timeOffset, track) {
  const seiSamples = [];
  const videoData = track.samples;
  const timescale2 = track.timescale;
  const trackId = track.id;
  let isHEVCFlavor = false;
  const moofs = findBox(videoData, ["moof"]);
  moofs.map((moof) => {
    const moofOffset = moof.byteOffset - 8;
    const trafs = findBox(moof, ["traf"]);
    trafs.map((traf) => {
      const baseTime = findBox(traf, ["tfdt"]).map((tfdt) => {
        const version5 = tfdt[0];
        let result = readUint32(tfdt, 4);
        if (version5 === 1) {
          result *= Math.pow(2, 32);
          result += readUint32(tfdt, 8);
        }
        return result / timescale2;
      })[0];
      if (baseTime !== void 0) {
        timeOffset = baseTime;
      }
      return findBox(traf, ["tfhd"]).map((tfhd) => {
        const id = readUint32(tfhd, 4);
        const tfhdFlags = readUint32(tfhd, 0) & 16777215;
        const baseDataOffsetPresent = (tfhdFlags & 1) !== 0;
        const sampleDescriptionIndexPresent = (tfhdFlags & 2) !== 0;
        const defaultSampleDurationPresent = (tfhdFlags & 8) !== 0;
        let defaultSampleDuration = 0;
        const defaultSampleSizePresent = (tfhdFlags & 16) !== 0;
        let defaultSampleSize = 0;
        const defaultSampleFlagsPresent = (tfhdFlags & 32) !== 0;
        let tfhdOffset = 8;
        if (id === trackId) {
          if (baseDataOffsetPresent) {
            tfhdOffset += 8;
          }
          if (sampleDescriptionIndexPresent) {
            tfhdOffset += 4;
          }
          if (defaultSampleDurationPresent) {
            defaultSampleDuration = readUint32(tfhd, tfhdOffset);
            tfhdOffset += 4;
          }
          if (defaultSampleSizePresent) {
            defaultSampleSize = readUint32(tfhd, tfhdOffset);
            tfhdOffset += 4;
          }
          if (defaultSampleFlagsPresent) {
            tfhdOffset += 4;
          }
          if (track.type === "video") {
            isHEVCFlavor = isHEVC(track.codec);
          }
          findBox(traf, ["trun"]).map((trun) => {
            const version5 = trun[0];
            const flags = readUint32(trun, 0) & 16777215;
            const dataOffsetPresent = (flags & 1) !== 0;
            let dataOffset = 0;
            const firstSampleFlagsPresent = (flags & 4) !== 0;
            const sampleDurationPresent = (flags & 256) !== 0;
            let sampleDuration = 0;
            const sampleSizePresent = (flags & 512) !== 0;
            let sampleSize = 0;
            const sampleFlagsPresent = (flags & 1024) !== 0;
            const sampleCompositionOffsetsPresent = (flags & 2048) !== 0;
            let compositionOffset = 0;
            const sampleCount = readUint32(trun, 4);
            let trunOffset = 8;
            if (dataOffsetPresent) {
              dataOffset = readUint32(trun, trunOffset);
              trunOffset += 4;
            }
            if (firstSampleFlagsPresent) {
              trunOffset += 4;
            }
            let sampleOffset = dataOffset + moofOffset;
            for (let ix = 0; ix < sampleCount; ix++) {
              if (sampleDurationPresent) {
                sampleDuration = readUint32(trun, trunOffset);
                trunOffset += 4;
              } else {
                sampleDuration = defaultSampleDuration;
              }
              if (sampleSizePresent) {
                sampleSize = readUint32(trun, trunOffset);
                trunOffset += 4;
              } else {
                sampleSize = defaultSampleSize;
              }
              if (sampleFlagsPresent) {
                trunOffset += 4;
              }
              if (sampleCompositionOffsetsPresent) {
                if (version5 === 0) {
                  compositionOffset = readUint32(trun, trunOffset);
                } else {
                  compositionOffset = readSint32(trun, trunOffset);
                }
                trunOffset += 4;
              }
              if (track.type === ElementaryStreamTypes.VIDEO) {
                let naluTotalSize = 0;
                while (naluTotalSize < sampleSize) {
                  const naluSize = readUint32(videoData, sampleOffset);
                  sampleOffset += 4;
                  if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {
                    const data = videoData.subarray(sampleOffset, sampleOffset + naluSize);
                    parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale2, seiSamples);
                  }
                  sampleOffset += naluSize;
                  naluTotalSize += naluSize + 4;
                }
              }
              timeOffset += sampleDuration / timescale2;
            }
          });
        }
      });
    });
  });
  return seiSamples;
}
function isHEVC(codec) {
  if (!codec) {
    return false;
  }
  const delimit = codec.indexOf(".");
  const baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);
  return baseCodec === "hvc1" || baseCodec === "hev1" || // Dolby Vision
  baseCodec === "dvh1" || baseCodec === "dvhe";
}
function isSEIMessage(isHEVCFlavor, naluHeader) {
  if (isHEVCFlavor) {
    const naluType = naluHeader >> 1 & 63;
    return naluType === 39 || naluType === 40;
  } else {
    const naluType = naluHeader & 31;
    return naluType === 6;
  }
}
function parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {
  const data = discardEPB(unescapedData);
  let seiPtr = 0;
  seiPtr += headerSize;
  let payloadType = 0;
  let payloadSize = 0;
  let endOfCaptions = false;
  let b = 0;
  while (seiPtr < data.length) {
    payloadType = 0;
    do {
      if (seiPtr >= data.length) {
        break;
      }
      b = data[seiPtr++];
      payloadType += b;
    } while (b === 255);
    payloadSize = 0;
    do {
      if (seiPtr >= data.length) {
        break;
      }
      b = data[seiPtr++];
      payloadSize += b;
    } while (b === 255);
    const leftOver = data.length - seiPtr;
    if (!endOfCaptions && payloadType === 4 && seiPtr < data.length) {
      endOfCaptions = true;
      const countryCode = data[seiPtr++];
      if (countryCode === 181) {
        const providerCode = readUint16(data, seiPtr);
        seiPtr += 2;
        if (providerCode === 49) {
          const userStructure = readUint32(data, seiPtr);
          seiPtr += 4;
          if (userStructure === 1195456820) {
            const userDataType = data[seiPtr++];
            if (userDataType === 3) {
              const firstByte = data[seiPtr++];
              const totalCCs = 31 & firstByte;
              const enabled = 64 & firstByte;
              const totalBytes = enabled ? 2 + totalCCs * 3 : 0;
              const byteArray = new Uint8Array(totalBytes);
              if (enabled) {
                byteArray[0] = firstByte;
                for (let i = 1; i < totalBytes; i++) {
                  byteArray[i] = data[seiPtr++];
                }
              }
              samples.push({
                type: userDataType,
                payloadType,
                pts,
                bytes: byteArray
              });
            }
          }
        }
      }
    } else if (payloadType === 5 && payloadSize < leftOver) {
      endOfCaptions = true;
      if (payloadSize > 16) {
        const uuidStrArray = [];
        for (let i = 0; i < 16; i++) {
          const _b = data[seiPtr++].toString(16);
          uuidStrArray.push(_b.length == 1 ? "0" + _b : _b);
          if (i === 3 || i === 5 || i === 7 || i === 9) {
            uuidStrArray.push("-");
          }
        }
        const length = payloadSize - 16;
        const userDataBytes = new Uint8Array(length);
        for (let i = 0; i < length; i++) {
          userDataBytes[i] = data[seiPtr++];
        }
        samples.push({
          payloadType,
          pts,
          uuid: uuidStrArray.join(""),
          userData: utf8ArrayToStr(userDataBytes),
          userDataBytes
        });
      }
    } else if (payloadSize < leftOver) {
      seiPtr += payloadSize;
    } else if (payloadSize > leftOver) {
      break;
    }
  }
}
function discardEPB(data) {
  const length = data.byteLength;
  const EPBPositions = [];
  let i = 1;
  while (i < length - 2) {
    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
      EPBPositions.push(i + 2);
      i += 2;
    } else {
      i++;
    }
  }
  if (EPBPositions.length === 0) {
    return data;
  }
  const newLength = length - EPBPositions.length;
  const newData = new Uint8Array(newLength);
  let sourceIndex = 0;
  for (i = 0; i < newLength; sourceIndex++, i++) {
    if (sourceIndex === EPBPositions[0]) {
      sourceIndex++;
      EPBPositions.shift();
    }
    newData[i] = data[sourceIndex];
  }
  return newData;
}
function parseEmsg(data) {
  const version5 = data[0];
  let schemeIdUri = "";
  let value = "";
  let timeScale = 0;
  let presentationTimeDelta = 0;
  let presentationTime = 0;
  let eventDuration = 0;
  let id = 0;
  let offset = 0;
  if (version5 === 0) {
    while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
      schemeIdUri += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
    }
    schemeIdUri += bin2str(data.subarray(offset, offset + 1));
    offset += 1;
    while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
      value += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
    }
    value += bin2str(data.subarray(offset, offset + 1));
    offset += 1;
    timeScale = readUint32(data, 12);
    presentationTimeDelta = readUint32(data, 16);
    eventDuration = readUint32(data, 20);
    id = readUint32(data, 24);
    offset = 28;
  } else if (version5 === 1) {
    offset += 4;
    timeScale = readUint32(data, offset);
    offset += 4;
    const leftPresentationTime = readUint32(data, offset);
    offset += 4;
    const rightPresentationTime = readUint32(data, offset);
    offset += 4;
    presentationTime = 2 ** 32 * leftPresentationTime + rightPresentationTime;
    if (!Number.isSafeInteger(presentationTime)) {
      presentationTime = Number.MAX_SAFE_INTEGER;
      logger.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box");
    }
    eventDuration = readUint32(data, offset);
    offset += 4;
    id = readUint32(data, offset);
    offset += 4;
    while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
      schemeIdUri += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
    }
    schemeIdUri += bin2str(data.subarray(offset, offset + 1));
    offset += 1;
    while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
      value += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
    }
    value += bin2str(data.subarray(offset, offset + 1));
    offset += 1;
  }
  const payload = data.subarray(offset, data.byteLength);
  return {
    schemeIdUri,
    value,
    timeScale,
    presentationTime,
    presentationTimeDelta,
    eventDuration,
    id,
    payload
  };
}
function mp4Box(type2, ...payload) {
  const len = payload.length;
  let size = 8;
  let i = len;
  while (i--) {
    size += payload[i].byteLength;
  }
  const result = new Uint8Array(size);
  result[0] = size >> 24 & 255;
  result[1] = size >> 16 & 255;
  result[2] = size >> 8 & 255;
  result[3] = size & 255;
  result.set(type2, 4);
  for (i = 0, size = 8; i < len; i++) {
    result.set(payload[i], size);
    size += payload[i].byteLength;
  }
  return result;
}
function mp4pssh(systemId, keyids, data) {
  if (systemId.byteLength !== 16) {
    throw new RangeError("Invalid system id");
  }
  let version5;
  let kids;
  if (keyids) {
    version5 = 1;
    kids = new Uint8Array(keyids.length * 16);
    for (let ix = 0; ix < keyids.length; ix++) {
      const k = keyids[ix];
      if (k.byteLength !== 16) {
        throw new RangeError("Invalid key");
      }
      kids.set(k, ix * 16);
    }
  } else {
    version5 = 0;
    kids = new Uint8Array();
  }
  let kidCount;
  if (version5 > 0) {
    kidCount = new Uint8Array(4);
    if (keyids.length > 0) {
      new DataView(kidCount.buffer).setUint32(0, keyids.length, false);
    }
  } else {
    kidCount = new Uint8Array();
  }
  const dataSize = new Uint8Array(4);
  if (data && data.byteLength > 0) {
    new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);
  }
  return mp4Box(
    [112, 115, 115, 104],
    new Uint8Array([
      version5,
      0,
      0,
      0
      // Flags
    ]),
    systemId,
    // 16 bytes
    kidCount,
    kids,
    dataSize,
    data || new Uint8Array()
  );
}
function parsePssh(initData) {
  if (!(initData instanceof ArrayBuffer) || initData.byteLength < 32) {
    return null;
  }
  const result = {
    version: 0,
    systemId: "",
    kids: null,
    data: null
  };
  const view = new DataView(initData);
  const boxSize = view.getUint32(0);
  if (initData.byteLength !== boxSize && boxSize > 44) {
    return null;
  }
  const type2 = view.getUint32(4);
  if (type2 !== 1886614376) {
    return null;
  }
  result.version = view.getUint32(8) >>> 24;
  if (result.version > 1) {
    return null;
  }
  result.systemId = Hex.hexDump(new Uint8Array(initData, 12, 16));
  const dataSizeOrKidCount = view.getUint32(28);
  if (result.version === 0) {
    if (boxSize - 32 < dataSizeOrKidCount) {
      return null;
    }
    result.data = new Uint8Array(initData, 32, dataSizeOrKidCount);
  } else if (result.version === 1) {
    result.kids = [];
    for (let i = 0; i < dataSizeOrKidCount; i++) {
      result.kids.push(new Uint8Array(initData, 32 + i * 16, 16));
    }
  }
  return result;
}
var keyUriToKeyIdMap = {};
var LevelKey = class _LevelKey {
  static clearKeyUriToKeyIdMap() {
    keyUriToKeyIdMap = {};
  }
  constructor(method, uri, format, formatversions = [1], iv = null) {
    this.uri = void 0;
    this.method = void 0;
    this.keyFormat = void 0;
    this.keyFormatVersions = void 0;
    this.encrypted = void 0;
    this.isCommonEncryption = void 0;
    this.iv = null;
    this.key = null;
    this.keyId = null;
    this.pssh = null;
    this.method = method;
    this.uri = uri;
    this.keyFormat = format;
    this.keyFormatVersions = formatversions;
    this.iv = iv;
    this.encrypted = method ? method !== "NONE" : false;
    this.isCommonEncryption = this.encrypted && method !== "AES-128";
  }
  isSupported() {
    if (this.method) {
      if (this.method === "AES-128" || this.method === "NONE") {
        return true;
      }
      if (this.keyFormat === "identity") {
        return this.method === "SAMPLE-AES";
      } else {
        switch (this.keyFormat) {
          case KeySystemFormats.FAIRPLAY:
          case KeySystemFormats.WIDEVINE:
          case KeySystemFormats.PLAYREADY:
          case KeySystemFormats.CLEARKEY:
            return ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) !== -1;
        }
      }
    }
    return false;
  }
  getDecryptData(sn) {
    if (!this.encrypted || !this.uri) {
      return null;
    }
    if (this.method === "AES-128" && this.uri && !this.iv) {
      if (typeof sn !== "number") {
        if (this.method === "AES-128" && !this.iv) {
          logger.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`);
        }
        sn = 0;
      }
      const iv = createInitializationVector(sn);
      const decryptdata = new _LevelKey(this.method, this.uri, "identity", this.keyFormatVersions, iv);
      return decryptdata;
    }
    const keyBytes = convertDataUriToArrayBytes(this.uri);
    if (keyBytes) {
      switch (this.keyFormat) {
        case KeySystemFormats.WIDEVINE:
          this.pssh = keyBytes;
          if (keyBytes.length >= 22) {
            this.keyId = keyBytes.subarray(keyBytes.length - 22, keyBytes.length - 6);
          }
          break;
        case KeySystemFormats.PLAYREADY: {
          const PlayReadyKeySystemUUID = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
          this.pssh = mp4pssh(PlayReadyKeySystemUUID, null, keyBytes);
          const keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);
          const keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));
          const xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf("<"), keyByteStr.length);
          const parser6 = new DOMParser();
          const xmlDoc = parser6.parseFromString(xmlKeyBytes, "text/xml");
          const keyData = xmlDoc.getElementsByTagName("KID")[0];
          if (keyData) {
            const keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute("VALUE");
            if (keyId) {
              const keyIdArray = base64Decode(keyId).subarray(0, 16);
              changeEndianness(keyIdArray);
              this.keyId = keyIdArray;
            }
          }
          break;
        }
        default: {
          let keydata = keyBytes.subarray(0, 16);
          if (keydata.length !== 16) {
            const padded = new Uint8Array(16);
            padded.set(keydata, 16 - keydata.length);
            keydata = padded;
          }
          this.keyId = keydata;
          break;
        }
      }
    }
    if (!this.keyId || this.keyId.byteLength !== 16) {
      let keyId = keyUriToKeyIdMap[this.uri];
      if (!keyId) {
        const val = Object.keys(keyUriToKeyIdMap).length % Number.MAX_SAFE_INTEGER;
        keyId = new Uint8Array(16);
        const dv = new DataView(keyId.buffer, 12, 4);
        dv.setUint32(0, val);
        keyUriToKeyIdMap[this.uri] = keyId;
      }
      this.keyId = keyId;
    }
    return this;
  }
};
function createInitializationVector(segmentNumber) {
  const uint8View = new Uint8Array(16);
  for (let i = 12; i < 16; i++) {
    uint8View[i] = segmentNumber >> 8 * (15 - i) & 255;
  }
  return uint8View;
}
var VARIABLE_REPLACEMENT_REGEX = /\{\$([a-zA-Z0-9-_]+)\}/g;
function hasVariableReferences(str) {
  return VARIABLE_REPLACEMENT_REGEX.test(str);
}
function substituteVariablesInAttributes(parsed, attr, attributeNames) {
  if (parsed.variableList !== null || parsed.hasVariableRefs) {
    for (let i = attributeNames.length; i--; ) {
      const name = attributeNames[i];
      const value = attr[name];
      if (value) {
        attr[name] = substituteVariables(parsed, value);
      }
    }
  }
}
function substituteVariables(parsed, value) {
  if (parsed.variableList !== null || parsed.hasVariableRefs) {
    const variableList = parsed.variableList;
    return value.replace(VARIABLE_REPLACEMENT_REGEX, (variableReference) => {
      const variableName = variableReference.substring(2, variableReference.length - 1);
      const variableValue = variableList == null ? void 0 : variableList[variableName];
      if (variableValue === void 0) {
        parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${variableName}"`));
        return variableReference;
      }
      return variableValue;
    });
  }
  return value;
}
function addVariableDefinition(parsed, attr, parentUrl) {
  let variableList = parsed.variableList;
  if (!variableList) {
    parsed.variableList = variableList = {};
  }
  let NAME;
  let VALUE;
  if ("QUERYPARAM" in attr) {
    NAME = attr.QUERYPARAM;
    try {
      const searchParams = new self.URL(parentUrl).searchParams;
      if (searchParams.has(NAME)) {
        VALUE = searchParams.get(NAME);
      } else {
        throw new Error(`"${NAME}" does not match any query parameter in URI: "${parentUrl}"`);
      }
    } catch (error) {
      parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${error.message}`));
    }
  } else {
    NAME = attr.NAME;
    VALUE = attr.VALUE;
  }
  if (NAME in variableList) {
    parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${NAME}"`));
  } else {
    variableList[NAME] = VALUE || "";
  }
}
function importVariableDefinition(parsed, attr, sourceVariableList) {
  const IMPORT = attr.IMPORT;
  if (sourceVariableList && IMPORT in sourceVariableList) {
    let variableList = parsed.variableList;
    if (!variableList) {
      parsed.variableList = variableList = {};
    }
    variableList[IMPORT] = sourceVariableList[IMPORT];
  } else {
    parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${IMPORT}"`));
  }
}
function getMediaSource() {
  if (typeof self === "undefined") return void 0;
  return self.MediaSource || self.WebKitMediaSource;
}
var sampleEntryCodesISO = {
  audio: {
    a3ds: true,
    "ac-3": true,
    "ac-4": true,
    alac: true,
    alaw: true,
    dra1: true,
    "dts+": true,
    "dts-": true,
    dtsc: true,
    dtse: true,
    dtsh: true,
    "ec-3": true,
    enca: true,
    g719: true,
    g726: true,
    m4ae: true,
    mha1: true,
    mha2: true,
    mhm1: true,
    mhm2: true,
    mlpa: true,
    mp4a: true,
    "raw ": true,
    Opus: true,
    opus: true,
    // browsers expect this to be lowercase despite MP4RA says 'Opus'
    samr: true,
    sawb: true,
    sawp: true,
    sevc: true,
    sqcp: true,
    ssmv: true,
    twos: true,
    ulaw: true
  },
  video: {
    avc1: true,
    avc2: true,
    avc3: true,
    avc4: true,
    avcp: true,
    av01: true,
    drac: true,
    dva1: true,
    dvav: true,
    dvh1: true,
    dvhe: true,
    encv: true,
    hev1: true,
    hvc1: true,
    mjp2: true,
    mp4v: true,
    mvc1: true,
    mvc2: true,
    mvc3: true,
    mvc4: true,
    resv: true,
    rv60: true,
    s263: true,
    svc1: true,
    svc2: true,
    "vc-1": true,
    vp08: true,
    vp09: true
  },
  text: {
    stpp: true,
    wvtt: true
  }
};
var MediaSource$2 = getMediaSource();
function isCodecType(codec, type2) {
  const typeCodes = sampleEntryCodesISO[type2];
  return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;
}
function isCodecSupportedInMp4(codec, type2) {
  var _MediaSource$isTypeSu;
  return (_MediaSource$isTypeSu = MediaSource$2 == null ? void 0 : MediaSource$2.isTypeSupported(`${type2 || "video"}/mp4;codecs="${codec}"`)) != null ? _MediaSource$isTypeSu : false;
}
var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g;
var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
var IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m;
var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([
  /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
  // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
  /(?!#) *(\S[\S ]*)/.source,
  // segment URI, group 3 => the URI (note newline is not eaten)
  /#EXT-X-BYTERANGE:*(.+)/.source,
  // next segment's byterange, group 4 => range spec (x@y)
  /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,
  // next segment's program date/time group 5 => the datetime spec
  /#.*/.source
  // All other non-segment oriented tags will match with all groups empty
].join("|"), "g");
var LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
var M3U8Parser = class _M3U8Parser {
  static findGroup(groups, mediaGroupId) {
    for (let i = 0; i < groups.length; i++) {
      const group = groups[i];
      if (group.id === mediaGroupId) {
        return group;
      }
    }
  }
  static convertAVC1ToAVCOTI(codec) {
    const avcdata = codec.split(".");
    if (avcdata.length > 2) {
      let result = avcdata.shift() + ".";
      result += parseInt(avcdata.shift()).toString(16);
      result += ("000" + parseInt(avcdata.shift()).toString(16)).slice(-4);
      return result;
    }
    return codec;
  }
  static resolve(url, baseUrl) {
    return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {
      alwaysNormalize: true
    });
  }
  static isMediaPlaylist(str) {
    return IS_MEDIA_PLAYLIST.test(str);
  }
  static parseMasterPlaylist(string, baseurl) {
    const hasVariableRefs = hasVariableReferences(string);
    const parsed = {
      contentSteering: null,
      levels: [],
      playlistParsingError: null,
      sessionData: null,
      sessionKeys: null,
      startTimeOffset: null,
      variableList: null,
      hasVariableRefs
    };
    const levelsWithKnownCodecs = [];
    MASTER_PLAYLIST_REGEX.lastIndex = 0;
    let result;
    while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
      if (result[1]) {
        var _level$unknownCodecs;
        const attrs = new AttrList(result[1]);
        {
          substituteVariablesInAttributes(parsed, attrs, ["CODECS", "SUPPLEMENTAL-CODECS", "ALLOWED-CPC", "PATHWAY-ID", "STABLE-VARIANT-ID", "AUDIO", "VIDEO", "SUBTITLES", "CLOSED-CAPTIONS", "NAME"]);
        }
        const uri = substituteVariables(parsed, result[2]);
        const level = {
          attrs,
          bitrate: attrs.decimalInteger("AVERAGE-BANDWIDTH") || attrs.decimalInteger("BANDWIDTH"),
          name: attrs.NAME,
          url: _M3U8Parser.resolve(uri, baseurl)
        };
        const resolution = attrs.decimalResolution("RESOLUTION");
        if (resolution) {
          level.width = resolution.width;
          level.height = resolution.height;
        }
        setCodecs((attrs.CODECS || "").split(/[ ,]+/).filter((c) => c), level);
        if (level.videoCodec && level.videoCodec.indexOf("avc1") !== -1) {
          level.videoCodec = _M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);
        }
        if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {
          levelsWithKnownCodecs.push(level);
        }
        parsed.levels.push(level);
      } else if (result[3]) {
        const tag = result[3];
        const attributes = result[4];
        switch (tag) {
          case "SESSION-DATA": {
            const sessionAttrs = new AttrList(attributes);
            {
              substituteVariablesInAttributes(parsed, sessionAttrs, ["DATA-ID", "LANGUAGE", "VALUE", "URI"]);
            }
            const dataId = sessionAttrs["DATA-ID"];
            if (dataId) {
              if (parsed.sessionData === null) {
                parsed.sessionData = {};
              }
              parsed.sessionData[dataId] = sessionAttrs;
            }
            break;
          }
          case "SESSION-KEY": {
            const sessionKey = parseKey(attributes, baseurl, parsed);
            if (sessionKey.encrypted && sessionKey.isSupported()) {
              if (parsed.sessionKeys === null) {
                parsed.sessionKeys = [];
              }
              parsed.sessionKeys.push(sessionKey);
            } else {
              logger.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${attributes}"`);
            }
            break;
          }
          case "DEFINE": {
            {
              const variableAttributes = new AttrList(attributes);
              substituteVariablesInAttributes(parsed, variableAttributes, ["NAME", "VALUE", "QUERYPARAM"]);
              addVariableDefinition(parsed, variableAttributes, baseurl);
            }
            break;
          }
          case "CONTENT-STEERING": {
            const contentSteeringAttributes = new AttrList(attributes);
            {
              substituteVariablesInAttributes(parsed, contentSteeringAttributes, ["SERVER-URI", "PATHWAY-ID"]);
            }
            parsed.contentSteering = {
              uri: _M3U8Parser.resolve(contentSteeringAttributes["SERVER-URI"], baseurl),
              pathwayId: contentSteeringAttributes["PATHWAY-ID"] || "."
            };
            break;
          }
          case "START": {
            parsed.startTimeOffset = parseStartTimeOffset(attributes);
            break;
          }
        }
      }
    }
    const stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;
    parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;
    if (parsed.levels.length === 0) {
      parsed.playlistParsingError = new Error("no levels found in manifest");
    }
    return parsed;
  }
  static parseMasterPlaylistMedia(string, baseurl, parsed) {
    let result;
    const results = {};
    const levels = parsed.levels;
    const groupsByType = {
      AUDIO: levels.map((level) => ({
        id: level.attrs.AUDIO,
        audioCodec: level.audioCodec
      })),
      SUBTITLES: levels.map((level) => ({
        id: level.attrs.SUBTITLES,
        textCodec: level.textCodec
      })),
      "CLOSED-CAPTIONS": []
    };
    let id = 0;
    MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
    while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
      const attrs = new AttrList(result[1]);
      const type2 = attrs.TYPE;
      if (type2) {
        const groups = groupsByType[type2];
        const medias = results[type2] || [];
        results[type2] = medias;
        {
          substituteVariablesInAttributes(parsed, attrs, ["URI", "GROUP-ID", "LANGUAGE", "ASSOC-LANGUAGE", "STABLE-RENDITION-ID", "NAME", "INSTREAM-ID", "CHARACTERISTICS", "CHANNELS"]);
        }
        const media = {
          attrs,
          bitrate: 0,
          id: id++,
          groupId: attrs["GROUP-ID"] || "",
          instreamId: attrs["INSTREAM-ID"],
          name: attrs.NAME || attrs.LANGUAGE || "",
          type: type2,
          default: attrs.bool("DEFAULT"),
          autoselect: attrs.bool("AUTOSELECT"),
          forced: attrs.bool("FORCED"),
          lang: attrs.LANGUAGE,
          url: attrs.URI ? _M3U8Parser.resolve(attrs.URI, baseurl) : ""
        };
        if (groups != null && groups.length) {
          const groupCodec = _M3U8Parser.findGroup(groups, media.groupId) || groups[0];
          assignCodec(media, groupCodec, "audioCodec");
          assignCodec(media, groupCodec, "textCodec");
        }
        medias.push(media);
      }
    }
    return results;
  }
  static parseLevelPlaylist(string, baseurl, id, type2, levelUrlId, multivariantVariableList) {
    const level = new LevelDetails(baseurl);
    const fragments = level.fragments;
    let currentInitSegment = null;
    let currentSN = 0;
    let currentPart = 0;
    let totalduration = 0;
    let discontinuityCounter = 0;
    let prevFrag = null;
    let frag = new Fragment(type2, baseurl);
    let result;
    let i;
    let levelkeys;
    let firstPdtIndex = -1;
    let createNextFrag = false;
    LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;
    level.m3u8 = string;
    level.hasVariableRefs = hasVariableReferences(string);
    while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
      if (createNextFrag) {
        createNextFrag = false;
        frag = new Fragment(type2, baseurl);
        frag.start = totalduration;
        frag.sn = currentSN;
        frag.cc = discontinuityCounter;
        frag.level = id;
        if (currentInitSegment) {
          frag.initSegment = currentInitSegment;
          frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
          currentInitSegment.rawProgramDateTime = null;
        }
      }
      const duration5 = result[1];
      if (duration5) {
        frag.duration = parseFloat(duration5);
        const title = (" " + result[2]).slice(1);
        frag.title = title || null;
        frag.tagList.push(title ? ["INF", duration5, title] : ["INF", duration5]);
      } else if (result[3]) {
        if (isFiniteNumber(frag.duration)) {
          frag.start = totalduration;
          if (levelkeys) {
            setFragLevelKeys(frag, levelkeys, level);
          }
          frag.sn = currentSN;
          frag.level = id;
          frag.cc = discontinuityCounter;
          frag.urlId = levelUrlId;
          fragments.push(frag);
          const uri = (" " + result[3]).slice(1);
          frag.relurl = substituteVariables(level, uri);
          assignProgramDateTime(frag, prevFrag);
          prevFrag = frag;
          totalduration += frag.duration;
          currentSN++;
          currentPart = 0;
          createNextFrag = true;
        }
      } else if (result[4]) {
        const data = (" " + result[4]).slice(1);
        if (prevFrag) {
          frag.setByteRange(data, prevFrag);
        } else {
          frag.setByteRange(data);
        }
      } else if (result[5]) {
        frag.rawProgramDateTime = (" " + result[5]).slice(1);
        frag.tagList.push(["PROGRAM-DATE-TIME", frag.rawProgramDateTime]);
        if (firstPdtIndex === -1) {
          firstPdtIndex = fragments.length;
        }
      } else {
        result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
        if (!result) {
          logger.warn("No matches on slow regex match for level playlist!");
          continue;
        }
        for (i = 1; i < result.length; i++) {
          if (typeof result[i] !== "undefined") {
            break;
          }
        }
        const tag = (" " + result[i]).slice(1);
        const value1 = (" " + result[i + 1]).slice(1);
        const value2 = result[i + 2] ? (" " + result[i + 2]).slice(1) : "";
        switch (tag) {
          case "PLAYLIST-TYPE":
            level.type = value1.toUpperCase();
            break;
          case "MEDIA-SEQUENCE":
            currentSN = level.startSN = parseInt(value1);
            break;
          case "SKIP": {
            const skipAttrs = new AttrList(value1);
            {
              substituteVariablesInAttributes(level, skipAttrs, ["RECENTLY-REMOVED-DATERANGES"]);
            }
            const skippedSegments = skipAttrs.decimalInteger("SKIPPED-SEGMENTS");
            if (isFiniteNumber(skippedSegments)) {
              level.skippedSegments = skippedSegments;
              for (let _i = skippedSegments; _i--; ) {
                fragments.unshift(null);
              }
              currentSN += skippedSegments;
            }
            const recentlyRemovedDateranges = skipAttrs.enumeratedString("RECENTLY-REMOVED-DATERANGES");
            if (recentlyRemovedDateranges) {
              level.recentlyRemovedDateranges = recentlyRemovedDateranges.split("	");
            }
            break;
          }
          case "TARGETDURATION":
            level.targetduration = Math.max(parseInt(value1), 1);
            break;
          case "VERSION":
            level.version = parseInt(value1);
            break;
          case "EXTM3U":
            break;
          case "ENDLIST":
            level.live = false;
            break;
          case "#":
            if (value1 || value2) {
              frag.tagList.push(value2 ? [value1, value2] : [value1]);
            }
            break;
          case "DISCONTINUITY":
            discontinuityCounter++;
            frag.tagList.push(["DIS"]);
            break;
          case "GAP":
            frag.gap = true;
            frag.tagList.push([tag]);
            break;
          case "BITRATE":
            frag.tagList.push([tag, value1]);
            break;
          case "DATERANGE": {
            const dateRangeAttr = new AttrList(value1);
            {
              substituteVariablesInAttributes(level, dateRangeAttr, ["ID", "CLASS", "START-DATE", "END-DATE", "SCTE35-CMD", "SCTE35-OUT", "SCTE35-IN"]);
              substituteVariablesInAttributes(level, dateRangeAttr, dateRangeAttr.clientAttrs);
            }
            const dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);
            if (dateRange.isValid || level.skippedSegments) {
              level.dateRanges[dateRange.id] = dateRange;
            } else {
              logger.warn(`Ignoring invalid DATERANGE tag: "${value1}"`);
            }
            frag.tagList.push(["EXT-X-DATERANGE", value1]);
            break;
          }
          case "DEFINE": {
            {
              const variableAttributes = new AttrList(value1);
              substituteVariablesInAttributes(level, variableAttributes, ["NAME", "VALUE", "IMPORT", "QUERYPARAM"]);
              if ("IMPORT" in variableAttributes) {
                importVariableDefinition(level, variableAttributes, multivariantVariableList);
              } else {
                addVariableDefinition(level, variableAttributes, baseurl);
              }
            }
            break;
          }
          case "DISCONTINUITY-SEQUENCE":
            discontinuityCounter = parseInt(value1);
            break;
          case "KEY": {
            const levelKey = parseKey(value1, baseurl, level);
            if (levelKey.isSupported()) {
              if (levelKey.method === "NONE") {
                levelkeys = void 0;
                break;
              }
              if (!levelkeys) {
                levelkeys = {};
              }
              if (levelkeys[levelKey.keyFormat]) {
                levelkeys = _extends({}, levelkeys);
              }
              levelkeys[levelKey.keyFormat] = levelKey;
            } else {
              logger.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${value1}"`);
            }
            break;
          }
          case "START":
            level.startTimeOffset = parseStartTimeOffset(value1);
            break;
          case "MAP": {
            const mapAttrs = new AttrList(value1);
            {
              substituteVariablesInAttributes(level, mapAttrs, ["BYTERANGE", "URI"]);
            }
            if (frag.duration) {
              const init = new Fragment(type2, baseurl);
              setInitSegment(init, mapAttrs, id, levelkeys);
              currentInitSegment = init;
              frag.initSegment = currentInitSegment;
              if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {
                frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
              }
            } else {
              setInitSegment(frag, mapAttrs, id, levelkeys);
              currentInitSegment = frag;
              createNextFrag = true;
            }
            break;
          }
          case "SERVER-CONTROL": {
            const serverControlAttrs = new AttrList(value1);
            level.canBlockReload = serverControlAttrs.bool("CAN-BLOCK-RELOAD");
            level.canSkipUntil = serverControlAttrs.optionalFloat("CAN-SKIP-UNTIL", 0);
            level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool("CAN-SKIP-DATERANGES");
            level.partHoldBack = serverControlAttrs.optionalFloat("PART-HOLD-BACK", 0);
            level.holdBack = serverControlAttrs.optionalFloat("HOLD-BACK", 0);
            break;
          }
          case "PART-INF": {
            const partInfAttrs = new AttrList(value1);
            level.partTarget = partInfAttrs.decimalFloatingPoint("PART-TARGET");
            break;
          }
          case "PART": {
            let partList = level.partList;
            if (!partList) {
              partList = level.partList = [];
            }
            const previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : void 0;
            const index = currentPart++;
            const partAttrs = new AttrList(value1);
            {
              substituteVariablesInAttributes(level, partAttrs, ["BYTERANGE", "URI"]);
            }
            const part = new Part(partAttrs, frag, baseurl, index, previousFragmentPart);
            partList.push(part);
            frag.duration += part.duration;
            break;
          }
          case "PRELOAD-HINT": {
            const preloadHintAttrs = new AttrList(value1);
            {
              substituteVariablesInAttributes(level, preloadHintAttrs, ["URI"]);
            }
            level.preloadHint = preloadHintAttrs;
            break;
          }
          case "RENDITION-REPORT": {
            const renditionReportAttrs = new AttrList(value1);
            {
              substituteVariablesInAttributes(level, renditionReportAttrs, ["URI"]);
            }
            level.renditionReports = level.renditionReports || [];
            level.renditionReports.push(renditionReportAttrs);
            break;
          }
          default:
            logger.warn(`line parsed but not handled: ${result}`);
            break;
        }
      }
    }
    if (prevFrag && !prevFrag.relurl) {
      fragments.pop();
      totalduration -= prevFrag.duration;
      if (level.partList) {
        level.fragmentHint = prevFrag;
      }
    } else if (level.partList) {
      assignProgramDateTime(frag, prevFrag);
      frag.cc = discontinuityCounter;
      level.fragmentHint = frag;
      if (levelkeys) {
        setFragLevelKeys(frag, levelkeys, level);
      }
    }
    const fragmentLength = fragments.length;
    const firstFragment = fragments[0];
    const lastFragment = fragments[fragmentLength - 1];
    totalduration += level.skippedSegments * level.targetduration;
    if (totalduration > 0 && fragmentLength && lastFragment) {
      level.averagetargetduration = totalduration / fragmentLength;
      const lastSn = lastFragment.sn;
      level.endSN = lastSn !== "initSegment" ? lastSn : 0;
      if (!level.live) {
        lastFragment.endList = true;
      }
      if (firstFragment) {
        level.startCC = firstFragment.cc;
      }
    } else {
      level.endSN = 0;
      level.startCC = 0;
    }
    if (level.fragmentHint) {
      totalduration += level.fragmentHint.duration;
    }
    level.totalduration = totalduration;
    level.endCC = discontinuityCounter;
    if (firstPdtIndex > 0) {
      backfillProgramDateTimes(fragments, firstPdtIndex);
    }
    return level;
  }
};
function parseKey(keyTagAttributes, baseurl, parsed) {
  var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;
  const keyAttrs = new AttrList(keyTagAttributes);
  {
    substituteVariablesInAttributes(parsed, keyAttrs, ["KEYFORMAT", "KEYFORMATVERSIONS", "URI", "IV", "URI"]);
  }
  const decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : "";
  const decrypturi = keyAttrs.URI;
  const decryptiv = keyAttrs.hexadecimalInteger("IV");
  const decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;
  const decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : "identity";
  if (decrypturi && keyAttrs.IV && !decryptiv) {
    logger.error(`Invalid IV: ${keyAttrs.IV}`);
  }
  const resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : "";
  const keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : "1").split("/").map(Number).filter(Number.isFinite);
  return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);
}
function parseStartTimeOffset(startAttributes) {
  const startAttrs = new AttrList(startAttributes);
  const startTimeOffset = startAttrs.decimalFloatingPoint("TIME-OFFSET");
  if (isFiniteNumber(startTimeOffset)) {
    return startTimeOffset;
  }
  return null;
}
function setCodecs(codecs, level) {
  ["video", "audio", "text"].forEach((type2) => {
    const filtered = codecs.filter((codec) => isCodecType(codec, type2));
    if (filtered.length) {
      const preferred = filtered.filter((codec) => {
        return codec.lastIndexOf("avc1", 0) === 0 || codec.lastIndexOf("mp4a", 0) === 0;
      });
      level[`${type2}Codec`] = preferred.length > 0 ? preferred[0] : filtered[0];
      codecs = codecs.filter((codec) => filtered.indexOf(codec) === -1);
    }
  });
  level.unknownCodecs = codecs;
}
function assignCodec(media, groupItem, codecProperty) {
  const codecValue = groupItem[codecProperty];
  if (codecValue) {
    media[codecProperty] = codecValue;
  }
}
function backfillProgramDateTimes(fragments, firstPdtIndex) {
  let fragPrev = fragments[firstPdtIndex];
  for (let i = firstPdtIndex; i--; ) {
    const frag = fragments[i];
    if (!frag) {
      return;
    }
    frag.programDateTime = fragPrev.programDateTime - frag.duration * 1e3;
    fragPrev = frag;
  }
}
function assignProgramDateTime(frag, prevFrag) {
  if (frag.rawProgramDateTime) {
    frag.programDateTime = Date.parse(frag.rawProgramDateTime);
  } else if (prevFrag != null && prevFrag.programDateTime) {
    frag.programDateTime = prevFrag.endProgramDateTime;
  }
  if (!isFiniteNumber(frag.programDateTime)) {
    frag.programDateTime = null;
    frag.rawProgramDateTime = null;
  }
}
function setInitSegment(frag, mapAttrs, id, levelkeys) {
  frag.relurl = mapAttrs.URI;
  if (mapAttrs.BYTERANGE) {
    frag.setByteRange(mapAttrs.BYTERANGE);
  }
  frag.level = id;
  frag.sn = "initSegment";
  if (levelkeys) {
    frag.levelkeys = levelkeys;
  }
  frag.initSegment = null;
}
function setFragLevelKeys(frag, levelkeys, level) {
  frag.levelkeys = levelkeys;
  const {
    encryptedFragments
  } = level;
  if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some((format) => levelkeys[format].isCommonEncryption)) {
    encryptedFragments.push(frag);
  }
}
var PlaylistContextType = {
  MANIFEST: "manifest",
  LEVEL: "level",
  AUDIO_TRACK: "audioTrack",
  SUBTITLE_TRACK: "subtitleTrack"
};
var PlaylistLevelType = {
  MAIN: "main",
  AUDIO: "audio",
  SUBTITLE: "subtitle"
};
function mapContextToLevelType(context) {
  const {
    type: type2
  } = context;
  switch (type2) {
    case PlaylistContextType.AUDIO_TRACK:
      return PlaylistLevelType.AUDIO;
    case PlaylistContextType.SUBTITLE_TRACK:
      return PlaylistLevelType.SUBTITLE;
    default:
      return PlaylistLevelType.MAIN;
  }
}
function getResponseUrl(response, context) {
  let url = response.url;
  if (url === void 0 || url.indexOf("data:") === 0) {
    url = context.url;
  }
  return url;
}
var PlaylistLoader = class {
  constructor(hls) {
    this.hls = void 0;
    this.loaders = /* @__PURE__ */ Object.create(null);
    this.variableList = null;
    this.hls = hls;
    this.registerListeners();
  }
  startLoad(startPosition) {
  }
  stopLoad() {
    this.destroyInternalLoaders();
  }
  registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
    hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
    hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
  }
  unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
    hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
    hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
  }
  /**
   * Returns defaults or configured loader-type overloads (pLoader and loader config params)
   */
  createInternalLoader(context) {
    const config = this.hls.config;
    const PLoader = config.pLoader;
    const Loader = config.loader;
    const InternalLoader = PLoader || Loader;
    const loader = new InternalLoader(config);
    this.loaders[context.type] = loader;
    return loader;
  }
  getInternalLoader(context) {
    return this.loaders[context.type];
  }
  resetInternalLoader(contextType) {
    if (this.loaders[contextType]) {
      delete this.loaders[contextType];
    }
  }
  /**
   * Call `destroy` on all internal loader instances mapped (one per context type)
   */
  destroyInternalLoaders() {
    for (const contextType in this.loaders) {
      const loader = this.loaders[contextType];
      if (loader) {
        loader.destroy();
      }
      this.resetInternalLoader(contextType);
    }
  }
  destroy() {
    this.variableList = null;
    this.unregisterListeners();
    this.destroyInternalLoaders();
  }
  onManifestLoading(event, data) {
    const {
      url
    } = data;
    this.variableList = null;
    this.load({
      id: null,
      level: 0,
      responseType: "text",
      type: PlaylistContextType.MANIFEST,
      url,
      deliveryDirectives: null
    });
  }
  onLevelLoading(event, data) {
    const {
      id,
      level,
      url,
      deliveryDirectives
    } = data;
    this.load({
      id,
      level,
      responseType: "text",
      type: PlaylistContextType.LEVEL,
      url,
      deliveryDirectives
    });
  }
  onAudioTrackLoading(event, data) {
    const {
      id,
      groupId,
      url,
      deliveryDirectives
    } = data;
    this.load({
      id,
      groupId,
      level: null,
      responseType: "text",
      type: PlaylistContextType.AUDIO_TRACK,
      url,
      deliveryDirectives
    });
  }
  onSubtitleTrackLoading(event, data) {
    const {
      id,
      groupId,
      url,
      deliveryDirectives
    } = data;
    this.load({
      id,
      groupId,
      level: null,
      responseType: "text",
      type: PlaylistContextType.SUBTITLE_TRACK,
      url,
      deliveryDirectives
    });
  }
  load(context) {
    var _context$deliveryDire;
    const config = this.hls.config;
    let loader = this.getInternalLoader(context);
    if (loader) {
      const loaderContext = loader.context;
      if (loaderContext && loaderContext.url === context.url) {
        logger.trace("[playlist-loader]: playlist request ongoing");
        return;
      }
      logger.log(`[playlist-loader]: aborting previous loader for type: ${context.type}`);
      loader.abort();
    }
    let loadPolicy;
    if (context.type === PlaylistContextType.MANIFEST) {
      loadPolicy = config.manifestLoadPolicy.default;
    } else {
      loadPolicy = _extends({}, config.playlistLoadPolicy.default, {
        timeoutRetry: null,
        errorRetry: null
      });
    }
    loader = this.createInternalLoader(context);
    if ((_context$deliveryDire = context.deliveryDirectives) != null && _context$deliveryDire.part) {
      let levelDetails;
      if (context.type === PlaylistContextType.LEVEL && context.level !== null) {
        levelDetails = this.hls.levels[context.level].details;
      } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {
        levelDetails = this.hls.audioTracks[context.id].details;
      } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {
        levelDetails = this.hls.subtitleTracks[context.id].details;
      }
      if (levelDetails) {
        const partTarget = levelDetails.partTarget;
        const targetDuration = levelDetails.targetduration;
        if (partTarget && targetDuration) {
          const maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1e3;
          loadPolicy = _extends({}, loadPolicy, {
            maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),
            maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)
          });
        }
      }
    }
    const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};
    const loaderConfig = {
      loadPolicy,
      timeout: loadPolicy.maxLoadTimeMs,
      maxRetry: legacyRetryCompatibility.maxNumRetry || 0,
      retryDelay: legacyRetryCompatibility.retryDelayMs || 0,
      maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0
    };
    const loaderCallbacks = {
      onSuccess: (response, stats, context2, networkDetails) => {
        const loader2 = this.getInternalLoader(context2);
        this.resetInternalLoader(context2.type);
        const string = response.data;
        if (string.indexOf("#EXTM3U") !== 0) {
          this.handleManifestParsingError(response, context2, new Error("no EXTM3U delimiter"), networkDetails || null, stats);
          return;
        }
        stats.parsing.start = performance.now();
        if (M3U8Parser.isMediaPlaylist(string)) {
          this.handleTrackOrLevelPlaylist(response, stats, context2, networkDetails || null, loader2);
        } else {
          this.handleMasterPlaylist(response, stats, context2, networkDetails);
        }
      },
      onError: (response, context2, networkDetails, stats) => {
        this.handleNetworkError(context2, networkDetails, false, response, stats);
      },
      onTimeout: (stats, context2, networkDetails) => {
        this.handleNetworkError(context2, networkDetails, true, void 0, stats);
      }
    };
    loader.load(context, loaderConfig, loaderCallbacks);
  }
  handleMasterPlaylist(response, stats, context, networkDetails) {
    const hls = this.hls;
    const string = response.data;
    const url = getResponseUrl(response, context);
    const parsedResult = M3U8Parser.parseMasterPlaylist(string, url);
    if (parsedResult.playlistParsingError) {
      this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);
      return;
    }
    const {
      contentSteering,
      levels,
      sessionData,
      sessionKeys,
      startTimeOffset,
      variableList
    } = parsedResult;
    this.variableList = variableList;
    const {
      AUDIO: audioTracks = [],
      SUBTITLES: subtitles,
      "CLOSED-CAPTIONS": captions
    } = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult);
    if (audioTracks.length) {
      const embeddedAudioFound = audioTracks.some((audioTrack) => !audioTrack.url);
      if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
        logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one");
        audioTracks.unshift({
          type: "main",
          name: "main",
          groupId: "main",
          default: false,
          autoselect: false,
          forced: false,
          id: -1,
          attrs: new AttrList({}),
          bitrate: 0,
          url: ""
        });
      }
    }
    hls.trigger(Events.MANIFEST_LOADED, {
      levels,
      audioTracks,
      subtitles,
      captions,
      contentSteering,
      url,
      stats,
      networkDetails,
      sessionData,
      sessionKeys,
      startTimeOffset,
      variableList
    });
  }
  handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {
    const hls = this.hls;
    const {
      id,
      level,
      type: type2
    } = context;
    const url = getResponseUrl(response, context);
    const levelUrlId = isFiniteNumber(id) ? id : 0;
    const levelId = isFiniteNumber(level) ? level : levelUrlId;
    const levelType = mapContextToLevelType(context);
    const levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId, this.variableList);
    if (type2 === PlaylistContextType.MANIFEST) {
      const singleLevel = {
        attrs: new AttrList({}),
        bitrate: 0,
        details: levelDetails,
        name: "",
        url
      };
      hls.trigger(Events.MANIFEST_LOADED, {
        levels: [singleLevel],
        audioTracks: [],
        url,
        stats,
        networkDetails,
        sessionData: null,
        sessionKeys: null,
        contentSteering: null,
        startTimeOffset: null,
        variableList: null
      });
    }
    stats.parsing.end = performance.now();
    context.levelDetails = levelDetails;
    this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);
  }
  handleManifestParsingError(response, context, error, networkDetails, stats) {
    this.hls.trigger(Events.ERROR, {
      type: ErrorTypes.NETWORK_ERROR,
      details: ErrorDetails.MANIFEST_PARSING_ERROR,
      fatal: context.type === PlaylistContextType.MANIFEST,
      url: response.url,
      err: error,
      error,
      reason: error.message,
      response,
      context,
      networkDetails,
      stats
    });
  }
  handleNetworkError(context, networkDetails, timeout = false, response, stats) {
    let message = `A network ${timeout ? "timeout" : "error" + (response ? " (status " + response.code + ")" : "")} occurred while loading ${context.type}`;
    if (context.type === PlaylistContextType.LEVEL) {
      message += `: ${context.level} id: ${context.id}`;
    } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {
      message += ` id: ${context.id} group-id: "${context.groupId}"`;
    }
    const error = new Error(message);
    logger.warn(`[playlist-loader]: ${message}`);
    let details = ErrorDetails.UNKNOWN;
    let fatal = false;
    const loader = this.getInternalLoader(context);
    switch (context.type) {
      case PlaylistContextType.MANIFEST:
        details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;
        fatal = true;
        break;
      case PlaylistContextType.LEVEL:
        details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;
        fatal = false;
        break;
      case PlaylistContextType.AUDIO_TRACK:
        details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
        fatal = false;
        break;
      case PlaylistContextType.SUBTITLE_TRACK:
        details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;
        fatal = false;
        break;
    }
    if (loader) {
      this.resetInternalLoader(context.type);
    }
    const errorData = {
      type: ErrorTypes.NETWORK_ERROR,
      details,
      fatal,
      url: context.url,
      loader,
      context,
      error,
      networkDetails,
      stats
    };
    if (response) {
      const url = (networkDetails == null ? void 0 : networkDetails.url) || context.url;
      errorData.response = _objectSpread2({
        url,
        data: void 0
      }, response);
    }
    this.hls.trigger(Events.ERROR, errorData);
  }
  handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {
    const hls = this.hls;
    const {
      type: type2,
      level,
      id,
      groupId,
      deliveryDirectives
    } = context;
    const url = getResponseUrl(response, context);
    const parent = mapContextToLevelType(context);
    const levelIndex = typeof context.level === "number" && parent === PlaylistLevelType.MAIN ? level : void 0;
    if (!levelDetails.fragments.length) {
      const _error = new Error("No Segments found in Playlist");
      hls.trigger(Events.ERROR, {
        type: ErrorTypes.NETWORK_ERROR,
        details: ErrorDetails.LEVEL_EMPTY_ERROR,
        fatal: false,
        url,
        error: _error,
        reason: _error.message,
        response,
        context,
        level: levelIndex,
        parent,
        networkDetails,
        stats
      });
      return;
    }
    if (!levelDetails.targetduration) {
      levelDetails.playlistParsingError = new Error("Missing Target Duration");
    }
    const error = levelDetails.playlistParsingError;
    if (error) {
      hls.trigger(Events.ERROR, {
        type: ErrorTypes.NETWORK_ERROR,
        details: ErrorDetails.LEVEL_PARSING_ERROR,
        fatal: false,
        url,
        error,
        reason: error.message,
        response,
        context,
        level: levelIndex,
        parent,
        networkDetails,
        stats
      });
      return;
    }
    if (levelDetails.live && loader) {
      if (loader.getCacheAge) {
        levelDetails.ageHeader = loader.getCacheAge() || 0;
      }
      if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {
        levelDetails.ageHeader = 0;
      }
    }
    switch (type2) {
      case PlaylistContextType.MANIFEST:
      case PlaylistContextType.LEVEL:
        hls.trigger(Events.LEVEL_LOADED, {
          details: levelDetails,
          level: levelIndex || 0,
          id: id || 0,
          stats,
          networkDetails,
          deliveryDirectives
        });
        break;
      case PlaylistContextType.AUDIO_TRACK:
        hls.trigger(Events.AUDIO_TRACK_LOADED, {
          details: levelDetails,
          id: id || 0,
          groupId: groupId || "",
          stats,
          networkDetails,
          deliveryDirectives
        });
        break;
      case PlaylistContextType.SUBTITLE_TRACK:
        hls.trigger(Events.SUBTITLE_TRACK_LOADED, {
          details: levelDetails,
          id: id || 0,
          groupId: groupId || "",
          stats,
          networkDetails,
          deliveryDirectives
        });
        break;
    }
  }
};
function sendAddTrackEvent(track, videoEl) {
  let event;
  try {
    event = new Event("addtrack");
  } catch (err) {
    event = document.createEvent("Event");
    event.initEvent("addtrack", false, false);
  }
  event.track = track;
  videoEl.dispatchEvent(event);
}
function addCueToTrack(track, cue) {
  const mode = track.mode;
  if (mode === "disabled") {
    track.mode = "hidden";
  }
  if (track.cues && !track.cues.getCueById(cue.id)) {
    try {
      track.addCue(cue);
      if (!track.cues.getCueById(cue.id)) {
        throw new Error(`addCue is failed for: ${cue}`);
      }
    } catch (err) {
      logger.debug(`[texttrack-utils]: ${err}`);
      try {
        const textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);
        textTrackCue.id = cue.id;
        track.addCue(textTrackCue);
      } catch (err2) {
        logger.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${err2}`);
      }
    }
  }
  if (mode === "disabled") {
    track.mode = mode;
  }
}
function clearCurrentCues(track) {
  const mode = track.mode;
  if (mode === "disabled") {
    track.mode = "hidden";
  }
  if (track.cues) {
    for (let i = track.cues.length; i--; ) {
      track.removeCue(track.cues[i]);
    }
  }
  if (mode === "disabled") {
    track.mode = mode;
  }
}
function removeCuesInRange(track, start2, end, predicate) {
  const mode = track.mode;
  if (mode === "disabled") {
    track.mode = "hidden";
  }
  if (track.cues && track.cues.length > 0) {
    const cues = getCuesInRange(track.cues, start2, end);
    for (let i = 0; i < cues.length; i++) {
      if (!predicate || predicate(cues[i])) {
        track.removeCue(cues[i]);
      }
    }
  }
  if (mode === "disabled") {
    track.mode = mode;
  }
}
function getFirstCueIndexAfterTime(cues, time) {
  if (time < cues[0].startTime) {
    return 0;
  }
  const len = cues.length - 1;
  if (time > cues[len].endTime) {
    return -1;
  }
  let left = 0;
  let right = len;
  while (left <= right) {
    const mid = Math.floor((right + left) / 2);
    if (time < cues[mid].startTime) {
      right = mid - 1;
    } else if (time > cues[mid].startTime && left < len) {
      left = mid + 1;
    } else {
      return mid;
    }
  }
  return cues[left].startTime - time < time - cues[right].startTime ? left : right;
}
function getCuesInRange(cues, start2, end) {
  const cuesFound = [];
  const firstCueInRange = getFirstCueIndexAfterTime(cues, start2);
  if (firstCueInRange > -1) {
    for (let i = firstCueInRange, len = cues.length; i < len; i++) {
      const cue = cues[i];
      if (cue.startTime >= start2 && cue.endTime <= end) {
        cuesFound.push(cue);
      } else if (cue.startTime > end) {
        return cuesFound;
      }
    }
  }
  return cuesFound;
}
var MetadataSchema = {
  audioId3: "org.id3",
  dateRange: "com.apple.quicktime.HLS",
  emsg: "https://aomedia.org/emsg/ID3"
};
var MIN_CUE_DURATION = 0.25;
function getCueClass() {
  if (typeof self === "undefined") return void 0;
  return self.WebKitDataCue || self.VTTCue || self.TextTrackCue;
}
var MAX_CUE_ENDTIME = (() => {
  const Cue = getCueClass();
  try {
    new Cue(0, Number.POSITIVE_INFINITY, "");
  } catch (e) {
    return Number.MAX_VALUE;
  }
  return Number.POSITIVE_INFINITY;
})();
function dateRangeDateToTimelineSeconds(date, offset) {
  return date.getTime() / 1e3 - offset;
}
function hexToArrayBuffer(str) {
  return Uint8Array.from(str.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer;
}
var ID3TrackController = class {
  constructor(hls) {
    this.hls = void 0;
    this.id3Track = null;
    this.media = null;
    this.dateRangeCuesAppended = {};
    this.hls = hls;
    this._registerListeners();
  }
  destroy() {
    this._unregisterListeners();
    this.id3Track = null;
    this.media = null;
    this.dateRangeCuesAppended = {};
    this.hls = null;
  }
  _registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
  }
  _unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
  }
  // Add ID3 metatadata text track.
  onMediaAttached(event, data) {
    this.media = data.media;
  }
  onMediaDetaching() {
    if (!this.id3Track) {
      return;
    }
    clearCurrentCues(this.id3Track);
    this.id3Track = null;
    this.media = null;
    this.dateRangeCuesAppended = {};
  }
  onManifestLoading() {
    this.dateRangeCuesAppended = {};
  }
  createTrack(media) {
    const track = this.getID3Track(media.textTracks);
    track.mode = "hidden";
    return track;
  }
  getID3Track(textTracks) {
    if (!this.media) {
      return;
    }
    for (let i = 0; i < textTracks.length; i++) {
      const textTrack = textTracks[i];
      if (textTrack.kind === "metadata" && textTrack.label === "id3") {
        sendAddTrackEvent(textTrack, this.media);
        return textTrack;
      }
    }
    return this.media.addTextTrack("metadata", "id3");
  }
  onFragParsingMetadata(event, data) {
    if (!this.media) {
      return;
    }
    const {
      hls: {
        config: {
          enableEmsgMetadataCues,
          enableID3MetadataCues
        }
      }
    } = this;
    if (!enableEmsgMetadataCues && !enableID3MetadataCues) {
      return;
    }
    const {
      samples
    } = data;
    if (!this.id3Track) {
      this.id3Track = this.createTrack(this.media);
    }
    const Cue = getCueClass();
    for (let i = 0; i < samples.length; i++) {
      const type2 = samples[i].type;
      if (type2 === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {
        continue;
      }
      const frames = getID3Frames(samples[i].data);
      if (frames) {
        const startTime = samples[i].pts;
        let endTime = startTime + samples[i].duration;
        if (endTime > MAX_CUE_ENDTIME) {
          endTime = MAX_CUE_ENDTIME;
        }
        const timeDiff = endTime - startTime;
        if (timeDiff <= 0) {
          endTime = startTime + MIN_CUE_DURATION;
        }
        for (let j = 0; j < frames.length; j++) {
          const frame = frames[j];
          if (!isTimeStampFrame(frame)) {
            this.updateId3CueEnds(startTime, type2);
            const cue = new Cue(startTime, endTime, "");
            cue.value = frame;
            if (type2) {
              cue.type = type2;
            }
            this.id3Track.addCue(cue);
          }
        }
      }
    }
  }
  updateId3CueEnds(startTime, type2) {
    var _this$id3Track;
    const cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;
    if (cues) {
      for (let i = cues.length; i--; ) {
        const cue = cues[i];
        if (cue.type === type2 && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {
          cue.endTime = startTime;
        }
      }
    }
  }
  onBufferFlushing(event, {
    startOffset,
    endOffset,
    type: type2
  }) {
    const {
      id3Track,
      hls
    } = this;
    if (!hls) {
      return;
    }
    const {
      config: {
        enableEmsgMetadataCues,
        enableID3MetadataCues
      }
    } = hls;
    if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {
      let predicate;
      if (type2 === "audio") {
        predicate = (cue) => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;
      } else if (type2 === "video") {
        predicate = (cue) => cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;
      } else {
        predicate = (cue) => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;
      }
      removeCuesInRange(id3Track, startOffset, endOffset, predicate);
    }
  }
  onLevelUpdated(event, {
    details
  }) {
    if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {
      return;
    }
    const {
      dateRangeCuesAppended,
      id3Track
    } = this;
    const {
      dateRanges
    } = details;
    const ids = Object.keys(dateRanges);
    if (id3Track) {
      const idsToRemove = Object.keys(dateRangeCuesAppended).filter((id) => !ids.includes(id));
      for (let i = idsToRemove.length; i--; ) {
        const id = idsToRemove[i];
        Object.keys(dateRangeCuesAppended[id].cues).forEach((key) => {
          id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);
        });
        delete dateRangeCuesAppended[id];
      }
    }
    const lastFragment = details.fragments[details.fragments.length - 1];
    if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {
      return;
    }
    if (!this.id3Track) {
      this.id3Track = this.createTrack(this.media);
    }
    const dateTimeOffset = lastFragment.programDateTime / 1e3 - lastFragment.start;
    const Cue = getCueClass();
    for (let i = 0; i < ids.length; i++) {
      const id = ids[i];
      const dateRange = dateRanges[id];
      const appendedDateRangeCues = dateRangeCuesAppended[id];
      const cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};
      let durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;
      const startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);
      let endTime = MAX_CUE_ENDTIME;
      const endDate = dateRange.endDate;
      if (endDate) {
        endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);
        durationKnown = true;
      } else if (dateRange.endOnNext && !durationKnown) {
        const nextDateRangeWithSameClass = ids.reduce((filterMapArray, id2) => {
          const candidate = dateRanges[id2];
          if (candidate.class === dateRange.class && candidate.id !== id2 && candidate.startDate > dateRange.startDate) {
            filterMapArray.push(candidate);
          }
          return filterMapArray;
        }, []).sort((a, b) => a.startDate.getTime() - b.startDate.getTime())[0];
        if (nextDateRangeWithSameClass) {
          endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);
          durationKnown = true;
        }
      }
      const attributes = Object.keys(dateRange.attr);
      for (let j = 0; j < attributes.length; j++) {
        const key = attributes[j];
        if (!isDateRangeCueAttribute(key)) {
          continue;
        }
        let cue = cues[key];
        if (cue) {
          if (durationKnown && !appendedDateRangeCues.durationKnown) {
            cue.endTime = endTime;
          }
        } else {
          let data = dateRange.attr[key];
          cue = new Cue(startTime, endTime, "");
          if (isSCTE35Attribute(key)) {
            data = hexToArrayBuffer(data);
          }
          cue.value = {
            key,
            data
          };
          cue.type = MetadataSchema.dateRange;
          cue.id = id;
          this.id3Track.addCue(cue);
          cues[key] = cue;
        }
      }
      dateRangeCuesAppended[id] = {
        cues,
        dateRange,
        durationKnown
      };
    }
  }
};
var LatencyController = class {
  constructor(hls) {
    this.hls = void 0;
    this.config = void 0;
    this.media = null;
    this.levelDetails = null;
    this.currentTime = 0;
    this.stallCount = 0;
    this._latency = null;
    this.timeupdateHandler = () => this.timeupdate();
    this.hls = hls;
    this.config = hls.config;
    this.registerListeners();
  }
  get latency() {
    return this._latency || 0;
  }
  get maxLatency() {
    const {
      config,
      levelDetails
    } = this;
    if (config.liveMaxLatencyDuration !== void 0) {
      return config.liveMaxLatencyDuration;
    }
    return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;
  }
  get targetLatency() {
    const {
      levelDetails
    } = this;
    if (levelDetails === null) {
      return null;
    }
    const {
      holdBack,
      partHoldBack,
      targetduration
    } = levelDetails;
    const {
      liveSyncDuration,
      liveSyncDurationCount,
      lowLatencyMode
    } = this.config;
    const userConfig = this.hls.userConfig;
    let targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;
    if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {
      targetLatency = liveSyncDuration !== void 0 ? liveSyncDuration : liveSyncDurationCount * targetduration;
    }
    const maxLiveSyncOnStallIncrease = targetduration;
    const liveSyncOnStallIncrease = 1;
    return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);
  }
  get liveSyncPosition() {
    const liveEdge = this.estimateLiveEdge();
    const targetLatency = this.targetLatency;
    const levelDetails = this.levelDetails;
    if (liveEdge === null || targetLatency === null || levelDetails === null) {
      return null;
    }
    const edge = levelDetails.edge;
    const syncPosition = liveEdge - targetLatency - this.edgeStalled;
    const min = edge - levelDetails.totalduration;
    const max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);
    return Math.min(Math.max(min, syncPosition), max);
  }
  get drift() {
    const {
      levelDetails
    } = this;
    if (levelDetails === null) {
      return 1;
    }
    return levelDetails.drift;
  }
  get edgeStalled() {
    const {
      levelDetails
    } = this;
    if (levelDetails === null) {
      return 0;
    }
    const maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;
    return Math.max(levelDetails.age - maxLevelUpdateAge, 0);
  }
  get forwardBufferLength() {
    const {
      media,
      levelDetails
    } = this;
    if (!media || !levelDetails) {
      return 0;
    }
    const bufferedRanges = media.buffered.length;
    return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;
  }
  destroy() {
    this.unregisterListeners();
    this.onMediaDetaching();
    this.levelDetails = null;
    this.hls = this.timeupdateHandler = null;
  }
  registerListeners() {
    this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    this.hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
    this.hls.on(Events.ERROR, this.onError, this);
  }
  unregisterListeners() {
    this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    this.hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
    this.hls.off(Events.ERROR, this.onError, this);
  }
  onMediaAttached(event, data) {
    this.media = data.media;
    this.media.addEventListener("timeupdate", this.timeupdateHandler);
  }
  onMediaDetaching() {
    if (this.media) {
      this.media.removeEventListener("timeupdate", this.timeupdateHandler);
      this.media = null;
    }
  }
  onManifestLoading() {
    this.levelDetails = null;
    this._latency = null;
    this.stallCount = 0;
  }
  onLevelUpdated(event, {
    details
  }) {
    this.levelDetails = details;
    if (details.advanced) {
      this.timeupdate();
    }
    if (!details.live && this.media) {
      this.media.removeEventListener("timeupdate", this.timeupdateHandler);
    }
  }
  onError(event, data) {
    var _this$levelDetails;
    if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {
      return;
    }
    this.stallCount++;
    if ((_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {
      logger.warn("[playback-rate-controller]: Stall detected, adjusting target latency");
    }
  }
  timeupdate() {
    const {
      media,
      levelDetails
    } = this;
    if (!media || !levelDetails) {
      return;
    }
    this.currentTime = media.currentTime;
    const latency = this.computeLatency();
    if (latency === null) {
      return;
    }
    this._latency = latency;
    const {
      lowLatencyMode,
      maxLiveSyncPlaybackRate
    } = this.config;
    if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1) {
      return;
    }
    const targetLatency = this.targetLatency;
    if (targetLatency === null) {
      return;
    }
    const distanceFromTarget = latency - targetLatency;
    const liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);
    const inLiveRange = distanceFromTarget < liveMinLatencyDuration;
    if (levelDetails.live && inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {
      const max = Math.min(2, Math.max(1, maxLiveSyncPlaybackRate));
      const rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;
      media.playbackRate = Math.min(max, Math.max(1, rate));
    } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {
      media.playbackRate = 1;
    }
  }
  estimateLiveEdge() {
    const {
      levelDetails
    } = this;
    if (levelDetails === null) {
      return null;
    }
    return levelDetails.edge + levelDetails.age;
  }
  computeLatency() {
    const liveEdge = this.estimateLiveEdge();
    if (liveEdge === null) {
      return null;
    }
    return liveEdge - this.currentTime;
  }
};
var HdcpLevels = ["NONE", "TYPE-0", "TYPE-1", null];
var HlsSkip = {
  No: "",
  Yes: "YES",
  v2: "v2"
};
function getSkipValue(details, msn) {
  const {
    canSkipUntil,
    canSkipDateRanges,
    endSN
  } = details;
  const snChangeGoal = msn !== void 0 ? msn - endSN : 0;
  if (canSkipUntil && snChangeGoal < canSkipUntil) {
    if (canSkipDateRanges) {
      return HlsSkip.v2;
    }
    return HlsSkip.Yes;
  }
  return HlsSkip.No;
}
var HlsUrlParameters = class {
  constructor(msn, part, skip) {
    this.msn = void 0;
    this.part = void 0;
    this.skip = void 0;
    this.msn = msn;
    this.part = part;
    this.skip = skip;
  }
  addDirectives(uri) {
    const url = new self.URL(uri);
    if (this.msn !== void 0) {
      url.searchParams.set("_HLS_msn", this.msn.toString());
    }
    if (this.part !== void 0) {
      url.searchParams.set("_HLS_part", this.part.toString());
    }
    if (this.skip) {
      url.searchParams.set("_HLS_skip", this.skip);
    }
    return url.href;
  }
};
var Level = class {
  constructor(data) {
    this._attrs = void 0;
    this.audioCodec = void 0;
    this.bitrate = void 0;
    this.codecSet = void 0;
    this.height = void 0;
    this.id = void 0;
    this.name = void 0;
    this.videoCodec = void 0;
    this.width = void 0;
    this.unknownCodecs = void 0;
    this.audioGroupIds = void 0;
    this.details = void 0;
    this.fragmentError = 0;
    this.loadError = 0;
    this.loaded = void 0;
    this.realBitrate = 0;
    this.textGroupIds = void 0;
    this.url = void 0;
    this._urlId = 0;
    this.url = [data.url];
    this._attrs = [data.attrs];
    this.bitrate = data.bitrate;
    if (data.details) {
      this.details = data.details;
    }
    this.id = data.id || 0;
    this.name = data.name;
    this.width = data.width || 0;
    this.height = data.height || 0;
    this.audioCodec = data.audioCodec;
    this.videoCodec = data.videoCodec;
    this.unknownCodecs = data.unknownCodecs;
    this.codecSet = [data.videoCodec, data.audioCodec].filter((c) => c).join(",").replace(/\.[^.,]+/g, "");
  }
  get maxBitrate() {
    return Math.max(this.realBitrate, this.bitrate);
  }
  get attrs() {
    return this._attrs[this._urlId];
  }
  get pathwayId() {
    return this.attrs["PATHWAY-ID"] || ".";
  }
  get uri() {
    return this.url[this._urlId] || "";
  }
  get urlId() {
    return this._urlId;
  }
  set urlId(value) {
    const newValue = value % this.url.length;
    if (this._urlId !== newValue) {
      this.fragmentError = 0;
      this.loadError = 0;
      this.details = void 0;
      this._urlId = newValue;
    }
  }
  get audioGroupId() {
    var _this$audioGroupIds;
    return (_this$audioGroupIds = this.audioGroupIds) == null ? void 0 : _this$audioGroupIds[this.urlId];
  }
  get textGroupId() {
    var _this$textGroupIds;
    return (_this$textGroupIds = this.textGroupIds) == null ? void 0 : _this$textGroupIds[this.urlId];
  }
  addFallback(data) {
    this.url.push(data.url);
    this._attrs.push(data.attrs);
  }
};
function updateFromToPTS(fragFrom, fragTo) {
  const fragToPTS = fragTo.startPTS;
  if (isFiniteNumber(fragToPTS)) {
    let duration5 = 0;
    let frag;
    if (fragTo.sn > fragFrom.sn) {
      duration5 = fragToPTS - fragFrom.start;
      frag = fragFrom;
    } else {
      duration5 = fragFrom.start - fragToPTS;
      frag = fragTo;
    }
    if (frag.duration !== duration5) {
      frag.duration = duration5;
    }
  } else if (fragTo.sn > fragFrom.sn) {
    const contiguous = fragFrom.cc === fragTo.cc;
    if (contiguous && fragFrom.minEndPTS) {
      fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);
    } else {
      fragTo.start = fragFrom.start + fragFrom.duration;
    }
  } else {
    fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
  }
}
function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
  const parsedMediaDuration = endPTS - startPTS;
  if (parsedMediaDuration <= 0) {
    logger.warn("Fragment should have a positive duration", frag);
    endPTS = startPTS + frag.duration;
    endDTS = startDTS + frag.duration;
  }
  let maxStartPTS = startPTS;
  let minEndPTS = endPTS;
  const fragStartPts = frag.startPTS;
  const fragEndPts = frag.endPTS;
  if (isFiniteNumber(fragStartPts)) {
    const deltaPTS = Math.abs(fragStartPts - startPTS);
    if (!isFiniteNumber(frag.deltaPTS)) {
      frag.deltaPTS = deltaPTS;
    } else {
      frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
    }
    maxStartPTS = Math.max(startPTS, fragStartPts);
    startPTS = Math.min(startPTS, fragStartPts);
    startDTS = Math.min(startDTS, frag.startDTS);
    minEndPTS = Math.min(endPTS, fragEndPts);
    endPTS = Math.max(endPTS, fragEndPts);
    endDTS = Math.max(endDTS, frag.endDTS);
  }
  const drift = startPTS - frag.start;
  if (frag.start !== 0) {
    frag.start = startPTS;
  }
  frag.duration = endPTS - frag.start;
  frag.startPTS = startPTS;
  frag.maxStartPTS = maxStartPTS;
  frag.startDTS = startDTS;
  frag.endPTS = endPTS;
  frag.minEndPTS = minEndPTS;
  frag.endDTS = endDTS;
  const sn = frag.sn;
  if (!details || sn < details.startSN || sn > details.endSN) {
    return 0;
  }
  let i;
  const fragIdx = sn - details.startSN;
  const fragments = details.fragments;
  fragments[fragIdx] = frag;
  for (i = fragIdx; i > 0; i--) {
    updateFromToPTS(fragments[i], fragments[i - 1]);
  }
  for (i = fragIdx; i < fragments.length - 1; i++) {
    updateFromToPTS(fragments[i], fragments[i + 1]);
  }
  if (details.fragmentHint) {
    updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);
  }
  details.PTSKnown = details.alignedSliding = true;
  return drift;
}
function mergeDetails(oldDetails, newDetails) {
  let currentInitSegment = null;
  const oldFragments = oldDetails.fragments;
  for (let i = oldFragments.length - 1; i >= 0; i--) {
    const oldInit = oldFragments[i].initSegment;
    if (oldInit) {
      currentInitSegment = oldInit;
      break;
    }
  }
  if (oldDetails.fragmentHint) {
    delete oldDetails.fragmentHint.endPTS;
  }
  let ccOffset = 0;
  let PTSFrag;
  mapFragmentIntersection(oldDetails, newDetails, (oldFrag, newFrag) => {
    if (oldFrag.relurl) {
      ccOffset = oldFrag.cc - newFrag.cc;
    }
    if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {
      newFrag.start = newFrag.startPTS = oldFrag.startPTS;
      newFrag.startDTS = oldFrag.startDTS;
      newFrag.maxStartPTS = oldFrag.maxStartPTS;
      newFrag.endPTS = oldFrag.endPTS;
      newFrag.endDTS = oldFrag.endDTS;
      newFrag.minEndPTS = oldFrag.minEndPTS;
      newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;
      if (newFrag.duration) {
        PTSFrag = newFrag;
      }
      newDetails.PTSKnown = newDetails.alignedSliding = true;
    }
    newFrag.elementaryStreams = oldFrag.elementaryStreams;
    newFrag.loader = oldFrag.loader;
    newFrag.stats = oldFrag.stats;
    newFrag.urlId = oldFrag.urlId;
    if (oldFrag.initSegment) {
      newFrag.initSegment = oldFrag.initSegment;
      currentInitSegment = oldFrag.initSegment;
    }
  });
  if (currentInitSegment) {
    const fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
    fragmentsToCheck.forEach((frag) => {
      var _currentInitSegment;
      if (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl)) {
        frag.initSegment = currentInitSegment;
      }
    });
  }
  if (newDetails.skippedSegments) {
    newDetails.deltaUpdateFailed = newDetails.fragments.some((frag) => !frag);
    if (newDetails.deltaUpdateFailed) {
      logger.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
      for (let i = newDetails.skippedSegments; i--; ) {
        newDetails.fragments.shift();
      }
      newDetails.startSN = newDetails.fragments[0].sn;
      newDetails.startCC = newDetails.fragments[0].cc;
    } else if (newDetails.canSkipDateRanges) {
      newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);
    }
  }
  const newFragments = newDetails.fragments;
  if (ccOffset) {
    logger.warn("discontinuity sliding from playlist, take drift into account");
    for (let i = 0; i < newFragments.length; i++) {
      newFragments[i].cc += ccOffset;
    }
  }
  if (newDetails.skippedSegments) {
    newDetails.startCC = newDetails.fragments[0].cc;
  }
  mapPartIntersection(oldDetails.partList, newDetails.partList, (oldPart, newPart) => {
    newPart.elementaryStreams = oldPart.elementaryStreams;
    newPart.stats = oldPart.stats;
  });
  if (PTSFrag) {
    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
  } else {
    adjustSliding(oldDetails, newDetails);
  }
  if (newFragments.length) {
    newDetails.totalduration = newDetails.edge - newFragments[0].start;
  }
  newDetails.driftStartTime = oldDetails.driftStartTime;
  newDetails.driftStart = oldDetails.driftStart;
  const advancedDateTime = newDetails.advancedDateTime;
  if (newDetails.advanced && advancedDateTime) {
    const edge = newDetails.edge;
    if (!newDetails.driftStart) {
      newDetails.driftStartTime = advancedDateTime;
      newDetails.driftStart = edge;
    }
    newDetails.driftEndTime = advancedDateTime;
    newDetails.driftEnd = edge;
  } else {
    newDetails.driftEndTime = oldDetails.driftEndTime;
    newDetails.driftEnd = oldDetails.driftEnd;
    newDetails.advancedDateTime = oldDetails.advancedDateTime;
  }
}
function mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {
  const dateRanges = _extends({}, oldDateRanges);
  if (recentlyRemovedDateranges) {
    recentlyRemovedDateranges.forEach((id) => {
      delete dateRanges[id];
    });
  }
  Object.keys(deltaDateRanges).forEach((id) => {
    const dateRange = new DateRange(deltaDateRanges[id].attr, dateRanges[id]);
    if (dateRange.isValid) {
      dateRanges[id] = dateRange;
    } else {
      logger.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${JSON.stringify(deltaDateRanges[id].attr)}"`);
    }
  });
  return dateRanges;
}
function mapPartIntersection(oldParts, newParts, intersectionFn) {
  if (oldParts && newParts) {
    let delta = 0;
    for (let i = 0, len = oldParts.length; i <= len; i++) {
      const oldPart = oldParts[i];
      const newPart = newParts[i + delta];
      if (oldPart && newPart && oldPart.index === newPart.index && oldPart.fragment.sn === newPart.fragment.sn) {
        intersectionFn(oldPart, newPart);
      } else {
        delta--;
      }
    }
  }
}
function mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {
  const skippedSegments = newDetails.skippedSegments;
  const start2 = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;
  const end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;
  const delta = newDetails.startSN - oldDetails.startSN;
  const newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
  const oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;
  for (let i = start2; i <= end; i++) {
    const oldFrag = oldFrags[delta + i];
    let newFrag = newFrags[i];
    if (skippedSegments && !newFrag && i < skippedSegments) {
      newFrag = newDetails.fragments[i] = oldFrag;
    }
    if (oldFrag && newFrag) {
      intersectionFn(oldFrag, newFrag);
    }
  }
}
function adjustSliding(oldDetails, newDetails) {
  const delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;
  const oldFragments = oldDetails.fragments;
  if (delta < 0 || delta >= oldFragments.length) {
    return;
  }
  addSliding(newDetails, oldFragments[delta].start);
}
function addSliding(details, start2) {
  if (start2) {
    const fragments = details.fragments;
    for (let i = details.skippedSegments; i < fragments.length; i++) {
      fragments[i].start += start2;
    }
    if (details.fragmentHint) {
      details.fragmentHint.start += start2;
    }
  }
}
function computeReloadInterval(newDetails, distanceToLiveEdgeMs = Infinity) {
  let reloadInterval = 1e3 * newDetails.targetduration;
  if (newDetails.updated) {
    const fragments = newDetails.fragments;
    const liveEdgeMaxTargetDurations = 4;
    if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {
      const lastSegmentDuration = fragments[fragments.length - 1].duration * 1e3;
      if (lastSegmentDuration < reloadInterval) {
        reloadInterval = lastSegmentDuration;
      }
    }
  } else {
    reloadInterval /= 2;
  }
  return Math.round(reloadInterval);
}
function getFragmentWithSN(level, sn, fragCurrent) {
  if (!(level != null && level.details)) {
    return null;
  }
  const levelDetails = level.details;
  let fragment = levelDetails.fragments[sn - levelDetails.startSN];
  if (fragment) {
    return fragment;
  }
  fragment = levelDetails.fragmentHint;
  if (fragment && fragment.sn === sn) {
    return fragment;
  }
  if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {
    return fragCurrent;
  }
  return null;
}
function getPartWith(level, sn, partIndex) {
  var _level$details;
  if (!(level != null && level.details)) {
    return null;
  }
  return findPart((_level$details = level.details) == null ? void 0 : _level$details.partList, sn, partIndex);
}
function findPart(partList, sn, partIndex) {
  if (partList) {
    for (let i = partList.length; i--; ) {
      const part = partList[i];
      if (part.index === partIndex && part.fragment.sn === sn) {
        return part;
      }
    }
  }
  return null;
}
function isTimeoutError(error) {
  switch (error.details) {
    case ErrorDetails.FRAG_LOAD_TIMEOUT:
    case ErrorDetails.KEY_LOAD_TIMEOUT:
    case ErrorDetails.LEVEL_LOAD_TIMEOUT:
    case ErrorDetails.MANIFEST_LOAD_TIMEOUT:
      return true;
  }
  return false;
}
function getRetryConfig(loadPolicy, error) {
  const isTimeout = isTimeoutError(error);
  return loadPolicy.default[`${isTimeout ? "timeout" : "error"}Retry`];
}
function getRetryDelay(retryConfig, retryCount) {
  const backoffFactor = retryConfig.backoff === "linear" ? 1 : Math.pow(2, retryCount);
  return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);
}
function getLoaderConfigWithoutReties(loderConfig) {
  return _objectSpread2(_objectSpread2({}, loderConfig), {
    errorRetry: null,
    timeoutRetry: null
  });
}
function shouldRetry(retryConfig, retryCount, isTimeout, httpStatus) {
  return !!retryConfig && retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);
}
function retryForHttpStatus(httpStatus) {
  return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);
}
var BinarySearch = {
  /**
   * Searches for an item in an array which matches a certain condition.
   * This requires the condition to only match one item in the array,
   * and for the array to be ordered.
   *
   * @param list The array to search.
   * @param comparisonFn
   *      Called and provided a candidate item as the first argument.
   *      Should return:
   *          > -1 if the item should be located at a lower index than the provided item.
   *          > 1 if the item should be located at a higher index than the provided item.
   *          > 0 if the item is the item you're looking for.
   *
   * @returns the object if found, otherwise returns null
   */
  search: function(list, comparisonFn) {
    let minIndex = 0;
    let maxIndex = list.length - 1;
    let currentIndex = null;
    let currentElement = null;
    while (minIndex <= maxIndex) {
      currentIndex = (minIndex + maxIndex) / 2 | 0;
      currentElement = list[currentIndex];
      const comparisonResult = comparisonFn(currentElement);
      if (comparisonResult > 0) {
        minIndex = currentIndex + 1;
      } else if (comparisonResult < 0) {
        maxIndex = currentIndex - 1;
      } else {
        return currentElement;
      }
    }
    return null;
  }
};
function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
  if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {
    return null;
  }
  const startPDT = fragments[0].programDateTime;
  if (PDTValue < (startPDT || 0)) {
    return null;
  }
  const endPDT = fragments[fragments.length - 1].endProgramDateTime;
  if (PDTValue >= (endPDT || 0)) {
    return null;
  }
  maxFragLookUpTolerance = maxFragLookUpTolerance || 0;
  for (let seg = 0; seg < fragments.length; ++seg) {
    const frag = fragments[seg];
    if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
      return frag;
    }
  }
  return null;
}
function findFragmentByPTS(fragPrevious, fragments, bufferEnd = 0, maxFragLookUpTolerance = 0) {
  let fragNext = null;
  if (fragPrevious) {
    fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;
  } else if (bufferEnd === 0 && fragments[0].start === 0) {
    fragNext = fragments[0];
  }
  if (fragNext && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0) {
    return fragNext;
  }
  const foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));
  if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {
    return foundFragment;
  }
  return fragNext;
}
function fragmentWithinToleranceTest(bufferEnd = 0, maxFragLookUpTolerance = 0, candidate) {
  if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {
    return 0;
  }
  const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
    return 1;
  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
    return -1;
  }
  return 0;
}
function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
  const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1e3;
  const endProgramDateTime = candidate.endProgramDateTime || 0;
  return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
}
function findFragWithCC(fragments, cc) {
  return BinarySearch.search(fragments, (candidate) => {
    if (candidate.cc < cc) {
      return 1;
    } else if (candidate.cc > cc) {
      return -1;
    } else {
      return 0;
    }
  });
}
var RENDITION_PENALTY_DURATION_MS = 3e5;
var NetworkErrorAction = {
  DoNothing: 0,
  SendEndCallback: 1,
  SendAlternateToPenaltyBox: 2,
  RemoveAlternatePermanently: 3,
  InsertDiscontinuity: 4,
  RetryRequest: 5
};
var ErrorActionFlags = {
  None: 0,
  MoveAllAlternatesMatchingHost: 1,
  MoveAllAlternatesMatchingHDCP: 2,
  SwitchToSDR: 4
};
var ErrorController = class {
  constructor(hls) {
    this.hls = void 0;
    this.playlistError = 0;
    this.penalizedRenditions = {};
    this.log = void 0;
    this.warn = void 0;
    this.error = void 0;
    this.hls = hls;
    this.log = logger.log.bind(logger, `[info]:`);
    this.warn = logger.warn.bind(logger, `[warning]:`);
    this.error = logger.error.bind(logger, `[error]:`);
    this.registerListeners();
  }
  registerListeners() {
    const hls = this.hls;
    hls.on(Events.ERROR, this.onError, this);
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
  }
  unregisterListeners() {
    const hls = this.hls;
    if (!hls) {
      return;
    }
    hls.off(Events.ERROR, this.onError, this);
    hls.off(Events.ERROR, this.onErrorOut, this);
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
  }
  destroy() {
    this.unregisterListeners();
    this.hls = null;
    this.penalizedRenditions = {};
  }
  startLoad(startPosition) {
    this.playlistError = 0;
  }
  stopLoad() {
  }
  getVariantLevelIndex(frag) {
    return (frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;
  }
  onManifestLoading() {
    this.playlistError = 0;
    this.penalizedRenditions = {};
  }
  onLevelUpdated() {
    this.playlistError = 0;
  }
  onError(event, data) {
    var _data$frag, _data$level;
    if (data.fatal) {
      return;
    }
    const hls = this.hls;
    const context = data.context;
    switch (data.details) {
      case ErrorDetails.FRAG_LOAD_ERROR:
      case ErrorDetails.FRAG_LOAD_TIMEOUT:
      case ErrorDetails.KEY_LOAD_ERROR:
      case ErrorDetails.KEY_LOAD_TIMEOUT:
        data.errorAction = this.getFragRetryOrSwitchAction(data);
        return;
      case ErrorDetails.FRAG_PARSING_ERROR:
        if ((_data$frag = data.frag) != null && _data$frag.gap) {
          data.errorAction = {
            action: NetworkErrorAction.DoNothing,
            flags: ErrorActionFlags.None
          };
          return;
        }
      case ErrorDetails.FRAG_GAP:
      case ErrorDetails.FRAG_DECRYPT_ERROR: {
        data.errorAction = this.getFragRetryOrSwitchAction(data);
        data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;
        return;
      }
      case ErrorDetails.LEVEL_EMPTY_ERROR:
      case ErrorDetails.LEVEL_PARSING_ERROR:
        {
          var _data$context, _data$context$levelDe;
          const levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;
          if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {
            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);
          } else {
            data.levelRetry = false;
            data.errorAction = this.getLevelSwitchAction(data, levelIndex);
          }
        }
        return;
      case ErrorDetails.LEVEL_LOAD_ERROR:
      case ErrorDetails.LEVEL_LOAD_TIMEOUT:
        if (typeof (context == null ? void 0 : context.level) === "number") {
          data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);
        }
        return;
      case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
      case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
      case ErrorDetails.SUBTITLE_LOAD_ERROR:
      case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:
        if (context) {
          const level = hls.levels[hls.loadLevel];
          if (level && (context.type === PlaylistContextType.AUDIO_TRACK && context.groupId === level.audioGroupId || context.type === PlaylistContextType.SUBTITLE_TRACK && context.groupId === level.textGroupId)) {
            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);
            data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;
            data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;
            return;
          }
        }
        return;
      case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
        {
          const level = hls.levels[hls.loadLevel];
          const restrictedHdcpLevel = level == null ? void 0 : level.attrs["HDCP-LEVEL"];
          if (restrictedHdcpLevel) {
            data.errorAction = {
              action: NetworkErrorAction.SendAlternateToPenaltyBox,
              flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,
              hdcpLevel: restrictedHdcpLevel
            };
          }
        }
        return;
      case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
      case ErrorDetails.REMUX_ALLOC_ERROR:
        data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);
        return;
      case ErrorDetails.INTERNAL_EXCEPTION:
      case ErrorDetails.BUFFER_APPENDING_ERROR:
      case ErrorDetails.BUFFER_APPEND_ERROR:
      case ErrorDetails.BUFFER_FULL_ERROR:
      case ErrorDetails.LEVEL_SWITCH_ERROR:
      case ErrorDetails.BUFFER_STALLED_ERROR:
      case ErrorDetails.BUFFER_SEEK_OVER_HOLE:
      case ErrorDetails.BUFFER_NUDGE_ON_STALL:
        data.errorAction = {
          action: NetworkErrorAction.DoNothing,
          flags: ErrorActionFlags.None
        };
        return;
    }
    if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {
      const levelIndex = this.getVariantLevelIndex(data.frag);
      data.levelRetry = false;
      data.errorAction = this.getLevelSwitchAction(data, levelIndex);
      return;
    }
  }
  getPlaylistRetryOrSwitchAction(data, levelIndex) {
    var _data$response;
    const hls = this.hls;
    const retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);
    const retryCount = this.playlistError++;
    const httpStatus = (_data$response = data.response) == null ? void 0 : _data$response.code;
    const retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), httpStatus);
    if (retry) {
      return {
        action: NetworkErrorAction.RetryRequest,
        flags: ErrorActionFlags.None,
        retryConfig,
        retryCount
      };
    }
    const errorAction = this.getLevelSwitchAction(data, levelIndex);
    if (retryConfig) {
      errorAction.retryConfig = retryConfig;
      errorAction.retryCount = retryCount;
    }
    return errorAction;
  }
  getFragRetryOrSwitchAction(data) {
    const hls = this.hls;
    const variantLevelIndex = this.getVariantLevelIndex(data.frag);
    const level = hls.levels[variantLevelIndex];
    const {
      fragLoadPolicy,
      keyLoadPolicy
    } = hls.config;
    const retryConfig = getRetryConfig(data.details.startsWith("key") ? keyLoadPolicy : fragLoadPolicy, data);
    const fragmentErrors = hls.levels.reduce((acc, level2) => acc + level2.fragmentError, 0);
    if (level) {
      var _data$response2;
      if (data.details !== ErrorDetails.FRAG_GAP) {
        level.fragmentError++;
      }
      const httpStatus = (_data$response2 = data.response) == null ? void 0 : _data$response2.code;
      const retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), httpStatus);
      if (retry) {
        return {
          action: NetworkErrorAction.RetryRequest,
          flags: ErrorActionFlags.None,
          retryConfig,
          retryCount: fragmentErrors
        };
      }
    }
    const errorAction = this.getLevelSwitchAction(data, variantLevelIndex);
    if (retryConfig) {
      errorAction.retryConfig = retryConfig;
      errorAction.retryCount = fragmentErrors;
    }
    return errorAction;
  }
  getLevelSwitchAction(data, levelIndex) {
    const hls = this.hls;
    if (levelIndex === null || levelIndex === void 0) {
      levelIndex = hls.loadLevel;
    }
    const level = this.hls.levels[levelIndex];
    if (level) {
      level.loadError++;
      if (hls.autoLevelEnabled) {
        var _data$frag2, _data$context2;
        let nextLevel = -1;
        const {
          levels,
          loadLevel,
          minAutoLevel,
          maxAutoLevel
        } = hls;
        const fragErrorType = (_data$frag2 = data.frag) == null ? void 0 : _data$frag2.type;
        const {
          type: playlistErrorType,
          groupId: playlistErrorGroupId
        } = (_data$context2 = data.context) != null ? _data$context2 : {};
        for (let i = levels.length; i--; ) {
          const candidate = (i + loadLevel) % levels.length;
          if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {
            const levelCandidate = levels[candidate];
            if (data.details === ErrorDetails.FRAG_GAP && data.frag) {
              const levelDetails = levels[candidate].details;
              if (levelDetails) {
                const fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);
                if (fragCandidate != null && fragCandidate.gap) {
                  continue;
                }
              }
            } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && playlistErrorGroupId === levelCandidate.audioGroupId || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && playlistErrorGroupId === levelCandidate.textGroupId) {
              continue;
            } else if (fragErrorType === PlaylistLevelType.AUDIO && level.audioGroupId === levelCandidate.audioGroupId || fragErrorType === PlaylistLevelType.SUBTITLE && level.textGroupId === levelCandidate.textGroupId) {
              continue;
            }
            nextLevel = candidate;
            break;
          }
        }
        if (nextLevel > -1 && hls.loadLevel !== nextLevel) {
          data.levelRetry = true;
          this.playlistError = 0;
          return {
            action: NetworkErrorAction.SendAlternateToPenaltyBox,
            flags: ErrorActionFlags.None,
            nextAutoLevel: nextLevel
          };
        }
      }
    }
    return {
      action: NetworkErrorAction.SendAlternateToPenaltyBox,
      flags: ErrorActionFlags.MoveAllAlternatesMatchingHost
    };
  }
  onErrorOut(event, data) {
    var _data$errorAction;
    switch ((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action) {
      case NetworkErrorAction.DoNothing:
        break;
      case NetworkErrorAction.SendAlternateToPenaltyBox:
        this.sendAlternateToPenaltyBox(data);
        if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {
          data.fatal = true;
        }
        break;
    }
    if (data.fatal) {
      this.hls.stopLoad();
      return;
    }
  }
  sendAlternateToPenaltyBox(data) {
    const hls = this.hls;
    const errorAction = data.errorAction;
    if (!errorAction) {
      return;
    }
    const {
      flags,
      hdcpLevel,
      nextAutoLevel
    } = errorAction;
    switch (flags) {
      case ErrorActionFlags.None:
        this.switchLevel(data, nextAutoLevel);
        break;
      case ErrorActionFlags.MoveAllAlternatesMatchingHost:
        {
          if (!errorAction.resolved) {
            errorAction.resolved = this.redundantFailover(data);
          }
        }
        break;
      case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:
        if (hdcpLevel) {
          hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];
          errorAction.resolved = true;
        }
        this.warn(`Restricting playback to HDCP-LEVEL of "${hls.maxHdcpLevel}" or lower`);
        break;
    }
    if (!errorAction.resolved) {
      this.switchLevel(data, nextAutoLevel);
    }
  }
  switchLevel(data, levelIndex) {
    if (levelIndex !== void 0 && data.errorAction) {
      this.warn(`switching to level ${levelIndex} after ${data.details}`);
      this.hls.nextAutoLevel = levelIndex;
      data.errorAction.resolved = true;
      this.hls.nextLoadLevel = this.hls.nextAutoLevel;
    }
  }
  redundantFailover(data) {
    const {
      hls,
      penalizedRenditions
    } = this;
    const levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;
    const level = hls.levels[levelIndex];
    const redundantLevels = level.url.length;
    const errorUrlId = data.frag ? data.frag.urlId : level.urlId;
    if (level.urlId === errorUrlId && (!data.frag || level.details)) {
      this.penalizeRendition(level, data);
    }
    for (let i = 1; i < redundantLevels; i++) {
      const newUrlId = (errorUrlId + i) % redundantLevels;
      const penalizedRendition = penalizedRenditions[newUrlId];
      if (!penalizedRendition || checkExpired(penalizedRendition, data, penalizedRenditions[errorUrlId])) {
        this.warn(`Switching to Redundant Stream ${newUrlId + 1}/${redundantLevels}: "${level.url[newUrlId]}" after ${data.details}`);
        this.playlistError = 0;
        hls.levels.forEach((lv) => {
          lv.urlId = newUrlId;
        });
        hls.nextLoadLevel = levelIndex;
        return true;
      }
    }
    return false;
  }
  penalizeRendition(level, data) {
    const {
      penalizedRenditions
    } = this;
    const penalizedRendition = penalizedRenditions[level.urlId] || {
      lastErrorPerfMs: 0,
      errors: [],
      details: void 0
    };
    penalizedRendition.lastErrorPerfMs = performance.now();
    penalizedRendition.errors.push(data);
    penalizedRendition.details = level.details;
    penalizedRenditions[level.urlId] = penalizedRendition;
  }
};
function checkExpired(penalizedRendition, data, currentPenaltyState) {
  if (performance.now() - penalizedRendition.lastErrorPerfMs > RENDITION_PENALTY_DURATION_MS) {
    return true;
  }
  const lastErrorDetails = penalizedRendition.details;
  if (data.details === ErrorDetails.FRAG_GAP && lastErrorDetails && data.frag) {
    const position = data.frag.start;
    const candidateFrag = findFragmentByPTS(null, lastErrorDetails.fragments, position);
    if (candidateFrag && !candidateFrag.gap) {
      return true;
    }
  }
  if (currentPenaltyState && penalizedRendition.errors.length < currentPenaltyState.errors.length) {
    const lastCandidateError = penalizedRendition.errors[penalizedRendition.errors.length - 1];
    if (lastErrorDetails && lastCandidateError.frag && data.frag && Math.abs(lastCandidateError.frag.start - data.frag.start) > lastErrorDetails.targetduration * 3) {
      return true;
    }
  }
  return false;
}
var BasePlaylistController = class {
  constructor(hls, logPrefix) {
    this.hls = void 0;
    this.timer = -1;
    this.requestScheduled = -1;
    this.canLoad = false;
    this.log = void 0;
    this.warn = void 0;
    this.log = logger.log.bind(logger, `${logPrefix}:`);
    this.warn = logger.warn.bind(logger, `${logPrefix}:`);
    this.hls = hls;
  }
  destroy() {
    this.clearTimer();
    this.hls = this.log = this.warn = null;
  }
  clearTimer() {
    clearTimeout(this.timer);
    this.timer = -1;
  }
  startLoad() {
    this.canLoad = true;
    this.requestScheduled = -1;
    this.loadPlaylist();
  }
  stopLoad() {
    this.canLoad = false;
    this.clearTimer();
  }
  switchParams(playlistUri, previous) {
    const renditionReports = previous == null ? void 0 : previous.renditionReports;
    if (renditionReports) {
      let foundIndex = -1;
      for (let i = 0; i < renditionReports.length; i++) {
        const attr = renditionReports[i];
        let uri;
        try {
          uri = new self.URL(attr.URI, previous.url).href;
        } catch (error) {
          logger.warn(`Could not construct new URL for Rendition Report: ${error}`);
          uri = attr.URI || "";
        }
        if (uri === playlistUri) {
          foundIndex = i;
          break;
        } else if (uri === playlistUri.substring(0, uri.length)) {
          foundIndex = i;
        }
      }
      if (foundIndex !== -1) {
        const attr = renditionReports[foundIndex];
        const msn = parseInt(attr["LAST-MSN"]) || (previous == null ? void 0 : previous.lastPartSn);
        let part = parseInt(attr["LAST-PART"]) || (previous == null ? void 0 : previous.lastPartIndex);
        if (this.hls.config.lowLatencyMode) {
          const currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);
          if (part >= 0 && currentGoal > previous.partTarget) {
            part += 1;
          }
        }
        return new HlsUrlParameters(msn, part >= 0 ? part : void 0, HlsSkip.No);
      }
    }
  }
  loadPlaylist(hlsUrlParameters) {
    if (this.requestScheduled === -1) {
      this.requestScheduled = self.performance.now();
    }
  }
  shouldLoadPlaylist(playlist) {
    return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);
  }
  shouldReloadPlaylist(playlist) {
    return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(playlist);
  }
  playlistLoaded(index, data, previousDetails) {
    const {
      details,
      stats
    } = data;
    const now2 = self.performance.now();
    const elapsed = stats.loading.first ? Math.max(0, now2 - stats.loading.first) : 0;
    details.advancedDateTime = Date.now() - elapsed;
    if (details.live || previousDetails != null && previousDetails.live) {
      details.reloaded(previousDetails);
      if (previousDetails) {
        this.log(`live playlist ${index} ${details.advanced ? "REFRESHED " + details.lastPartSn + "-" + details.lastPartIndex : details.updated ? "UPDATED" : "MISSED"}`);
      }
      if (previousDetails && details.fragments.length > 0) {
        mergeDetails(previousDetails, details);
      }
      if (!this.canLoad || !details.live) {
        return;
      }
      let deliveryDirectives;
      let msn = void 0;
      let part = void 0;
      if (details.canBlockReload && details.endSN && details.advanced) {
        const lowLatencyMode = this.hls.config.lowLatencyMode;
        const lastPartSn = details.lastPartSn;
        const endSn = details.endSN;
        const lastPartIndex = details.lastPartIndex;
        const hasParts = lastPartIndex !== -1;
        const lastPart = lastPartSn === endSn;
        const nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;
        if (hasParts) {
          msn = lastPart ? endSn + 1 : lastPartSn;
          part = lastPart ? nextSnStartIndex : lastPartIndex + 1;
        } else {
          msn = endSn + 1;
        }
        const lastAdvanced = details.age;
        const cdnAge = lastAdvanced + details.ageHeader;
        let currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);
        if (currentGoal > 0) {
          if (previousDetails && currentGoal > previousDetails.tuneInGoal) {
            this.warn(`CDN Tune-in goal increased from: ${previousDetails.tuneInGoal} to: ${currentGoal} with playlist age: ${details.age}`);
            currentGoal = 0;
          } else {
            const segments = Math.floor(currentGoal / details.targetduration);
            msn += segments;
            if (part !== void 0) {
              const parts = Math.round(currentGoal % details.targetduration / details.partTarget);
              part += parts;
            }
            this.log(`CDN Tune-in age: ${details.ageHeader}s last advanced ${lastAdvanced.toFixed(2)}s goal: ${currentGoal} skip sn ${segments} to part ${part}`);
          }
          details.tuneInGoal = currentGoal;
        }
        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
        if (lowLatencyMode || !lastPart) {
          this.loadPlaylist(deliveryDirectives);
          return;
        }
      } else if (details.canBlockReload || details.canSkipUntil) {
        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
      }
      const bufferInfo = this.hls.mainForwardBufferInfo;
      const position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;
      const distanceToLiveEdgeMs = (details.edge - position) * 1e3;
      const reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);
      if (details.updated && now2 > this.requestScheduled + reloadInterval) {
        this.requestScheduled = stats.loading.start;
      }
      if (msn !== void 0 && details.canBlockReload) {
        this.requestScheduled = stats.loading.first + reloadInterval - (details.partTarget * 1e3 || 1e3);
      } else if (this.requestScheduled === -1 || this.requestScheduled + reloadInterval < now2) {
        this.requestScheduled = now2;
      } else if (this.requestScheduled - now2 <= 0) {
        this.requestScheduled += reloadInterval;
      }
      let estimatedTimeUntilUpdate = this.requestScheduled - now2;
      estimatedTimeUntilUpdate = Math.max(0, estimatedTimeUntilUpdate);
      this.log(`reload live playlist ${index} in ${Math.round(estimatedTimeUntilUpdate)} ms`);
      this.timer = self.setTimeout(() => this.loadPlaylist(deliveryDirectives), estimatedTimeUntilUpdate);
    } else {
      this.clearTimer();
    }
  }
  getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {
    let skip = getSkipValue(details, msn);
    if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {
      msn = previousDeliveryDirectives.msn;
      part = previousDeliveryDirectives.part;
      skip = HlsSkip.No;
    }
    return new HlsUrlParameters(msn, part, skip);
  }
  checkRetry(errorEvent) {
    const errorDetails = errorEvent.details;
    const isTimeout = isTimeoutError(errorEvent);
    const errorAction = errorEvent.errorAction;
    const {
      action,
      retryCount = 0,
      retryConfig
    } = errorAction || {};
    const retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);
    if (retry) {
      var _errorEvent$context;
      this.requestScheduled = -1;
      if (retryCount >= retryConfig.maxNumRetry) {
        return false;
      }
      if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {
        this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after "${errorDetails}" without delivery-directives`);
        this.loadPlaylist();
      } else {
        const delay = getRetryDelay(retryConfig, retryCount);
        this.timer = self.setTimeout(() => this.loadPlaylist(), delay);
        this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after "${errorDetails}" in ${delay}ms`);
      }
      errorEvent.levelRetry = true;
      errorAction.resolved = true;
    }
    return retry;
  }
};
var chromeOrFirefox;
var LevelController = class extends BasePlaylistController {
  constructor(hls, contentSteeringController) {
    super(hls, "[level-controller]");
    this._levels = [];
    this._firstLevel = -1;
    this._startLevel = void 0;
    this.currentLevel = null;
    this.currentLevelIndex = -1;
    this.manualLevelIndex = -1;
    this.steering = void 0;
    this.onParsedComplete = void 0;
    this.steering = contentSteeringController;
    this._registerListeners();
  }
  _registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
    hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
    hls.on(Events.ERROR, this.onError, this);
  }
  _unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
    hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
    hls.off(Events.ERROR, this.onError, this);
  }
  destroy() {
    this._unregisterListeners();
    this.steering = null;
    this.resetLevels();
    super.destroy();
  }
  startLoad() {
    const levels = this._levels;
    levels.forEach((level) => {
      level.loadError = 0;
      level.fragmentError = 0;
    });
    super.startLoad();
  }
  resetLevels() {
    this._startLevel = void 0;
    this.manualLevelIndex = -1;
    this.currentLevelIndex = -1;
    this.currentLevel = null;
    this._levels = [];
  }
  onManifestLoading(event, data) {
    this.resetLevels();
  }
  onManifestLoaded(event, data) {
    const levels = [];
    const levelSet = {};
    let levelFromSet;
    data.levels.forEach((levelParsed) => {
      var _levelParsed$audioCod;
      const attributes = levelParsed.attrs;
      if (((_levelParsed$audioCod = levelParsed.audioCodec) == null ? void 0 : _levelParsed$audioCod.indexOf("mp4a.40.34")) !== -1) {
        chromeOrFirefox || (chromeOrFirefox = /chrome|firefox/i.test(navigator.userAgent));
        if (chromeOrFirefox) {
          levelParsed.audioCodec = void 0;
        }
      }
      const {
        AUDIO: AUDIO5,
        CODECS,
        "FRAME-RATE": FRAMERATE,
        "PATHWAY-ID": PATHWAY,
        RESOLUTION,
        SUBTITLES: SUBTITLES5
      } = attributes;
      const contentSteeringPrefix = `${PATHWAY || "."}-`;
      const levelKey = `${contentSteeringPrefix}${levelParsed.bitrate}-${RESOLUTION}-${FRAMERATE}-${CODECS}`;
      levelFromSet = levelSet[levelKey];
      if (!levelFromSet) {
        levelFromSet = new Level(levelParsed);
        levelSet[levelKey] = levelFromSet;
        levels.push(levelFromSet);
      } else {
        levelFromSet.addFallback(levelParsed);
      }
      addGroupId(levelFromSet, "audio", AUDIO5);
      addGroupId(levelFromSet, "text", SUBTITLES5);
    });
    this.filterAndSortMediaOptions(levels, data);
  }
  filterAndSortMediaOptions(unfilteredLevels, data) {
    let audioTracks = [];
    let subtitleTracks = [];
    let resolutionFound = false;
    let videoCodecFound = false;
    let audioCodecFound = false;
    let levels = unfilteredLevels.filter(({
      audioCodec,
      videoCodec,
      width: width2,
      height: height2,
      unknownCodecs
    }) => {
      resolutionFound || (resolutionFound = !!(width2 && height2));
      videoCodecFound || (videoCodecFound = !!videoCodec);
      audioCodecFound || (audioCodecFound = !!audioCodec);
      return !(unknownCodecs != null && unknownCodecs.length) && (!audioCodec || isCodecSupportedInMp4(audioCodec, "audio")) && (!videoCodec || isCodecSupportedInMp4(videoCodec, "video"));
    });
    if ((resolutionFound || videoCodecFound) && audioCodecFound) {
      levels = levels.filter(({
        videoCodec,
        width: width2,
        height: height2
      }) => !!videoCodec || !!(width2 && height2));
    }
    if (levels.length === 0) {
      Promise.resolve().then(() => {
        if (this.hls) {
          const error = new Error("no level with compatible codecs found in manifest");
          this.hls.trigger(Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
            fatal: true,
            url: data.url,
            error,
            reason: error.message
          });
        }
      });
      return;
    }
    if (data.audioTracks) {
      audioTracks = data.audioTracks.filter((track) => !track.audioCodec || isCodecSupportedInMp4(track.audioCodec, "audio"));
      assignTrackIdsByGroup(audioTracks);
    }
    if (data.subtitles) {
      subtitleTracks = data.subtitles;
      assignTrackIdsByGroup(subtitleTracks);
    }
    const unsortedLevels = levels.slice(0);
    levels.sort((a, b) => {
      if (a.attrs["HDCP-LEVEL"] !== b.attrs["HDCP-LEVEL"]) {
        return (a.attrs["HDCP-LEVEL"] || "") > (b.attrs["HDCP-LEVEL"] || "") ? 1 : -1;
      }
      if (a.bitrate !== b.bitrate) {
        return a.bitrate - b.bitrate;
      }
      if (a.attrs["FRAME-RATE"] !== b.attrs["FRAME-RATE"]) {
        return a.attrs.decimalFloatingPoint("FRAME-RATE") - b.attrs.decimalFloatingPoint("FRAME-RATE");
      }
      if (a.attrs.SCORE !== b.attrs.SCORE) {
        return a.attrs.decimalFloatingPoint("SCORE") - b.attrs.decimalFloatingPoint("SCORE");
      }
      if (resolutionFound && a.height !== b.height) {
        return a.height - b.height;
      }
      return 0;
    });
    let firstLevelInPlaylist = unsortedLevels[0];
    if (this.steering) {
      levels = this.steering.filterParsedLevels(levels);
      if (levels.length !== unsortedLevels.length) {
        for (let i = 0; i < unsortedLevels.length; i++) {
          if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {
            firstLevelInPlaylist = unsortedLevels[i];
            break;
          }
        }
      }
    }
    this._levels = levels;
    for (let i = 0; i < levels.length; i++) {
      if (levels[i] === firstLevelInPlaylist) {
        this._firstLevel = i;
        this.log(`manifest loaded, ${levels.length} level(s) found, first bitrate: ${firstLevelInPlaylist.bitrate}`);
        break;
      }
    }
    const audioOnly3 = audioCodecFound && !videoCodecFound;
    const edata = {
      levels,
      audioTracks,
      subtitleTracks,
      sessionData: data.sessionData,
      sessionKeys: data.sessionKeys,
      firstLevel: this._firstLevel,
      stats: data.stats,
      audio: audioCodecFound,
      video: videoCodecFound,
      altAudio: !audioOnly3 && audioTracks.some((t2) => !!t2.url)
    };
    this.hls.trigger(Events.MANIFEST_PARSED, edata);
    if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {
      this.hls.startLoad(this.hls.config.startPosition);
    }
  }
  get levels() {
    if (this._levels.length === 0) {
      return null;
    }
    return this._levels;
  }
  get level() {
    return this.currentLevelIndex;
  }
  set level(newLevel) {
    const levels = this._levels;
    if (levels.length === 0) {
      return;
    }
    if (newLevel < 0 || newLevel >= levels.length) {
      const error = new Error("invalid level idx");
      const fatal = newLevel < 0;
      this.hls.trigger(Events.ERROR, {
        type: ErrorTypes.OTHER_ERROR,
        details: ErrorDetails.LEVEL_SWITCH_ERROR,
        level: newLevel,
        fatal,
        error,
        reason: error.message
      });
      if (fatal) {
        return;
      }
      newLevel = Math.min(newLevel, levels.length - 1);
    }
    const lastLevelIndex = this.currentLevelIndex;
    const lastLevel = this.currentLevel;
    const lastPathwayId = lastLevel ? lastLevel.attrs["PATHWAY-ID"] : void 0;
    const level = levels[newLevel];
    const pathwayId = level.attrs["PATHWAY-ID"];
    this.currentLevelIndex = newLevel;
    this.currentLevel = level;
    if (lastLevelIndex === newLevel && level.details && lastLevel && lastPathwayId === pathwayId) {
      return;
    }
    this.log(`Switching to level ${newLevel}${pathwayId ? " with Pathway " + pathwayId : ""} from level ${lastLevelIndex}${lastPathwayId ? " with Pathway " + lastPathwayId : ""}`);
    const levelSwitchingData = _extends({}, level, {
      level: newLevel,
      maxBitrate: level.maxBitrate,
      attrs: level.attrs,
      uri: level.uri,
      urlId: level.urlId
    });
    delete levelSwitchingData._attrs;
    delete levelSwitchingData._urlId;
    this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);
    const levelDetails = level.details;
    if (!levelDetails || levelDetails.live) {
      const hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? void 0 : lastLevel.details);
      this.loadPlaylist(hlsUrlParameters);
    }
  }
  get manualLevel() {
    return this.manualLevelIndex;
  }
  set manualLevel(newLevel) {
    this.manualLevelIndex = newLevel;
    if (this._startLevel === void 0) {
      this._startLevel = newLevel;
    }
    if (newLevel !== -1) {
      this.level = newLevel;
    }
  }
  get firstLevel() {
    return this._firstLevel;
  }
  set firstLevel(newLevel) {
    this._firstLevel = newLevel;
  }
  get startLevel() {
    if (this._startLevel === void 0) {
      const configStartLevel = this.hls.config.startLevel;
      if (configStartLevel !== void 0) {
        return configStartLevel;
      } else {
        return this._firstLevel;
      }
    } else {
      return this._startLevel;
    }
  }
  set startLevel(newLevel) {
    this._startLevel = newLevel;
  }
  onError(event, data) {
    if (data.fatal || !data.context) {
      return;
    }
    if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {
      this.checkRetry(data);
    }
  }
  // reset errors on the successful load of a fragment
  onFragLoaded(event, {
    frag
  }) {
    if (frag !== void 0 && frag.type === PlaylistLevelType.MAIN) {
      const level = this._levels[frag.level];
      if (level !== void 0) {
        level.loadError = 0;
      }
    }
  }
  onLevelLoaded(event, data) {
    var _data$deliveryDirecti2;
    const {
      level,
      details
    } = data;
    const curLevel = this._levels[level];
    if (!curLevel) {
      var _data$deliveryDirecti;
      this.warn(`Invalid level index ${level}`);
      if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {
        details.deltaUpdateFailed = true;
      }
      return;
    }
    if (level === this.currentLevelIndex) {
      if (curLevel.fragmentError === 0) {
        curLevel.loadError = 0;
      }
      this.playlistLoaded(level, data, curLevel.details);
    } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {
      details.deltaUpdateFailed = true;
    }
  }
  onAudioTrackSwitched(event, data) {
    const currentLevel = this.currentLevel;
    if (!currentLevel) {
      return;
    }
    const audioGroupId = this.hls.audioTracks[data.id].groupId;
    if (currentLevel.audioGroupIds && currentLevel.audioGroupId !== audioGroupId) {
      let urlId = -1;
      for (let i = 0; i < currentLevel.audioGroupIds.length; i++) {
        if (currentLevel.audioGroupIds[i] === audioGroupId) {
          urlId = i;
          break;
        }
      }
      if (urlId !== -1 && urlId !== currentLevel.urlId) {
        currentLevel.urlId = urlId;
        if (this.canLoad) {
          this.startLoad();
        }
      }
    }
  }
  loadPlaylist(hlsUrlParameters) {
    super.loadPlaylist();
    const currentLevelIndex = this.currentLevelIndex;
    const currentLevel = this.currentLevel;
    if (currentLevel && this.shouldLoadPlaylist(currentLevel)) {
      const id = currentLevel.urlId;
      let url = currentLevel.uri;
      if (hlsUrlParameters) {
        try {
          url = hlsUrlParameters.addDirectives(url);
        } catch (error) {
          this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);
        }
      }
      const pathwayId = currentLevel.attrs["PATHWAY-ID"];
      this.log(`Loading level index ${currentLevelIndex}${(hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== void 0 ? " at sn " + hlsUrlParameters.msn + " part " + hlsUrlParameters.part : ""} with${pathwayId ? " Pathway " + pathwayId : ""} URI ${id + 1}/${currentLevel.url.length} ${url}`);
      this.clearTimer();
      this.hls.trigger(Events.LEVEL_LOADING, {
        url,
        level: currentLevelIndex,
        id,
        deliveryDirectives: hlsUrlParameters || null
      });
    }
  }
  get nextLoadLevel() {
    if (this.manualLevelIndex !== -1) {
      return this.manualLevelIndex;
    } else {
      return this.hls.nextAutoLevel;
    }
  }
  set nextLoadLevel(nextLevel) {
    this.level = nextLevel;
    if (this.manualLevelIndex === -1) {
      this.hls.nextAutoLevel = nextLevel;
    }
  }
  removeLevel(levelIndex, urlId) {
    const filterLevelAndGroupByIdIndex = (url, id) => id !== urlId;
    const levels = this._levels.filter((level, index) => {
      if (index !== levelIndex) {
        return true;
      }
      if (level.url.length > 1 && urlId !== void 0) {
        level.url = level.url.filter(filterLevelAndGroupByIdIndex);
        if (level.audioGroupIds) {
          level.audioGroupIds = level.audioGroupIds.filter(filterLevelAndGroupByIdIndex);
        }
        if (level.textGroupIds) {
          level.textGroupIds = level.textGroupIds.filter(filterLevelAndGroupByIdIndex);
        }
        level.urlId = 0;
        return true;
      }
      if (this.steering) {
        this.steering.removeLevel(level);
      }
      return false;
    });
    this.hls.trigger(Events.LEVELS_UPDATED, {
      levels
    });
  }
  onLevelsUpdated(event, {
    levels
  }) {
    levels.forEach((level, index) => {
      const {
        details
      } = level;
      if (details != null && details.fragments) {
        details.fragments.forEach((fragment) => {
          fragment.level = index;
        });
      }
    });
    this._levels = levels;
  }
};
function addGroupId(level, type2, id) {
  if (!id) {
    return;
  }
  if (type2 === "audio") {
    if (!level.audioGroupIds) {
      level.audioGroupIds = [];
    }
    level.audioGroupIds[level.url.length - 1] = id;
  } else if (type2 === "text") {
    if (!level.textGroupIds) {
      level.textGroupIds = [];
    }
    level.textGroupIds[level.url.length - 1] = id;
  }
}
function assignTrackIdsByGroup(tracks) {
  const groups = {};
  tracks.forEach((track) => {
    const groupId = track.groupId || "";
    track.id = groups[groupId] = groups[groupId] || 0;
    groups[groupId]++;
  });
}
var FragmentState = {
  NOT_LOADED: "NOT_LOADED",
  APPENDING: "APPENDING",
  PARTIAL: "PARTIAL",
  OK: "OK"
};
var FragmentTracker = class {
  constructor(hls) {
    this.activePartLists = /* @__PURE__ */ Object.create(null);
    this.endListFragments = /* @__PURE__ */ Object.create(null);
    this.fragments = /* @__PURE__ */ Object.create(null);
    this.timeRanges = /* @__PURE__ */ Object.create(null);
    this.bufferPadding = 0.2;
    this.hls = void 0;
    this.hasGaps = false;
    this.hls = hls;
    this._registerListeners();
  }
  _registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);
    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
  }
  _unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);
    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
  }
  destroy() {
    this._unregisterListeners();
    this.fragments = // @ts-ignore
    this.activePartLists = // @ts-ignore
    this.endListFragments = this.timeRanges = null;
  }
  /**
   * Return a Fragment or Part with an appended range that matches the position and levelType
   * Otherwise, return null
   */
  getAppendedFrag(position, levelType) {
    const activeParts = this.activePartLists[levelType];
    if (activeParts) {
      for (let i = activeParts.length; i--; ) {
        const activePart = activeParts[i];
        if (!activePart) {
          break;
        }
        const appendedPTS = activePart.end;
        if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {
          return activePart;
        }
      }
    }
    return this.getBufferedFrag(position, levelType);
  }
  /**
   * Return a buffered Fragment that matches the position and levelType.
   * A buffered Fragment is one whose loading, parsing and appending is done (completed or "partial" meaning aborted).
   * If not found any Fragment, return null
   */
  getBufferedFrag(position, levelType) {
    const {
      fragments
    } = this;
    const keys3 = Object.keys(fragments);
    for (let i = keys3.length; i--; ) {
      const fragmentEntity = fragments[keys3[i]];
      if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {
        const frag = fragmentEntity.body;
        if (frag.start <= position && position <= frag.end) {
          return frag;
        }
      }
    }
    return null;
  }
  /**
   * Partial fragments effected by coded frame eviction will be removed
   * The browser will unload parts of the buffer to free up memory for new buffer data
   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
   */
  detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart) {
    if (this.timeRanges) {
      this.timeRanges[elementaryStream] = timeRange;
    }
    const appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;
    Object.keys(this.fragments).forEach((key) => {
      const fragmentEntity = this.fragments[key];
      if (!fragmentEntity) {
        return;
      }
      if (appendedPartSn >= fragmentEntity.body.sn) {
        return;
      }
      if (!fragmentEntity.buffered && !fragmentEntity.loaded) {
        if (fragmentEntity.body.type === playlistType) {
          this.removeFragment(fragmentEntity.body);
        }
        return;
      }
      const esData = fragmentEntity.range[elementaryStream];
      if (!esData) {
        return;
      }
      esData.time.some((time) => {
        const isNotBuffered = !this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);
        if (isNotBuffered) {
          this.removeFragment(fragmentEntity.body);
        }
        return isNotBuffered;
      });
    });
  }
  /**
   * Checks if the fragment passed in is loaded in the buffer properly
   * Partially loaded fragments will be registered as a partial fragment
   */
  detectPartialFragments(data) {
    const timeRanges = this.timeRanges;
    const {
      frag,
      part
    } = data;
    if (!timeRanges || frag.sn === "initSegment") {
      return;
    }
    const fragKey = getFragmentKey(frag);
    const fragmentEntity = this.fragments[fragKey];
    if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {
      return;
    }
    const isFragHint = !frag.relurl;
    Object.keys(timeRanges).forEach((elementaryStream) => {
      const streamInfo = frag.elementaryStreams[elementaryStream];
      if (!streamInfo) {
        return;
      }
      const timeRange = timeRanges[elementaryStream];
      const partial = isFragHint || streamInfo.partial === true;
      fragmentEntity.range[elementaryStream] = this.getBufferedTimes(frag, part, partial, timeRange);
    });
    fragmentEntity.loaded = null;
    if (Object.keys(fragmentEntity.range).length) {
      fragmentEntity.buffered = true;
      const endList = fragmentEntity.body.endList = frag.endList || fragmentEntity.body.endList;
      if (endList) {
        this.endListFragments[fragmentEntity.body.type] = fragmentEntity;
      }
      if (!isPartial(fragmentEntity)) {
        this.removeParts(frag.sn - 1, frag.type);
      }
    } else {
      this.removeFragment(fragmentEntity.body);
    }
  }
  removeParts(snToKeep, levelType) {
    const activeParts = this.activePartLists[levelType];
    if (!activeParts) {
      return;
    }
    this.activePartLists[levelType] = activeParts.filter((part) => part.fragment.sn >= snToKeep);
  }
  fragBuffered(frag, force) {
    const fragKey = getFragmentKey(frag);
    let fragmentEntity = this.fragments[fragKey];
    if (!fragmentEntity && force) {
      fragmentEntity = this.fragments[fragKey] = {
        body: frag,
        appendedPTS: null,
        loaded: null,
        buffered: false,
        range: /* @__PURE__ */ Object.create(null)
      };
      if (frag.gap) {
        this.hasGaps = true;
      }
    }
    if (fragmentEntity) {
      fragmentEntity.loaded = null;
      fragmentEntity.buffered = true;
    }
  }
  getBufferedTimes(fragment, part, partial, timeRange) {
    const buffered = {
      time: [],
      partial
    };
    const startPTS = fragment.start;
    const endPTS = fragment.end;
    const minEndPTS = fragment.minEndPTS || endPTS;
    const maxStartPTS = fragment.maxStartPTS || startPTS;
    for (let i = 0; i < timeRange.length; i++) {
      const startTime = timeRange.start(i) - this.bufferPadding;
      const endTime = timeRange.end(i) + this.bufferPadding;
      if (maxStartPTS >= startTime && minEndPTS <= endTime) {
        buffered.time.push({
          startPTS: Math.max(startPTS, timeRange.start(i)),
          endPTS: Math.min(endPTS, timeRange.end(i))
        });
        break;
      } else if (startPTS < endTime && endPTS > startTime) {
        buffered.partial = true;
        buffered.time.push({
          startPTS: Math.max(startPTS, timeRange.start(i)),
          endPTS: Math.min(endPTS, timeRange.end(i))
        });
      } else if (endPTS <= startTime) {
        break;
      }
    }
    return buffered;
  }
  /**
   * Gets the partial fragment for a certain time
   */
  getPartialFragment(time) {
    let bestFragment = null;
    let timePadding;
    let startTime;
    let endTime;
    let bestOverlap = 0;
    const {
      bufferPadding,
      fragments
    } = this;
    Object.keys(fragments).forEach((key) => {
      const fragmentEntity = fragments[key];
      if (!fragmentEntity) {
        return;
      }
      if (isPartial(fragmentEntity)) {
        startTime = fragmentEntity.body.start - bufferPadding;
        endTime = fragmentEntity.body.end + bufferPadding;
        if (time >= startTime && time <= endTime) {
          timePadding = Math.min(time - startTime, endTime - time);
          if (bestOverlap <= timePadding) {
            bestFragment = fragmentEntity.body;
            bestOverlap = timePadding;
          }
        }
      }
    });
    return bestFragment;
  }
  isEndListAppended(type2) {
    const lastFragmentEntity = this.endListFragments[type2];
    return lastFragmentEntity !== void 0 && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));
  }
  getState(fragment) {
    const fragKey = getFragmentKey(fragment);
    const fragmentEntity = this.fragments[fragKey];
    if (fragmentEntity) {
      if (!fragmentEntity.buffered) {
        return FragmentState.APPENDING;
      } else if (isPartial(fragmentEntity)) {
        return FragmentState.PARTIAL;
      } else {
        return FragmentState.OK;
      }
    }
    return FragmentState.NOT_LOADED;
  }
  isTimeBuffered(startPTS, endPTS, timeRange) {
    let startTime;
    let endTime;
    for (let i = 0; i < timeRange.length; i++) {
      startTime = timeRange.start(i) - this.bufferPadding;
      endTime = timeRange.end(i) + this.bufferPadding;
      if (startPTS >= startTime && endPTS <= endTime) {
        return true;
      }
      if (endPTS <= startTime) {
        return false;
      }
    }
    return false;
  }
  onFragLoaded(event, data) {
    const {
      frag,
      part
    } = data;
    if (frag.sn === "initSegment" || frag.bitrateTest) {
      return;
    }
    const loaded = part ? null : data;
    const fragKey = getFragmentKey(frag);
    this.fragments[fragKey] = {
      body: frag,
      appendedPTS: null,
      loaded,
      buffered: false,
      range: /* @__PURE__ */ Object.create(null)
    };
  }
  onBufferAppended(event, data) {
    const {
      frag,
      part,
      timeRanges
    } = data;
    if (frag.sn === "initSegment") {
      return;
    }
    const playlistType = frag.type;
    if (part) {
      let activeParts = this.activePartLists[playlistType];
      if (!activeParts) {
        this.activePartLists[playlistType] = activeParts = [];
      }
      activeParts.push(part);
    }
    this.timeRanges = timeRanges;
    Object.keys(timeRanges).forEach((elementaryStream) => {
      const timeRange = timeRanges[elementaryStream];
      this.detectEvictedFragments(elementaryStream, timeRange, playlistType, part);
    });
  }
  onFragBuffered(event, data) {
    this.detectPartialFragments(data);
  }
  hasFragment(fragment) {
    const fragKey = getFragmentKey(fragment);
    return !!this.fragments[fragKey];
  }
  hasParts(type2) {
    var _this$activePartLists;
    return !!((_this$activePartLists = this.activePartLists[type2]) != null && _this$activePartLists.length);
  }
  removeFragmentsInRange(start2, end, playlistType, withGapOnly, unbufferedOnly) {
    if (withGapOnly && !this.hasGaps) {
      return;
    }
    Object.keys(this.fragments).forEach((key) => {
      const fragmentEntity = this.fragments[key];
      if (!fragmentEntity) {
        return;
      }
      const frag = fragmentEntity.body;
      if (frag.type !== playlistType || withGapOnly && !frag.gap) {
        return;
      }
      if (frag.start < end && frag.end > start2 && (fragmentEntity.buffered || unbufferedOnly)) {
        this.removeFragment(frag);
      }
    });
  }
  removeFragment(fragment) {
    const fragKey = getFragmentKey(fragment);
    fragment.stats.loaded = 0;
    fragment.clearElementaryStreamInfo();
    const activeParts = this.activePartLists[fragment.type];
    if (activeParts) {
      const snToRemove = fragment.sn;
      this.activePartLists[fragment.type] = activeParts.filter((part) => part.fragment.sn !== snToRemove);
    }
    delete this.fragments[fragKey];
    if (fragment.endList) {
      delete this.endListFragments[fragment.type];
    }
  }
  removeAllFragments() {
    this.fragments = /* @__PURE__ */ Object.create(null);
    this.endListFragments = /* @__PURE__ */ Object.create(null);
    this.activePartLists = /* @__PURE__ */ Object.create(null);
    this.hasGaps = false;
  }
};
function isPartial(fragmentEntity) {
  var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;
  return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? void 0 : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? void 0 : _fragmentEntity$range3.partial));
}
function getFragmentKey(fragment) {
  return `${fragment.type}_${fragment.level}_${fragment.urlId}_${fragment.sn}`;
}
var MIN_CHUNK_SIZE = Math.pow(2, 17);
var FragmentLoader = class {
  constructor(config) {
    this.config = void 0;
    this.loader = null;
    this.partLoadTimeout = -1;
    this.config = config;
  }
  destroy() {
    if (this.loader) {
      this.loader.destroy();
      this.loader = null;
    }
  }
  abort() {
    if (this.loader) {
      this.loader.abort();
    }
  }
  load(frag, onProgress) {
    const url = frag.url;
    if (!url) {
      return Promise.reject(new LoadError({
        type: ErrorTypes.NETWORK_ERROR,
        details: ErrorDetails.FRAG_LOAD_ERROR,
        fatal: false,
        frag,
        error: new Error(`Fragment does not have a ${url ? "part list" : "url"}`),
        networkDetails: null
      }));
    }
    this.abort();
    const config = this.config;
    const FragmentILoader = config.fLoader;
    const DefaultILoader = config.loader;
    return new Promise((resolve, reject) => {
      if (this.loader) {
        this.loader.destroy();
      }
      if (frag.gap) {
        if (frag.tagList.some((tags) => tags[0] === "GAP")) {
          reject(createGapLoadError(frag));
          return;
        } else {
          frag.gap = false;
        }
      }
      const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
      const loaderContext = createLoaderContext(frag);
      const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);
      const loaderConfig = {
        loadPolicy,
        timeout: loadPolicy.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0,
        highWaterMark: frag.sn === "initSegment" ? Infinity : MIN_CHUNK_SIZE
      };
      frag.stats = loader.stats;
      loader.load(loaderContext, loaderConfig, {
        onSuccess: (response, stats, context, networkDetails) => {
          this.resetLoader(frag, loader);
          let payload = response.data;
          if (context.resetIV && frag.decryptdata) {
            frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));
            payload = payload.slice(16);
          }
          resolve({
            frag,
            part: null,
            payload,
            networkDetails
          });
        },
        onError: (response, context, networkDetails, stats) => {
          this.resetLoader(frag, loader);
          reject(new LoadError({
            type: ErrorTypes.NETWORK_ERROR,
            details: ErrorDetails.FRAG_LOAD_ERROR,
            fatal: false,
            frag,
            response: _objectSpread2({
              url,
              data: void 0
            }, response),
            error: new Error(`HTTP Error ${response.code} ${response.text}`),
            networkDetails,
            stats
          }));
        },
        onAbort: (stats, context, networkDetails) => {
          this.resetLoader(frag, loader);
          reject(new LoadError({
            type: ErrorTypes.NETWORK_ERROR,
            details: ErrorDetails.INTERNAL_ABORTED,
            fatal: false,
            frag,
            error: new Error("Aborted"),
            networkDetails,
            stats
          }));
        },
        onTimeout: (stats, context, networkDetails) => {
          this.resetLoader(frag, loader);
          reject(new LoadError({
            type: ErrorTypes.NETWORK_ERROR,
            details: ErrorDetails.FRAG_LOAD_TIMEOUT,
            fatal: false,
            frag,
            error: new Error(`Timeout after ${loaderConfig.timeout}ms`),
            networkDetails,
            stats
          }));
        },
        onProgress: (stats, context, data, networkDetails) => {
          if (onProgress) {
            onProgress({
              frag,
              part: null,
              payload: data,
              networkDetails
            });
          }
        }
      });
    });
  }
  loadPart(frag, part, onProgress) {
    this.abort();
    const config = this.config;
    const FragmentILoader = config.fLoader;
    const DefaultILoader = config.loader;
    return new Promise((resolve, reject) => {
      if (this.loader) {
        this.loader.destroy();
      }
      if (frag.gap || part.gap) {
        reject(createGapLoadError(frag, part));
        return;
      }
      const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
      const loaderContext = createLoaderContext(frag, part);
      const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);
      const loaderConfig = {
        loadPolicy,
        timeout: loadPolicy.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0,
        highWaterMark: MIN_CHUNK_SIZE
      };
      part.stats = loader.stats;
      loader.load(loaderContext, loaderConfig, {
        onSuccess: (response, stats, context, networkDetails) => {
          this.resetLoader(frag, loader);
          this.updateStatsFromPart(frag, part);
          const partLoadedData = {
            frag,
            part,
            payload: response.data,
            networkDetails
          };
          onProgress(partLoadedData);
          resolve(partLoadedData);
        },
        onError: (response, context, networkDetails, stats) => {
          this.resetLoader(frag, loader);
          reject(new LoadError({
            type: ErrorTypes.NETWORK_ERROR,
            details: ErrorDetails.FRAG_LOAD_ERROR,
            fatal: false,
            frag,
            part,
            response: _objectSpread2({
              url: loaderContext.url,
              data: void 0
            }, response),
            error: new Error(`HTTP Error ${response.code} ${response.text}`),
            networkDetails,
            stats
          }));
        },
        onAbort: (stats, context, networkDetails) => {
          frag.stats.aborted = part.stats.aborted;
          this.resetLoader(frag, loader);
          reject(new LoadError({
            type: ErrorTypes.NETWORK_ERROR,
            details: ErrorDetails.INTERNAL_ABORTED,
            fatal: false,
            frag,
            part,
            error: new Error("Aborted"),
            networkDetails,
            stats
          }));
        },
        onTimeout: (stats, context, networkDetails) => {
          this.resetLoader(frag, loader);
          reject(new LoadError({
            type: ErrorTypes.NETWORK_ERROR,
            details: ErrorDetails.FRAG_LOAD_TIMEOUT,
            fatal: false,
            frag,
            part,
            error: new Error(`Timeout after ${loaderConfig.timeout}ms`),
            networkDetails,
            stats
          }));
        }
      });
    });
  }
  updateStatsFromPart(frag, part) {
    const fragStats = frag.stats;
    const partStats = part.stats;
    const partTotal = partStats.total;
    fragStats.loaded += partStats.loaded;
    if (partTotal) {
      const estTotalParts = Math.round(frag.duration / part.duration);
      const estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);
      const estRemainingParts = estTotalParts - estLoadedParts;
      const estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);
      fragStats.total = fragStats.loaded + estRemainingBytes;
    } else {
      fragStats.total = Math.max(fragStats.loaded, fragStats.total);
    }
    const fragLoading = fragStats.loading;
    const partLoading = partStats.loading;
    if (fragLoading.start) {
      fragLoading.first += partLoading.first - partLoading.start;
    } else {
      fragLoading.start = partLoading.start;
      fragLoading.first = partLoading.first;
    }
    fragLoading.end = partLoading.end;
  }
  resetLoader(frag, loader) {
    frag.loader = null;
    if (this.loader === loader) {
      self.clearTimeout(this.partLoadTimeout);
      this.loader = null;
    }
    loader.destroy();
  }
};
function createLoaderContext(frag, part = null) {
  const segment = part || frag;
  const loaderContext = {
    frag,
    part,
    responseType: "arraybuffer",
    url: segment.url,
    headers: {},
    rangeStart: 0,
    rangeEnd: 0
  };
  const start2 = segment.byteRangeStartOffset;
  const end = segment.byteRangeEndOffset;
  if (isFiniteNumber(start2) && isFiniteNumber(end)) {
    var _frag$decryptdata;
    let byteRangeStart = start2;
    let byteRangeEnd = end;
    if (frag.sn === "initSegment" && ((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method) === "AES-128") {
      const fragmentLen = end - start2;
      if (fragmentLen % 16) {
        byteRangeEnd = end + (16 - fragmentLen % 16);
      }
      if (start2 !== 0) {
        loaderContext.resetIV = true;
        byteRangeStart = start2 - 16;
      }
    }
    loaderContext.rangeStart = byteRangeStart;
    loaderContext.rangeEnd = byteRangeEnd;
  }
  return loaderContext;
}
function createGapLoadError(frag, part) {
  const error = new Error(`GAP ${frag.gap ? "tag" : "attribute"} found`);
  const errorData = {
    type: ErrorTypes.MEDIA_ERROR,
    details: ErrorDetails.FRAG_GAP,
    fatal: false,
    frag,
    error,
    networkDetails: null
  };
  if (part) {
    errorData.part = part;
  }
  (part ? part : frag).stats.aborted = true;
  return new LoadError(errorData);
}
var LoadError = class extends Error {
  constructor(data) {
    super(data.error.message);
    this.data = void 0;
    this.data = data;
  }
};
var KeyLoader = class {
  constructor(config) {
    this.config = void 0;
    this.keyUriToKeyInfo = {};
    this.emeController = null;
    this.config = config;
  }
  abort(type2) {
    for (const uri in this.keyUriToKeyInfo) {
      const loader = this.keyUriToKeyInfo[uri].loader;
      if (loader) {
        if (type2 && type2 !== loader.context.frag.type) {
          return;
        }
        loader.abort();
      }
    }
  }
  detach() {
    for (const uri in this.keyUriToKeyInfo) {
      const keyInfo = this.keyUriToKeyInfo[uri];
      if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {
        delete this.keyUriToKeyInfo[uri];
      }
    }
  }
  destroy() {
    this.detach();
    for (const uri in this.keyUriToKeyInfo) {
      const loader = this.keyUriToKeyInfo[uri].loader;
      if (loader) {
        loader.destroy();
      }
    }
    this.keyUriToKeyInfo = {};
  }
  createKeyLoadError(frag, details = ErrorDetails.KEY_LOAD_ERROR, error, networkDetails, response) {
    return new LoadError({
      type: ErrorTypes.NETWORK_ERROR,
      details,
      fatal: false,
      frag,
      response,
      error,
      networkDetails
    });
  }
  loadClear(loadingFrag, encryptedFragments) {
    if (this.emeController && this.config.emeEnabled) {
      const {
        sn,
        cc
      } = loadingFrag;
      for (let i = 0; i < encryptedFragments.length; i++) {
        const frag = encryptedFragments[i];
        if (cc <= frag.cc && (sn === "initSegment" || frag.sn === "initSegment" || sn < frag.sn)) {
          this.emeController.selectKeySystemFormat(frag).then((keySystemFormat) => {
            frag.setKeyFormat(keySystemFormat);
          });
          break;
        }
      }
    }
  }
  load(frag) {
    if (!frag.decryptdata && frag.encrypted && this.emeController) {
      return this.emeController.selectKeySystemFormat(frag).then((keySystemFormat) => {
        return this.loadInternal(frag, keySystemFormat);
      });
    }
    return this.loadInternal(frag);
  }
  loadInternal(frag, keySystemFormat) {
    var _keyInfo, _keyInfo2;
    if (keySystemFormat) {
      frag.setKeyFormat(keySystemFormat);
    }
    const decryptdata = frag.decryptdata;
    if (!decryptdata) {
      const error = new Error(keySystemFormat ? `Expected frag.decryptdata to be defined after setting format ${keySystemFormat}` : "Missing decryption data on fragment in onKeyLoading");
      return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));
    }
    const uri = decryptdata.uri;
    if (!uri) {
      return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${uri}"`)));
    }
    let keyInfo = this.keyUriToKeyInfo[uri];
    if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {
      decryptdata.key = keyInfo.decryptdata.key;
      return Promise.resolve({
        frag,
        keyInfo
      });
    }
    if ((_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {
      var _keyInfo$mediaKeySess;
      switch ((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) == null ? void 0 : _keyInfo$mediaKeySess.keyStatus) {
        case void 0:
        case "status-pending":
        case "usable":
        case "usable-in-future":
          return keyInfo.keyLoadPromise.then((keyLoadedData) => {
            decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;
            return {
              frag,
              keyInfo
            };
          });
      }
    }
    keyInfo = this.keyUriToKeyInfo[uri] = {
      decryptdata,
      keyLoadPromise: null,
      loader: null,
      mediaKeySessionContext: null
    };
    switch (decryptdata.method) {
      case "ISO-23001-7":
      case "SAMPLE-AES":
      case "SAMPLE-AES-CENC":
      case "SAMPLE-AES-CTR":
        if (decryptdata.keyFormat === "identity") {
          return this.loadKeyHTTP(keyInfo, frag);
        }
        return this.loadKeyEME(keyInfo, frag);
      case "AES-128":
        return this.loadKeyHTTP(keyInfo, frag);
      default:
        return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${decryptdata.method}"`)));
    }
  }
  loadKeyEME(keyInfo, frag) {
    const keyLoadedData = {
      frag,
      keyInfo
    };
    if (this.emeController && this.config.emeEnabled) {
      const keySessionContextPromise = this.emeController.loadKey(keyLoadedData);
      if (keySessionContextPromise) {
        return (keyInfo.keyLoadPromise = keySessionContextPromise.then((keySessionContext) => {
          keyInfo.mediaKeySessionContext = keySessionContext;
          return keyLoadedData;
        })).catch((error) => {
          keyInfo.keyLoadPromise = null;
          throw error;
        });
      }
    }
    return Promise.resolve(keyLoadedData);
  }
  loadKeyHTTP(keyInfo, frag) {
    const config = this.config;
    const Loader = config.loader;
    const keyLoader = new Loader(config);
    frag.keyLoader = keyInfo.loader = keyLoader;
    return keyInfo.keyLoadPromise = new Promise((resolve, reject) => {
      const loaderContext = {
        keyInfo,
        frag,
        responseType: "arraybuffer",
        url: keyInfo.decryptdata.uri
      };
      const loadPolicy = config.keyLoadPolicy.default;
      const loaderConfig = {
        loadPolicy,
        timeout: loadPolicy.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0
      };
      const loaderCallbacks = {
        onSuccess: (response, stats, context, networkDetails) => {
          const {
            frag: frag2,
            keyInfo: keyInfo2,
            url: uri
          } = context;
          if (!frag2.decryptdata || keyInfo2 !== this.keyUriToKeyInfo[uri]) {
            return reject(this.createKeyLoadError(frag2, ErrorDetails.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), networkDetails));
          }
          keyInfo2.decryptdata.key = frag2.decryptdata.key = new Uint8Array(response.data);
          frag2.keyLoader = null;
          keyInfo2.loader = null;
          resolve({
            frag: frag2,
            keyInfo: keyInfo2
          });
        },
        onError: (response, context, networkDetails, stats) => {
          this.resetLoader(context);
          reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`HTTP Error ${response.code} loading key ${response.text}`), networkDetails, _objectSpread2({
            url: loaderContext.url,
            data: void 0
          }, response)));
        },
        onTimeout: (stats, context, networkDetails) => {
          this.resetLoader(context);
          reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), networkDetails));
        },
        onAbort: (stats, context, networkDetails) => {
          this.resetLoader(context);
          reject(this.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error("key loading aborted"), networkDetails));
        }
      };
      keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);
    });
  }
  resetLoader(context) {
    const {
      frag,
      keyInfo,
      url: uri
    } = context;
    const loader = keyInfo.loader;
    if (frag.keyLoader === loader) {
      frag.keyLoader = null;
      keyInfo.loader = null;
    }
    delete this.keyUriToKeyInfo[uri];
    if (loader) {
      loader.destroy();
    }
  }
};
var TaskLoop = class {
  constructor() {
    this._boundTick = void 0;
    this._tickTimer = null;
    this._tickInterval = null;
    this._tickCallCount = 0;
    this._boundTick = this.tick.bind(this);
  }
  destroy() {
    this.onHandlerDestroying();
    this.onHandlerDestroyed();
  }
  onHandlerDestroying() {
    this.clearNextTick();
    this.clearInterval();
  }
  onHandlerDestroyed() {
  }
  hasInterval() {
    return !!this._tickInterval;
  }
  hasNextTick() {
    return !!this._tickTimer;
  }
  /**
   * @param millis - Interval time (ms)
   * @eturns True when interval has been scheduled, false when already scheduled (no effect)
   */
  setInterval(millis) {
    if (!this._tickInterval) {
      this._tickCallCount = 0;
      this._tickInterval = self.setInterval(this._boundTick, millis);
      return true;
    }
    return false;
  }
  /**
   * @returns True when interval was cleared, false when none was set (no effect)
   */
  clearInterval() {
    if (this._tickInterval) {
      self.clearInterval(this._tickInterval);
      this._tickInterval = null;
      return true;
    }
    return false;
  }
  /**
   * @returns True when timeout was cleared, false when none was set (no effect)
   */
  clearNextTick() {
    if (this._tickTimer) {
      self.clearTimeout(this._tickTimer);
      this._tickTimer = null;
      return true;
    }
    return false;
  }
  /**
   * Will call the subclass doTick implementation in this main loop tick
   * or in the next one (via setTimeout(,0)) in case it has already been called
   * in this tick (in case this is a re-entrant call).
   */
  tick() {
    this._tickCallCount++;
    if (this._tickCallCount === 1) {
      this.doTick();
      if (this._tickCallCount > 1) {
        this.tickImmediate();
      }
      this._tickCallCount = 0;
    }
  }
  tickImmediate() {
    this.clearNextTick();
    this._tickTimer = self.setTimeout(this._boundTick, 0);
  }
  /**
   * For subclass to implement task logic
   * @abstract
   */
  doTick() {
  }
};
var noopBuffered = {
  length: 0,
  start: () => 0,
  end: () => 0
};
var BufferHelper = class _BufferHelper {
  /**
   * Return true if `media`'s buffered include `position`
   */
  static isBuffered(media, position) {
    try {
      if (media) {
        const buffered = _BufferHelper.getBuffered(media);
        for (let i = 0; i < buffered.length; i++) {
          if (position >= buffered.start(i) && position <= buffered.end(i)) {
            return true;
          }
        }
      }
    } catch (error) {
    }
    return false;
  }
  static bufferInfo(media, pos, maxHoleDuration) {
    try {
      if (media) {
        const vbuffered = _BufferHelper.getBuffered(media);
        const buffered = [];
        let i;
        for (i = 0; i < vbuffered.length; i++) {
          buffered.push({
            start: vbuffered.start(i),
            end: vbuffered.end(i)
          });
        }
        return this.bufferedInfo(buffered, pos, maxHoleDuration);
      }
    } catch (error) {
    }
    return {
      len: 0,
      start: pos,
      end: pos,
      nextStart: void 0
    };
  }
  static bufferedInfo(buffered, pos, maxHoleDuration) {
    pos = Math.max(0, pos);
    buffered.sort(function(a, b) {
      const diff = a.start - b.start;
      if (diff) {
        return diff;
      } else {
        return b.end - a.end;
      }
    });
    let buffered2 = [];
    if (maxHoleDuration) {
      for (let i = 0; i < buffered.length; i++) {
        const buf2len = buffered2.length;
        if (buf2len) {
          const buf2end = buffered2[buf2len - 1].end;
          if (buffered[i].start - buf2end < maxHoleDuration) {
            if (buffered[i].end > buf2end) {
              buffered2[buf2len - 1].end = buffered[i].end;
            }
          } else {
            buffered2.push(buffered[i]);
          }
        } else {
          buffered2.push(buffered[i]);
        }
      }
    } else {
      buffered2 = buffered;
    }
    let bufferLen = 0;
    let bufferStartNext;
    let bufferStart = pos;
    let bufferEnd = pos;
    for (let i = 0; i < buffered2.length; i++) {
      const start2 = buffered2[i].start;
      const end = buffered2[i].end;
      if (pos + maxHoleDuration >= start2 && pos < end) {
        bufferStart = start2;
        bufferEnd = end;
        bufferLen = bufferEnd - pos;
      } else if (pos + maxHoleDuration < start2) {
        bufferStartNext = start2;
        break;
      }
    }
    return {
      len: bufferLen,
      start: bufferStart || 0,
      end: bufferEnd || 0,
      nextStart: bufferStartNext
    };
  }
  /**
   * Safe method to get buffered property.
   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource
   */
  static getBuffered(media) {
    try {
      return media.buffered;
    } catch (e) {
      logger.log("failed to get media.buffered", e);
      return noopBuffered;
    }
  }
};
var ChunkMetadata = class {
  constructor(level, sn, id, size = 0, part = -1, partial = false) {
    this.level = void 0;
    this.sn = void 0;
    this.part = void 0;
    this.id = void 0;
    this.size = void 0;
    this.partial = void 0;
    this.transmuxing = getNewPerformanceTiming();
    this.buffering = {
      audio: getNewPerformanceTiming(),
      video: getNewPerformanceTiming(),
      audiovideo: getNewPerformanceTiming()
    };
    this.level = level;
    this.sn = sn;
    this.id = id;
    this.size = size;
    this.part = part;
    this.partial = partial;
  }
};
function getNewPerformanceTiming() {
  return {
    start: 0,
    executeStart: 0,
    executeEnd: 0,
    end: 0
  };
}
function findFirstFragWithCC(fragments, cc) {
  let firstFrag = null;
  for (let i = 0, len = fragments.length; i < len; i++) {
    const currentFrag = fragments[i];
    if (currentFrag && currentFrag.cc === cc) {
      firstFrag = currentFrag;
      break;
    }
  }
  return firstFrag;
}
function shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {
  if (lastLevel.details) {
    if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {
      return true;
    }
  }
  return false;
}
function findDiscontinuousReferenceFrag(prevDetails, curDetails, referenceIndex = 0) {
  const prevFrags = prevDetails.fragments;
  const curFrags = curDetails.fragments;
  if (!curFrags.length || !prevFrags.length) {
    logger.log("No fragments to align");
    return;
  }
  const prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);
  if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {
    logger.log("No frag in previous level to align on");
    return;
  }
  return prevStartFrag;
}
function adjustFragmentStart(frag, sliding) {
  if (frag) {
    const start2 = frag.start + sliding;
    frag.start = frag.startPTS = start2;
    frag.endPTS = start2 + frag.duration;
  }
}
function adjustSlidingStart(sliding, details) {
  const fragments = details.fragments;
  for (let i = 0, len = fragments.length; i < len; i++) {
    adjustFragmentStart(fragments[i], sliding);
  }
  if (details.fragmentHint) {
    adjustFragmentStart(details.fragmentHint, sliding);
  }
  details.alignedSliding = true;
}
function alignStream(lastFrag, lastLevel, details) {
  if (!lastLevel) {
    return;
  }
  alignDiscontinuities(lastFrag, details, lastLevel);
  if (!details.alignedSliding && lastLevel.details) {
    alignPDT(details, lastLevel.details);
  }
  if (!details.alignedSliding && lastLevel.details && !details.skippedSegments) {
    adjustSliding(lastLevel.details, details);
  }
}
function alignDiscontinuities(lastFrag, details, lastLevel) {
  if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {
    const referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);
    if (referenceFrag && isFiniteNumber(referenceFrag.start)) {
      logger.log(`Adjusting PTS using last level due to CC increase within current level ${details.url}`);
      adjustSlidingStart(referenceFrag.start, details);
    }
  }
}
function alignPDT(details, lastDetails) {
  if (!lastDetails.fragments.length || !details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {
    return;
  }
  const lastPDT = lastDetails.fragments[0].programDateTime;
  const newPDT = details.fragments[0].programDateTime;
  const sliding = (newPDT - lastPDT) / 1e3 + lastDetails.fragments[0].start;
  if (sliding && isFiniteNumber(sliding)) {
    logger.log(`Adjusting PTS using programDateTime delta ${newPDT - lastPDT}ms, sliding:${sliding.toFixed(3)} ${details.url} `);
    adjustSlidingStart(sliding, details);
  }
}
function alignMediaPlaylistByPDT(details, refDetails) {
  if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {
    return;
  }
  const fragments = details.fragments;
  const refFragments = refDetails.fragments;
  if (!fragments.length || !refFragments.length) {
    return;
  }
  const middleFrag = Math.round(refFragments.length / 2) - 1;
  const refFrag = refFragments[middleFrag];
  const frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.round(fragments.length / 2) - 1];
  const refPDT = refFrag.programDateTime;
  const targetPDT = frag.programDateTime;
  if (refPDT === null || targetPDT === null) {
    return;
  }
  const delta = (targetPDT - refPDT) / 1e3 - (frag.start - refFrag.start);
  adjustSlidingStart(delta, details);
}
var AESCrypto = class {
  constructor(subtle, iv) {
    this.subtle = void 0;
    this.aesIV = void 0;
    this.subtle = subtle;
    this.aesIV = iv;
  }
  decrypt(data, key) {
    return this.subtle.decrypt({
      name: "AES-CBC",
      iv: this.aesIV
    }, key, data);
  }
};
var FastAESKey = class {
  constructor(subtle, key) {
    this.subtle = void 0;
    this.key = void 0;
    this.subtle = subtle;
    this.key = key;
  }
  expandKey() {
    return this.subtle.importKey("raw", this.key, {
      name: "AES-CBC"
    }, false, ["encrypt", "decrypt"]);
  }
};
function removePadding(array) {
  const outputBytes = array.byteLength;
  const paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);
  if (paddingBytes) {
    return sliceUint8(array, 0, outputBytes - paddingBytes);
  }
  return array;
}
var AESDecryptor = class {
  constructor() {
    this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.sBox = new Uint32Array(256);
    this.invSBox = new Uint32Array(256);
    this.key = new Uint32Array(0);
    this.ksRows = 0;
    this.keySize = 0;
    this.keySchedule = void 0;
    this.invKeySchedule = void 0;
    this.initTable();
  }
  // Using view.getUint32() also swaps the byte order.
  uint8ArrayToUint32Array_(arrayBuffer) {
    const view = new DataView(arrayBuffer);
    const newArray = new Uint32Array(4);
    for (let i = 0; i < 4; i++) {
      newArray[i] = view.getUint32(i * 4);
    }
    return newArray;
  }
  initTable() {
    const sBox = this.sBox;
    const invSBox = this.invSBox;
    const subMix = this.subMix;
    const subMix0 = subMix[0];
    const subMix1 = subMix[1];
    const subMix2 = subMix[2];
    const subMix3 = subMix[3];
    const invSubMix = this.invSubMix;
    const invSubMix0 = invSubMix[0];
    const invSubMix1 = invSubMix[1];
    const invSubMix2 = invSubMix[2];
    const invSubMix3 = invSubMix[3];
    const d2 = new Uint32Array(256);
    let x = 0;
    let xi = 0;
    let i = 0;
    for (i = 0; i < 256; i++) {
      if (i < 128) {
        d2[i] = i << 1;
      } else {
        d2[i] = i << 1 ^ 283;
      }
    }
    for (i = 0; i < 256; i++) {
      let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
      sx = sx >>> 8 ^ sx & 255 ^ 99;
      sBox[x] = sx;
      invSBox[sx] = x;
      const x2 = d2[x];
      const x4 = d2[x2];
      const x8 = d2[x4];
      let t2 = d2[sx] * 257 ^ sx * 16843008;
      subMix0[x] = t2 << 24 | t2 >>> 8;
      subMix1[x] = t2 << 16 | t2 >>> 16;
      subMix2[x] = t2 << 8 | t2 >>> 24;
      subMix3[x] = t2;
      t2 = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
      invSubMix0[sx] = t2 << 24 | t2 >>> 8;
      invSubMix1[sx] = t2 << 16 | t2 >>> 16;
      invSubMix2[sx] = t2 << 8 | t2 >>> 24;
      invSubMix3[sx] = t2;
      if (!x) {
        x = xi = 1;
      } else {
        x = x2 ^ d2[d2[d2[x8 ^ x2]]];
        xi ^= d2[d2[xi]];
      }
    }
  }
  expandKey(keyBuffer) {
    const key = this.uint8ArrayToUint32Array_(keyBuffer);
    let sameKey = true;
    let offset = 0;
    while (offset < key.length && sameKey) {
      sameKey = key[offset] === this.key[offset];
      offset++;
    }
    if (sameKey) {
      return;
    }
    this.key = key;
    const keySize = this.keySize = key.length;
    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
      throw new Error("Invalid aes key size=" + keySize);
    }
    const ksRows = this.ksRows = (keySize + 6 + 1) * 4;
    let ksRow;
    let invKsRow;
    const keySchedule = this.keySchedule = new Uint32Array(ksRows);
    const invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
    const sbox = this.sBox;
    const rcon = this.rcon;
    const invSubMix = this.invSubMix;
    const invSubMix0 = invSubMix[0];
    const invSubMix1 = invSubMix[1];
    const invSubMix2 = invSubMix[2];
    const invSubMix3 = invSubMix[3];
    let prev;
    let t2;
    for (ksRow = 0; ksRow < ksRows; ksRow++) {
      if (ksRow < keySize) {
        prev = keySchedule[ksRow] = key[ksRow];
        continue;
      }
      t2 = prev;
      if (ksRow % keySize === 0) {
        t2 = t2 << 8 | t2 >>> 24;
        t2 = sbox[t2 >>> 24] << 24 | sbox[t2 >>> 16 & 255] << 16 | sbox[t2 >>> 8 & 255] << 8 | sbox[t2 & 255];
        t2 ^= rcon[ksRow / keySize | 0] << 24;
      } else if (keySize > 6 && ksRow % keySize === 4) {
        t2 = sbox[t2 >>> 24] << 24 | sbox[t2 >>> 16 & 255] << 16 | sbox[t2 >>> 8 & 255] << 8 | sbox[t2 & 255];
      }
      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t2) >>> 0;
    }
    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
      ksRow = ksRows - invKsRow;
      if (invKsRow & 3) {
        t2 = keySchedule[ksRow];
      } else {
        t2 = keySchedule[ksRow - 4];
      }
      if (invKsRow < 4 || ksRow <= 4) {
        invKeySchedule[invKsRow] = t2;
      } else {
        invKeySchedule[invKsRow] = invSubMix0[sbox[t2 >>> 24]] ^ invSubMix1[sbox[t2 >>> 16 & 255]] ^ invSubMix2[sbox[t2 >>> 8 & 255]] ^ invSubMix3[sbox[t2 & 255]];
      }
      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
    }
  }
  // Adding this as a method greatly improves performance.
  networkToHostOrderSwap(word) {
    return word << 24 | (word & 65280) << 8 | (word & 16711680) >> 8 | word >>> 24;
  }
  decrypt(inputArrayBuffer, offset, aesIV) {
    const nRounds = this.keySize + 6;
    const invKeySchedule = this.invKeySchedule;
    const invSBOX = this.invSBox;
    const invSubMix = this.invSubMix;
    const invSubMix0 = invSubMix[0];
    const invSubMix1 = invSubMix[1];
    const invSubMix2 = invSubMix[2];
    const invSubMix3 = invSubMix[3];
    const initVector = this.uint8ArrayToUint32Array_(aesIV);
    let initVector0 = initVector[0];
    let initVector1 = initVector[1];
    let initVector2 = initVector[2];
    let initVector3 = initVector[3];
    const inputInt32 = new Int32Array(inputArrayBuffer);
    const outputInt32 = new Int32Array(inputInt32.length);
    let t0, t1, t2, t3;
    let s0, s1, s2, s3;
    let inputWords0, inputWords1, inputWords2, inputWords3;
    let ksRow, i;
    const swapWord = this.networkToHostOrderSwap;
    while (offset < inputInt32.length) {
      inputWords0 = swapWord(inputInt32[offset]);
      inputWords1 = swapWord(inputInt32[offset + 1]);
      inputWords2 = swapWord(inputInt32[offset + 2]);
      inputWords3 = swapWord(inputInt32[offset + 3]);
      s0 = inputWords0 ^ invKeySchedule[0];
      s1 = inputWords3 ^ invKeySchedule[1];
      s2 = inputWords2 ^ invKeySchedule[2];
      s3 = inputWords1 ^ invKeySchedule[3];
      ksRow = 4;
      for (i = 1; i < nRounds; i++) {
        t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 255] ^ invSubMix2[s2 >> 8 & 255] ^ invSubMix3[s3 & 255] ^ invKeySchedule[ksRow];
        t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 255] ^ invSubMix2[s3 >> 8 & 255] ^ invSubMix3[s0 & 255] ^ invKeySchedule[ksRow + 1];
        t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 255] ^ invSubMix2[s0 >> 8 & 255] ^ invSubMix3[s1 & 255] ^ invKeySchedule[ksRow + 2];
        t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 255] ^ invSubMix2[s1 >> 8 & 255] ^ invSubMix3[s2 & 255] ^ invKeySchedule[ksRow + 3];
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
        ksRow = ksRow + 4;
      }
      t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 255] << 16 ^ invSBOX[s2 >> 8 & 255] << 8 ^ invSBOX[s3 & 255] ^ invKeySchedule[ksRow];
      t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 255] << 16 ^ invSBOX[s3 >> 8 & 255] << 8 ^ invSBOX[s0 & 255] ^ invKeySchedule[ksRow + 1];
      t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 255] << 16 ^ invSBOX[s0 >> 8 & 255] << 8 ^ invSBOX[s1 & 255] ^ invKeySchedule[ksRow + 2];
      t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 255] << 16 ^ invSBOX[s1 >> 8 & 255] << 8 ^ invSBOX[s2 & 255] ^ invKeySchedule[ksRow + 3];
      outputInt32[offset] = swapWord(t0 ^ initVector0);
      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
      outputInt32[offset + 3] = swapWord(t1 ^ initVector3);
      initVector0 = inputWords0;
      initVector1 = inputWords1;
      initVector2 = inputWords2;
      initVector3 = inputWords3;
      offset = offset + 4;
    }
    return outputInt32.buffer;
  }
};
var CHUNK_SIZE = 16;
var Decrypter = class {
  constructor(config, {
    removePKCS7Padding = true
  } = {}) {
    this.logEnabled = true;
    this.removePKCS7Padding = void 0;
    this.subtle = null;
    this.softwareDecrypter = null;
    this.key = null;
    this.fastAesKey = null;
    this.remainderData = null;
    this.currentIV = null;
    this.currentResult = null;
    this.useSoftware = void 0;
    this.useSoftware = config.enableSoftwareAES;
    this.removePKCS7Padding = removePKCS7Padding;
    if (removePKCS7Padding) {
      try {
        const browserCrypto = self.crypto;
        if (browserCrypto) {
          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
        }
      } catch (e) {
      }
    }
    if (this.subtle === null) {
      this.useSoftware = true;
    }
  }
  destroy() {
    this.subtle = null;
    this.softwareDecrypter = null;
    this.key = null;
    this.fastAesKey = null;
    this.remainderData = null;
    this.currentIV = null;
    this.currentResult = null;
  }
  isSync() {
    return this.useSoftware;
  }
  flush() {
    const {
      currentResult,
      remainderData
    } = this;
    if (!currentResult || remainderData) {
      this.reset();
      return null;
    }
    const data = new Uint8Array(currentResult);
    this.reset();
    if (this.removePKCS7Padding) {
      return removePadding(data);
    }
    return data;
  }
  reset() {
    this.currentResult = null;
    this.currentIV = null;
    this.remainderData = null;
    if (this.softwareDecrypter) {
      this.softwareDecrypter = null;
    }
  }
  decrypt(data, key, iv) {
    if (this.useSoftware) {
      return new Promise((resolve, reject) => {
        this.softwareDecrypt(new Uint8Array(data), key, iv);
        const decryptResult = this.flush();
        if (decryptResult) {
          resolve(decryptResult.buffer);
        } else {
          reject(new Error("[softwareDecrypt] Failed to decrypt data"));
        }
      });
    }
    return this.webCryptoDecrypt(new Uint8Array(data), key, iv);
  }
  // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached
  // data is handled in the flush() call
  softwareDecrypt(data, key, iv) {
    const {
      currentIV,
      currentResult,
      remainderData
    } = this;
    this.logOnce("JS AES decrypt");
    if (remainderData) {
      data = appendUint8Array(remainderData, data);
      this.remainderData = null;
    }
    const currentChunk = this.getValidChunk(data);
    if (!currentChunk.length) {
      return null;
    }
    if (currentIV) {
      iv = currentIV;
    }
    let softwareDecrypter = this.softwareDecrypter;
    if (!softwareDecrypter) {
      softwareDecrypter = this.softwareDecrypter = new AESDecryptor();
    }
    softwareDecrypter.expandKey(key);
    const result = currentResult;
    this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);
    this.currentIV = sliceUint8(currentChunk, -16).buffer;
    if (!result) {
      return null;
    }
    return result;
  }
  webCryptoDecrypt(data, key, iv) {
    const subtle = this.subtle;
    if (this.key !== key || !this.fastAesKey) {
      this.key = key;
      this.fastAesKey = new FastAESKey(subtle, key);
    }
    return this.fastAesKey.expandKey().then((aesKey) => {
      if (!subtle) {
        return Promise.reject(new Error("web crypto not initialized"));
      }
      this.logOnce("WebCrypto AES decrypt");
      const crypto = new AESCrypto(subtle, new Uint8Array(iv));
      return crypto.decrypt(data.buffer, aesKey);
    }).catch((err) => {
      logger.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${err.name}: ${err.message}`);
      return this.onWebCryptoError(data, key, iv);
    });
  }
  onWebCryptoError(data, key, iv) {
    this.useSoftware = true;
    this.logEnabled = true;
    this.softwareDecrypt(data, key, iv);
    const decryptResult = this.flush();
    if (decryptResult) {
      return decryptResult.buffer;
    }
    throw new Error("WebCrypto and softwareDecrypt: failed to decrypt data");
  }
  getValidChunk(data) {
    let currentChunk = data;
    const splitPoint = data.length - data.length % CHUNK_SIZE;
    if (splitPoint !== data.length) {
      currentChunk = sliceUint8(data, 0, splitPoint);
      this.remainderData = sliceUint8(data, splitPoint);
    }
    return currentChunk;
  }
  logOnce(msg) {
    if (!this.logEnabled) {
      return;
    }
    logger.log(`[decrypter]: ${msg}`);
    this.logEnabled = false;
  }
};
var TimeRanges = {
  toString: function(r2) {
    let log2 = "";
    const len = r2.length;
    for (let i = 0; i < len; i++) {
      log2 += `[${r2.start(i).toFixed(3)}-${r2.end(i).toFixed(3)}]`;
    }
    return log2;
  }
};
var State = {
  STOPPED: "STOPPED",
  IDLE: "IDLE",
  KEY_LOADING: "KEY_LOADING",
  FRAG_LOADING: "FRAG_LOADING",
  FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
  WAITING_TRACK: "WAITING_TRACK",
  PARSING: "PARSING",
  PARSED: "PARSED",
  ENDED: "ENDED",
  ERROR: "ERROR",
  WAITING_INIT_PTS: "WAITING_INIT_PTS",
  WAITING_LEVEL: "WAITING_LEVEL"
};
var BaseStreamController = class extends TaskLoop {
  constructor(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {
    super();
    this.hls = void 0;
    this.fragPrevious = null;
    this.fragCurrent = null;
    this.fragmentTracker = void 0;
    this.transmuxer = null;
    this._state = State.STOPPED;
    this.playlistType = void 0;
    this.media = null;
    this.mediaBuffer = null;
    this.config = void 0;
    this.bitrateTest = false;
    this.lastCurrentTime = 0;
    this.nextLoadPosition = 0;
    this.startPosition = 0;
    this.startTimeOffset = null;
    this.loadedmetadata = false;
    this.retryDate = 0;
    this.levels = null;
    this.fragmentLoader = void 0;
    this.keyLoader = void 0;
    this.levelLastLoaded = null;
    this.startFragRequested = false;
    this.decrypter = void 0;
    this.initPTS = [];
    this.onvseeking = null;
    this.onvended = null;
    this.logPrefix = "";
    this.log = void 0;
    this.warn = void 0;
    this.playlistType = playlistType;
    this.logPrefix = logPrefix;
    this.log = logger.log.bind(logger, `${logPrefix}:`);
    this.warn = logger.warn.bind(logger, `${logPrefix}:`);
    this.hls = hls;
    this.fragmentLoader = new FragmentLoader(hls.config);
    this.keyLoader = keyLoader;
    this.fragmentTracker = fragmentTracker;
    this.config = hls.config;
    this.decrypter = new Decrypter(hls.config);
    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
  }
  doTick() {
    this.onTickEnd();
  }
  onTickEnd() {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  startLoad(startPosition) {
  }
  stopLoad() {
    this.fragmentLoader.abort();
    this.keyLoader.abort(this.playlistType);
    const frag = this.fragCurrent;
    if (frag != null && frag.loader) {
      frag.abortRequests();
      this.fragmentTracker.removeFragment(frag);
    }
    this.resetTransmuxer();
    this.fragCurrent = null;
    this.fragPrevious = null;
    this.clearInterval();
    this.clearNextTick();
    this.state = State.STOPPED;
  }
  _streamEnded(bufferInfo, levelDetails) {
    if (levelDetails.live || bufferInfo.nextStart || !bufferInfo.end || !this.media) {
      return false;
    }
    const partList = levelDetails.partList;
    if (partList != null && partList.length) {
      const lastPart = partList[partList.length - 1];
      const lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);
      return lastPartBuffered;
    }
    const playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;
    return this.fragmentTracker.isEndListAppended(playlistType);
  }
  getLevelDetails() {
    if (this.levels && this.levelLastLoaded !== null) {
      var _this$levels$this$lev;
      return (_this$levels$this$lev = this.levels[this.levelLastLoaded]) == null ? void 0 : _this$levels$this$lev.details;
    }
  }
  onMediaAttached(event, data) {
    const media = this.media = this.mediaBuffer = data.media;
    this.onvseeking = this.onMediaSeeking.bind(this);
    this.onvended = this.onMediaEnded.bind(this);
    media.addEventListener("seeking", this.onvseeking);
    media.addEventListener("ended", this.onvended);
    const config = this.config;
    if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {
      this.startLoad(config.startPosition);
    }
  }
  onMediaDetaching() {
    const media = this.media;
    if (media != null && media.ended) {
      this.log("MSE detaching and video ended, reset startPosition");
      this.startPosition = this.lastCurrentTime = 0;
    }
    if (media && this.onvseeking && this.onvended) {
      media.removeEventListener("seeking", this.onvseeking);
      media.removeEventListener("ended", this.onvended);
      this.onvseeking = this.onvended = null;
    }
    if (this.keyLoader) {
      this.keyLoader.detach();
    }
    this.media = this.mediaBuffer = null;
    this.loadedmetadata = false;
    this.fragmentTracker.removeAllFragments();
    this.stopLoad();
  }
  onMediaSeeking() {
    const {
      config,
      fragCurrent,
      media,
      mediaBuffer,
      state
    } = this;
    const currentTime = media ? media.currentTime : 0;
    const bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);
    this.log(`media seeking to ${isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime}, state: ${state}`);
    if (this.state === State.ENDED) {
      this.resetLoadingState();
    } else if (fragCurrent) {
      const tolerance = config.maxFragLookUpTolerance;
      const fragStartOffset = fragCurrent.start - tolerance;
      const fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
      if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {
        const pastFragment = currentTime > fragEndOffset;
        if (currentTime < fragStartOffset || pastFragment) {
          if (pastFragment && fragCurrent.loader) {
            this.log("seeking outside of buffer while fragment load in progress, cancel fragment load");
            fragCurrent.abortRequests();
            this.resetLoadingState();
          }
          this.fragPrevious = null;
        }
      }
    }
    if (media) {
      this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);
      this.lastCurrentTime = currentTime;
    }
    if (!this.loadedmetadata && !bufferInfo.len) {
      this.nextLoadPosition = this.startPosition = currentTime;
    }
    this.tickImmediate();
  }
  onMediaEnded() {
    this.startPosition = this.lastCurrentTime = 0;
  }
  onManifestLoaded(event, data) {
    this.startTimeOffset = data.startTimeOffset;
    this.initPTS = [];
  }
  onHandlerDestroying() {
    this.stopLoad();
    super.onHandlerDestroying();
  }
  onHandlerDestroyed() {
    this.state = State.STOPPED;
    if (this.fragmentLoader) {
      this.fragmentLoader.destroy();
    }
    if (this.keyLoader) {
      this.keyLoader.destroy();
    }
    if (this.decrypter) {
      this.decrypter.destroy();
    }
    this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;
    super.onHandlerDestroyed();
  }
  loadFragment(frag, level, targetBufferTime) {
    this._loadFragForPlayback(frag, level, targetBufferTime);
  }
  _loadFragForPlayback(frag, level, targetBufferTime) {
    const progressCallback = (data) => {
      if (this.fragContextChanged(frag)) {
        this.warn(`Fragment ${frag.sn}${data.part ? " p: " + data.part.index : ""} of level ${frag.level} was dropped during download.`);
        this.fragmentTracker.removeFragment(frag);
        return;
      }
      frag.stats.chunkCount++;
      this._handleFragmentLoadProgress(data);
    };
    this._doFragLoad(frag, level, targetBufferTime, progressCallback).then((data) => {
      if (!data) {
        return;
      }
      const state = this.state;
      if (this.fragContextChanged(frag)) {
        if (state === State.FRAG_LOADING || !this.fragCurrent && state === State.PARSING) {
          this.fragmentTracker.removeFragment(frag);
          this.state = State.IDLE;
        }
        return;
      }
      if ("payload" in data) {
        this.log(`Loaded fragment ${frag.sn} of level ${frag.level}`);
        this.hls.trigger(Events.FRAG_LOADED, data);
      }
      this._handleFragmentLoadComplete(data);
    }).catch((reason) => {
      if (this.state === State.STOPPED || this.state === State.ERROR) {
        return;
      }
      this.warn(reason);
      this.resetFragmentLoading(frag);
    });
  }
  clearTrackerIfNeeded(frag) {
    var _this$mediaBuffer;
    const {
      fragmentTracker
    } = this;
    const fragState = fragmentTracker.getState(frag);
    if (fragState === FragmentState.APPENDING) {
      const playlistType = frag.type;
      const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);
      const minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);
      if (this.reduceMaxBufferLength(minForwardBufferLength)) {
        fragmentTracker.removeFragment(frag);
      }
    } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {
      fragmentTracker.removeAllFragments();
    } else if (fragmentTracker.hasParts(frag.type)) {
      fragmentTracker.detectPartialFragments({
        frag,
        part: null,
        stats: frag.stats,
        id: frag.type
      });
      if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {
        fragmentTracker.removeFragment(frag);
      }
    }
  }
  checkLiveUpdate(details) {
    if (details.updated && !details.live) {
      const lastFragment = details.fragments[details.fragments.length - 1];
      this.fragmentTracker.detectPartialFragments({
        frag: lastFragment,
        part: null,
        stats: lastFragment.stats,
        id: lastFragment.type
      });
    }
    if (!details.fragments[0]) {
      details.deltaUpdateFailed = true;
    }
  }
  flushMainBuffer(startOffset, endOffset, type2 = null) {
    if (!(startOffset - endOffset)) {
      return;
    }
    const flushScope = {
      startOffset,
      endOffset,
      type: type2
    };
    this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);
  }
  _loadInitSegment(frag, level) {
    this._doFragLoad(frag, level).then((data) => {
      if (!data || this.fragContextChanged(frag) || !this.levels) {
        throw new Error("init load aborted");
      }
      return data;
    }).then((data) => {
      const {
        hls
      } = this;
      const {
        payload
      } = data;
      const decryptData = frag.decryptdata;
      if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === "AES-128") {
        const startTime = self.performance.now();
        return this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch((err) => {
          hls.trigger(Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.FRAG_DECRYPT_ERROR,
            fatal: false,
            error: err,
            reason: err.message,
            frag
          });
          throw err;
        }).then((decryptedData) => {
          const endTime = self.performance.now();
          hls.trigger(Events.FRAG_DECRYPTED, {
            frag,
            payload: decryptedData,
            stats: {
              tstart: startTime,
              tdecrypt: endTime
            }
          });
          data.payload = decryptedData;
          return data;
        });
      }
      return data;
    }).then((data) => {
      const {
        fragCurrent,
        hls,
        levels
      } = this;
      if (!levels) {
        throw new Error("init load aborted, missing levels");
      }
      const stats = frag.stats;
      this.state = State.IDLE;
      level.fragmentError = 0;
      frag.data = new Uint8Array(data.payload);
      stats.parsing.start = stats.buffering.start = self.performance.now();
      stats.parsing.end = stats.buffering.end = self.performance.now();
      if (data.frag === fragCurrent) {
        hls.trigger(Events.FRAG_BUFFERED, {
          stats,
          frag: fragCurrent,
          part: null,
          id: frag.type
        });
      }
      this.tick();
    }).catch((reason) => {
      if (this.state === State.STOPPED || this.state === State.ERROR) {
        return;
      }
      this.warn(reason);
      this.resetFragmentLoading(frag);
    });
  }
  fragContextChanged(frag) {
    const {
      fragCurrent
    } = this;
    return !frag || !fragCurrent || frag.level !== fragCurrent.level || frag.sn !== fragCurrent.sn || frag.urlId !== fragCurrent.urlId;
  }
  fragBufferedComplete(frag, part) {
    var _frag$startPTS, _frag$endPTS, _this$fragCurrent, _this$fragPrevious;
    const media = this.mediaBuffer ? this.mediaBuffer : this.media;
    this.log(`Buffered ${frag.type} sn: ${frag.sn}${part ? " part: " + part.index : ""} of ${this.playlistType === PlaylistLevelType.MAIN ? "level" : "track"} ${frag.level} (frag:[${((_frag$startPTS = frag.startPTS) != null ? _frag$startPTS : NaN).toFixed(3)}-${((_frag$endPTS = frag.endPTS) != null ? _frag$endPTS : NaN).toFixed(3)}] > buffer:${media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : "(detached)"})`);
    this.state = State.IDLE;
    if (!media) {
      return;
    }
    if (!this.loadedmetadata && frag.type == PlaylistLevelType.MAIN && media.buffered.length && ((_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.sn) === ((_this$fragPrevious = this.fragPrevious) == null ? void 0 : _this$fragPrevious.sn)) {
      this.loadedmetadata = true;
      this.seekToStartPos();
    }
    this.tick();
  }
  seekToStartPos() {
  }
  _handleFragmentLoadComplete(fragLoadedEndData) {
    const {
      transmuxer
    } = this;
    if (!transmuxer) {
      return;
    }
    const {
      frag,
      part,
      partsLoaded
    } = fragLoadedEndData;
    const complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some((fragLoaded) => !fragLoaded);
    const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);
    transmuxer.flush(chunkMeta);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _handleFragmentLoadProgress(frag) {
  }
  _doFragLoad(frag, level, targetBufferTime = null, progressCallback) {
    var _frag$decryptdata;
    const details = level == null ? void 0 : level.details;
    if (!this.levels || !details) {
      throw new Error(`frag load aborted, missing level${details ? "" : " detail"}s`);
    }
    let keyLoadingPromise = null;
    if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {
      this.log(`Loading key for ${frag.sn} of [${details.startSN}-${details.endSN}], ${this.logPrefix === "[stream-controller]" ? "level" : "track"} ${frag.level}`);
      this.state = State.KEY_LOADING;
      this.fragCurrent = frag;
      keyLoadingPromise = this.keyLoader.load(frag).then((keyLoadedData) => {
        if (!this.fragContextChanged(keyLoadedData.frag)) {
          this.hls.trigger(Events.KEY_LOADED, keyLoadedData);
          if (this.state === State.KEY_LOADING) {
            this.state = State.IDLE;
          }
          return keyLoadedData;
        }
      });
      this.hls.trigger(Events.KEY_LOADING, {
        frag
      });
      if (this.fragCurrent === null) {
        keyLoadingPromise = Promise.reject(new Error(`frag load aborted, context changed in KEY_LOADING`));
      }
    } else if (!frag.encrypted && details.encryptedFragments.length) {
      this.keyLoader.loadClear(frag, details.encryptedFragments);
    }
    targetBufferTime = Math.max(frag.start, targetBufferTime || 0);
    if (this.config.lowLatencyMode && frag.sn !== "initSegment") {
      const partList = details.partList;
      if (partList && progressCallback) {
        if (targetBufferTime > frag.end && details.fragmentHint) {
          frag = details.fragmentHint;
        }
        const partIndex = this.getNextPart(partList, frag, targetBufferTime);
        if (partIndex > -1) {
          const part = partList[partIndex];
          this.log(`Loading part sn: ${frag.sn} p: ${part.index} cc: ${frag.cc} of playlist [${details.startSN}-${details.endSN}] parts [0-${partIndex}-${partList.length - 1}] ${this.logPrefix === "[stream-controller]" ? "level" : "track"}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);
          this.nextLoadPosition = part.start + part.duration;
          this.state = State.FRAG_LOADING;
          let _result;
          if (keyLoadingPromise) {
            _result = keyLoadingPromise.then((keyLoadedData) => {
              if (!keyLoadedData || this.fragContextChanged(keyLoadedData.frag)) {
                return null;
              }
              return this.doFragPartsLoad(frag, part, level, progressCallback);
            }).catch((error) => this.handleFragLoadError(error));
          } else {
            _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch((error) => this.handleFragLoadError(error));
          }
          this.hls.trigger(Events.FRAG_LOADING, {
            frag,
            part,
            targetBufferTime
          });
          if (this.fragCurrent === null) {
            return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING parts`));
          }
          return _result;
        } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {
          return Promise.resolve(null);
        }
      }
    }
    this.log(`Loading fragment ${frag.sn} cc: ${frag.cc} ${details ? "of [" + details.startSN + "-" + details.endSN + "] " : ""}${this.logPrefix === "[stream-controller]" ? "level" : "track"}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);
    if (isFiniteNumber(frag.sn) && !this.bitrateTest) {
      this.nextLoadPosition = frag.start + frag.duration;
    }
    this.state = State.FRAG_LOADING;
    const dataOnProgress = this.config.progressive;
    let result;
    if (dataOnProgress && keyLoadingPromise) {
      result = keyLoadingPromise.then((keyLoadedData) => {
        if (!keyLoadedData || this.fragContextChanged(keyLoadedData == null ? void 0 : keyLoadedData.frag)) {
          return null;
        }
        return this.fragmentLoader.load(frag, progressCallback);
      }).catch((error) => this.handleFragLoadError(error));
    } else {
      result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : void 0), keyLoadingPromise]).then(([fragLoadedData]) => {
        if (!dataOnProgress && fragLoadedData && progressCallback) {
          progressCallback(fragLoadedData);
        }
        return fragLoadedData;
      }).catch((error) => this.handleFragLoadError(error));
    }
    this.hls.trigger(Events.FRAG_LOADING, {
      frag,
      targetBufferTime
    });
    if (this.fragCurrent === null) {
      return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING`));
    }
    return result;
  }
  doFragPartsLoad(frag, fromPart, level, progressCallback) {
    return new Promise((resolve, reject) => {
      var _level$details;
      const partsLoaded = [];
      const initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;
      const loadPart = (part) => {
        this.fragmentLoader.loadPart(frag, part, progressCallback).then((partLoadedData) => {
          partsLoaded[part.index] = partLoadedData;
          const loadedPart = partLoadedData.part;
          this.hls.trigger(Events.FRAG_LOADED, partLoadedData);
          const nextPart = getPartWith(level, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);
          if (nextPart) {
            loadPart(nextPart);
          } else {
            return resolve({
              frag,
              part: loadedPart,
              partsLoaded
            });
          }
        }).catch(reject);
      };
      loadPart(fromPart);
    });
  }
  handleFragLoadError(error) {
    if ("data" in error) {
      const data = error.data;
      if (error.data && data.details === ErrorDetails.INTERNAL_ABORTED) {
        this.handleFragLoadAborted(data.frag, data.part);
      } else {
        this.hls.trigger(Events.ERROR, data);
      }
    } else {
      this.hls.trigger(Events.ERROR, {
        type: ErrorTypes.OTHER_ERROR,
        details: ErrorDetails.INTERNAL_EXCEPTION,
        err: error,
        error,
        fatal: true
      });
    }
    return null;
  }
  _handleTransmuxerFlush(chunkMeta) {
    const context = this.getCurrentContext(chunkMeta);
    if (!context || this.state !== State.PARSING) {
      if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {
        this.state = State.IDLE;
      }
      return;
    }
    const {
      frag,
      part,
      level
    } = context;
    const now2 = self.performance.now();
    frag.stats.parsing.end = now2;
    if (part) {
      part.stats.parsing.end = now2;
    }
    this.updateLevelTiming(frag, part, level, chunkMeta.partial);
  }
  getCurrentContext(chunkMeta) {
    const {
      levels,
      fragCurrent
    } = this;
    const {
      level: levelIndex,
      sn,
      part: partIndex
    } = chunkMeta;
    if (!(levels != null && levels[levelIndex])) {
      this.warn(`Levels object was unset while buffering fragment ${sn} of level ${levelIndex}. The current chunk will not be buffered.`);
      return null;
    }
    const level = levels[levelIndex];
    const part = partIndex > -1 ? getPartWith(level, sn, partIndex) : null;
    const frag = part ? part.fragment : getFragmentWithSN(level, sn, fragCurrent);
    if (!frag) {
      return null;
    }
    if (fragCurrent && fragCurrent !== frag) {
      frag.stats = fragCurrent.stats;
    }
    return {
      frag,
      part,
      level
    };
  }
  bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {
    var _buffer;
    if (!data || this.state !== State.PARSING) {
      return;
    }
    const {
      data1,
      data2
    } = data;
    let buffer = data1;
    if (data1 && data2) {
      buffer = appendUint8Array(data1, data2);
    }
    if (!((_buffer = buffer) != null && _buffer.length)) {
      return;
    }
    const segment = {
      type: data.type,
      frag,
      part,
      chunkMeta,
      parent: frag.type,
      data: buffer
    };
    this.hls.trigger(Events.BUFFER_APPENDING, segment);
    if (data.dropped && data.independent && !part) {
      if (noBacktracking) {
        return;
      }
      this.flushBufferGap(frag);
    }
  }
  flushBufferGap(frag) {
    const media = this.media;
    if (!media) {
      return;
    }
    if (!BufferHelper.isBuffered(media, media.currentTime)) {
      this.flushMainBuffer(0, frag.start);
      return;
    }
    const currentTime = media.currentTime;
    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
    const fragDuration = frag.duration;
    const segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);
    const start2 = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);
    if (frag.start - start2 > segmentFraction) {
      this.flushMainBuffer(start2, frag.start);
    }
  }
  getFwdBufferInfo(bufferable, type2) {
    const pos = this.getLoadPosition();
    if (!isFiniteNumber(pos)) {
      return null;
    }
    return this.getFwdBufferInfoAtPos(bufferable, pos, type2);
  }
  getFwdBufferInfoAtPos(bufferable, pos, type2) {
    const {
      config: {
        maxBufferHole
      }
    } = this;
    const bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);
    if (bufferInfo.len === 0 && bufferInfo.nextStart !== void 0) {
      const bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type2);
      if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {
        return BufferHelper.bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, maxBufferHole));
      }
    }
    return bufferInfo;
  }
  getMaxBufferLength(levelBitrate) {
    const {
      config
    } = this;
    let maxBufLen;
    if (levelBitrate) {
      maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
    } else {
      maxBufLen = config.maxBufferLength;
    }
    return Math.min(maxBufLen, config.maxMaxBufferLength);
  }
  reduceMaxBufferLength(threshold) {
    const config = this.config;
    const minLength = threshold || config.maxBufferLength;
    if (config.maxMaxBufferLength >= minLength) {
      config.maxMaxBufferLength /= 2;
      this.warn(`Reduce max buffer length to ${config.maxMaxBufferLength}s`);
      return true;
    }
    return false;
  }
  getAppendedFrag(position, playlistType = PlaylistLevelType.MAIN) {
    const fragOrPart = this.fragmentTracker.getAppendedFrag(position, PlaylistLevelType.MAIN);
    if (fragOrPart && "fragment" in fragOrPart) {
      return fragOrPart.fragment;
    }
    return fragOrPart;
  }
  getNextFragment(pos, levelDetails) {
    const fragments = levelDetails.fragments;
    const fragLen = fragments.length;
    if (!fragLen) {
      return null;
    }
    const {
      config
    } = this;
    const start2 = fragments[0].start;
    let frag;
    if (levelDetails.live) {
      const initialLiveManifestSize = config.initialLiveManifestSize;
      if (fragLen < initialLiveManifestSize) {
        this.warn(`Not enough fragments to start playback (have: ${fragLen}, need: ${initialLiveManifestSize})`);
        return null;
      }
      if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1) {
        frag = this.getInitialLiveFragment(levelDetails, fragments);
        this.startPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;
      }
    } else if (pos <= start2) {
      frag = fragments[0];
    }
    if (!frag) {
      const end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;
      frag = this.getFragmentAtPosition(pos, end, levelDetails);
    }
    return this.mapToInitFragWhenRequired(frag);
  }
  isLoopLoading(frag, targetBufferTime) {
    const trackerState = this.fragmentTracker.getState(frag);
    return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;
  }
  getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {
    const gapStart = frag.gap;
    const nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);
    if (nextFragment === null) {
      return nextFragment;
    }
    frag = nextFragment;
    if (gapStart && frag && !frag.gap && bufferInfo.nextStart) {
      const nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType);
      if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {
        this.log(`buffer full after gaps in "${playlistType}" playlist starting at sn: ${frag.sn}`);
        return null;
      }
    }
    return frag;
  }
  mapToInitFragWhenRequired(frag) {
    if (frag != null && frag.initSegment && !(frag != null && frag.initSegment.data) && !this.bitrateTest) {
      return frag.initSegment;
    }
    return frag;
  }
  getNextPart(partList, frag, targetBufferTime) {
    let nextPart = -1;
    let contiguous = false;
    let independentAttrOmitted = true;
    for (let i = 0, len = partList.length; i < len; i++) {
      const part = partList[i];
      independentAttrOmitted = independentAttrOmitted && !part.independent;
      if (nextPart > -1 && targetBufferTime < part.start) {
        break;
      }
      const loaded = part.loaded;
      if (loaded) {
        nextPart = -1;
      } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {
        nextPart = i;
      }
      contiguous = loaded;
    }
    return nextPart;
  }
  loadedEndOfParts(partList, targetBufferTime) {
    const lastPart = partList[partList.length - 1];
    return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;
  }
  /*
   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the
   "sliding" of the playlist, which is its offset from the start of playback. After sliding we can compute the real
   start and end times for each fragment in the playlist (after which this method will not need to be called).
  */
  getInitialLiveFragment(levelDetails, fragments) {
    const fragPrevious = this.fragPrevious;
    let frag = null;
    if (fragPrevious) {
      if (levelDetails.hasProgramDateTime) {
        this.log(`Live playlist, switching playlist, load frag with same PDT: ${fragPrevious.programDateTime}`);
        frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);
      }
      if (!frag) {
        const targetSN = fragPrevious.sn + 1;
        if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
          const fragNext = fragments[targetSN - levelDetails.startSN];
          if (fragPrevious.cc === fragNext.cc) {
            frag = fragNext;
            this.log(`Live playlist, switching playlist, load frag with next SN: ${frag.sn}`);
          }
        }
        if (!frag) {
          frag = findFragWithCC(fragments, fragPrevious.cc);
          if (frag) {
            this.log(`Live playlist, switching playlist, load frag with same CC: ${frag.sn}`);
          }
        }
      }
    } else {
      const liveStart = this.hls.liveSyncPosition;
      if (liveStart !== null) {
        frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);
      }
    }
    return frag;
  }
  /*
  This method finds the best matching fragment given the provided position.
   */
  getFragmentAtPosition(bufferEnd, end, levelDetails) {
    const {
      config
    } = this;
    let {
      fragPrevious
    } = this;
    let {
      fragments,
      endSN
    } = levelDetails;
    const {
      fragmentHint
    } = levelDetails;
    const tolerance = config.maxFragLookUpTolerance;
    const partList = levelDetails.partList;
    const loadingParts = !!(config.lowLatencyMode && partList != null && partList.length && fragmentHint);
    if (loadingParts && fragmentHint && !this.bitrateTest) {
      fragments = fragments.concat(fragmentHint);
      endSN = fragmentHint.sn;
    }
    let frag;
    if (bufferEnd < end) {
      const lookupTolerance = bufferEnd > end - tolerance ? 0 : tolerance;
      frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);
    } else {
      frag = fragments[fragments.length - 1];
    }
    if (frag) {
      const curSNIdx = frag.sn - levelDetails.startSN;
      const fragState = this.fragmentTracker.getState(frag);
      if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {
        fragPrevious = frag;
      }
      if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn)) {
        const sameLevel = fragPrevious && frag.level === fragPrevious.level;
        if (sameLevel) {
          const nextFrag = fragments[curSNIdx + 1];
          if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {
            frag = nextFrag;
          } else {
            frag = null;
          }
        }
      }
    }
    return frag;
  }
  synchronizeToLiveEdge(levelDetails) {
    const {
      config,
      media
    } = this;
    if (!media) {
      return;
    }
    const liveSyncPosition = this.hls.liveSyncPosition;
    const currentTime = media.currentTime;
    const start2 = levelDetails.fragments[0].start;
    const end = levelDetails.edge;
    const withinSlidingWindow = currentTime >= start2 - config.maxFragLookUpTolerance && currentTime <= end;
    if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {
      const maxLatency = config.liveMaxLatencyDuration !== void 0 ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;
      if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {
        if (!this.loadedmetadata) {
          this.nextLoadPosition = liveSyncPosition;
        }
        if (media.readyState) {
          this.warn(`Playback: ${currentTime.toFixed(3)} is located too far from the end of live sliding playlist: ${end}, reset currentTime to : ${liveSyncPosition.toFixed(3)}`);
          media.currentTime = liveSyncPosition;
        }
      }
    }
  }
  alignPlaylists(details, previousDetails) {
    const {
      levels,
      levelLastLoaded,
      fragPrevious
    } = this;
    const lastLevel = levelLastLoaded !== null ? levels[levelLastLoaded] : null;
    const length = details.fragments.length;
    if (!length) {
      this.warn(`No fragments in live playlist`);
      return 0;
    }
    const slidingStart = details.fragments[0].start;
    const firstLevelLoad = !previousDetails;
    const aligned = details.alignedSliding && isFiniteNumber(slidingStart);
    if (firstLevelLoad || !aligned && !slidingStart) {
      alignStream(fragPrevious, lastLevel, details);
      const alignedSlidingStart = details.fragments[0].start;
      this.log(`Live playlist sliding: ${alignedSlidingStart.toFixed(2)} start-sn: ${previousDetails ? previousDetails.startSN : "na"}->${details.startSN} prev-sn: ${fragPrevious ? fragPrevious.sn : "na"} fragments: ${length}`);
      return alignedSlidingStart;
    }
    return slidingStart;
  }
  waitForCdnTuneIn(details) {
    const advancePartLimit = 3;
    return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);
  }
  setStartPosition(details, sliding) {
    let startPosition = this.startPosition;
    if (startPosition < sliding) {
      startPosition = -1;
    }
    if (startPosition === -1 || this.lastCurrentTime === -1) {
      const offsetInMultivariantPlaylist = this.startTimeOffset !== null;
      const startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;
      if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {
        startPosition = sliding + startTimeOffset;
        if (startTimeOffset < 0) {
          startPosition += details.totalduration;
        }
        startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);
        this.log(`Start time offset ${startTimeOffset} found in ${offsetInMultivariantPlaylist ? "multivariant" : "media"} playlist, adjust startPosition to ${startPosition}`);
        this.startPosition = startPosition;
      } else if (details.live) {
        startPosition = this.hls.liveSyncPosition || sliding;
      } else {
        this.startPosition = startPosition = 0;
      }
      this.lastCurrentTime = startPosition;
    }
    this.nextLoadPosition = startPosition;
  }
  getLoadPosition() {
    const {
      media
    } = this;
    let pos = 0;
    if (this.loadedmetadata && media) {
      pos = media.currentTime;
    } else if (this.nextLoadPosition) {
      pos = this.nextLoadPosition;
    }
    return pos;
  }
  handleFragLoadAborted(frag, part) {
    if (this.transmuxer && frag.sn !== "initSegment" && frag.stats.aborted) {
      this.warn(`Fragment ${frag.sn}${part ? " part " + part.index : ""} of level ${frag.level} was aborted`);
      this.resetFragmentLoading(frag);
    }
  }
  resetFragmentLoading(frag) {
    if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {
      this.state = State.IDLE;
    }
  }
  onFragmentOrKeyLoadError(filterType, data) {
    if (data.chunkMeta && !data.frag) {
      const context = this.getCurrentContext(data.chunkMeta);
      if (context) {
        data.frag = context.frag;
      }
    }
    const frag = data.frag;
    if (!frag || frag.type !== filterType || !this.levels) {
      return;
    }
    if (this.fragContextChanged(frag)) {
      var _this$fragCurrent2;
      this.warn(`Frag load error must match current frag to retry ${frag.url} > ${(_this$fragCurrent2 = this.fragCurrent) == null ? void 0 : _this$fragCurrent2.url}`);
      return;
    }
    const gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;
    if (gapTagEncountered) {
      this.fragmentTracker.fragBuffered(frag, true);
    }
    const errorAction = data.errorAction;
    const {
      action,
      retryCount = 0,
      retryConfig
    } = errorAction || {};
    if (errorAction && action === NetworkErrorAction.RetryRequest && retryConfig) {
      var _this$levelLastLoaded;
      this.resetStartWhenNotLoaded((_this$levelLastLoaded = this.levelLastLoaded) != null ? _this$levelLastLoaded : frag.level);
      const delay = getRetryDelay(retryConfig, retryCount);
      this.warn(`Fragment ${frag.sn} of ${filterType} ${frag.level} errored with ${data.details}, retrying loading ${retryCount + 1}/${retryConfig.maxNumRetry} in ${delay}ms`);
      errorAction.resolved = true;
      this.retryDate = self.performance.now() + delay;
      this.state = State.FRAG_LOADING_WAITING_RETRY;
    } else if (retryConfig && errorAction) {
      this.resetFragmentErrors(filterType);
      if (retryCount < retryConfig.maxNumRetry) {
        if (!gapTagEncountered) {
          errorAction.resolved = true;
        }
      } else {
        logger.warn(`${data.details} reached or exceeded max retry (${retryCount})`);
      }
    } else if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox) {
      this.state = State.WAITING_LEVEL;
    } else {
      this.state = State.ERROR;
    }
    this.tickImmediate();
  }
  reduceLengthAndFlushBuffer(data) {
    if (this.state === State.PARSING || this.state === State.PARSED) {
      const playlistType = data.parent;
      const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);
      const buffered = bufferedInfo && bufferedInfo.len > 0.5;
      if (buffered) {
        this.reduceMaxBufferLength(bufferedInfo.len);
      }
      const flushBuffer = !buffered;
      if (flushBuffer) {
        this.warn(`Buffer full error while media.currentTime is not buffered, flush ${playlistType} buffer`);
      }
      if (data.frag) {
        this.fragmentTracker.removeFragment(data.frag);
        this.nextLoadPosition = data.frag.start;
      }
      this.resetLoadingState();
      return flushBuffer;
    }
    return false;
  }
  resetFragmentErrors(filterType) {
    if (filterType === PlaylistLevelType.AUDIO) {
      this.fragCurrent = null;
    }
    if (!this.loadedmetadata) {
      this.startFragRequested = false;
    }
    if (this.state !== State.STOPPED) {
      this.state = State.IDLE;
    }
  }
  afterBufferFlushed(media, bufferType, playlistType) {
    if (!media) {
      return;
    }
    const bufferedTimeRanges = BufferHelper.getBuffered(media);
    this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);
    if (this.state === State.ENDED) {
      this.resetLoadingState();
    }
  }
  resetLoadingState() {
    this.log("Reset loading state");
    this.fragCurrent = null;
    this.fragPrevious = null;
    this.state = State.IDLE;
  }
  resetStartWhenNotLoaded(level) {
    if (!this.loadedmetadata) {
      this.startFragRequested = false;
      const details = this.levels ? this.levels[level].details : null;
      if (details != null && details.live) {
        this.startPosition = -1;
        this.setStartPosition(details, 0);
        this.resetLoadingState();
      } else {
        this.nextLoadPosition = this.startPosition;
      }
    }
  }
  resetWhenMissingContext(chunkMeta) {
    var _this$levelLastLoaded2;
    this.warn(`The loading context changed while buffering fragment ${chunkMeta.sn} of level ${chunkMeta.level}. This chunk will not be buffered.`);
    this.removeUnbufferedFrags();
    this.resetStartWhenNotLoaded((_this$levelLastLoaded2 = this.levelLastLoaded) != null ? _this$levelLastLoaded2 : chunkMeta.level);
    this.resetLoadingState();
  }
  removeUnbufferedFrags(start2 = 0) {
    this.fragmentTracker.removeFragmentsInRange(start2, Infinity, this.playlistType, false, true);
  }
  updateLevelTiming(frag, part, level, partial) {
    var _this$transmuxer;
    const details = level.details;
    if (!details) {
      this.warn("level.details undefined");
      return;
    }
    const parsed = Object.keys(frag.elementaryStreams).reduce((result, type2) => {
      const info = frag.elementaryStreams[type2];
      if (info) {
        const parsedDuration = info.endPTS - info.startPTS;
        if (parsedDuration <= 0) {
          this.warn(`Could not parse fragment ${frag.sn} ${type2} duration reliably (${parsedDuration})`);
          return result || false;
        }
        const drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);
        this.hls.trigger(Events.LEVEL_PTS_UPDATED, {
          details,
          level,
          drift,
          type: type2,
          frag,
          start: info.startPTS,
          end: info.endPTS
        });
        return true;
      }
      return result;
    }, false);
    if (parsed) {
      level.fragmentError = 0;
    } else if (((_this$transmuxer = this.transmuxer) == null ? void 0 : _this$transmuxer.error) === null) {
      const error = new Error(`Found no media in fragment ${frag.sn} of level ${frag.level} resetting transmuxer to fallback to playlist timing`);
      if (level.fragmentError === 0) {
        level.fragmentError++;
        frag.gap = true;
        this.fragmentTracker.removeFragment(frag);
        this.fragmentTracker.fragBuffered(frag, true);
      }
      this.warn(error.message);
      this.hls.trigger(Events.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.FRAG_PARSING_ERROR,
        fatal: false,
        error,
        frag,
        reason: `Found no media in msn ${frag.sn} of level "${level.url}"`
      });
      if (!this.hls) {
        return;
      }
      this.resetTransmuxer();
    }
    this.state = State.PARSED;
    this.hls.trigger(Events.FRAG_PARSED, {
      frag,
      part
    });
  }
  resetTransmuxer() {
    if (this.transmuxer) {
      this.transmuxer.destroy();
      this.transmuxer = null;
    }
  }
  recoverWorkerError(data) {
    if (data.event === "demuxerWorker") {
      var _ref, _this$levelLastLoaded3, _this$fragCurrent3;
      this.fragmentTracker.removeAllFragments();
      this.resetTransmuxer();
      this.resetStartWhenNotLoaded((_ref = (_this$levelLastLoaded3 = this.levelLastLoaded) != null ? _this$levelLastLoaded3 : (_this$fragCurrent3 = this.fragCurrent) == null ? void 0 : _this$fragCurrent3.level) != null ? _ref : 0);
      this.resetLoadingState();
    }
  }
  set state(nextState) {
    const previousState = this._state;
    if (previousState !== nextState) {
      this._state = nextState;
      this.log(`${previousState}->${nextState}`);
    }
  }
  get state() {
    return this._state;
  }
};
function getSourceBuffer() {
  return self.SourceBuffer || self.WebKitSourceBuffer;
}
function isSupported() {
  const mediaSource = getMediaSource();
  if (!mediaSource) {
    return false;
  }
  const sourceBuffer = getSourceBuffer();
  const isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === "function" && mediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
  const sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === "function" && typeof sourceBuffer.prototype.remove === "function";
  return !!isTypeSupported && !!sourceBufferValidAPI;
}
function changeTypeSupported() {
  var _sourceBuffer$prototy;
  const sourceBuffer = getSourceBuffer();
  return typeof (sourceBuffer == null ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? void 0 : _sourceBuffer$prototy.changeType) === "function";
}
function hasUMDWorker() {
  return typeof __HLS_WORKER_BUNDLE__ === "function";
}
function injectWorker() {
  const blob = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {
    type: "text/javascript"
  });
  const objectURL = self.URL.createObjectURL(blob);
  const worker = new self.Worker(objectURL);
  return {
    worker,
    objectURL
  };
}
function loadWorker(path) {
  const scriptURL = new self.URL(path, self.location.href).href;
  const worker = new self.Worker(scriptURL);
  return {
    worker,
    scriptURL
  };
}
function dummyTrack(type2 = "", inputTimeScale = 9e4) {
  return {
    type: type2,
    id: -1,
    pid: -1,
    inputTimeScale,
    sequenceNumber: -1,
    samples: [],
    dropped: 0
  };
}
var BaseAudioDemuxer = class {
  constructor() {
    this._audioTrack = void 0;
    this._id3Track = void 0;
    this.frameIndex = 0;
    this.cachedData = null;
    this.basePTS = null;
    this.initPTS = null;
    this.lastPTS = null;
  }
  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
    this._id3Track = {
      type: "id3",
      id: 3,
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0
    };
  }
  resetTimeStamp(deaultTimestamp) {
    this.initPTS = deaultTimestamp;
    this.resetContiguity();
  }
  resetContiguity() {
    this.basePTS = null;
    this.lastPTS = null;
    this.frameIndex = 0;
  }
  canParse(data, offset) {
    return false;
  }
  appendFrame(track, data, offset) {
  }
  // feed incoming data to the front of the parsing pipeline
  demux(data, timeOffset) {
    if (this.cachedData) {
      data = appendUint8Array(this.cachedData, data);
      this.cachedData = null;
    }
    let id3Data = getID3Data(data, 0);
    let offset = id3Data ? id3Data.length : 0;
    let lastDataIndex;
    const track = this._audioTrack;
    const id3Track = this._id3Track;
    const timestamp = id3Data ? getTimeStamp(id3Data) : void 0;
    const length = data.length;
    if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {
      this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);
      this.lastPTS = this.basePTS;
    }
    if (this.lastPTS === null) {
      this.lastPTS = this.basePTS;
    }
    if (id3Data && id3Data.length > 0) {
      id3Track.samples.push({
        pts: this.lastPTS,
        dts: this.lastPTS,
        data: id3Data,
        type: MetadataSchema.audioId3,
        duration: Number.POSITIVE_INFINITY
      });
    }
    while (offset < length) {
      if (this.canParse(data, offset)) {
        const frame = this.appendFrame(track, data, offset);
        if (frame) {
          this.frameIndex++;
          this.lastPTS = frame.sample.pts;
          offset += frame.length;
          lastDataIndex = offset;
        } else {
          offset = length;
        }
      } else if (canParse$2(data, offset)) {
        id3Data = getID3Data(data, offset);
        id3Track.samples.push({
          pts: this.lastPTS,
          dts: this.lastPTS,
          data: id3Data,
          type: MetadataSchema.audioId3,
          duration: Number.POSITIVE_INFINITY
        });
        offset += id3Data.length;
        lastDataIndex = offset;
      } else {
        offset++;
      }
      if (offset === length && lastDataIndex !== length) {
        const partialData = sliceUint8(data, lastDataIndex);
        if (this.cachedData) {
          this.cachedData = appendUint8Array(this.cachedData, partialData);
        } else {
          this.cachedData = partialData;
        }
      }
    }
    return {
      audioTrack: track,
      videoTrack: dummyTrack(),
      id3Track,
      textTrack: dummyTrack()
    };
  }
  demuxSampleAes(data, keyData, timeOffset) {
    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));
  }
  flush(timeOffset) {
    const cachedData = this.cachedData;
    if (cachedData) {
      this.cachedData = null;
      this.demux(cachedData, 0);
    }
    return {
      audioTrack: this._audioTrack,
      videoTrack: dummyTrack(),
      id3Track: this._id3Track,
      textTrack: dummyTrack()
    };
  }
  destroy() {
  }
};
var initPTSFn = (timestamp, timeOffset, initPTS) => {
  if (isFiniteNumber(timestamp)) {
    return timestamp * 90;
  }
  const init90kHz = initPTS ? initPTS.baseTime * 9e4 / initPTS.timescale : 0;
  return timeOffset * 9e4 + init90kHz;
};
function getAudioConfig(observer, data, offset, audioCodec) {
  let adtsObjectType;
  let adtsExtensionSamplingIndex;
  let adtsChannelConfig;
  let config;
  const userAgent = navigator.userAgent.toLowerCase();
  const manifestCodec = audioCodec;
  const adtsSamplingRates = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
  adtsObjectType = ((data[offset + 2] & 192) >>> 6) + 1;
  const adtsSamplingIndex = (data[offset + 2] & 60) >>> 2;
  if (adtsSamplingIndex > adtsSamplingRates.length - 1) {
    observer.trigger(Events.ERROR, {
      type: ErrorTypes.MEDIA_ERROR,
      details: ErrorDetails.FRAG_PARSING_ERROR,
      fatal: true,
      reason: `invalid ADTS sampling index:${adtsSamplingIndex}`
    });
    return;
  }
  adtsChannelConfig = (data[offset + 2] & 1) << 2;
  adtsChannelConfig |= (data[offset + 3] & 192) >>> 6;
  logger.log(`manifest codec:${audioCodec}, ADTS type:${adtsObjectType}, samplingIndex:${adtsSamplingIndex}`);
  if (/firefox/i.test(userAgent)) {
    if (adtsSamplingIndex >= 6) {
      adtsObjectType = 5;
      config = new Array(4);
      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;
    } else {
      adtsObjectType = 2;
      config = new Array(2);
      adtsExtensionSamplingIndex = adtsSamplingIndex;
    }
  } else if (userAgent.indexOf("android") !== -1) {
    adtsObjectType = 2;
    config = new Array(2);
    adtsExtensionSamplingIndex = adtsSamplingIndex;
  } else {
    adtsObjectType = 5;
    config = new Array(4);
    if (audioCodec && (audioCodec.indexOf("mp4a.40.29") !== -1 || audioCodec.indexOf("mp4a.40.5") !== -1) || !audioCodec && adtsSamplingIndex >= 6) {
      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;
    } else {
      if (audioCodec && audioCodec.indexOf("mp4a.40.2") !== -1 && (adtsSamplingIndex >= 6 && adtsChannelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChannelConfig === 1) {
        adtsObjectType = 2;
        config = new Array(2);
      }
      adtsExtensionSamplingIndex = adtsSamplingIndex;
    }
  }
  config[0] = adtsObjectType << 3;
  config[0] |= (adtsSamplingIndex & 14) >> 1;
  config[1] |= (adtsSamplingIndex & 1) << 7;
  config[1] |= adtsChannelConfig << 3;
  if (adtsObjectType === 5) {
    config[1] |= (adtsExtensionSamplingIndex & 14) >> 1;
    config[2] = (adtsExtensionSamplingIndex & 1) << 7;
    config[2] |= 2 << 2;
    config[3] = 0;
  }
  return {
    config,
    samplerate: adtsSamplingRates[adtsSamplingIndex],
    channelCount: adtsChannelConfig,
    codec: "mp4a.40." + adtsObjectType,
    manifestCodec
  };
}
function isHeaderPattern$1(data, offset) {
  return data[offset] === 255 && (data[offset + 1] & 246) === 240;
}
function getHeaderLength(data, offset) {
  return data[offset + 1] & 1 ? 7 : 9;
}
function getFullFrameLength(data, offset) {
  return (data[offset + 3] & 3) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 224) >>> 5;
}
function canGetFrameLength(data, offset) {
  return offset + 5 < data.length;
}
function isHeader$1(data, offset) {
  return offset + 1 < data.length && isHeaderPattern$1(data, offset);
}
function canParse$1(data, offset) {
  return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;
}
function probe$1(data, offset) {
  if (isHeader$1(data, offset)) {
    const headerLength = getHeaderLength(data, offset);
    if (offset + headerLength >= data.length) {
      return false;
    }
    const frameLength = getFullFrameLength(data, offset);
    if (frameLength <= headerLength) {
      return false;
    }
    const newOffset = offset + frameLength;
    return newOffset === data.length || isHeader$1(data, newOffset);
  }
  return false;
}
function initTrackConfig(track, observer, data, offset, audioCodec) {
  if (!track.samplerate) {
    const config = getAudioConfig(observer, data, offset, audioCodec);
    if (!config) {
      return;
    }
    track.config = config.config;
    track.samplerate = config.samplerate;
    track.channelCount = config.channelCount;
    track.codec = config.codec;
    track.manifestCodec = config.manifestCodec;
    logger.log(`parsed codec:${track.codec}, rate:${config.samplerate}, channels:${config.channelCount}`);
  }
}
function getFrameDuration(samplerate) {
  return 1024 * 9e4 / samplerate;
}
function parseFrameHeader(data, offset) {
  const headerLength = getHeaderLength(data, offset);
  if (offset + headerLength <= data.length) {
    const frameLength = getFullFrameLength(data, offset) - headerLength;
    if (frameLength > 0) {
      return {
        headerLength,
        frameLength
      };
    }
  }
}
function appendFrame$1(track, data, offset, pts, frameIndex) {
  const frameDuration = getFrameDuration(track.samplerate);
  const stamp = pts + frameIndex * frameDuration;
  const header = parseFrameHeader(data, offset);
  let unit;
  if (header) {
    const {
      frameLength,
      headerLength
    } = header;
    const _length = headerLength + frameLength;
    const missing = Math.max(0, offset + _length - data.length);
    if (missing) {
      unit = new Uint8Array(_length - headerLength);
      unit.set(data.subarray(offset + headerLength, data.length), 0);
    } else {
      unit = data.subarray(offset + headerLength, offset + _length);
    }
    const _sample = {
      unit,
      pts: stamp
    };
    if (!missing) {
      track.samples.push(_sample);
    }
    return {
      sample: _sample,
      length: _length,
      missing
    };
  }
  const length = data.length - offset;
  unit = new Uint8Array(length);
  unit.set(data.subarray(offset, data.length), 0);
  const sample = {
    unit,
    pts: stamp
  };
  return {
    sample,
    length,
    missing: -1
  };
}
var AACDemuxer = class extends BaseAudioDemuxer {
  constructor(observer, config) {
    super();
    this.observer = void 0;
    this.config = void 0;
    this.observer = observer;
    this.config = config;
  }
  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);
    this._audioTrack = {
      container: "audio/adts",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "aac",
      samples: [],
      manifestCodec: audioCodec,
      duration: trackDuration,
      inputTimeScale: 9e4,
      dropped: 0
    };
  }
  // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS
  static probe(data) {
    if (!data) {
      return false;
    }
    const id3Data = getID3Data(data, 0) || [];
    let offset = id3Data.length;
    for (let length = data.length; offset < length; offset++) {
      if (probe$1(data, offset)) {
        logger.log("ADTS sync word found !");
        return true;
      }
    }
    return false;
  }
  canParse(data, offset) {
    return canParse$1(data, offset);
  }
  appendFrame(track, data, offset) {
    initTrackConfig(track, this.observer, data, offset, track.manifestCodec);
    const frame = appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);
    if (frame && frame.missing === 0) {
      return frame;
    }
  }
};
var emsgSchemePattern = /\/emsg[-/]ID3/i;
var MP4Demuxer = class {
  constructor(observer, config) {
    this.remainderData = null;
    this.timeOffset = 0;
    this.config = void 0;
    this.videoTrack = void 0;
    this.audioTrack = void 0;
    this.id3Track = void 0;
    this.txtTrack = void 0;
    this.config = config;
  }
  resetTimeStamp() {
  }
  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
    const videoTrack = this.videoTrack = dummyTrack("video", 1);
    const audioTrack = this.audioTrack = dummyTrack("audio", 1);
    const captionTrack = this.txtTrack = dummyTrack("text", 1);
    this.id3Track = dummyTrack("id3", 1);
    this.timeOffset = 0;
    if (!(initSegment != null && initSegment.byteLength)) {
      return;
    }
    const initData = parseInitSegment(initSegment);
    if (initData.video) {
      const {
        id,
        timescale: timescale2,
        codec
      } = initData.video;
      videoTrack.id = id;
      videoTrack.timescale = captionTrack.timescale = timescale2;
      videoTrack.codec = codec;
    }
    if (initData.audio) {
      const {
        id,
        timescale: timescale2,
        codec
      } = initData.audio;
      audioTrack.id = id;
      audioTrack.timescale = timescale2;
      audioTrack.codec = codec;
    }
    captionTrack.id = RemuxerTrackIdConfig.text;
    videoTrack.sampleDuration = 0;
    videoTrack.duration = audioTrack.duration = trackDuration;
  }
  resetContiguity() {
    this.remainderData = null;
  }
  static probe(data) {
    data = data.length > 16384 ? data.subarray(0, 16384) : data;
    return findBox(data, ["moof"]).length > 0;
  }
  demux(data, timeOffset) {
    this.timeOffset = timeOffset;
    let videoSamples = data;
    const videoTrack = this.videoTrack;
    const textTrack = this.txtTrack;
    if (this.config.progressive) {
      if (this.remainderData) {
        videoSamples = appendUint8Array(this.remainderData, data);
      }
      const segmentedData = segmentValidRange(videoSamples);
      this.remainderData = segmentedData.remainder;
      videoTrack.samples = segmentedData.valid || new Uint8Array();
    } else {
      videoTrack.samples = videoSamples;
    }
    const id3Track = this.extractID3Track(videoTrack, timeOffset);
    textTrack.samples = parseSamples(timeOffset, videoTrack);
    return {
      videoTrack,
      audioTrack: this.audioTrack,
      id3Track,
      textTrack: this.txtTrack
    };
  }
  flush() {
    const timeOffset = this.timeOffset;
    const videoTrack = this.videoTrack;
    const textTrack = this.txtTrack;
    videoTrack.samples = this.remainderData || new Uint8Array();
    this.remainderData = null;
    const id3Track = this.extractID3Track(videoTrack, this.timeOffset);
    textTrack.samples = parseSamples(timeOffset, videoTrack);
    return {
      videoTrack,
      audioTrack: dummyTrack(),
      id3Track,
      textTrack: dummyTrack()
    };
  }
  extractID3Track(videoTrack, timeOffset) {
    const id3Track = this.id3Track;
    if (videoTrack.samples.length) {
      const emsgs = findBox(videoTrack.samples, ["emsg"]);
      if (emsgs) {
        emsgs.forEach((data) => {
          const emsgInfo = parseEmsg(data);
          if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {
            const pts = isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;
            let duration5 = emsgInfo.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;
            if (duration5 <= 1e-3) {
              duration5 = Number.POSITIVE_INFINITY;
            }
            const payload = emsgInfo.payload;
            id3Track.samples.push({
              data: payload,
              len: payload.byteLength,
              dts: pts,
              pts,
              type: MetadataSchema.emsg,
              duration: duration5
            });
          }
        });
      }
    }
    return id3Track;
  }
  demuxSampleAes(data, keyData, timeOffset) {
    return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"));
  }
  destroy() {
  }
};
var chromeVersion$1 = null;
var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];
var SamplingRateMap = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3];
var SamplesCoefficients = [
  // MPEG 2.5
  [
    0,
    // Reserved
    72,
    // Layer3
    144,
    // Layer2
    12
    // Layer1
  ],
  // Reserved
  [
    0,
    // Reserved
    0,
    // Layer3
    0,
    // Layer2
    0
    // Layer1
  ],
  // MPEG 2
  [
    0,
    // Reserved
    72,
    // Layer3
    144,
    // Layer2
    12
    // Layer1
  ],
  // MPEG 1
  [
    0,
    // Reserved
    144,
    // Layer3
    144,
    // Layer2
    12
    // Layer1
  ]
];
var BytesInSlot = [
  0,
  // Reserved
  1,
  // Layer3
  1,
  // Layer2
  4
  // Layer1
];
function appendFrame(track, data, offset, pts, frameIndex) {
  if (offset + 24 > data.length) {
    return;
  }
  const header = parseHeader(data, offset);
  if (header && offset + header.frameLength <= data.length) {
    const frameDuration = header.samplesPerFrame * 9e4 / header.sampleRate;
    const stamp = pts + frameIndex * frameDuration;
    const sample = {
      unit: data.subarray(offset, offset + header.frameLength),
      pts: stamp,
      dts: stamp
    };
    track.config = [];
    track.channelCount = header.channelCount;
    track.samplerate = header.sampleRate;
    track.samples.push(sample);
    return {
      sample,
      length: header.frameLength,
      missing: 0
    };
  }
}
function parseHeader(data, offset) {
  const mpegVersion = data[offset + 1] >> 3 & 3;
  const mpegLayer = data[offset + 1] >> 1 & 3;
  const bitRateIndex = data[offset + 2] >> 4 & 15;
  const sampleRateIndex = data[offset + 2] >> 2 & 3;
  if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {
    const paddingBit = data[offset + 2] >> 1 & 1;
    const channelMode = data[offset + 3] >> 6;
    const columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;
    const bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1e3;
    const columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;
    const sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];
    const channelCount = channelMode === 3 ? 1 : 2;
    const sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];
    const bytesInSlot = BytesInSlot[mpegLayer];
    const samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
    const frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;
    if (chromeVersion$1 === null) {
      const userAgent = navigator.userAgent || "";
      const result = userAgent.match(/Chrome\/(\d+)/i);
      chromeVersion$1 = result ? parseInt(result[1]) : 0;
    }
    const needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;
    if (needChromeFix && mpegLayer === 2 && bitRate >= 224e3 && channelMode === 0) {
      data[offset + 3] = data[offset + 3] | 128;
    }
    return {
      sampleRate,
      channelCount,
      frameLength,
      samplesPerFrame
    };
  }
}
function isHeaderPattern(data, offset) {
  return data[offset] === 255 && (data[offset + 1] & 224) === 224 && (data[offset + 1] & 6) !== 0;
}
function isHeader(data, offset) {
  return offset + 1 < data.length && isHeaderPattern(data, offset);
}
function canParse(data, offset) {
  const headerSize = 4;
  return isHeaderPattern(data, offset) && headerSize <= data.length - offset;
}
function probe(data, offset) {
  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
    const headerLength = 4;
    const header = parseHeader(data, offset);
    let frameLength = headerLength;
    if (header != null && header.frameLength) {
      frameLength = header.frameLength;
    }
    const newOffset = offset + frameLength;
    return newOffset === data.length || isHeader(data, newOffset);
  }
  return false;
}
var ExpGolomb = class {
  constructor(data) {
    this.data = void 0;
    this.bytesAvailable = void 0;
    this.word = void 0;
    this.bitsAvailable = void 0;
    this.data = data;
    this.bytesAvailable = data.byteLength;
    this.word = 0;
    this.bitsAvailable = 0;
  }
  // ():void
  loadWord() {
    const data = this.data;
    const bytesAvailable = this.bytesAvailable;
    const position = data.byteLength - bytesAvailable;
    const workingBytes = new Uint8Array(4);
    const availableBytes = Math.min(4, bytesAvailable);
    if (availableBytes === 0) {
      throw new Error("no bytes available");
    }
    workingBytes.set(data.subarray(position, position + availableBytes));
    this.word = new DataView(workingBytes.buffer).getUint32(0);
    this.bitsAvailable = availableBytes * 8;
    this.bytesAvailable -= availableBytes;
  }
  // (count:int):void
  skipBits(count) {
    let skipBytes;
    count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);
    if (this.bitsAvailable > count) {
      this.word <<= count;
      this.bitsAvailable -= count;
    } else {
      count -= this.bitsAvailable;
      skipBytes = count >> 3;
      count -= skipBytes << 3;
      this.bytesAvailable -= skipBytes;
      this.loadWord();
      this.word <<= count;
      this.bitsAvailable -= count;
    }
  }
  // (size:int):uint
  readBits(size) {
    let bits = Math.min(this.bitsAvailable, size);
    const valu = this.word >>> 32 - bits;
    if (size > 32) {
      logger.error("Cannot read more than 32 bits at a time");
    }
    this.bitsAvailable -= bits;
    if (this.bitsAvailable > 0) {
      this.word <<= bits;
    } else if (this.bytesAvailable > 0) {
      this.loadWord();
    } else {
      throw new Error("no bits available");
    }
    bits = size - bits;
    if (bits > 0 && this.bitsAvailable) {
      return valu << bits | this.readBits(bits);
    } else {
      return valu;
    }
  }
  // ():uint
  skipLZ() {
    let leadingZeroCount;
    for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
      if ((this.word & 2147483648 >>> leadingZeroCount) !== 0) {
        this.word <<= leadingZeroCount;
        this.bitsAvailable -= leadingZeroCount;
        return leadingZeroCount;
      }
    }
    this.loadWord();
    return leadingZeroCount + this.skipLZ();
  }
  // ():void
  skipUEG() {
    this.skipBits(1 + this.skipLZ());
  }
  // ():void
  skipEG() {
    this.skipBits(1 + this.skipLZ());
  }
  // ():uint
  readUEG() {
    const clz = this.skipLZ();
    return this.readBits(clz + 1) - 1;
  }
  // ():int
  readEG() {
    const valu = this.readUEG();
    if (1 & valu) {
      return 1 + valu >>> 1;
    } else {
      return -1 * (valu >>> 1);
    }
  }
  // Some convenience functions
  // :Boolean
  readBoolean() {
    return this.readBits(1) === 1;
  }
  // ():int
  readUByte() {
    return this.readBits(8);
  }
  // ():int
  readUShort() {
    return this.readBits(16);
  }
  // ():int
  readUInt() {
    return this.readBits(32);
  }
  /**
   * Advance the ExpGolomb decoder past a scaling list. The scaling
   * list is optionally transmitted as part of a sequence parameter
   * set and is not relevant to transmuxing.
   * @param count the number of entries in this scaling list
   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
   */
  skipScalingList(count) {
    let lastScale = 8;
    let nextScale = 8;
    let deltaScale;
    for (let j = 0; j < count; j++) {
      if (nextScale !== 0) {
        deltaScale = this.readEG();
        nextScale = (lastScale + deltaScale + 256) % 256;
      }
      lastScale = nextScale === 0 ? lastScale : nextScale;
    }
  }
  /**
   * Read a sequence parameter set and return some interesting video
   * properties. A sequence parameter set is the H264 metadata that
   * describes the properties of upcoming video frames.
   * @returns an object with configuration parsed from the
   * sequence parameter set, including the dimensions of the
   * associated video frames.
   */
  readSPS() {
    let frameCropLeftOffset = 0;
    let frameCropRightOffset = 0;
    let frameCropTopOffset = 0;
    let frameCropBottomOffset = 0;
    let numRefFramesInPicOrderCntCycle;
    let scalingListCount;
    let i;
    const readUByte = this.readUByte.bind(this);
    const readBits = this.readBits.bind(this);
    const readUEG = this.readUEG.bind(this);
    const readBoolean = this.readBoolean.bind(this);
    const skipBits = this.skipBits.bind(this);
    const skipEG = this.skipEG.bind(this);
    const skipUEG = this.skipUEG.bind(this);
    const skipScalingList = this.skipScalingList.bind(this);
    readUByte();
    const profileIdc = readUByte();
    readBits(5);
    skipBits(3);
    readUByte();
    skipUEG();
    if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
      const chromaFormatIdc = readUEG();
      if (chromaFormatIdc === 3) {
        skipBits(1);
      }
      skipUEG();
      skipUEG();
      skipBits(1);
      if (readBoolean()) {
        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
        for (i = 0; i < scalingListCount; i++) {
          if (readBoolean()) {
            if (i < 6) {
              skipScalingList(16);
            } else {
              skipScalingList(64);
            }
          }
        }
      }
    }
    skipUEG();
    const picOrderCntType = readUEG();
    if (picOrderCntType === 0) {
      readUEG();
    } else if (picOrderCntType === 1) {
      skipBits(1);
      skipEG();
      skipEG();
      numRefFramesInPicOrderCntCycle = readUEG();
      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
        skipEG();
      }
    }
    skipUEG();
    skipBits(1);
    const picWidthInMbsMinus1 = readUEG();
    const picHeightInMapUnitsMinus1 = readUEG();
    const frameMbsOnlyFlag = readBits(1);
    if (frameMbsOnlyFlag === 0) {
      skipBits(1);
    }
    skipBits(1);
    if (readBoolean()) {
      frameCropLeftOffset = readUEG();
      frameCropRightOffset = readUEG();
      frameCropTopOffset = readUEG();
      frameCropBottomOffset = readUEG();
    }
    let pixelRatio = [1, 1];
    if (readBoolean()) {
      if (readBoolean()) {
        const aspectRatioIdc = readUByte();
        switch (aspectRatioIdc) {
          case 1:
            pixelRatio = [1, 1];
            break;
          case 2:
            pixelRatio = [12, 11];
            break;
          case 3:
            pixelRatio = [10, 11];
            break;
          case 4:
            pixelRatio = [16, 11];
            break;
          case 5:
            pixelRatio = [40, 33];
            break;
          case 6:
            pixelRatio = [24, 11];
            break;
          case 7:
            pixelRatio = [20, 11];
            break;
          case 8:
            pixelRatio = [32, 11];
            break;
          case 9:
            pixelRatio = [80, 33];
            break;
          case 10:
            pixelRatio = [18, 11];
            break;
          case 11:
            pixelRatio = [15, 11];
            break;
          case 12:
            pixelRatio = [64, 33];
            break;
          case 13:
            pixelRatio = [160, 99];
            break;
          case 14:
            pixelRatio = [4, 3];
            break;
          case 15:
            pixelRatio = [3, 2];
            break;
          case 16:
            pixelRatio = [2, 1];
            break;
          case 255: {
            pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
            break;
          }
        }
      }
    }
    return {
      width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
      height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
      pixelRatio
    };
  }
  readSliceType() {
    this.readUByte();
    this.readUEG();
    return this.readUEG();
  }
};
var SampleAesDecrypter = class {
  constructor(observer, config, keyData) {
    this.keyData = void 0;
    this.decrypter = void 0;
    this.keyData = keyData;
    this.decrypter = new Decrypter(config, {
      removePKCS7Padding: false
    });
  }
  decryptBuffer(encryptedData) {
    return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer);
  }
  // AAC - encrypt all full 16 bytes blocks starting from offset 16
  decryptAacSample(samples, sampleIndex, callback2) {
    const curUnit = samples[sampleIndex].unit;
    if (curUnit.length <= 16) {
      return;
    }
    const encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
    const encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);
    this.decryptBuffer(encryptedBuffer).then((decryptedBuffer) => {
      const decryptedData = new Uint8Array(decryptedBuffer);
      curUnit.set(decryptedData, 16);
      if (!this.decrypter.isSync()) {
        this.decryptAacSamples(samples, sampleIndex + 1, callback2);
      }
    });
  }
  decryptAacSamples(samples, sampleIndex, callback2) {
    for (; ; sampleIndex++) {
      if (sampleIndex >= samples.length) {
        callback2();
        return;
      }
      if (samples[sampleIndex].unit.length < 32) {
        continue;
      }
      this.decryptAacSample(samples, sampleIndex, callback2);
      if (!this.decrypter.isSync()) {
        return;
      }
    }
  }
  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32
  getAvcEncryptedData(decodedData) {
    const encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
    const encryptedData = new Int8Array(encryptedDataLen);
    let outputPos = 0;
    for (let inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {
      encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
    }
    return encryptedData;
  }
  getAvcDecryptedUnit(decodedData, decryptedData) {
    const uint8DecryptedData = new Uint8Array(decryptedData);
    let inputPos = 0;
    for (let outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {
      decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);
    }
    return decodedData;
  }
  decryptAvcSample(samples, sampleIndex, unitIndex, callback2, curUnit) {
    const decodedData = discardEPB(curUnit.data);
    const encryptedData = this.getAvcEncryptedData(decodedData);
    this.decryptBuffer(encryptedData.buffer).then((decryptedBuffer) => {
      curUnit.data = this.getAvcDecryptedUnit(decodedData, decryptedBuffer);
      if (!this.decrypter.isSync()) {
        this.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback2);
      }
    });
  }
  decryptAvcSamples(samples, sampleIndex, unitIndex, callback2) {
    if (samples instanceof Uint8Array) {
      throw new Error("Cannot decrypt samples of type Uint8Array");
    }
    for (; ; sampleIndex++, unitIndex = 0) {
      if (sampleIndex >= samples.length) {
        callback2();
        return;
      }
      const curUnits = samples[sampleIndex].units;
      for (; ; unitIndex++) {
        if (unitIndex >= curUnits.length) {
          break;
        }
        const curUnit = curUnits[unitIndex];
        if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
          continue;
        }
        this.decryptAvcSample(samples, sampleIndex, unitIndex, callback2, curUnit);
        if (!this.decrypter.isSync()) {
          return;
        }
      }
    }
  }
};
var PACKET_LENGTH = 188;
var TSDemuxer = class _TSDemuxer {
  constructor(observer, config, typeSupported) {
    this.observer = void 0;
    this.config = void 0;
    this.typeSupported = void 0;
    this.sampleAes = null;
    this.pmtParsed = false;
    this.audioCodec = void 0;
    this.videoCodec = void 0;
    this._duration = 0;
    this._pmtId = -1;
    this._avcTrack = void 0;
    this._audioTrack = void 0;
    this._id3Track = void 0;
    this._txtTrack = void 0;
    this.aacOverFlow = null;
    this.avcSample = null;
    this.remainderData = null;
    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
  }
  static probe(data) {
    const syncOffset = _TSDemuxer.syncOffset(data);
    if (syncOffset > 0) {
      logger.warn(`MPEG2-TS detected but first sync word found @ offset ${syncOffset}`);
    }
    return syncOffset !== -1;
  }
  static syncOffset(data) {
    const length = data.length;
    let scanwindow = Math.min(PACKET_LENGTH * 5, data.length - PACKET_LENGTH) + 1;
    let i = 0;
    while (i < scanwindow) {
      let foundPat = false;
      let packetStart = -1;
      let tsPackets = 0;
      for (let j = i; j < length; j += PACKET_LENGTH) {
        if (data[j] === 71) {
          tsPackets++;
          if (packetStart === -1) {
            packetStart = j;
            if (packetStart !== 0) {
              scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;
            }
          }
          if (!foundPat) {
            foundPat = parsePID(data, j) === 0;
          }
          if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {
            return packetStart;
          }
        } else if (tsPackets) {
          return -1;
        } else {
          break;
        }
      }
      i++;
    }
    return -1;
  }
  /**
   * Creates a track model internal to demuxer used to drive remuxing input
   */
  static createTrack(type2, duration5) {
    return {
      container: type2 === "video" || type2 === "audio" ? "video/mp2t" : void 0,
      type: type2,
      id: RemuxerTrackIdConfig[type2],
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0,
      duration: type2 === "audio" ? duration5 : void 0
    };
  }
  /**
   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
   * Resets all internal track instances of the demuxer.
   */
  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
    this.pmtParsed = false;
    this._pmtId = -1;
    this._avcTrack = _TSDemuxer.createTrack("video");
    this._audioTrack = _TSDemuxer.createTrack("audio", trackDuration);
    this._id3Track = _TSDemuxer.createTrack("id3");
    this._txtTrack = _TSDemuxer.createTrack("text");
    this._audioTrack.segmentCodec = "aac";
    this.aacOverFlow = null;
    this.avcSample = null;
    this.remainderData = null;
    this.audioCodec = audioCodec;
    this.videoCodec = videoCodec;
    this._duration = trackDuration;
  }
  resetTimeStamp() {
  }
  resetContiguity() {
    const {
      _audioTrack,
      _avcTrack,
      _id3Track
    } = this;
    if (_audioTrack) {
      _audioTrack.pesData = null;
    }
    if (_avcTrack) {
      _avcTrack.pesData = null;
    }
    if (_id3Track) {
      _id3Track.pesData = null;
    }
    this.aacOverFlow = null;
    this.avcSample = null;
    this.remainderData = null;
  }
  demux(data, timeOffset, isSampleAes = false, flush = false) {
    if (!isSampleAes) {
      this.sampleAes = null;
    }
    let pes;
    const videoTrack = this._avcTrack;
    const audioTrack = this._audioTrack;
    const id3Track = this._id3Track;
    const textTrack = this._txtTrack;
    let avcId = videoTrack.pid;
    let avcData = videoTrack.pesData;
    let audioId = audioTrack.pid;
    let id3Id = id3Track.pid;
    let audioData = audioTrack.pesData;
    let id3Data = id3Track.pesData;
    let unknownPID = null;
    let pmtParsed = this.pmtParsed;
    let pmtId = this._pmtId;
    let len = data.length;
    if (this.remainderData) {
      data = appendUint8Array(this.remainderData, data);
      len = data.length;
      this.remainderData = null;
    }
    if (len < PACKET_LENGTH && !flush) {
      this.remainderData = data;
      return {
        audioTrack,
        videoTrack,
        id3Track,
        textTrack
      };
    }
    const syncOffset = Math.max(0, _TSDemuxer.syncOffset(data));
    len -= (len - syncOffset) % PACKET_LENGTH;
    if (len < data.byteLength && !flush) {
      this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);
    }
    let tsPacketErrors = 0;
    for (let start2 = syncOffset; start2 < len; start2 += PACKET_LENGTH) {
      if (data[start2] === 71) {
        const stt = !!(data[start2 + 1] & 64);
        const pid = parsePID(data, start2);
        const atf = (data[start2 + 3] & 48) >> 4;
        let offset;
        if (atf > 1) {
          offset = start2 + 5 + data[start2 + 4];
          if (offset === start2 + PACKET_LENGTH) {
            continue;
          }
        } else {
          offset = start2 + 4;
        }
        switch (pid) {
          case avcId:
            if (stt) {
              if (avcData && (pes = parsePES(avcData))) {
                this.parseAVCPES(videoTrack, textTrack, pes, false);
              }
              avcData = {
                data: [],
                size: 0
              };
            }
            if (avcData) {
              avcData.data.push(data.subarray(offset, start2 + PACKET_LENGTH));
              avcData.size += start2 + PACKET_LENGTH - offset;
            }
            break;
          case audioId:
            if (stt) {
              if (audioData && (pes = parsePES(audioData))) {
                switch (audioTrack.segmentCodec) {
                  case "aac":
                    this.parseAACPES(audioTrack, pes);
                    break;
                  case "mp3":
                    this.parseMPEGPES(audioTrack, pes);
                    break;
                }
              }
              audioData = {
                data: [],
                size: 0
              };
            }
            if (audioData) {
              audioData.data.push(data.subarray(offset, start2 + PACKET_LENGTH));
              audioData.size += start2 + PACKET_LENGTH - offset;
            }
            break;
          case id3Id:
            if (stt) {
              if (id3Data && (pes = parsePES(id3Data))) {
                this.parseID3PES(id3Track, pes);
              }
              id3Data = {
                data: [],
                size: 0
              };
            }
            if (id3Data) {
              id3Data.data.push(data.subarray(offset, start2 + PACKET_LENGTH));
              id3Data.size += start2 + PACKET_LENGTH - offset;
            }
            break;
          case 0:
            if (stt) {
              offset += data[offset] + 1;
            }
            pmtId = this._pmtId = parsePAT(data, offset);
            break;
          case pmtId: {
            if (stt) {
              offset += data[offset] + 1;
            }
            const parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes);
            avcId = parsedPIDs.avc;
            if (avcId > 0) {
              videoTrack.pid = avcId;
            }
            audioId = parsedPIDs.audio;
            if (audioId > 0) {
              audioTrack.pid = audioId;
              audioTrack.segmentCodec = parsedPIDs.segmentCodec;
            }
            id3Id = parsedPIDs.id3;
            if (id3Id > 0) {
              id3Track.pid = id3Id;
            }
            if (unknownPID !== null && !pmtParsed) {
              logger.warn(`MPEG-TS PMT found at ${start2} after unknown PID '${unknownPID}'. Backtracking to sync byte @${syncOffset} to parse all TS packets.`);
              unknownPID = null;
              start2 = syncOffset - 188;
            }
            pmtParsed = this.pmtParsed = true;
            break;
          }
          case 17:
          case 8191:
            break;
          default:
            unknownPID = pid;
            break;
        }
      } else {
        tsPacketErrors++;
      }
    }
    if (tsPacketErrors > 0) {
      const error = new Error(`Found ${tsPacketErrors} TS packet/s that do not start with 0x47`);
      this.observer.emit(Events.ERROR, Events.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.FRAG_PARSING_ERROR,
        fatal: false,
        error,
        reason: error.message
      });
    }
    videoTrack.pesData = avcData;
    audioTrack.pesData = audioData;
    id3Track.pesData = id3Data;
    const demuxResult = {
      audioTrack,
      videoTrack,
      id3Track,
      textTrack
    };
    if (flush) {
      this.extractRemainingSamples(demuxResult);
    }
    return demuxResult;
  }
  flush() {
    const {
      remainderData
    } = this;
    this.remainderData = null;
    let result;
    if (remainderData) {
      result = this.demux(remainderData, -1, false, true);
    } else {
      result = {
        videoTrack: this._avcTrack,
        audioTrack: this._audioTrack,
        id3Track: this._id3Track,
        textTrack: this._txtTrack
      };
    }
    this.extractRemainingSamples(result);
    if (this.sampleAes) {
      return this.decrypt(result, this.sampleAes);
    }
    return result;
  }
  extractRemainingSamples(demuxResult) {
    const {
      audioTrack,
      videoTrack,
      id3Track,
      textTrack
    } = demuxResult;
    const avcData = videoTrack.pesData;
    const audioData = audioTrack.pesData;
    const id3Data = id3Track.pesData;
    let pes;
    if (avcData && (pes = parsePES(avcData))) {
      this.parseAVCPES(videoTrack, textTrack, pes, true);
      videoTrack.pesData = null;
    } else {
      videoTrack.pesData = avcData;
    }
    if (audioData && (pes = parsePES(audioData))) {
      switch (audioTrack.segmentCodec) {
        case "aac":
          this.parseAACPES(audioTrack, pes);
          break;
        case "mp3":
          this.parseMPEGPES(audioTrack, pes);
          break;
      }
      audioTrack.pesData = null;
    } else {
      if (audioData != null && audioData.size) {
        logger.log("last AAC PES packet truncated,might overlap between fragments");
      }
      audioTrack.pesData = audioData;
    }
    if (id3Data && (pes = parsePES(id3Data))) {
      this.parseID3PES(id3Track, pes);
      id3Track.pesData = null;
    } else {
      id3Track.pesData = id3Data;
    }
  }
  demuxSampleAes(data, keyData, timeOffset) {
    const demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);
    const sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);
    return this.decrypt(demuxResult, sampleAes);
  }
  decrypt(demuxResult, sampleAes) {
    return new Promise((resolve) => {
      const {
        audioTrack,
        videoTrack
      } = demuxResult;
      if (audioTrack.samples && audioTrack.segmentCodec === "aac") {
        sampleAes.decryptAacSamples(audioTrack.samples, 0, () => {
          if (videoTrack.samples) {
            sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {
              resolve(demuxResult);
            });
          } else {
            resolve(demuxResult);
          }
        });
      } else if (videoTrack.samples) {
        sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {
          resolve(demuxResult);
        });
      }
    });
  }
  destroy() {
    this._duration = 0;
  }
  parseAVCPES(track, textTrack, pes, last) {
    const units = this.parseAVCNALu(track, pes.data);
    let avcSample = this.avcSample;
    let push2;
    let spsfound = false;
    pes.data = null;
    if (avcSample && units.length && !track.audFound) {
      pushAccessUnit(avcSample, track);
      avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, "");
    }
    units.forEach((unit) => {
      var _avcSample2;
      switch (unit.type) {
        case 1: {
          let iskey = false;
          push2 = true;
          const data = unit.data;
          if (spsfound && data.length > 4) {
            const sliceType = new ExpGolomb(data).readSliceType();
            if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
              iskey = true;
            }
          }
          if (iskey) {
            var _avcSample;
            if ((_avcSample = avcSample) != null && _avcSample.frame && !avcSample.key) {
              pushAccessUnit(avcSample, track);
              avcSample = this.avcSample = null;
            }
          }
          if (!avcSample) {
            avcSample = this.avcSample = createAVCSample(true, pes.pts, pes.dts, "");
          }
          avcSample.frame = true;
          avcSample.key = iskey;
          break;
        }
        case 5:
          push2 = true;
          if ((_avcSample2 = avcSample) != null && _avcSample2.frame && !avcSample.key) {
            pushAccessUnit(avcSample, track);
            avcSample = this.avcSample = null;
          }
          if (!avcSample) {
            avcSample = this.avcSample = createAVCSample(true, pes.pts, pes.dts, "");
          }
          avcSample.key = true;
          avcSample.frame = true;
          break;
        case 6: {
          push2 = true;
          parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);
          break;
        }
        case 7:
          push2 = true;
          spsfound = true;
          if (!track.sps) {
            const sps = unit.data;
            const expGolombDecoder = new ExpGolomb(sps);
            const config = expGolombDecoder.readSPS();
            track.width = config.width;
            track.height = config.height;
            track.pixelRatio = config.pixelRatio;
            track.sps = [sps];
            track.duration = this._duration;
            const codecarray = sps.subarray(1, 4);
            let codecstring = "avc1.";
            for (let i = 0; i < 3; i++) {
              let h = codecarray[i].toString(16);
              if (h.length < 2) {
                h = "0" + h;
              }
              codecstring += h;
            }
            track.codec = codecstring;
          }
          break;
        case 8:
          push2 = true;
          if (!track.pps) {
            track.pps = [unit.data];
          }
          break;
        case 9:
          push2 = false;
          track.audFound = true;
          if (avcSample) {
            pushAccessUnit(avcSample, track);
          }
          avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, "");
          break;
        case 12:
          push2 = true;
          break;
        default:
          push2 = false;
          if (avcSample) {
            avcSample.debug += "unknown NAL " + unit.type + " ";
          }
          break;
      }
      if (avcSample && push2) {
        const units2 = avcSample.units;
        units2.push(unit);
      }
    });
    if (last && avcSample) {
      pushAccessUnit(avcSample, track);
      this.avcSample = null;
    }
  }
  getLastNalUnit(samples) {
    var _avcSample3;
    let avcSample = this.avcSample;
    let lastUnit;
    if (!avcSample || avcSample.units.length === 0) {
      avcSample = samples[samples.length - 1];
    }
    if ((_avcSample3 = avcSample) != null && _avcSample3.units) {
      const units = avcSample.units;
      lastUnit = units[units.length - 1];
    }
    return lastUnit;
  }
  parseAVCNALu(track, array) {
    const len = array.byteLength;
    let state = track.naluState || 0;
    const lastState = state;
    const units = [];
    let i = 0;
    let value;
    let overflow;
    let unitType;
    let lastUnitStart = -1;
    let lastUnitType = 0;
    if (state === -1) {
      lastUnitStart = 0;
      lastUnitType = array[0] & 31;
      state = 0;
      i = 1;
    }
    while (i < len) {
      value = array[i++];
      if (!state) {
        state = value ? 0 : 1;
        continue;
      }
      if (state === 1) {
        state = value ? 0 : 2;
        continue;
      }
      if (!value) {
        state = 3;
      } else if (value === 1) {
        if (lastUnitStart >= 0) {
          const unit = {
            data: array.subarray(lastUnitStart, i - state - 1),
            type: lastUnitType
          };
          units.push(unit);
        } else {
          const lastUnit = this.getLastNalUnit(track.samples);
          if (lastUnit) {
            if (lastState && i <= 4 - lastState) {
              if (lastUnit.state) {
                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
              }
            }
            overflow = i - state - 1;
            if (overflow > 0) {
              const tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
              tmp.set(lastUnit.data, 0);
              tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
              lastUnit.data = tmp;
              lastUnit.state = 0;
            }
          }
        }
        if (i < len) {
          unitType = array[i] & 31;
          lastUnitStart = i;
          lastUnitType = unitType;
          state = 0;
        } else {
          state = -1;
        }
      } else {
        state = 0;
      }
    }
    if (lastUnitStart >= 0 && state >= 0) {
      const unit = {
        data: array.subarray(lastUnitStart, len),
        type: lastUnitType,
        state
      };
      units.push(unit);
    }
    if (units.length === 0) {
      const lastUnit = this.getLastNalUnit(track.samples);
      if (lastUnit) {
        const tmp = new Uint8Array(lastUnit.data.byteLength + array.byteLength);
        tmp.set(lastUnit.data, 0);
        tmp.set(array, lastUnit.data.byteLength);
        lastUnit.data = tmp;
      }
    }
    track.naluState = state;
    return units;
  }
  parseAACPES(track, pes) {
    let startOffset = 0;
    const aacOverFlow = this.aacOverFlow;
    let data = pes.data;
    if (aacOverFlow) {
      this.aacOverFlow = null;
      const frameMissingBytes = aacOverFlow.missing;
      const sampleLength = aacOverFlow.sample.unit.byteLength;
      if (frameMissingBytes === -1) {
        const tmp = new Uint8Array(sampleLength + data.byteLength);
        tmp.set(aacOverFlow.sample.unit, 0);
        tmp.set(data, sampleLength);
        data = tmp;
      } else {
        const frameOverflowBytes = sampleLength - frameMissingBytes;
        aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);
        track.samples.push(aacOverFlow.sample);
        startOffset = aacOverFlow.missing;
      }
    }
    let offset;
    let len;
    for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
      if (isHeader$1(data, offset)) {
        break;
      }
    }
    if (offset !== startOffset) {
      let reason;
      const recoverable = offset < len - 1;
      if (recoverable) {
        reason = `AAC PES did not start with ADTS header,offset:${offset}`;
      } else {
        reason = "No ADTS header found in AAC PES";
      }
      const error = new Error(reason);
      logger.warn(`parsing error: ${reason}`);
      this.observer.emit(Events.ERROR, Events.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.FRAG_PARSING_ERROR,
        fatal: false,
        levelRetry: recoverable,
        error,
        reason
      });
      if (!recoverable) {
        return;
      }
    }
    initTrackConfig(track, this.observer, data, offset, this.audioCodec);
    let pts;
    if (pes.pts !== void 0) {
      pts = pes.pts;
    } else if (aacOverFlow) {
      const frameDuration = getFrameDuration(track.samplerate);
      pts = aacOverFlow.sample.pts + frameDuration;
    } else {
      logger.warn("[tsdemuxer]: AAC PES unknown PTS");
      return;
    }
    let frameIndex = 0;
    let frame;
    while (offset < len) {
      frame = appendFrame$1(track, data, offset, pts, frameIndex);
      offset += frame.length;
      if (!frame.missing) {
        frameIndex++;
        for (; offset < len - 1; offset++) {
          if (isHeader$1(data, offset)) {
            break;
          }
        }
      } else {
        this.aacOverFlow = frame;
        break;
      }
    }
  }
  parseMPEGPES(track, pes) {
    const data = pes.data;
    const length = data.length;
    let frameIndex = 0;
    let offset = 0;
    const pts = pes.pts;
    if (pts === void 0) {
      logger.warn("[tsdemuxer]: MPEG PES unknown PTS");
      return;
    }
    while (offset < length) {
      if (isHeader(data, offset)) {
        const frame = appendFrame(track, data, offset, pts, frameIndex);
        if (frame) {
          offset += frame.length;
          frameIndex++;
        } else {
          break;
        }
      } else {
        offset++;
      }
    }
  }
  parseID3PES(id3Track, pes) {
    if (pes.pts === void 0) {
      logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
      return;
    }
    const id3Sample = _extends({}, pes, {
      type: this._avcTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,
      duration: Number.POSITIVE_INFINITY
    });
    id3Track.samples.push(id3Sample);
  }
};
function createAVCSample(key, pts, dts, debug) {
  return {
    key,
    frame: false,
    pts,
    dts,
    units: [],
    debug,
    length: 0
  };
}
function parsePID(data, offset) {
  return ((data[offset + 1] & 31) << 8) + data[offset + 2];
}
function parsePAT(data, offset) {
  return (data[offset + 10] & 31) << 8 | data[offset + 11];
}
function parsePMT(data, offset, typeSupported, isSampleAes) {
  const result = {
    audio: -1,
    avc: -1,
    id3: -1,
    segmentCodec: "aac"
  };
  const sectionLength = (data[offset + 1] & 15) << 8 | data[offset + 2];
  const tableEnd = offset + 3 + sectionLength - 4;
  const programInfoLength = (data[offset + 10] & 15) << 8 | data[offset + 11];
  offset += 12 + programInfoLength;
  while (offset < tableEnd) {
    const pid = parsePID(data, offset);
    switch (data[offset]) {
      case 207:
        if (!isSampleAes) {
          logger.log("ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
          break;
        }
      case 15:
        if (result.audio === -1) {
          result.audio = pid;
        }
        break;
      case 21:
        if (result.id3 === -1) {
          result.id3 = pid;
        }
        break;
      case 219:
        if (!isSampleAes) {
          logger.log("H.264 with AES-128-CBC slice encryption found in unencrypted stream");
          break;
        }
      case 27:
        if (result.avc === -1) {
          result.avc = pid;
        }
        break;
      case 3:
      case 4:
        if (typeSupported.mpeg !== true && typeSupported.mp3 !== true) {
          logger.log("MPEG audio found, not supported in this browser");
        } else if (result.audio === -1) {
          result.audio = pid;
          result.segmentCodec = "mp3";
        }
        break;
      case 36:
        logger.warn("Unsupported HEVC stream type found");
        break;
    }
    offset += ((data[offset + 3] & 15) << 8 | data[offset + 4]) + 5;
  }
  return result;
}
function parsePES(stream) {
  let i = 0;
  let frag;
  let pesLen;
  let pesHdrLen;
  let pesPts;
  let pesDts;
  const data = stream.data;
  if (!stream || stream.size === 0) {
    return null;
  }
  while (data[0].length < 19 && data.length > 1) {
    const newData = new Uint8Array(data[0].length + data[1].length);
    newData.set(data[0]);
    newData.set(data[1], data[0].length);
    data[0] = newData;
    data.splice(1, 1);
  }
  frag = data[0];
  const pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
  if (pesPrefix === 1) {
    pesLen = (frag[4] << 8) + frag[5];
    if (pesLen && pesLen > stream.size - 6) {
      return null;
    }
    const pesFlags = frag[7];
    if (pesFlags & 192) {
      pesPts = (frag[9] & 14) * 536870912 + // 1 << 29
      (frag[10] & 255) * 4194304 + // 1 << 22
      (frag[11] & 254) * 16384 + // 1 << 14
      (frag[12] & 255) * 128 + // 1 << 7
      (frag[13] & 254) / 2;
      if (pesFlags & 64) {
        pesDts = (frag[14] & 14) * 536870912 + // 1 << 29
        (frag[15] & 255) * 4194304 + // 1 << 22
        (frag[16] & 254) * 16384 + // 1 << 14
        (frag[17] & 255) * 128 + // 1 << 7
        (frag[18] & 254) / 2;
        if (pesPts - pesDts > 60 * 9e4) {
          logger.warn(`${Math.round((pesPts - pesDts) / 9e4)}s delta between PTS and DTS, align them`);
          pesPts = pesDts;
        }
      } else {
        pesDts = pesPts;
      }
    }
    pesHdrLen = frag[8];
    let payloadStartOffset = pesHdrLen + 9;
    if (stream.size <= payloadStartOffset) {
      return null;
    }
    stream.size -= payloadStartOffset;
    const pesData = new Uint8Array(stream.size);
    for (let j = 0, dataLen = data.length; j < dataLen; j++) {
      frag = data[j];
      let len = frag.byteLength;
      if (payloadStartOffset) {
        if (payloadStartOffset > len) {
          payloadStartOffset -= len;
          continue;
        } else {
          frag = frag.subarray(payloadStartOffset);
          len -= payloadStartOffset;
          payloadStartOffset = 0;
        }
      }
      pesData.set(frag, i);
      i += len;
    }
    if (pesLen) {
      pesLen -= pesHdrLen + 3;
    }
    return {
      data: pesData,
      pts: pesPts,
      dts: pesDts,
      len: pesLen
    };
  }
  return null;
}
function pushAccessUnit(avcSample, avcTrack) {
  if (avcSample.units.length && avcSample.frame) {
    if (avcSample.pts === void 0) {
      const samples = avcTrack.samples;
      const nbSamples = samples.length;
      if (nbSamples) {
        const lastSample = samples[nbSamples - 1];
        avcSample.pts = lastSample.pts;
        avcSample.dts = lastSample.dts;
      } else {
        avcTrack.dropped++;
        return;
      }
    }
    avcTrack.samples.push(avcSample);
  }
  if (avcSample.debug.length) {
    logger.log(avcSample.pts + "/" + avcSample.dts + ":" + avcSample.debug);
  }
}
var MP3Demuxer = class extends BaseAudioDemuxer {
  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);
    this._audioTrack = {
      container: "audio/mpeg",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "mp3",
      samples: [],
      manifestCodec: audioCodec,
      duration: trackDuration,
      inputTimeScale: 9e4,
      dropped: 0
    };
  }
  static probe(data) {
    if (!data) {
      return false;
    }
    const id3Data = getID3Data(data, 0) || [];
    let offset = id3Data.length;
    for (let length = data.length; offset < length; offset++) {
      if (probe(data, offset)) {
        logger.log("MPEG Audio sync word found !");
        return true;
      }
    }
    return false;
  }
  canParse(data, offset) {
    return canParse(data, offset);
  }
  appendFrame(track, data, offset) {
    if (this.basePTS === null) {
      return;
    }
    return appendFrame(track, data, offset, this.basePTS, this.frameIndex);
  }
};
var AAC = class {
  static getSilentFrame(codec, channelCount) {
    switch (codec) {
      case "mp4a.40.2":
        if (channelCount === 1) {
          return new Uint8Array([0, 200, 0, 128, 35, 128]);
        } else if (channelCount === 2) {
          return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
        } else if (channelCount === 3) {
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
        } else if (channelCount === 4) {
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
        } else if (channelCount === 5) {
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
        } else if (channelCount === 6) {
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
        }
        break;
      default:
        if (channelCount === 1) {
          return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        } else if (channelCount === 2) {
          return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        } else if (channelCount === 3) {
          return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        }
        break;
    }
    return void 0;
  }
};
var UINT32_MAX = Math.pow(2, 32) - 1;
var MP4 = class _MP4 {
  static init() {
    _MP4.types = {
      avc1: [],
      // codingname
      avcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      ".mp3": [],
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: [],
      smhd: []
    };
    let i;
    for (i in _MP4.types) {
      if (_MP4.types.hasOwnProperty(i)) {
        _MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
      }
    }
    const videoHdlr = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      118,
      105,
      100,
      101,
      // handler_type: 'vide'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      86,
      105,
      100,
      101,
      111,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'VideoHandler'
    ]);
    const audioHdlr = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      115,
      111,
      117,
      110,
      // handler_type: 'soun'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      83,
      111,
      117,
      110,
      100,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'SoundHandler'
    ]);
    _MP4.HDLR_TYPES = {
      video: videoHdlr,
      audio: audioHdlr
    };
    const dref = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1,
      // entry_count
      0,
      0,
      0,
      12,
      // entry_size
      117,
      114,
      108,
      32,
      // 'url' type
      0,
      // version 0
      0,
      0,
      1
      // entry_flags
    ]);
    const stco = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0
      // entry_count
    ]);
    _MP4.STTS = _MP4.STSC = _MP4.STCO = stco;
    _MP4.STSZ = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // sample_size
      0,
      0,
      0,
      0
      // sample_count
    ]);
    _MP4.VMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      1,
      // flags
      0,
      0,
      // graphicsmode
      0,
      0,
      0,
      0,
      0,
      0
      // opcolor
    ]);
    _MP4.SMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      // balance
      0,
      0
      // reserved
    ]);
    _MP4.STSD = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1
    ]);
    const majorBrand = new Uint8Array([105, 115, 111, 109]);
    const avc1Brand = new Uint8Array([97, 118, 99, 49]);
    const minorVersion = new Uint8Array([0, 0, 0, 1]);
    _MP4.FTYP = _MP4.box(_MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
    _MP4.DINF = _MP4.box(_MP4.types.dinf, _MP4.box(_MP4.types.dref, dref));
  }
  static box(type2, ...payload) {
    let size = 8;
    let i = payload.length;
    const len = i;
    while (i--) {
      size += payload[i].byteLength;
    }
    const result = new Uint8Array(size);
    result[0] = size >> 24 & 255;
    result[1] = size >> 16 & 255;
    result[2] = size >> 8 & 255;
    result[3] = size & 255;
    result.set(type2, 4);
    for (i = 0, size = 8; i < len; i++) {
      result.set(payload[i], size);
      size += payload[i].byteLength;
    }
    return result;
  }
  static hdlr(type2) {
    return _MP4.box(_MP4.types.hdlr, _MP4.HDLR_TYPES[type2]);
  }
  static mdat(data) {
    return _MP4.box(_MP4.types.mdat, data);
  }
  static mdhd(timescale2, duration5) {
    duration5 *= timescale2;
    const upperWordDuration = Math.floor(duration5 / (UINT32_MAX + 1));
    const lowerWordDuration = Math.floor(duration5 % (UINT32_MAX + 1));
    return _MP4.box(_MP4.types.mdhd, new Uint8Array([
      1,
      // version 1
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      // modification_time
      timescale2 >> 24 & 255,
      timescale2 >> 16 & 255,
      timescale2 >> 8 & 255,
      timescale2 & 255,
      // timescale
      upperWordDuration >> 24,
      upperWordDuration >> 16 & 255,
      upperWordDuration >> 8 & 255,
      upperWordDuration & 255,
      lowerWordDuration >> 24,
      lowerWordDuration >> 16 & 255,
      lowerWordDuration >> 8 & 255,
      lowerWordDuration & 255,
      85,
      196,
      // 'und' language (undetermined)
      0,
      0
    ]));
  }
  static mdia(track) {
    return _MP4.box(_MP4.types.mdia, _MP4.mdhd(track.timescale, track.duration), _MP4.hdlr(track.type), _MP4.minf(track));
  }
  static mfhd(sequenceNumber) {
    return _MP4.box(_MP4.types.mfhd, new Uint8Array([
      0,
      0,
      0,
      0,
      // flags
      sequenceNumber >> 24,
      sequenceNumber >> 16 & 255,
      sequenceNumber >> 8 & 255,
      sequenceNumber & 255
      // sequence_number
    ]));
  }
  static minf(track) {
    if (track.type === "audio") {
      return _MP4.box(_MP4.types.minf, _MP4.box(_MP4.types.smhd, _MP4.SMHD), _MP4.DINF, _MP4.stbl(track));
    } else {
      return _MP4.box(_MP4.types.minf, _MP4.box(_MP4.types.vmhd, _MP4.VMHD), _MP4.DINF, _MP4.stbl(track));
    }
  }
  static moof(sn, baseMediaDecodeTime, track) {
    return _MP4.box(_MP4.types.moof, _MP4.mfhd(sn), _MP4.traf(track, baseMediaDecodeTime));
  }
  static moov(tracks) {
    let i = tracks.length;
    const boxes = [];
    while (i--) {
      boxes[i] = _MP4.trak(tracks[i]);
    }
    return _MP4.box.apply(null, [_MP4.types.moov, _MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(_MP4.mvex(tracks)));
  }
  static mvex(tracks) {
    let i = tracks.length;
    const boxes = [];
    while (i--) {
      boxes[i] = _MP4.trex(tracks[i]);
    }
    return _MP4.box.apply(null, [_MP4.types.mvex, ...boxes]);
  }
  static mvhd(timescale2, duration5) {
    duration5 *= timescale2;
    const upperWordDuration = Math.floor(duration5 / (UINT32_MAX + 1));
    const lowerWordDuration = Math.floor(duration5 % (UINT32_MAX + 1));
    const bytes = new Uint8Array([
      1,
      // version 1
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      // modification_time
      timescale2 >> 24 & 255,
      timescale2 >> 16 & 255,
      timescale2 >> 8 & 255,
      timescale2 & 255,
      // timescale
      upperWordDuration >> 24,
      upperWordDuration >> 16 & 255,
      upperWordDuration >> 8 & 255,
      upperWordDuration & 255,
      lowerWordDuration >> 24,
      lowerWordDuration >> 16 & 255,
      lowerWordDuration >> 8 & 255,
      lowerWordDuration & 255,
      0,
      1,
      0,
      0,
      // 1.0 rate
      1,
      0,
      // 1.0 volume
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // pre_defined
      255,
      255,
      255,
      255
      // next_track_ID
    ]);
    return _MP4.box(_MP4.types.mvhd, bytes);
  }
  static sdtp(track) {
    const samples = track.samples || [];
    const bytes = new Uint8Array(4 + samples.length);
    let i;
    let flags;
    for (i = 0; i < samples.length; i++) {
      flags = samples[i].flags;
      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
    }
    return _MP4.box(_MP4.types.sdtp, bytes);
  }
  static stbl(track) {
    return _MP4.box(_MP4.types.stbl, _MP4.stsd(track), _MP4.box(_MP4.types.stts, _MP4.STTS), _MP4.box(_MP4.types.stsc, _MP4.STSC), _MP4.box(_MP4.types.stsz, _MP4.STSZ), _MP4.box(_MP4.types.stco, _MP4.STCO));
  }
  static avc1(track) {
    let sps = [];
    let pps = [];
    let i;
    let data;
    let len;
    for (i = 0; i < track.sps.length; i++) {
      data = track.sps[i];
      len = data.byteLength;
      sps.push(len >>> 8 & 255);
      sps.push(len & 255);
      sps = sps.concat(Array.prototype.slice.call(data));
    }
    for (i = 0; i < track.pps.length; i++) {
      data = track.pps[i];
      len = data.byteLength;
      pps.push(len >>> 8 & 255);
      pps.push(len & 255);
      pps = pps.concat(Array.prototype.slice.call(data));
    }
    const avcc = _MP4.box(_MP4.types.avcC, new Uint8Array([
      1,
      // version
      sps[3],
      // profile
      sps[4],
      // profile compat
      sps[5],
      // level
      252 | 3,
      // lengthSizeMinusOne, hard-coded to 4 bytes
      224 | track.sps.length
      // 3bit reserved (111) + numOfSequenceParameterSets
    ].concat(sps).concat([
      track.pps.length
      // numOfPictureParameterSets
    ]).concat(pps)));
    const width2 = track.width;
    const height2 = track.height;
    const hSpacing = track.pixelRatio[0];
    const vSpacing = track.pixelRatio[1];
    return _MP4.box(
      _MP4.types.avc1,
      new Uint8Array([
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        width2 >> 8 & 255,
        width2 & 255,
        // width
        height2 >> 8 & 255,
        height2 & 255,
        // height
        0,
        72,
        0,
        0,
        // horizresolution
        0,
        72,
        0,
        0,
        // vertresolution
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // frame_count
        18,
        100,
        97,
        105,
        108,
        // dailymotion/hls.js
        121,
        109,
        111,
        116,
        105,
        111,
        110,
        47,
        104,
        108,
        115,
        46,
        106,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // compressorname
        0,
        24,
        // depth = 24
        17,
        17
      ]),
      // pre_defined = -1
      avcc,
      _MP4.box(_MP4.types.btrt, new Uint8Array([
        0,
        28,
        156,
        128,
        // bufferSizeDB
        0,
        45,
        198,
        192,
        // maxBitrate
        0,
        45,
        198,
        192
      ])),
      // avgBitrate
      _MP4.box(_MP4.types.pasp, new Uint8Array([
        hSpacing >> 24,
        // hSpacing
        hSpacing >> 16 & 255,
        hSpacing >> 8 & 255,
        hSpacing & 255,
        vSpacing >> 24,
        // vSpacing
        vSpacing >> 16 & 255,
        vSpacing >> 8 & 255,
        vSpacing & 255
      ]))
    );
  }
  static esds(track) {
    const configlen = track.config.length;
    return new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      3,
      // descriptor_type
      23 + configlen,
      // length
      0,
      1,
      // es_id
      0,
      // stream_priority
      4,
      // descriptor_type
      15 + configlen,
      // length
      64,
      // codec : mpeg4_audio
      21,
      // stream_type
      0,
      0,
      0,
      // buffer_size
      0,
      0,
      0,
      0,
      // maxBitrate
      0,
      0,
      0,
      0,
      // avgBitrate
      5
      // descriptor_type
    ].concat([configlen]).concat(track.config).concat([6, 1, 2]));
  }
  static mp4a(track) {
    const samplerate = track.samplerate;
    return _MP4.box(_MP4.types.mp4a, new Uint8Array([
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      // reserved
      0,
      1,
      // data_reference_index
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      track.channelCount,
      // channelcount
      0,
      16,
      // sampleSize:16bits
      0,
      0,
      0,
      0,
      // reserved2
      samplerate >> 8 & 255,
      samplerate & 255,
      //
      0,
      0
    ]), _MP4.box(_MP4.types.esds, _MP4.esds(track)));
  }
  static mp3(track) {
    const samplerate = track.samplerate;
    return _MP4.box(_MP4.types[".mp3"], new Uint8Array([
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      // reserved
      0,
      1,
      // data_reference_index
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      track.channelCount,
      // channelcount
      0,
      16,
      // sampleSize:16bits
      0,
      0,
      0,
      0,
      // reserved2
      samplerate >> 8 & 255,
      samplerate & 255,
      //
      0,
      0
    ]));
  }
  static stsd(track) {
    if (track.type === "audio") {
      if (track.segmentCodec === "mp3" && track.codec === "mp3") {
        return _MP4.box(_MP4.types.stsd, _MP4.STSD, _MP4.mp3(track));
      }
      return _MP4.box(_MP4.types.stsd, _MP4.STSD, _MP4.mp4a(track));
    } else {
      return _MP4.box(_MP4.types.stsd, _MP4.STSD, _MP4.avc1(track));
    }
  }
  static tkhd(track) {
    const id = track.id;
    const duration5 = track.duration * track.timescale;
    const width2 = track.width;
    const height2 = track.height;
    const upperWordDuration = Math.floor(duration5 / (UINT32_MAX + 1));
    const lowerWordDuration = Math.floor(duration5 % (UINT32_MAX + 1));
    return _MP4.box(_MP4.types.tkhd, new Uint8Array([
      1,
      // version 1
      0,
      0,
      7,
      // flags
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      // modification_time
      id >> 24 & 255,
      id >> 16 & 255,
      id >> 8 & 255,
      id & 255,
      // track_ID
      0,
      0,
      0,
      0,
      // reserved
      upperWordDuration >> 24,
      upperWordDuration >> 16 & 255,
      upperWordDuration >> 8 & 255,
      upperWordDuration & 255,
      lowerWordDuration >> 24,
      lowerWordDuration >> 16 & 255,
      lowerWordDuration >> 8 & 255,
      lowerWordDuration & 255,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      // layer
      0,
      0,
      // alternate_group
      0,
      0,
      // non-audio track volume
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      width2 >> 8 & 255,
      width2 & 255,
      0,
      0,
      // width
      height2 >> 8 & 255,
      height2 & 255,
      0,
      0
      // height
    ]));
  }
  static traf(track, baseMediaDecodeTime) {
    const sampleDependencyTable = _MP4.sdtp(track);
    const id = track.id;
    const upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
    const lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
    return _MP4.box(
      _MP4.types.traf,
      _MP4.box(_MP4.types.tfhd, new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        id >> 24,
        id >> 16 & 255,
        id >> 8 & 255,
        id & 255
        // track_ID
      ])),
      _MP4.box(_MP4.types.tfdt, new Uint8Array([
        1,
        // version 1
        0,
        0,
        0,
        // flags
        upperWordBaseMediaDecodeTime >> 24,
        upperWordBaseMediaDecodeTime >> 16 & 255,
        upperWordBaseMediaDecodeTime >> 8 & 255,
        upperWordBaseMediaDecodeTime & 255,
        lowerWordBaseMediaDecodeTime >> 24,
        lowerWordBaseMediaDecodeTime >> 16 & 255,
        lowerWordBaseMediaDecodeTime >> 8 & 255,
        lowerWordBaseMediaDecodeTime & 255
      ])),
      _MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
      20 + // tfdt
      8 + // traf header
      16 + // mfhd
      8 + // moof header
      8),
      // mdat header
      sampleDependencyTable
    );
  }
  /**
   * Generate a track box.
   * @param track a track definition
   */
  static trak(track) {
    track.duration = track.duration || 4294967295;
    return _MP4.box(_MP4.types.trak, _MP4.tkhd(track), _MP4.mdia(track));
  }
  static trex(track) {
    const id = track.id;
    return _MP4.box(_MP4.types.trex, new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      id >> 24,
      id >> 16 & 255,
      id >> 8 & 255,
      id & 255,
      // track_ID
      0,
      0,
      0,
      1,
      // default_sample_description_index
      0,
      0,
      0,
      0,
      // default_sample_duration
      0,
      0,
      0,
      0,
      // default_sample_size
      0,
      1,
      0,
      1
      // default_sample_flags
    ]));
  }
  static trun(track, offset) {
    const samples = track.samples || [];
    const len = samples.length;
    const arraylen = 12 + 16 * len;
    const array = new Uint8Array(arraylen);
    let i;
    let sample;
    let duration5;
    let size;
    let flags;
    let cts;
    offset += 8 + arraylen;
    array.set([
      track.type === "video" ? 1 : 0,
      // version 1 for video with signed-int sample_composition_time_offset
      0,
      15,
      1,
      // flags
      len >>> 24 & 255,
      len >>> 16 & 255,
      len >>> 8 & 255,
      len & 255,
      // sample_count
      offset >>> 24 & 255,
      offset >>> 16 & 255,
      offset >>> 8 & 255,
      offset & 255
      // data_offset
    ], 0);
    for (i = 0; i < len; i++) {
      sample = samples[i];
      duration5 = sample.duration;
      size = sample.size;
      flags = sample.flags;
      cts = sample.cts;
      array.set([
        duration5 >>> 24 & 255,
        duration5 >>> 16 & 255,
        duration5 >>> 8 & 255,
        duration5 & 255,
        // sample_duration
        size >>> 24 & 255,
        size >>> 16 & 255,
        size >>> 8 & 255,
        size & 255,
        // sample_size
        flags.isLeading << 2 | flags.dependsOn,
        flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync,
        flags.degradPrio & 240 << 8,
        flags.degradPrio & 15,
        // sample_flags
        cts >>> 24 & 255,
        cts >>> 16 & 255,
        cts >>> 8 & 255,
        cts & 255
        // sample_composition_time_offset
      ], 12 + 16 * i);
    }
    return _MP4.box(_MP4.types.trun, array);
  }
  static initSegment(tracks) {
    if (!_MP4.types) {
      _MP4.init();
    }
    const movie = _MP4.moov(tracks);
    const result = new Uint8Array(_MP4.FTYP.byteLength + movie.byteLength);
    result.set(_MP4.FTYP);
    result.set(movie, _MP4.FTYP.byteLength);
    return result;
  }
};
MP4.types = void 0;
MP4.HDLR_TYPES = void 0;
MP4.STTS = void 0;
MP4.STSC = void 0;
MP4.STCO = void 0;
MP4.STSZ = void 0;
MP4.VMHD = void 0;
MP4.SMHD = void 0;
MP4.STSD = void 0;
MP4.FTYP = void 0;
MP4.DINF = void 0;
var MPEG_TS_CLOCK_FREQ_HZ = 9e4;
function toTimescaleFromBase(baseTime, destScale, srcBase = 1, round = false) {
  const result = baseTime * destScale * srcBase;
  return round ? Math.round(result) : result;
}
function toTimescaleFromScale(baseTime, destScale, srcScale = 1, round = false) {
  return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round);
}
function toMsFromMpegTsClock(baseTime, round = false) {
  return toTimescaleFromBase(baseTime, 1e3, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);
}
function toMpegTsClockFromTimescale(baseTime, srcScale = 1) {
  return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);
}
var MAX_SILENT_FRAME_DURATION = 10 * 1e3;
var AAC_SAMPLES_PER_FRAME = 1024;
var MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;
var chromeVersion = null;
var safariWebkitVersion = null;
var MP4Remuxer = class {
  constructor(observer, config, typeSupported, vendor = "") {
    this.observer = void 0;
    this.config = void 0;
    this.typeSupported = void 0;
    this.ISGenerated = false;
    this._initPTS = null;
    this._initDTS = null;
    this.nextAvcDts = null;
    this.nextAudioPts = null;
    this.videoSampleDuration = null;
    this.isAudioContiguous = false;
    this.isVideoContiguous = false;
    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    this.ISGenerated = false;
    if (chromeVersion === null) {
      const userAgent = navigator.userAgent || "";
      const result = userAgent.match(/Chrome\/(\d+)/i);
      chromeVersion = result ? parseInt(result[1]) : 0;
    }
    if (safariWebkitVersion === null) {
      const result = navigator.userAgent.match(/Safari\/(\d+)/i);
      safariWebkitVersion = result ? parseInt(result[1]) : 0;
    }
  }
  destroy() {
  }
  resetTimeStamp(defaultTimeStamp) {
    logger.log("[mp4-remuxer]: initPTS & initDTS reset");
    this._initPTS = this._initDTS = defaultTimeStamp;
  }
  resetNextTimestamp() {
    logger.log("[mp4-remuxer]: reset next timestamp");
    this.isVideoContiguous = false;
    this.isAudioContiguous = false;
  }
  resetInitSegment() {
    logger.log("[mp4-remuxer]: ISGenerated flag reset");
    this.ISGenerated = false;
  }
  getVideoStartPts(videoSamples) {
    let rolloverDetected = false;
    const startPTS = videoSamples.reduce((minPTS, sample) => {
      const delta = sample.pts - minPTS;
      if (delta < -4294967296) {
        rolloverDetected = true;
        return normalizePts(minPTS, sample.pts);
      } else if (delta > 0) {
        return minPTS;
      } else {
        return sample.pts;
      }
    }, videoSamples[0].pts);
    if (rolloverDetected) {
      logger.debug("PTS rollover detected");
    }
    return startPTS;
  }
  remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {
    let video;
    let audio;
    let initSegment;
    let text;
    let id3;
    let independent;
    let audioTimeOffset = timeOffset;
    let videoTimeOffset = timeOffset;
    const hasAudio = audioTrack.pid > -1;
    const hasVideo = videoTrack.pid > -1;
    const length = videoTrack.samples.length;
    const enoughAudioSamples = audioTrack.samples.length > 0;
    const enoughVideoSamples = flush && length > 0 || length > 1;
    const canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;
    if (canRemuxAvc) {
      if (!this.ISGenerated) {
        initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
      }
      const isVideoContiguous = this.isVideoContiguous;
      let firstKeyFrameIndex = -1;
      let firstKeyFramePTS;
      if (enoughVideoSamples) {
        firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);
        if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {
          independent = true;
          if (firstKeyFrameIndex > 0) {
            logger.warn(`[mp4-remuxer]: Dropped ${firstKeyFrameIndex} out of ${length} video samples due to a missing keyframe`);
            const startPTS = this.getVideoStartPts(videoTrack.samples);
            videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);
            videoTrack.dropped += firstKeyFrameIndex;
            videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;
            firstKeyFramePTS = videoTimeOffset;
          } else if (firstKeyFrameIndex === -1) {
            logger.warn(`[mp4-remuxer]: No keyframe found out of ${length} video samples`);
            independent = false;
          }
        }
      }
      if (this.ISGenerated) {
        if (enoughAudioSamples && enoughVideoSamples) {
          const startPTS = this.getVideoStartPts(videoTrack.samples);
          const tsDelta = normalizePts(audioTrack.samples[0].pts, startPTS) - startPTS;
          const audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;
          audioTimeOffset += Math.max(0, audiovideoTimestampDelta);
          videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);
        }
        if (enoughAudioSamples) {
          if (!audioTrack.samplerate) {
            logger.warn("[mp4-remuxer]: regenerate InitSegment as audio detected");
            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
          }
          audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : void 0);
          if (enoughVideoSamples) {
            const audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;
            if (!videoTrack.inputTimeScale) {
              logger.warn("[mp4-remuxer]: regenerate InitSegment as video detected");
              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
            }
            video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);
          }
        } else if (enoughVideoSamples) {
          video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);
        }
        if (video) {
          video.firstKeyFrame = firstKeyFrameIndex;
          video.independent = firstKeyFrameIndex !== -1;
          video.firstKeyFramePTS = firstKeyFramePTS;
        }
      }
    }
    if (this.ISGenerated && this._initPTS && this._initDTS) {
      if (id3Track.samples.length) {
        id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);
      }
      if (textTrack.samples.length) {
        text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);
      }
    }
    return {
      audio,
      video,
      initSegment,
      independent,
      text,
      id3
    };
  }
  generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {
    const audioSamples = audioTrack.samples;
    const videoSamples = videoTrack.samples;
    const typeSupported = this.typeSupported;
    const tracks = {};
    const _initPTS = this._initPTS;
    let computePTSDTS = !_initPTS || accurateTimeOffset;
    let container = "audio/mp4";
    let initPTS;
    let initDTS;
    let timescale2;
    if (computePTSDTS) {
      initPTS = initDTS = Infinity;
    }
    if (audioTrack.config && audioSamples.length) {
      audioTrack.timescale = audioTrack.samplerate;
      switch (audioTrack.segmentCodec) {
        case "mp3":
          if (typeSupported.mpeg) {
            container = "audio/mpeg";
            audioTrack.codec = "";
          } else if (typeSupported.mp3) {
            audioTrack.codec = "mp3";
          }
          break;
      }
      tracks.audio = {
        id: "audio",
        container,
        codec: audioTrack.codec,
        initSegment: audioTrack.segmentCodec === "mp3" && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([audioTrack]),
        metadata: {
          channelCount: audioTrack.channelCount
        }
      };
      if (computePTSDTS) {
        timescale2 = audioTrack.inputTimeScale;
        if (!_initPTS || timescale2 !== _initPTS.timescale) {
          initPTS = initDTS = audioSamples[0].pts - Math.round(timescale2 * timeOffset);
        } else {
          computePTSDTS = false;
        }
      }
    }
    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
      videoTrack.timescale = videoTrack.inputTimeScale;
      tracks.video = {
        id: "main",
        container: "video/mp4",
        codec: videoTrack.codec,
        initSegment: MP4.initSegment([videoTrack]),
        metadata: {
          width: videoTrack.width,
          height: videoTrack.height
        }
      };
      if (computePTSDTS) {
        timescale2 = videoTrack.inputTimeScale;
        if (!_initPTS || timescale2 !== _initPTS.timescale) {
          const startPTS = this.getVideoStartPts(videoSamples);
          const startOffset = Math.round(timescale2 * timeOffset);
          initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);
          initPTS = Math.min(initPTS, startPTS - startOffset);
        } else {
          computePTSDTS = false;
        }
      }
    }
    if (Object.keys(tracks).length) {
      this.ISGenerated = true;
      if (computePTSDTS) {
        this._initPTS = {
          baseTime: initPTS,
          timescale: timescale2
        };
        this._initDTS = {
          baseTime: initDTS,
          timescale: timescale2
        };
      } else {
        initPTS = timescale2 = void 0;
      }
      return {
        tracks,
        initPTS,
        timescale: timescale2
      };
    }
  }
  remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
    const timeScale = track.inputTimeScale;
    const inputSamples = track.samples;
    const outputSamples = [];
    const nbSamples = inputSamples.length;
    const initPTS = this._initPTS;
    let nextAvcDts = this.nextAvcDts;
    let offset = 8;
    let mp4SampleDuration = this.videoSampleDuration;
    let firstDTS;
    let lastDTS;
    let minPTS = Number.POSITIVE_INFINITY;
    let maxPTS = Number.NEGATIVE_INFINITY;
    let sortSamples = false;
    if (!contiguous || nextAvcDts === null) {
      const pts = timeOffset * timeScale;
      const cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);
      nextAvcDts = pts - cts;
    }
    const initTime = initPTS.baseTime * timeScale / initPTS.timescale;
    for (let i = 0; i < nbSamples; i++) {
      const sample = inputSamples[i];
      sample.pts = normalizePts(sample.pts - initTime, nextAvcDts);
      sample.dts = normalizePts(sample.dts - initTime, nextAvcDts);
      if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {
        sortSamples = true;
      }
    }
    if (sortSamples) {
      inputSamples.sort(function(a, b) {
        const deltadts = a.dts - b.dts;
        const deltapts = a.pts - b.pts;
        return deltadts || deltapts;
      });
    }
    firstDTS = inputSamples[0].dts;
    lastDTS = inputSamples[inputSamples.length - 1].dts;
    const inputDuration = lastDTS - firstDTS;
    const averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;
    if (contiguous) {
      const delta = firstDTS - nextAvcDts;
      const foundHole = delta > averageSampleDuration;
      const foundOverlap = delta < -1;
      if (foundHole || foundOverlap) {
        if (foundHole) {
          logger.warn(`AVC: ${toMsFromMpegTsClock(delta, true)} ms (${delta}dts) hole between fragments detected, filling it`);
        } else {
          logger.warn(`AVC: ${toMsFromMpegTsClock(-delta, true)} ms (${delta}dts) overlapping between fragments detected`);
        }
        if (!foundOverlap || nextAvcDts >= inputSamples[0].pts) {
          firstDTS = nextAvcDts;
          const firstPTS = inputSamples[0].pts - delta;
          inputSamples[0].dts = firstDTS;
          inputSamples[0].pts = firstPTS;
          logger.log(`Video: First PTS/DTS adjusted: ${toMsFromMpegTsClock(firstPTS, true)}/${toMsFromMpegTsClock(firstDTS, true)}, delta: ${toMsFromMpegTsClock(delta, true)} ms`);
        }
      }
    }
    firstDTS = Math.max(0, firstDTS);
    let nbNalu = 0;
    let naluLen = 0;
    for (let i = 0; i < nbSamples; i++) {
      const sample = inputSamples[i];
      const units = sample.units;
      const nbUnits = units.length;
      let sampleLen = 0;
      for (let j = 0; j < nbUnits; j++) {
        sampleLen += units[j].data.length;
      }
      naluLen += sampleLen;
      nbNalu += nbUnits;
      sample.length = sampleLen;
      sample.dts = Math.max(sample.dts, firstDTS);
      minPTS = Math.min(sample.pts, minPTS);
      maxPTS = Math.max(sample.pts, maxPTS);
    }
    lastDTS = inputSamples[nbSamples - 1].dts;
    const mdatSize = naluLen + 4 * nbNalu + 8;
    let mdat;
    try {
      mdat = new Uint8Array(mdatSize);
    } catch (err) {
      this.observer.emit(Events.ERROR, Events.ERROR, {
        type: ErrorTypes.MUX_ERROR,
        details: ErrorDetails.REMUX_ALLOC_ERROR,
        fatal: false,
        error: err,
        bytes: mdatSize,
        reason: `fail allocating video mdat ${mdatSize}`
      });
      return;
    }
    const view = new DataView(mdat.buffer);
    view.setUint32(0, mdatSize);
    mdat.set(MP4.types.mdat, 4);
    let stretchedLastFrame = false;
    let minDtsDelta = Number.POSITIVE_INFINITY;
    let minPtsDelta = Number.POSITIVE_INFINITY;
    let maxDtsDelta = Number.NEGATIVE_INFINITY;
    let maxPtsDelta = Number.NEGATIVE_INFINITY;
    for (let i = 0; i < nbSamples; i++) {
      const avcSample = inputSamples[i];
      const avcSampleUnits = avcSample.units;
      let mp4SampleLength = 0;
      for (let j = 0, nbUnits = avcSampleUnits.length; j < nbUnits; j++) {
        const unit = avcSampleUnits[j];
        const unitData = unit.data;
        const unitDataLen = unit.data.byteLength;
        view.setUint32(offset, unitDataLen);
        offset += 4;
        mdat.set(unitData, offset);
        offset += unitDataLen;
        mp4SampleLength += 4 + unitDataLen;
      }
      let ptsDelta;
      if (i < nbSamples - 1) {
        mp4SampleDuration = inputSamples[i + 1].dts - avcSample.dts;
        ptsDelta = inputSamples[i + 1].pts - avcSample.pts;
      } else {
        const config = this.config;
        const lastFrameDuration = i > 0 ? avcSample.dts - inputSamples[i - 1].dts : averageSampleDuration;
        ptsDelta = i > 0 ? avcSample.pts - inputSamples[i - 1].pts : averageSampleDuration;
        if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {
          const gapTolerance = Math.floor(config.maxBufferHole * timeScale);
          const deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;
          if (deltaToFrameEnd > gapTolerance) {
            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
            if (mp4SampleDuration < 0) {
              mp4SampleDuration = lastFrameDuration;
            } else {
              stretchedLastFrame = true;
            }
            logger.log(`[mp4-remuxer]: It is approximately ${deltaToFrameEnd / 90} ms to the next segment; using duration ${mp4SampleDuration / 90} ms for the last video frame.`);
          } else {
            mp4SampleDuration = lastFrameDuration;
          }
        } else {
          mp4SampleDuration = lastFrameDuration;
        }
      }
      const compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);
      minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);
      maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);
      minPtsDelta = Math.min(minPtsDelta, ptsDelta);
      maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);
      outputSamples.push(new Mp4Sample(avcSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));
    }
    if (outputSamples.length) {
      if (chromeVersion) {
        if (chromeVersion < 70) {
          const flags = outputSamples[0].flags;
          flags.dependsOn = 2;
          flags.isNonSync = 0;
        }
      } else if (safariWebkitVersion) {
        if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {
          logger.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
          let dts = firstDTS;
          for (let i = 0, len = outputSamples.length; i < len; i++) {
            const nextDts = dts + outputSamples[i].duration;
            const pts = dts + outputSamples[i].cts;
            if (i < len - 1) {
              const nextPts = nextDts + outputSamples[i + 1].cts;
              outputSamples[i].duration = nextPts - pts;
            } else {
              outputSamples[i].duration = i ? outputSamples[i - 1].duration : averageSampleDuration;
            }
            outputSamples[i].cts = 0;
            dts = nextDts;
          }
        }
      }
    }
    mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;
    this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;
    this.videoSampleDuration = mp4SampleDuration;
    this.isVideoContiguous = true;
    const moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends({}, track, {
      samples: outputSamples
    }));
    const type2 = "video";
    const data = {
      data1: moof,
      data2: mdat,
      startPTS: minPTS / timeScale,
      endPTS: (maxPTS + mp4SampleDuration) / timeScale,
      startDTS: firstDTS / timeScale,
      endDTS: nextAvcDts / timeScale,
      type: type2,
      hasAudio: false,
      hasVideo: true,
      nb: outputSamples.length,
      dropped: track.dropped
    };
    track.samples = [];
    track.dropped = 0;
    return data;
  }
  remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {
    const inputTimeScale = track.inputTimeScale;
    const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
    const scaleFactor = inputTimeScale / mp4timeScale;
    const mp4SampleDuration = track.segmentCodec === "aac" ? AAC_SAMPLES_PER_FRAME : MPEG_AUDIO_SAMPLE_PER_FRAME;
    const inputSampleDuration = mp4SampleDuration * scaleFactor;
    const initPTS = this._initPTS;
    const rawMPEG = track.segmentCodec === "mp3" && this.typeSupported.mpeg;
    const outputSamples = [];
    const alignedWithVideo = videoTimeOffset !== void 0;
    let inputSamples = track.samples;
    let offset = rawMPEG ? 0 : 8;
    let nextAudioPts = this.nextAudioPts || -1;
    const timeOffsetMpegTS = timeOffset * inputTimeScale;
    const initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;
    this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9e3 || Math.abs(normalizePts(inputSamples[0].pts - initTime, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration);
    inputSamples.forEach(function(sample) {
      sample.pts = normalizePts(sample.pts - initTime, timeOffsetMpegTS);
    });
    if (!contiguous || nextAudioPts < 0) {
      inputSamples = inputSamples.filter((sample) => sample.pts >= 0);
      if (!inputSamples.length) {
        return;
      }
      if (videoTimeOffset === 0) {
        nextAudioPts = 0;
      } else if (accurateTimeOffset && !alignedWithVideo) {
        nextAudioPts = Math.max(0, timeOffsetMpegTS);
      } else {
        nextAudioPts = inputSamples[0].pts;
      }
    }
    if (track.segmentCodec === "aac") {
      const maxAudioFramesDrift = this.config.maxAudioFramesDrift;
      for (let i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++) {
        const sample = inputSamples[i];
        const pts = sample.pts;
        const delta = pts - nextPts;
        const duration5 = Math.abs(1e3 * delta / inputTimeScale);
        if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {
          if (i === 0) {
            logger.warn(`Audio frame @ ${(pts / inputTimeScale).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1e3 * delta / inputTimeScale)} ms.`);
            this.nextAudioPts = nextAudioPts = nextPts = pts;
          }
        } else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration5 < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {
          let missing = Math.round(delta / inputSampleDuration);
          nextPts = pts - missing * inputSampleDuration;
          if (nextPts < 0) {
            missing--;
            nextPts += inputSampleDuration;
          }
          if (i === 0) {
            this.nextAudioPts = nextAudioPts = nextPts;
          }
          logger.warn(`[mp4-remuxer]: Injecting ${missing} audio frame @ ${(nextPts / inputTimeScale).toFixed(3)}s due to ${Math.round(1e3 * delta / inputTimeScale)} ms gap.`);
          for (let j = 0; j < missing; j++) {
            const newStamp = Math.max(nextPts, 0);
            let fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
            if (!fillFrame) {
              logger.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.");
              fillFrame = sample.unit.subarray();
            }
            inputSamples.splice(i, 0, {
              unit: fillFrame,
              pts: newStamp
            });
            nextPts += inputSampleDuration;
            i++;
          }
        }
        sample.pts = nextPts;
        nextPts += inputSampleDuration;
      }
    }
    let firstPTS = null;
    let lastPTS = null;
    let mdat;
    let mdatSize = 0;
    let sampleLength = inputSamples.length;
    while (sampleLength--) {
      mdatSize += inputSamples[sampleLength].unit.byteLength;
    }
    for (let j = 0, _nbSamples = inputSamples.length; j < _nbSamples; j++) {
      const audioSample = inputSamples[j];
      const unit = audioSample.unit;
      let pts = audioSample.pts;
      if (lastPTS !== null) {
        const prevSample = outputSamples[j - 1];
        prevSample.duration = Math.round((pts - lastPTS) / scaleFactor);
      } else {
        if (contiguous && track.segmentCodec === "aac") {
          pts = nextAudioPts;
        }
        firstPTS = pts;
        if (mdatSize > 0) {
          mdatSize += offset;
          try {
            mdat = new Uint8Array(mdatSize);
          } catch (err) {
            this.observer.emit(Events.ERROR, Events.ERROR, {
              type: ErrorTypes.MUX_ERROR,
              details: ErrorDetails.REMUX_ALLOC_ERROR,
              fatal: false,
              error: err,
              bytes: mdatSize,
              reason: `fail allocating audio mdat ${mdatSize}`
            });
            return;
          }
          if (!rawMPEG) {
            const view = new DataView(mdat.buffer);
            view.setUint32(0, mdatSize);
            mdat.set(MP4.types.mdat, 4);
          }
        } else {
          return;
        }
      }
      mdat.set(unit, offset);
      const unitLen = unit.byteLength;
      offset += unitLen;
      outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));
      lastPTS = pts;
    }
    const nbSamples = outputSamples.length;
    if (!nbSamples) {
      return;
    }
    const lastSample = outputSamples[outputSamples.length - 1];
    this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;
    const moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {
      samples: outputSamples
    }));
    track.samples = [];
    const start2 = firstPTS / inputTimeScale;
    const end = nextAudioPts / inputTimeScale;
    const type2 = "audio";
    const audioData = {
      data1: moof,
      data2: mdat,
      startPTS: start2,
      endPTS: end,
      startDTS: start2,
      endDTS: end,
      type: type2,
      hasAudio: true,
      hasVideo: false,
      nb: nbSamples
    };
    this.isAudioContiguous = true;
    return audioData;
  }
  remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
    const inputTimeScale = track.inputTimeScale;
    const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
    const scaleFactor = inputTimeScale / mp4timeScale;
    const nextAudioPts = this.nextAudioPts;
    const initDTS = this._initDTS;
    const init90kHz = initDTS.baseTime * 9e4 / initDTS.timescale;
    const startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + init90kHz;
    const endDTS = videoData.endDTS * inputTimeScale + init90kHz;
    const frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME;
    const nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);
    const silentFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
    logger.warn("[mp4-remuxer]: remux empty Audio");
    if (!silentFrame) {
      logger.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec");
      return;
    }
    const samples = [];
    for (let i = 0; i < nbSamples; i++) {
      const stamp = startDTS + i * frameDuration;
      samples.push({
        unit: silentFrame,
        pts: stamp,
        dts: stamp
      });
    }
    track.samples = samples;
    return this.remuxAudio(track, timeOffset, contiguous, false);
  }
};
function normalizePts(value, reference) {
  let offset;
  if (reference === null) {
    return value;
  }
  if (reference < value) {
    offset = -8589934592;
  } else {
    offset = 8589934592;
  }
  while (Math.abs(value - reference) > 4294967296) {
    value += offset;
  }
  return value;
}
function findKeyframeIndex(samples) {
  for (let i = 0; i < samples.length; i++) {
    if (samples[i].key) {
      return i;
    }
  }
  return -1;
}
function flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {
  const length = track.samples.length;
  if (!length) {
    return;
  }
  const inputTimeScale = track.inputTimeScale;
  for (let index = 0; index < length; index++) {
    const sample = track.samples[index];
    sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
    sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
  }
  const samples = track.samples;
  track.samples = [];
  return {
    samples
  };
}
function flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {
  const length = track.samples.length;
  if (!length) {
    return;
  }
  const inputTimeScale = track.inputTimeScale;
  for (let index = 0; index < length; index++) {
    const sample = track.samples[index];
    sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
  }
  track.samples.sort((a, b) => a.pts - b.pts);
  const samples = track.samples;
  track.samples = [];
  return {
    samples
  };
}
var Mp4Sample = class {
  constructor(isKeyframe, duration5, size, cts) {
    this.size = void 0;
    this.duration = void 0;
    this.cts = void 0;
    this.flags = void 0;
    this.duration = duration5;
    this.size = size;
    this.cts = cts;
    this.flags = new Mp4SampleFlags(isKeyframe);
  }
};
var Mp4SampleFlags = class {
  constructor(isKeyframe) {
    this.isLeading = 0;
    this.isDependedOn = 0;
    this.hasRedundancy = 0;
    this.degradPrio = 0;
    this.dependsOn = 1;
    this.isNonSync = 1;
    this.dependsOn = isKeyframe ? 2 : 1;
    this.isNonSync = isKeyframe ? 0 : 1;
  }
};
var PassThroughRemuxer = class {
  constructor() {
    this.emitInitSegment = false;
    this.audioCodec = void 0;
    this.videoCodec = void 0;
    this.initData = void 0;
    this.initPTS = null;
    this.initTracks = void 0;
    this.lastEndTime = null;
  }
  destroy() {
  }
  resetTimeStamp(defaultInitPTS) {
    this.initPTS = defaultInitPTS;
    this.lastEndTime = null;
  }
  resetNextTimestamp() {
    this.lastEndTime = null;
  }
  resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {
    this.audioCodec = audioCodec;
    this.videoCodec = videoCodec;
    this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));
    this.emitInitSegment = true;
  }
  generateInitSegment(initSegment) {
    let {
      audioCodec,
      videoCodec
    } = this;
    if (!(initSegment != null && initSegment.byteLength)) {
      this.initTracks = void 0;
      this.initData = void 0;
      return;
    }
    const initData = this.initData = parseInitSegment(initSegment);
    if (!audioCodec) {
      audioCodec = getParsedTrackCodec(initData.audio, ElementaryStreamTypes.AUDIO);
    }
    if (!videoCodec) {
      videoCodec = getParsedTrackCodec(initData.video, ElementaryStreamTypes.VIDEO);
    }
    const tracks = {};
    if (initData.audio && initData.video) {
      tracks.audiovideo = {
        container: "video/mp4",
        codec: audioCodec + "," + videoCodec,
        initSegment,
        id: "main"
      };
    } else if (initData.audio) {
      tracks.audio = {
        container: "audio/mp4",
        codec: audioCodec,
        initSegment,
        id: "audio"
      };
    } else if (initData.video) {
      tracks.video = {
        container: "video/mp4",
        codec: videoCodec,
        initSegment,
        id: "main"
      };
    } else {
      logger.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.");
    }
    this.initTracks = tracks;
  }
  remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {
    var _initData, _initData2;
    let {
      initPTS,
      lastEndTime
    } = this;
    const result = {
      audio: void 0,
      video: void 0,
      text: textTrack,
      id3: id3Track,
      initSegment: void 0
    };
    if (!isFiniteNumber(lastEndTime)) {
      lastEndTime = this.lastEndTime = timeOffset || 0;
    }
    const data = videoTrack.samples;
    if (!(data != null && data.length)) {
      return result;
    }
    const initSegment = {
      initPTS: void 0,
      timescale: 1
    };
    let initData = this.initData;
    if (!((_initData = initData) != null && _initData.length)) {
      this.generateInitSegment(data);
      initData = this.initData;
    }
    if (!((_initData2 = initData) != null && _initData2.length)) {
      logger.warn("[passthrough-remuxer.ts]: Failed to generate initSegment.");
      return result;
    }
    if (this.emitInitSegment) {
      initSegment.tracks = this.initTracks;
      this.emitInitSegment = false;
    }
    const duration5 = getDuration(data, initData);
    const startDTS = getStartDTS(initData, data);
    const decodeTime = startDTS === null ? timeOffset : startDTS;
    if (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration5) || initSegment.timescale !== initPTS.timescale && accurateTimeOffset) {
      initSegment.initPTS = decodeTime - timeOffset;
      if (initPTS && initPTS.timescale === 1) {
        logger.warn(`Adjusting initPTS by ${initSegment.initPTS - initPTS.baseTime}`);
      }
      this.initPTS = initPTS = {
        baseTime: initSegment.initPTS,
        timescale: 1
      };
    }
    const startTime = audioTrack ? decodeTime - initPTS.baseTime / initPTS.timescale : lastEndTime;
    const endTime = startTime + duration5;
    offsetStartDTS(initData, data, initPTS.baseTime / initPTS.timescale);
    if (duration5 > 0) {
      this.lastEndTime = endTime;
    } else {
      logger.warn("Duration parsed from mp4 should be greater than zero");
      this.resetNextTimestamp();
    }
    const hasAudio = !!initData.audio;
    const hasVideo = !!initData.video;
    let type2 = "";
    if (hasAudio) {
      type2 += "audio";
    }
    if (hasVideo) {
      type2 += "video";
    }
    const track = {
      data1: data,
      startPTS: startTime,
      startDTS: startTime,
      endPTS: endTime,
      endDTS: endTime,
      type: type2,
      hasAudio,
      hasVideo,
      nb: 1,
      dropped: 0
    };
    result.audio = track.type === "audio" ? track : void 0;
    result.video = track.type !== "audio" ? track : void 0;
    result.initSegment = initSegment;
    result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);
    if (textTrack.samples.length) {
      result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);
    }
    return result;
  }
};
function isInvalidInitPts(initPTS, startDTS, timeOffset, duration5) {
  if (initPTS === null) {
    return true;
  }
  const minDuration = Math.max(duration5, 1);
  const startTime = startDTS - initPTS.baseTime / initPTS.timescale;
  return Math.abs(startTime - timeOffset) > minDuration;
}
function getParsedTrackCodec(track, type2) {
  const parsedCodec = track == null ? void 0 : track.codec;
  if (parsedCodec && parsedCodec.length > 4) {
    return parsedCodec;
  }
  if (parsedCodec === "hvc1" || parsedCodec === "hev1") {
    return "hvc1.1.6.L120.90";
  }
  if (parsedCodec === "av01") {
    return "av01.0.04M.08";
  }
  if (parsedCodec === "avc1" || type2 === ElementaryStreamTypes.VIDEO) {
    return "avc1.42e01e";
  }
  return "mp4a.40.5";
}
var now;
try {
  now = self.performance.now.bind(self.performance);
} catch (err) {
  logger.debug("Unable to use Performance API on this environment");
  now = typeof self !== "undefined" && self.Date.now;
}
var muxConfig = [{
  demux: MP4Demuxer,
  remux: PassThroughRemuxer
}, {
  demux: TSDemuxer,
  remux: MP4Remuxer
}, {
  demux: AACDemuxer,
  remux: MP4Remuxer
}, {
  demux: MP3Demuxer,
  remux: MP4Remuxer
}];
var Transmuxer = class {
  constructor(observer, typeSupported, config, vendor, id) {
    this.async = false;
    this.observer = void 0;
    this.typeSupported = void 0;
    this.config = void 0;
    this.vendor = void 0;
    this.id = void 0;
    this.demuxer = void 0;
    this.remuxer = void 0;
    this.decrypter = void 0;
    this.probe = void 0;
    this.decryptionPromise = null;
    this.transmuxConfig = void 0;
    this.currentTransmuxState = void 0;
    this.observer = observer;
    this.typeSupported = typeSupported;
    this.config = config;
    this.vendor = vendor;
    this.id = id;
  }
  configure(transmuxConfig) {
    this.transmuxConfig = transmuxConfig;
    if (this.decrypter) {
      this.decrypter.reset();
    }
  }
  push(data, decryptdata, chunkMeta, state) {
    const stats = chunkMeta.transmuxing;
    stats.executeStart = now();
    let uintData = new Uint8Array(data);
    const {
      currentTransmuxState,
      transmuxConfig
    } = this;
    if (state) {
      this.currentTransmuxState = state;
    }
    const {
      contiguous,
      discontinuity,
      trackSwitch,
      accurateTimeOffset,
      timeOffset,
      initSegmentChange
    } = state || currentTransmuxState;
    const {
      audioCodec,
      videoCodec,
      defaultInitPts,
      duration: duration5,
      initSegmentData
    } = transmuxConfig;
    const keyData = getEncryptionType(uintData, decryptdata);
    if (keyData && keyData.method === "AES-128") {
      const decrypter = this.getDecrypter();
      if (decrypter.isSync()) {
        let decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);
        const loadingParts = chunkMeta.part > -1;
        if (loadingParts) {
          decryptedData = decrypter.flush();
        }
        if (!decryptedData) {
          stats.executeEnd = now();
          return emptyResult(chunkMeta);
        }
        uintData = new Uint8Array(decryptedData);
      } else {
        this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then((decryptedData) => {
          const result2 = this.push(decryptedData, null, chunkMeta);
          this.decryptionPromise = null;
          return result2;
        });
        return this.decryptionPromise;
      }
    }
    const resetMuxers = this.needsProbing(discontinuity, trackSwitch);
    if (resetMuxers) {
      const error = this.configureTransmuxer(uintData);
      if (error) {
        logger.warn(`[transmuxer] ${error.message}`);
        this.observer.emit(Events.ERROR, Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.FRAG_PARSING_ERROR,
          fatal: false,
          error,
          reason: error.message
        });
        stats.executeEnd = now();
        return emptyResult(chunkMeta);
      }
    }
    if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {
      this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration5, decryptdata);
    }
    if (discontinuity || initSegmentChange || resetMuxers) {
      this.resetInitialTimestamp(defaultInitPts);
    }
    if (!contiguous) {
      this.resetContiguity();
    }
    const result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);
    const currentState = this.currentTransmuxState;
    currentState.contiguous = true;
    currentState.discontinuity = false;
    currentState.trackSwitch = false;
    stats.executeEnd = now();
    return result;
  }
  // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)
  flush(chunkMeta) {
    const stats = chunkMeta.transmuxing;
    stats.executeStart = now();
    const {
      decrypter,
      currentTransmuxState,
      decryptionPromise
    } = this;
    if (decryptionPromise) {
      return decryptionPromise.then(() => {
        return this.flush(chunkMeta);
      });
    }
    const transmuxResults = [];
    const {
      timeOffset
    } = currentTransmuxState;
    if (decrypter) {
      const decryptedData = decrypter.flush();
      if (decryptedData) {
        transmuxResults.push(this.push(decryptedData, null, chunkMeta));
      }
    }
    const {
      demuxer,
      remuxer
    } = this;
    if (!demuxer || !remuxer) {
      stats.executeEnd = now();
      return [emptyResult(chunkMeta)];
    }
    const demuxResultOrPromise = demuxer.flush(timeOffset);
    if (isPromise(demuxResultOrPromise)) {
      return demuxResultOrPromise.then((demuxResult) => {
        this.flushRemux(transmuxResults, demuxResult, chunkMeta);
        return transmuxResults;
      });
    }
    this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);
    return transmuxResults;
  }
  flushRemux(transmuxResults, demuxResult, chunkMeta) {
    const {
      audioTrack,
      videoTrack,
      id3Track,
      textTrack
    } = demuxResult;
    const {
      accurateTimeOffset,
      timeOffset
    } = this.currentTransmuxState;
    logger.log(`[transmuxer.ts]: Flushed fragment ${chunkMeta.sn}${chunkMeta.part > -1 ? " p: " + chunkMeta.part : ""} of level ${chunkMeta.level}`);
    const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);
    transmuxResults.push({
      remuxResult,
      chunkMeta
    });
    chunkMeta.transmuxing.executeEnd = now();
  }
  resetInitialTimestamp(defaultInitPts) {
    const {
      demuxer,
      remuxer
    } = this;
    if (!demuxer || !remuxer) {
      return;
    }
    demuxer.resetTimeStamp(defaultInitPts);
    remuxer.resetTimeStamp(defaultInitPts);
  }
  resetContiguity() {
    const {
      demuxer,
      remuxer
    } = this;
    if (!demuxer || !remuxer) {
      return;
    }
    demuxer.resetContiguity();
    remuxer.resetNextTimestamp();
  }
  resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {
    const {
      demuxer,
      remuxer
    } = this;
    if (!demuxer || !remuxer) {
      return;
    }
    demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);
    remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);
  }
  destroy() {
    if (this.demuxer) {
      this.demuxer.destroy();
      this.demuxer = void 0;
    }
    if (this.remuxer) {
      this.remuxer.destroy();
      this.remuxer = void 0;
    }
  }
  transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {
    let result;
    if (keyData && keyData.method === "SAMPLE-AES") {
      result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);
    } else {
      result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);
    }
    return result;
  }
  transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {
    const {
      audioTrack,
      videoTrack,
      id3Track,
      textTrack
    } = this.demuxer.demux(data, timeOffset, false, !this.config.progressive);
    const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);
    return {
      remuxResult,
      chunkMeta
    };
  }
  transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {
    return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then((demuxResult) => {
      const remuxResult = this.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, this.id);
      return {
        remuxResult,
        chunkMeta
      };
    });
  }
  configureTransmuxer(data) {
    const {
      config,
      observer,
      typeSupported,
      vendor
    } = this;
    let mux;
    for (let i = 0, len = muxConfig.length; i < len; i++) {
      if (muxConfig[i].demux.probe(data)) {
        mux = muxConfig[i];
        break;
      }
    }
    if (!mux) {
      return new Error("Failed to find demuxer by probing fragment data");
    }
    const demuxer = this.demuxer;
    const remuxer = this.remuxer;
    const Remuxer = mux.remux;
    const Demuxer = mux.demux;
    if (!remuxer || !(remuxer instanceof Remuxer)) {
      this.remuxer = new Remuxer(observer, config, typeSupported, vendor);
    }
    if (!demuxer || !(demuxer instanceof Demuxer)) {
      this.demuxer = new Demuxer(observer, config, typeSupported);
      this.probe = Demuxer.probe;
    }
  }
  needsProbing(discontinuity, trackSwitch) {
    return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;
  }
  getDecrypter() {
    let decrypter = this.decrypter;
    if (!decrypter) {
      decrypter = this.decrypter = new Decrypter(this.config);
    }
    return decrypter;
  }
};
function getEncryptionType(data, decryptData) {
  let encryptionType = null;
  if (data.byteLength > 0 && decryptData != null && decryptData.key != null && decryptData.iv !== null && decryptData.method != null) {
    encryptionType = decryptData;
  }
  return encryptionType;
}
var emptyResult = (chunkMeta) => ({
  remuxResult: {},
  chunkMeta
});
function isPromise(p) {
  return "then" in p && p.then instanceof Function;
}
var TransmuxConfig = class {
  constructor(audioCodec, videoCodec, initSegmentData, duration5, defaultInitPts) {
    this.audioCodec = void 0;
    this.videoCodec = void 0;
    this.initSegmentData = void 0;
    this.duration = void 0;
    this.defaultInitPts = void 0;
    this.audioCodec = audioCodec;
    this.videoCodec = videoCodec;
    this.initSegmentData = initSegmentData;
    this.duration = duration5;
    this.defaultInitPts = defaultInitPts || null;
  }
};
var TransmuxState = class {
  constructor(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {
    this.discontinuity = void 0;
    this.contiguous = void 0;
    this.accurateTimeOffset = void 0;
    this.trackSwitch = void 0;
    this.timeOffset = void 0;
    this.initSegmentChange = void 0;
    this.discontinuity = discontinuity;
    this.contiguous = contiguous;
    this.accurateTimeOffset = accurateTimeOffset;
    this.trackSwitch = trackSwitch;
    this.timeOffset = timeOffset;
    this.initSegmentChange = initSegmentChange;
  }
};
var eventemitter3 = {
  exports: {}
};
(function(module) {
  var has = Object.prototype.hasOwnProperty, prefix = "~";
  function Events3() {
  }
  if (Object.create) {
    Events3.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events3().__proto__) prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events3();
    else delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events3();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0) return names;
    for (name in events = this._events) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on3(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
      else clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events3();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
var EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
var MediaSource$1 = getMediaSource() || {
  isTypeSupported: () => false
};
var TransmuxerInterface = class {
  constructor(hls, id, onTransmuxComplete, onFlush) {
    this.error = null;
    this.hls = void 0;
    this.id = void 0;
    this.observer = void 0;
    this.frag = null;
    this.part = null;
    this.useWorker = void 0;
    this.workerContext = null;
    this.onwmsg = void 0;
    this.transmuxer = null;
    this.onTransmuxComplete = void 0;
    this.onFlush = void 0;
    const config = hls.config;
    this.hls = hls;
    this.id = id;
    this.useWorker = !!config.enableWorker;
    this.onTransmuxComplete = onTransmuxComplete;
    this.onFlush = onFlush;
    const forwardMessage = (ev, data) => {
      data = data || {};
      data.frag = this.frag;
      data.id = this.id;
      if (ev === Events.ERROR) {
        this.error = data.error;
      }
      this.hls.trigger(ev, data);
    };
    this.observer = new EventEmitter();
    this.observer.on(Events.FRAG_DECRYPTED, forwardMessage);
    this.observer.on(Events.ERROR, forwardMessage);
    const typeSupported = {
      mp4: MediaSource$1.isTypeSupported("video/mp4"),
      mpeg: MediaSource$1.isTypeSupported("audio/mpeg"),
      mp3: MediaSource$1.isTypeSupported('audio/mp4; codecs="mp3"')
    };
    const vendor = navigator.vendor;
    if (this.useWorker && typeof Worker !== "undefined") {
      const canCreateWorker = config.workerPath || hasUMDWorker();
      if (canCreateWorker) {
        try {
          if (config.workerPath) {
            logger.log(`loading Web Worker ${config.workerPath} for "${id}"`);
            this.workerContext = loadWorker(config.workerPath);
          } else {
            logger.log(`injecting Web Worker for "${id}"`);
            this.workerContext = injectWorker();
          }
          this.onwmsg = (ev) => this.onWorkerMessage(ev);
          const {
            worker
          } = this.workerContext;
          worker.addEventListener("message", this.onwmsg);
          worker.onerror = (event) => {
            const error = new Error(`${event.message}  (${event.filename}:${event.lineno})`);
            config.enableWorker = false;
            logger.warn(`Error in "${id}" Web Worker, fallback to inline`);
            this.hls.trigger(Events.ERROR, {
              type: ErrorTypes.OTHER_ERROR,
              details: ErrorDetails.INTERNAL_EXCEPTION,
              fatal: false,
              event: "demuxerWorker",
              error
            });
          };
          worker.postMessage({
            cmd: "init",
            typeSupported,
            vendor,
            id,
            config: JSON.stringify(config)
          });
        } catch (err) {
          logger.warn(`Error setting up "${id}" Web Worker, fallback to inline`, err);
          this.resetWorker();
          this.error = null;
          this.transmuxer = new Transmuxer(this.observer, typeSupported, config, vendor, id);
        }
        return;
      }
    }
    this.transmuxer = new Transmuxer(this.observer, typeSupported, config, vendor, id);
  }
  resetWorker() {
    if (this.workerContext) {
      const {
        worker,
        objectURL
      } = this.workerContext;
      if (objectURL) {
        self.URL.revokeObjectURL(objectURL);
      }
      worker.removeEventListener("message", this.onwmsg);
      worker.onerror = null;
      worker.terminate();
      this.workerContext = null;
    }
  }
  destroy() {
    if (this.workerContext) {
      this.resetWorker();
      this.onwmsg = void 0;
    } else {
      const transmuxer = this.transmuxer;
      if (transmuxer) {
        transmuxer.destroy();
        this.transmuxer = null;
      }
    }
    const observer = this.observer;
    if (observer) {
      observer.removeAllListeners();
    }
    this.frag = null;
    this.observer = null;
    this.hls = null;
  }
  push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration5, accurateTimeOffset, chunkMeta, defaultInitPTS) {
    var _frag$initSegment, _lastFrag$initSegment;
    chunkMeta.transmuxing.start = self.performance.now();
    const {
      transmuxer
    } = this;
    const timeOffset = part ? part.start : frag.start;
    const decryptdata = frag.decryptdata;
    const lastFrag = this.frag;
    const discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
    const trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);
    const snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;
    const partDiff = this.part ? chunkMeta.part - this.part.index : -1;
    const progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? void 0 : lastFrag.stats.chunkCount);
    const contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));
    const now2 = self.performance.now();
    if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {
      frag.stats.parsing.start = now2;
    }
    if (part && (partDiff || !contiguous)) {
      part.stats.parsing.start = now2;
    }
    const initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? void 0 : _lastFrag$initSegment.url));
    const state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);
    if (!contiguous || discontinuity || initSegmentChange) {
      logger.log(`[transmuxer-interface, ${frag.type}]: Starting new transmux session for sn: ${chunkMeta.sn} p: ${chunkMeta.part} level: ${chunkMeta.level} id: ${chunkMeta.id}
        discontinuity: ${discontinuity}
        trackSwitch: ${trackSwitch}
        contiguous: ${contiguous}
        accurateTimeOffset: ${accurateTimeOffset}
        timeOffset: ${timeOffset}
        initSegmentChange: ${initSegmentChange}`);
      const config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration5, defaultInitPTS);
      this.configureTransmuxer(config);
    }
    this.frag = frag;
    this.part = part;
    if (this.workerContext) {
      this.workerContext.worker.postMessage({
        cmd: "demux",
        data,
        decryptdata,
        chunkMeta,
        state
      }, data instanceof ArrayBuffer ? [data] : []);
    } else if (transmuxer) {
      const transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);
      if (isPromise(transmuxResult)) {
        transmuxer.async = true;
        transmuxResult.then((data2) => {
          this.handleTransmuxComplete(data2);
        }).catch((error) => {
          this.transmuxerError(error, chunkMeta, "transmuxer-interface push error");
        });
      } else {
        transmuxer.async = false;
        this.handleTransmuxComplete(transmuxResult);
      }
    }
  }
  flush(chunkMeta) {
    chunkMeta.transmuxing.start = self.performance.now();
    const {
      transmuxer
    } = this;
    if (this.workerContext) {
      this.workerContext.worker.postMessage({
        cmd: "flush",
        chunkMeta
      });
    } else if (transmuxer) {
      let transmuxResult = transmuxer.flush(chunkMeta);
      const asyncFlush = isPromise(transmuxResult);
      if (asyncFlush || transmuxer.async) {
        if (!isPromise(transmuxResult)) {
          transmuxResult = Promise.resolve(transmuxResult);
        }
        transmuxResult.then((data) => {
          this.handleFlushResult(data, chunkMeta);
        }).catch((error) => {
          this.transmuxerError(error, chunkMeta, "transmuxer-interface flush error");
        });
      } else {
        this.handleFlushResult(transmuxResult, chunkMeta);
      }
    }
  }
  transmuxerError(error, chunkMeta, reason) {
    if (!this.hls) {
      return;
    }
    this.error = error;
    this.hls.trigger(Events.ERROR, {
      type: ErrorTypes.MEDIA_ERROR,
      details: ErrorDetails.FRAG_PARSING_ERROR,
      chunkMeta,
      fatal: false,
      error,
      err: error,
      reason
    });
  }
  handleFlushResult(results, chunkMeta) {
    results.forEach((result) => {
      this.handleTransmuxComplete(result);
    });
    this.onFlush(chunkMeta);
  }
  onWorkerMessage(ev) {
    const data = ev.data;
    const hls = this.hls;
    switch (data.event) {
      case "init": {
        var _this$workerContext;
        const objectURL = (_this$workerContext = this.workerContext) == null ? void 0 : _this$workerContext.objectURL;
        if (objectURL) {
          self.URL.revokeObjectURL(objectURL);
        }
        break;
      }
      case "transmuxComplete": {
        this.handleTransmuxComplete(data.data);
        break;
      }
      case "flush": {
        this.onFlush(data.data);
        break;
      }
      case "workerLog":
        if (logger[data.data.logType]) {
          logger[data.data.logType](data.data.message);
        }
        break;
      default: {
        data.data = data.data || {};
        data.data.frag = this.frag;
        data.data.id = this.id;
        hls.trigger(data.event, data.data);
        break;
      }
    }
  }
  configureTransmuxer(config) {
    const {
      transmuxer
    } = this;
    if (this.workerContext) {
      this.workerContext.worker.postMessage({
        cmd: "configure",
        config
      });
    } else if (transmuxer) {
      transmuxer.configure(config);
    }
  }
  handleTransmuxComplete(result) {
    result.chunkMeta.transmuxing.end = self.performance.now();
    this.onTransmuxComplete(result);
  }
};
var STALL_MINIMUM_DURATION_MS = 250;
var MAX_START_GAP_JUMP = 2;
var SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;
var SKIP_BUFFER_RANGE_START = 0.05;
var GapController = class {
  constructor(config, media, fragmentTracker, hls) {
    this.config = void 0;
    this.media = null;
    this.fragmentTracker = void 0;
    this.hls = void 0;
    this.nudgeRetry = 0;
    this.stallReported = false;
    this.stalled = null;
    this.moved = false;
    this.seeking = false;
    this.config = config;
    this.media = media;
    this.fragmentTracker = fragmentTracker;
    this.hls = hls;
  }
  destroy() {
    this.media = null;
    this.hls = this.fragmentTracker = null;
  }
  /**
   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.
   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).
   *
   * @param lastCurrentTime - Previously read playhead position
   */
  poll(lastCurrentTime, activeFrag) {
    const {
      config,
      media,
      stalled
    } = this;
    if (media === null) {
      return;
    }
    const {
      currentTime,
      seeking
    } = media;
    const seeked = this.seeking && !seeking;
    const beginSeek = !this.seeking && seeking;
    this.seeking = seeking;
    if (currentTime !== lastCurrentTime) {
      this.moved = true;
      if (stalled !== null) {
        if (this.stallReported) {
          const _stalledDuration = self.performance.now() - stalled;
          logger.warn(`playback not stuck anymore @${currentTime}, after ${Math.round(_stalledDuration)}ms`);
          this.stallReported = false;
        }
        this.stalled = null;
        this.nudgeRetry = 0;
      }
      return;
    }
    if (beginSeek || seeked) {
      this.stalled = null;
      return;
    }
    if (media.paused && !seeking || media.ended || media.playbackRate === 0 || !BufferHelper.getBuffered(media).length) {
      return;
    }
    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
    const isBuffered = bufferInfo.len > 0;
    const nextStart = bufferInfo.nextStart || 0;
    if (!isBuffered && !nextStart) {
      return;
    }
    if (seeking) {
      const hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;
      const noBufferGap = !nextStart || activeFrag && activeFrag.start <= currentTime || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);
      if (hasEnoughBuffer || noBufferGap) {
        return;
      }
      this.moved = false;
    }
    if (!this.moved && this.stalled !== null) {
      var _level$details;
      const startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;
      const level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;
      const isLive = level == null ? void 0 : (_level$details = level.details) == null ? void 0 : _level$details.live;
      const maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;
      const partialOrGap = this.fragmentTracker.getPartialFragment(currentTime);
      if (startJump > 0 && (startJump <= maxStartGapJump || partialOrGap)) {
        this._trySkipBufferHole(partialOrGap);
        return;
      }
    }
    const tnow = self.performance.now();
    if (stalled === null) {
      this.stalled = tnow;
      return;
    }
    const stalledDuration = tnow - stalled;
    if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {
      this._reportStall(bufferInfo);
      if (!this.media) {
        return;
      }
    }
    const bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);
    this._tryFixBufferStall(bufferedWithHoles, stalledDuration);
  }
  /**
   * Detects and attempts to fix known buffer stalling issues.
   * @param bufferInfo - The properties of the current buffer.
   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.
   * @private
   */
  _tryFixBufferStall(bufferInfo, stalledDurationMs) {
    const {
      config,
      fragmentTracker,
      media
    } = this;
    if (media === null) {
      return;
    }
    const currentTime = media.currentTime;
    const partial = fragmentTracker.getPartialFragment(currentTime);
    if (partial) {
      const targetTime = this._trySkipBufferHole(partial);
      if (targetTime || !this.media) {
        return;
      }
    }
    if ((bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && bufferInfo.nextStart - currentTime < config.maxBufferHole) && stalledDurationMs > config.highBufferWatchdogPeriod * 1e3) {
      logger.warn("Trying to nudge playhead over buffer-hole");
      this.stalled = null;
      this._tryNudgeBuffer();
    }
  }
  /**
   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.
   * @param bufferLen - The playhead distance from the end of the current buffer segment.
   * @private
   */
  _reportStall(bufferInfo) {
    const {
      hls,
      media,
      stallReported
    } = this;
    if (!stallReported && media) {
      this.stallReported = true;
      const error = new Error(`Playback stalling at @${media.currentTime} due to low buffer (${JSON.stringify(bufferInfo)})`);
      logger.warn(error.message);
      hls.trigger(Events.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.BUFFER_STALLED_ERROR,
        fatal: false,
        error,
        buffer: bufferInfo.len
      });
    }
  }
  /**
   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments
   * @param partial - The partial fragment found at the current time (where playback is stalling).
   * @private
   */
  _trySkipBufferHole(partial) {
    const {
      config,
      hls,
      media
    } = this;
    if (media === null) {
      return 0;
    }
    const currentTime = media.currentTime;
    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
    const startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;
    if (startTime) {
      const bufferStarved = bufferInfo.len <= config.maxBufferHole;
      const waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;
      const gapLength = startTime - currentTime;
      if (gapLength > 0 && (bufferStarved || waiting)) {
        if (gapLength > config.maxBufferHole) {
          const {
            fragmentTracker
          } = this;
          let startGap = false;
          if (currentTime === 0) {
            const startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);
            if (startFrag && startTime < startFrag.end) {
              startGap = true;
            }
          }
          if (!startGap) {
            const startProvisioned = partial || fragmentTracker.getAppendedFrag(currentTime, PlaylistLevelType.MAIN);
            if (startProvisioned) {
              let moreToLoad = false;
              let pos = startProvisioned.end;
              while (pos < startTime) {
                const provisioned = fragmentTracker.getPartialFragment(pos);
                if (provisioned) {
                  pos += provisioned.duration;
                } else {
                  moreToLoad = true;
                  break;
                }
              }
              if (moreToLoad) {
                return 0;
              }
            }
          }
        }
        const targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);
        logger.warn(`skipping hole, adjusting currentTime from ${currentTime} to ${targetTime}`);
        this.moved = true;
        this.stalled = null;
        media.currentTime = targetTime;
        if (partial && !partial.gap) {
          const error = new Error(`fragment loaded with buffer holes, seeking from ${currentTime} to ${targetTime}`);
          hls.trigger(Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,
            fatal: false,
            error,
            reason: error.message,
            frag: partial
          });
        }
        return targetTime;
      }
    }
    return 0;
  }
  /**
   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.
   * @private
   */
  _tryNudgeBuffer() {
    const {
      config,
      hls,
      media,
      nudgeRetry
    } = this;
    if (media === null) {
      return;
    }
    const currentTime = media.currentTime;
    this.nudgeRetry++;
    if (nudgeRetry < config.nudgeMaxRetry) {
      const targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;
      const error = new Error(`Nudging 'currentTime' from ${currentTime} to ${targetTime}`);
      logger.warn(error.message);
      media.currentTime = targetTime;
      hls.trigger(Events.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.BUFFER_NUDGE_ON_STALL,
        error,
        fatal: false
      });
    } else {
      const error = new Error(`Playhead still not moving while enough data buffered @${currentTime} after ${config.nudgeMaxRetry} nudges`);
      logger.error(error.message);
      hls.trigger(Events.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.BUFFER_STALLED_ERROR,
        error,
        fatal: true
      });
    }
  }
};
var TICK_INTERVAL$2 = 100;
var StreamController = class extends BaseStreamController {
  constructor(hls, fragmentTracker, keyLoader) {
    super(hls, fragmentTracker, keyLoader, "[stream-controller]", PlaylistLevelType.MAIN);
    this.audioCodecSwap = false;
    this.gapController = null;
    this.level = -1;
    this._forceStartLoad = false;
    this.altAudio = false;
    this.audioOnly = false;
    this.fragPlaying = null;
    this.onvplaying = null;
    this.onvseeked = null;
    this.fragLastKbps = 0;
    this.couldBacktrack = false;
    this.backtrackFragment = null;
    this.audioCodecSwitch = false;
    this.videoBuffer = null;
    this._registerListeners();
  }
  _registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
    hls.on(Events.ERROR, this.onError, this);
    hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
    hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
    hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  _unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
    hls.off(Events.ERROR, this.onError, this);
    hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
    hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
    hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  onHandlerDestroying() {
    this._unregisterListeners();
    this.onMediaDetaching();
  }
  startLoad(startPosition) {
    if (this.levels) {
      const {
        lastCurrentTime,
        hls
      } = this;
      this.stopLoad();
      this.setInterval(TICK_INTERVAL$2);
      this.level = -1;
      if (!this.startFragRequested) {
        let startLevel = hls.startLevel;
        if (startLevel === -1) {
          if (hls.config.testBandwidth && this.levels.length > 1) {
            startLevel = 0;
            this.bitrateTest = true;
          } else {
            startLevel = hls.nextAutoLevel;
          }
        }
        this.level = hls.nextLoadLevel = startLevel;
        this.loadedmetadata = false;
      }
      if (lastCurrentTime > 0 && startPosition === -1) {
        this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);
        startPosition = lastCurrentTime;
      }
      this.state = State.IDLE;
      this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
      this.tick();
    } else {
      this._forceStartLoad = true;
      this.state = State.STOPPED;
    }
  }
  stopLoad() {
    this._forceStartLoad = false;
    super.stopLoad();
  }
  doTick() {
    switch (this.state) {
      case State.WAITING_LEVEL: {
        var _levels$level;
        const {
          levels,
          level
        } = this;
        const details = levels == null ? void 0 : (_levels$level = levels[level]) == null ? void 0 : _levels$level.details;
        if (details && (!details.live || this.levelLastLoaded === this.level)) {
          if (this.waitForCdnTuneIn(details)) {
            break;
          }
          this.state = State.IDLE;
          break;
        } else if (this.hls.nextLoadLevel !== this.level) {
          this.state = State.IDLE;
          break;
        }
        break;
      }
      case State.FRAG_LOADING_WAITING_RETRY:
        {
          var _this$media;
          const now2 = self.performance.now();
          const retryDate = this.retryDate;
          if (!retryDate || now2 >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {
            this.resetStartWhenNotLoaded(this.level);
            this.state = State.IDLE;
          }
        }
        break;
    }
    if (this.state === State.IDLE) {
      this.doTickIdle();
    }
    this.onTickEnd();
  }
  onTickEnd() {
    super.onTickEnd();
    this.checkBuffer();
    this.checkFragmentChanged();
  }
  doTickIdle() {
    const {
      hls,
      levelLastLoaded,
      levels,
      media
    } = this;
    const {
      config,
      nextLoadLevel: level
    } = hls;
    if (levelLastLoaded === null || !media && (this.startFragRequested || !config.startFragPrefetch)) {
      return;
    }
    if (this.altAudio && this.audioOnly) {
      return;
    }
    if (!(levels != null && levels[level])) {
      return;
    }
    const levelInfo = levels[level];
    const bufferInfo = this.getMainFwdBufferInfo();
    if (bufferInfo === null) {
      return;
    }
    const lastDetails = this.getLevelDetails();
    if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {
      const data = {};
      if (this.altAudio) {
        data.type = "video";
      }
      this.hls.trigger(Events.BUFFER_EOS, data);
      this.state = State.ENDED;
      return;
    }
    if (hls.loadLevel !== level && hls.manualLevel === -1) {
      this.log(`Adapting to level ${level} from level ${this.level}`);
    }
    this.level = hls.nextLoadLevel = level;
    const levelDetails = levelInfo.details;
    if (!levelDetails || this.state === State.WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== level) {
      this.level = level;
      this.state = State.WAITING_LEVEL;
      return;
    }
    const bufferLen = bufferInfo.len;
    const maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);
    if (bufferLen >= maxBufLen) {
      return;
    }
    if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {
      this.backtrackFragment = null;
    }
    const targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;
    let frag = this.getNextFragment(targetBufferTime, levelDetails);
    if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== "initSegment" && this.fragmentTracker.getState(frag) !== FragmentState.OK) {
      var _this$backtrackFragme;
      const backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;
      const fragIdx = backtrackSn - levelDetails.startSN;
      const backtrackFrag = levelDetails.fragments[fragIdx - 1];
      if (backtrackFrag && frag.cc === backtrackFrag.cc) {
        frag = backtrackFrag;
        this.fragmentTracker.removeFragment(backtrackFrag);
      }
    } else if (this.backtrackFragment && bufferInfo.len) {
      this.backtrackFragment = null;
    }
    if (frag && this.isLoopLoading(frag, targetBufferTime)) {
      const gapStart = frag.gap;
      if (!gapStart) {
        const type2 = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;
        const mediaBuffer = (type2 === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
        if (mediaBuffer) {
          this.afterBufferFlushed(mediaBuffer, type2, PlaylistLevelType.MAIN);
        }
      }
      frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);
    }
    if (!frag) {
      return;
    }
    if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {
      frag = frag.initSegment;
    }
    this.loadFragment(frag, levelInfo, targetBufferTime);
  }
  loadFragment(frag, level, targetBufferTime) {
    const fragState = this.fragmentTracker.getState(frag);
    this.fragCurrent = frag;
    if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {
      if (frag.sn === "initSegment") {
        this._loadInitSegment(frag, level);
      } else if (this.bitrateTest) {
        this.log(`Fragment ${frag.sn} of level ${frag.level} is being downloaded to test bitrate and will not be buffered`);
        this._loadBitrateTestFrag(frag, level);
      } else {
        this.startFragRequested = true;
        super.loadFragment(frag, level, targetBufferTime);
      }
    } else {
      this.clearTrackerIfNeeded(frag);
    }
  }
  getBufferedFrag(position) {
    return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);
  }
  followingBufferedFrag(frag) {
    if (frag) {
      return this.getBufferedFrag(frag.end + 0.5);
    }
    return null;
  }
  /*
    on immediate level switch :
     - pause playback if playing
     - cancel any pending load request
     - and trigger a buffer flush
  */
  immediateLevelSwitch() {
    this.abortCurrentFrag();
    this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
  }
  /**
   * try to switch ASAP without breaking video playback:
   * in order to ensure smooth but quick level switching,
   * we need to find the next flushable buffer range
   * we should take into account new segment fetch time
   */
  nextLevelSwitch() {
    const {
      levels,
      media
    } = this;
    if (media != null && media.readyState) {
      let fetchdelay;
      const fragPlayingCurrent = this.getAppendedFrag(media.currentTime);
      if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {
        this.flushMainBuffer(0, fragPlayingCurrent.start - 1);
      }
      const levelDetails = this.getLevelDetails();
      if (levelDetails != null && levelDetails.live) {
        const bufferInfo = this.getMainFwdBufferInfo();
        if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {
          return;
        }
      }
      if (!media.paused && levels) {
        const nextLevelId = this.hls.nextLoadLevel;
        const nextLevel = levels[nextLevelId];
        const fragLastKbps = this.fragLastKbps;
        if (fragLastKbps && this.fragCurrent) {
          fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1e3 * fragLastKbps) + 1;
        } else {
          fetchdelay = 0;
        }
      } else {
        fetchdelay = 0;
      }
      const bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
      if (bufferedFrag) {
        const nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);
        if (nextBufferedFrag) {
          this.abortCurrentFrag();
          const maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;
          const fragDuration = nextBufferedFrag.duration;
          const startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * 0.5), fragDuration * 0.75));
          this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);
        }
      }
    }
  }
  abortCurrentFrag() {
    const fragCurrent = this.fragCurrent;
    this.fragCurrent = null;
    this.backtrackFragment = null;
    if (fragCurrent) {
      fragCurrent.abortRequests();
      this.fragmentTracker.removeFragment(fragCurrent);
    }
    switch (this.state) {
      case State.KEY_LOADING:
      case State.FRAG_LOADING:
      case State.FRAG_LOADING_WAITING_RETRY:
      case State.PARSING:
      case State.PARSED:
        this.state = State.IDLE;
        break;
    }
    this.nextLoadPosition = this.getLoadPosition();
  }
  flushMainBuffer(startOffset, endOffset) {
    super.flushMainBuffer(startOffset, endOffset, this.altAudio ? "video" : null);
  }
  onMediaAttached(event, data) {
    super.onMediaAttached(event, data);
    const media = data.media;
    this.onvplaying = this.onMediaPlaying.bind(this);
    this.onvseeked = this.onMediaSeeked.bind(this);
    media.addEventListener("playing", this.onvplaying);
    media.addEventListener("seeked", this.onvseeked);
    this.gapController = new GapController(this.config, media, this.fragmentTracker, this.hls);
  }
  onMediaDetaching() {
    const {
      media
    } = this;
    if (media && this.onvplaying && this.onvseeked) {
      media.removeEventListener("playing", this.onvplaying);
      media.removeEventListener("seeked", this.onvseeked);
      this.onvplaying = this.onvseeked = null;
      this.videoBuffer = null;
    }
    this.fragPlaying = null;
    if (this.gapController) {
      this.gapController.destroy();
      this.gapController = null;
    }
    super.onMediaDetaching();
  }
  onMediaPlaying() {
    this.tick();
  }
  onMediaSeeked() {
    const media = this.media;
    const currentTime = media ? media.currentTime : null;
    if (isFiniteNumber(currentTime)) {
      this.log(`Media seeked to ${currentTime.toFixed(3)}`);
    }
    const bufferInfo = this.getMainFwdBufferInfo();
    if (bufferInfo === null || bufferInfo.len === 0) {
      this.warn(`Main forward buffer length on "seeked" event ${bufferInfo ? bufferInfo.len : "empty"})`);
      return;
    }
    this.tick();
  }
  onManifestLoading() {
    this.log("Trigger BUFFER_RESET");
    this.hls.trigger(Events.BUFFER_RESET, void 0);
    this.fragmentTracker.removeAllFragments();
    this.couldBacktrack = false;
    this.startPosition = this.lastCurrentTime = 0;
    this.levels = this.fragPlaying = this.backtrackFragment = null;
    this.altAudio = this.audioOnly = false;
  }
  onManifestParsed(event, data) {
    let aac2 = false;
    let heaac = false;
    let codec;
    data.levels.forEach((level) => {
      codec = level.audioCodec;
      if (codec) {
        if (codec.indexOf("mp4a.40.2") !== -1) {
          aac2 = true;
        }
        if (codec.indexOf("mp4a.40.5") !== -1) {
          heaac = true;
        }
      }
    });
    this.audioCodecSwitch = aac2 && heaac && !changeTypeSupported();
    if (this.audioCodecSwitch) {
      this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC");
    }
    this.levels = data.levels;
    this.startFragRequested = false;
  }
  onLevelLoading(event, data) {
    const {
      levels
    } = this;
    if (!levels || this.state !== State.IDLE) {
      return;
    }
    const level = levels[data.level];
    if (!level.details || level.details.live && this.levelLastLoaded !== data.level || this.waitForCdnTuneIn(level.details)) {
      this.state = State.WAITING_LEVEL;
    }
  }
  onLevelLoaded(event, data) {
    var _curLevel$details;
    const {
      levels
    } = this;
    const newLevelId = data.level;
    const newDetails = data.details;
    const duration5 = newDetails.totalduration;
    if (!levels) {
      this.warn(`Levels were reset while loading level ${newLevelId}`);
      return;
    }
    this.log(`Level ${newLevelId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ""}, cc [${newDetails.startCC}, ${newDetails.endCC}] duration:${duration5}`);
    const curLevel = levels[newLevelId];
    const fragCurrent = this.fragCurrent;
    if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {
      if ((fragCurrent.level !== data.level || fragCurrent.urlId !== curLevel.urlId) && fragCurrent.loader) {
        this.abortCurrentFrag();
      }
    }
    let sliding = 0;
    if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {
      this.checkLiveUpdate(newDetails);
      if (newDetails.deltaUpdateFailed) {
        return;
      }
      sliding = this.alignPlaylists(newDetails, curLevel.details);
    }
    curLevel.details = newDetails;
    this.levelLastLoaded = newLevelId;
    this.hls.trigger(Events.LEVEL_UPDATED, {
      details: newDetails,
      level: newLevelId
    });
    if (this.state === State.WAITING_LEVEL) {
      if (this.waitForCdnTuneIn(newDetails)) {
        return;
      }
      this.state = State.IDLE;
    }
    if (!this.startFragRequested) {
      this.setStartPosition(newDetails, sliding);
    } else if (newDetails.live) {
      this.synchronizeToLiveEdge(newDetails);
    }
    this.tick();
  }
  _handleFragmentLoadProgress(data) {
    var _frag$initSegment;
    const {
      frag,
      part,
      payload
    } = data;
    const {
      levels
    } = this;
    if (!levels) {
      this.warn(`Levels were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);
      return;
    }
    const currentLevel = levels[frag.level];
    const details = currentLevel.details;
    if (!details) {
      this.warn(`Dropping fragment ${frag.sn} of level ${frag.level} after level details were reset`);
      this.fragmentTracker.removeFragment(frag);
      return;
    }
    const videoCodec = currentLevel.videoCodec;
    const accurateTimeOffset = details.PTSKnown || !details.live;
    const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;
    const audioCodec = this._getAudioCodec(currentLevel);
    const transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
    const partIndex = part ? part.index : -1;
    const partial = partIndex !== -1;
    const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
    const initPTS = this.initPTS[frag.cc];
    transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
  }
  onAudioTrackSwitching(event, data) {
    const fromAltAudio = this.altAudio;
    const altAudio = !!data.url;
    if (!altAudio) {
      if (this.mediaBuffer !== this.media) {
        this.log("Switching on main audio, use media.buffered to schedule main fragment loading");
        this.mediaBuffer = this.media;
        const fragCurrent = this.fragCurrent;
        if (fragCurrent) {
          this.log("Switching to main audio track, cancel main fragment load");
          fragCurrent.abortRequests();
          this.fragmentTracker.removeFragment(fragCurrent);
        }
        this.resetTransmuxer();
        this.resetLoadingState();
      } else if (this.audioOnly) {
        this.resetTransmuxer();
      }
      const hls = this.hls;
      if (fromAltAudio) {
        hls.trigger(Events.BUFFER_FLUSHING, {
          startOffset: 0,
          endOffset: Number.POSITIVE_INFINITY,
          type: null
        });
        this.fragmentTracker.removeAllFragments();
      }
      hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);
    }
  }
  onAudioTrackSwitched(event, data) {
    const trackId = data.id;
    const altAudio = !!this.hls.audioTracks[trackId].url;
    if (altAudio) {
      const videoBuffer = this.videoBuffer;
      if (videoBuffer && this.mediaBuffer !== videoBuffer) {
        this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading");
        this.mediaBuffer = videoBuffer;
      }
    }
    this.altAudio = altAudio;
    this.tick();
  }
  onBufferCreated(event, data) {
    const tracks = data.tracks;
    let mediaTrack;
    let name;
    let alternate = false;
    for (const type2 in tracks) {
      const track = tracks[type2];
      if (track.id === "main") {
        name = type2;
        mediaTrack = track;
        if (type2 === "video") {
          const videoTrack = tracks[type2];
          if (videoTrack) {
            this.videoBuffer = videoTrack.buffer;
          }
        }
      } else {
        alternate = true;
      }
    }
    if (alternate && mediaTrack) {
      this.log(`Alternate track found, use ${name}.buffered to schedule main fragment loading`);
      this.mediaBuffer = mediaTrack.buffer;
    } else {
      this.mediaBuffer = this.media;
    }
  }
  onFragBuffered(event, data) {
    const {
      frag,
      part
    } = data;
    if (frag && frag.type !== PlaylistLevelType.MAIN) {
      return;
    }
    if (this.fragContextChanged(frag)) {
      this.warn(`Fragment ${frag.sn}${part ? " p: " + part.index : ""} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}`);
      if (this.state === State.PARSED) {
        this.state = State.IDLE;
      }
      return;
    }
    const stats = part ? part.stats : frag.stats;
    this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));
    if (frag.sn !== "initSegment") {
      this.fragPrevious = frag;
    }
    this.fragBufferedComplete(frag, part);
  }
  onError(event, data) {
    var _data$context;
    if (data.fatal) {
      this.state = State.ERROR;
      return;
    }
    switch (data.details) {
      case ErrorDetails.FRAG_GAP:
      case ErrorDetails.FRAG_PARSING_ERROR:
      case ErrorDetails.FRAG_DECRYPT_ERROR:
      case ErrorDetails.FRAG_LOAD_ERROR:
      case ErrorDetails.FRAG_LOAD_TIMEOUT:
      case ErrorDetails.KEY_LOAD_ERROR:
      case ErrorDetails.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);
        break;
      case ErrorDetails.LEVEL_LOAD_ERROR:
      case ErrorDetails.LEVEL_LOAD_TIMEOUT:
      case ErrorDetails.LEVEL_PARSING_ERROR:
        if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.LEVEL) {
          this.state = State.IDLE;
        }
        break;
      case ErrorDetails.BUFFER_FULL_ERROR:
        if (!data.parent || data.parent !== "main") {
          return;
        }
        if (this.reduceLengthAndFlushBuffer(data)) {
          this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
        }
        break;
      case ErrorDetails.INTERNAL_EXCEPTION:
        this.recoverWorkerError(data);
        break;
    }
  }
  // Checks the health of the buffer and attempts to resolve playback stalls.
  checkBuffer() {
    const {
      media,
      gapController
    } = this;
    if (!media || !gapController || !media.readyState) {
      return;
    }
    if (this.loadedmetadata || !BufferHelper.getBuffered(media).length) {
      const activeFrag = this.state !== State.IDLE ? this.fragCurrent : null;
      gapController.poll(this.lastCurrentTime, activeFrag);
    }
    this.lastCurrentTime = media.currentTime;
  }
  onFragLoadEmergencyAborted() {
    this.state = State.IDLE;
    if (!this.loadedmetadata) {
      this.startFragRequested = false;
      this.nextLoadPosition = this.startPosition;
    }
    this.tickImmediate();
  }
  onBufferFlushed(event, {
    type: type2
  }) {
    if (type2 !== ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {
      const mediaBuffer = (type2 === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
      this.afterBufferFlushed(mediaBuffer, type2, PlaylistLevelType.MAIN);
    }
  }
  onLevelsUpdated(event, data) {
    this.levels = data.levels;
  }
  swapAudioCodec() {
    this.audioCodecSwap = !this.audioCodecSwap;
  }
  /**
   * Seeks to the set startPosition if not equal to the mediaElement's current time.
   */
  seekToStartPos() {
    const {
      media
    } = this;
    if (!media) {
      return;
    }
    const currentTime = media.currentTime;
    let startPosition = this.startPosition;
    if (startPosition >= 0 && currentTime < startPosition) {
      if (media.seeking) {
        this.log(`could not seek to ${startPosition}, already seeking at ${currentTime}`);
        return;
      }
      const buffered = BufferHelper.getBuffered(media);
      const bufferStart = buffered.length ? buffered.start(0) : 0;
      const delta = bufferStart - startPosition;
      if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {
        this.log(`adjusting start position by ${delta} to match buffer start`);
        startPosition += delta;
        this.startPosition = startPosition;
      }
      this.log(`seek to target start position ${startPosition} from current time ${currentTime}`);
      media.currentTime = startPosition;
    }
  }
  _getAudioCodec(currentLevel) {
    let audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
    if (this.audioCodecSwap && audioCodec) {
      this.log("Swapping audio codec");
      if (audioCodec.indexOf("mp4a.40.5") !== -1) {
        audioCodec = "mp4a.40.2";
      } else {
        audioCodec = "mp4a.40.5";
      }
    }
    return audioCodec;
  }
  _loadBitrateTestFrag(frag, level) {
    frag.bitrateTest = true;
    this._doFragLoad(frag, level).then((data) => {
      const {
        hls
      } = this;
      if (!data || this.fragContextChanged(frag)) {
        return;
      }
      level.fragmentError = 0;
      this.state = State.IDLE;
      this.startFragRequested = false;
      this.bitrateTest = false;
      const stats = frag.stats;
      stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();
      hls.trigger(Events.FRAG_LOADED, data);
      frag.bitrateTest = false;
    });
  }
  _handleTransmuxComplete(transmuxResult) {
    var _id3$samples;
    const id = "main";
    const {
      hls
    } = this;
    const {
      remuxResult,
      chunkMeta
    } = transmuxResult;
    const context = this.getCurrentContext(chunkMeta);
    if (!context) {
      this.resetWhenMissingContext(chunkMeta);
      return;
    }
    const {
      frag,
      part,
      level
    } = context;
    const {
      video,
      text,
      id3,
      initSegment
    } = remuxResult;
    const {
      details
    } = level;
    const audio = this.altAudio ? void 0 : remuxResult.audio;
    if (this.fragContextChanged(frag)) {
      this.fragmentTracker.removeFragment(frag);
      return;
    }
    this.state = State.PARSING;
    if (initSegment) {
      if (initSegment != null && initSegment.tracks) {
        const mapFragment = frag.initSegment || frag;
        this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);
        hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {
          frag: mapFragment,
          id,
          tracks: initSegment.tracks
        });
      }
      const initPTS = initSegment.initPTS;
      const timescale2 = initSegment.timescale;
      if (isFiniteNumber(initPTS)) {
        this.initPTS[frag.cc] = {
          baseTime: initPTS,
          timescale: timescale2
        };
        hls.trigger(Events.INIT_PTS_FOUND, {
          frag,
          id,
          initPTS,
          timescale: timescale2
        });
      }
    }
    if (video && details && frag.sn !== "initSegment") {
      const prevFrag = details.fragments[frag.sn - 1 - details.startSN];
      const isFirstFragment = frag.sn === details.startSN;
      const isFirstInDiscontinuity = !prevFrag || frag.cc > prevFrag.cc;
      if (remuxResult.independent !== false) {
        const {
          startPTS,
          endPTS,
          startDTS,
          endDTS
        } = video;
        if (part) {
          part.elementaryStreams[video.type] = {
            startPTS,
            endPTS,
            startDTS,
            endDTS
          };
        } else {
          if (video.firstKeyFrame && video.independent && chunkMeta.id === 1 && !isFirstInDiscontinuity) {
            this.couldBacktrack = true;
          }
          if (video.dropped && video.independent) {
            const bufferInfo = this.getMainFwdBufferInfo();
            const targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;
            const startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;
            if (!isFirstFragment && targetBufferTime < startTime - this.config.maxBufferHole && !isFirstInDiscontinuity) {
              this.backtrack(frag);
              return;
            } else if (isFirstInDiscontinuity) {
              frag.gap = true;
            }
            frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);
          }
        }
        frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);
        if (this.backtrackFragment) {
          this.backtrackFragment = frag;
        }
        this.bufferFragmentData(video, frag, part, chunkMeta, isFirstFragment || isFirstInDiscontinuity);
      } else if (isFirstFragment || isFirstInDiscontinuity) {
        frag.gap = true;
      } else {
        this.backtrack(frag);
        return;
      }
    }
    if (audio) {
      const {
        startPTS,
        endPTS,
        startDTS,
        endDTS
      } = audio;
      if (part) {
        part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {
          startPTS,
          endPTS,
          startDTS,
          endDTS
        };
      }
      frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);
      this.bufferFragmentData(audio, frag, part, chunkMeta);
    }
    if (details && id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {
      const emittedID3 = {
        id,
        frag,
        details,
        samples: id3.samples
      };
      hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);
    }
    if (details && text) {
      const emittedText = {
        id,
        frag,
        details,
        samples: text.samples
      };
      hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);
    }
  }
  _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {
    if (this.state !== State.PARSING) {
      return;
    }
    this.audioOnly = !!tracks.audio && !tracks.video;
    if (this.altAudio && !this.audioOnly) {
      delete tracks.audio;
    }
    const {
      audio,
      video,
      audiovideo
    } = tracks;
    if (audio) {
      let audioCodec = currentLevel.audioCodec;
      const ua = navigator.userAgent.toLowerCase();
      if (this.audioCodecSwitch) {
        if (audioCodec) {
          if (audioCodec.indexOf("mp4a.40.5") !== -1) {
            audioCodec = "mp4a.40.2";
          } else {
            audioCodec = "mp4a.40.5";
          }
        }
        if (audio.metadata.channelCount !== 1 && ua.indexOf("firefox") === -1) {
          audioCodec = "mp4a.40.5";
        }
      }
      if (ua.indexOf("android") !== -1 && audio.container !== "audio/mpeg") {
        audioCodec = "mp4a.40.2";
        this.log(`Android: force audio codec to ${audioCodec}`);
      }
      if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {
        this.log(`Swapping manifest audio codec "${currentLevel.audioCodec}" for "${audioCodec}"`);
      }
      audio.levelCodec = audioCodec;
      audio.id = "main";
      this.log(`Init audio buffer, container:${audio.container}, codecs[selected/level/parsed]=[${audioCodec || ""}/${currentLevel.audioCodec || ""}/${audio.codec}]`);
    }
    if (video) {
      video.levelCodec = currentLevel.videoCodec;
      video.id = "main";
      this.log(`Init video buffer, container:${video.container}, codecs[level/parsed]=[${currentLevel.videoCodec || ""}/${video.codec}]`);
    }
    if (audiovideo) {
      this.log(`Init audiovideo buffer, container:${audiovideo.container}, codecs[level/parsed]=[${currentLevel.attrs.CODECS || ""}/${audiovideo.codec}]`);
    }
    this.hls.trigger(Events.BUFFER_CODECS, tracks);
    Object.keys(tracks).forEach((trackName) => {
      const track = tracks[trackName];
      const initSegment = track.initSegment;
      if (initSegment != null && initSegment.byteLength) {
        this.hls.trigger(Events.BUFFER_APPENDING, {
          type: trackName,
          data: initSegment,
          frag,
          part: null,
          chunkMeta,
          parent: frag.type
        });
      }
    });
    this.tick();
  }
  getMainFwdBufferInfo() {
    return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, PlaylistLevelType.MAIN);
  }
  backtrack(frag) {
    this.couldBacktrack = true;
    this.backtrackFragment = frag;
    this.resetTransmuxer();
    this.flushBufferGap(frag);
    this.fragmentTracker.removeFragment(frag);
    this.fragPrevious = null;
    this.nextLoadPosition = frag.start;
    this.state = State.IDLE;
  }
  checkFragmentChanged() {
    const video = this.media;
    let fragPlayingCurrent = null;
    if (video && video.readyState > 1 && video.seeking === false) {
      const currentTime = video.currentTime;
      if (BufferHelper.isBuffered(video, currentTime)) {
        fragPlayingCurrent = this.getAppendedFrag(currentTime);
      } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {
        fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);
      }
      if (fragPlayingCurrent) {
        this.backtrackFragment = null;
        const fragPlaying = this.fragPlaying;
        const fragCurrentLevel = fragPlayingCurrent.level;
        if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel || fragPlayingCurrent.urlId !== fragPlaying.urlId) {
          this.fragPlaying = fragPlayingCurrent;
          this.hls.trigger(Events.FRAG_CHANGED, {
            frag: fragPlayingCurrent
          });
          if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {
            this.hls.trigger(Events.LEVEL_SWITCHED, {
              level: fragCurrentLevel
            });
          }
        }
      }
    }
  }
  get nextLevel() {
    const frag = this.nextBufferedFrag;
    if (frag) {
      return frag.level;
    }
    return -1;
  }
  get currentFrag() {
    const media = this.media;
    if (media) {
      return this.fragPlaying || this.getAppendedFrag(media.currentTime);
    }
    return null;
  }
  get currentProgramDateTime() {
    const media = this.media;
    if (media) {
      const currentTime = media.currentTime;
      const frag = this.currentFrag;
      if (frag && isFiniteNumber(currentTime) && isFiniteNumber(frag.programDateTime)) {
        const epocMs = frag.programDateTime + (currentTime - frag.start) * 1e3;
        return new Date(epocMs);
      }
    }
    return null;
  }
  get currentLevel() {
    const frag = this.currentFrag;
    if (frag) {
      return frag.level;
    }
    return -1;
  }
  get nextBufferedFrag() {
    const frag = this.currentFrag;
    if (frag) {
      return this.followingBufferedFrag(frag);
    }
    return null;
  }
  get forceStartLoad() {
    return this._forceStartLoad;
  }
};
var EWMA = class {
  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  constructor(halfLife, estimate = 0, weight = 0) {
    this.halfLife = void 0;
    this.alpha_ = void 0;
    this.estimate_ = void 0;
    this.totalWeight_ = void 0;
    this.halfLife = halfLife;
    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
    this.estimate_ = estimate;
    this.totalWeight_ = weight;
  }
  sample(weight, value) {
    const adjAlpha = Math.pow(this.alpha_, weight);
    this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
    this.totalWeight_ += weight;
  }
  getTotalWeight() {
    return this.totalWeight_;
  }
  getEstimate() {
    if (this.alpha_) {
      const zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
      if (zeroFactor) {
        return this.estimate_ / zeroFactor;
      }
    }
    return this.estimate_;
  }
};
var EwmaBandWidthEstimator = class {
  constructor(slow, fast, defaultEstimate, defaultTTFB = 100) {
    this.defaultEstimate_ = void 0;
    this.minWeight_ = void 0;
    this.minDelayMs_ = void 0;
    this.slow_ = void 0;
    this.fast_ = void 0;
    this.defaultTTFB_ = void 0;
    this.ttfb_ = void 0;
    this.defaultEstimate_ = defaultEstimate;
    this.minWeight_ = 1e-3;
    this.minDelayMs_ = 50;
    this.slow_ = new EWMA(slow);
    this.fast_ = new EWMA(fast);
    this.defaultTTFB_ = defaultTTFB;
    this.ttfb_ = new EWMA(slow);
  }
  update(slow, fast) {
    const {
      slow_,
      fast_,
      ttfb_
    } = this;
    if (slow_.halfLife !== slow) {
      this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());
    }
    if (fast_.halfLife !== fast) {
      this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());
    }
    if (ttfb_.halfLife !== slow) {
      this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());
    }
  }
  sample(durationMs, numBytes) {
    durationMs = Math.max(durationMs, this.minDelayMs_);
    const numBits = 8 * numBytes;
    const durationS = durationMs / 1e3;
    const bandwidthInBps = numBits / durationS;
    this.fast_.sample(durationS, bandwidthInBps);
    this.slow_.sample(durationS, bandwidthInBps);
  }
  sampleTTFB(ttfb) {
    const seconds = ttfb / 1e3;
    const weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);
    this.ttfb_.sample(weight, Math.max(ttfb, 5));
  }
  canEstimate() {
    return this.fast_.getTotalWeight() >= this.minWeight_;
  }
  getEstimate() {
    if (this.canEstimate()) {
      return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
    } else {
      return this.defaultEstimate_;
    }
  }
  getEstimateTTFB() {
    if (this.ttfb_.getTotalWeight() >= this.minWeight_) {
      return this.ttfb_.getEstimate();
    } else {
      return this.defaultTTFB_;
    }
  }
  destroy() {
  }
};
var AbrController = class {
  constructor(hls) {
    this.hls = void 0;
    this.lastLevelLoadSec = 0;
    this.lastLoadedFragLevel = 0;
    this._nextAutoLevel = -1;
    this.timer = -1;
    this.onCheck = this._abandonRulesCheck.bind(this);
    this.fragCurrent = null;
    this.partCurrent = null;
    this.bitrateTestDelay = 0;
    this.bwEstimator = void 0;
    this.hls = hls;
    const config = hls.config;
    this.bwEstimator = new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);
    this.registerListeners();
  }
  registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.FRAG_LOADING, this.onFragLoading, this);
    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
  }
  unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.FRAG_LOADING, this.onFragLoading, this);
    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
  }
  destroy() {
    this.unregisterListeners();
    this.clearTimer();
    this.hls = this.onCheck = null;
    this.fragCurrent = this.partCurrent = null;
  }
  onFragLoading(event, data) {
    var _data$part;
    const frag = data.frag;
    if (this.ignoreFragment(frag)) {
      return;
    }
    this.fragCurrent = frag;
    this.partCurrent = (_data$part = data.part) != null ? _data$part : null;
    this.clearTimer();
    this.timer = self.setInterval(this.onCheck, 100);
  }
  onLevelSwitching(event, data) {
    this.clearTimer();
  }
  getTimeToLoadFrag(timeToFirstByteSec, bandwidth2, fragSizeBits, isSwitch) {
    const fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth2;
    const playlistLoadSec = isSwitch ? this.lastLevelLoadSec : 0;
    return fragLoadSec + playlistLoadSec;
  }
  onLevelLoaded(event, data) {
    const config = this.hls.config;
    const {
      total,
      bwEstimate
    } = data.stats;
    if (isFiniteNumber(total) && isFiniteNumber(bwEstimate)) {
      this.lastLevelLoadSec = 8 * total / bwEstimate;
    }
    if (data.details.live) {
      this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);
    } else {
      this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);
    }
  }
  /*
      This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load
      quickly enough to prevent underbuffering
    */
  _abandonRulesCheck() {
    const {
      fragCurrent: frag,
      partCurrent: part,
      hls
    } = this;
    const {
      autoLevelEnabled,
      media
    } = hls;
    if (!frag || !media) {
      return;
    }
    const now2 = performance.now();
    const stats = part ? part.stats : frag.stats;
    const duration5 = part ? part.duration : frag.duration;
    const timeLoading = now2 - stats.loading.start;
    if (stats.aborted || stats.loaded && stats.loaded === stats.total || frag.level === 0) {
      this.clearTimer();
      this._nextAutoLevel = -1;
      return;
    }
    if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {
      return;
    }
    const bufferInfo = hls.mainForwardBufferInfo;
    if (bufferInfo === null) {
      return;
    }
    const ttfbEstimate = this.bwEstimator.getEstimateTTFB();
    const playbackRate = Math.abs(media.playbackRate);
    if (timeLoading <= Math.max(ttfbEstimate, 1e3 * (duration5 / (playbackRate * 2)))) {
      return;
    }
    const bufferStarvationDelay = bufferInfo.len / playbackRate;
    if (bufferStarvationDelay >= 2 * duration5 / playbackRate) {
      return;
    }
    const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;
    const loadedFirstByte = stats.loaded && ttfb > -1;
    const bwEstimate = this.bwEstimator.getEstimate();
    const {
      levels,
      minAutoLevel
    } = hls;
    const level = levels[frag.level];
    const expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration5 * level.maxBitrate / 8));
    let timeStreaming = timeLoading - ttfb;
    if (timeStreaming < 1 && loadedFirstByte) {
      timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);
    }
    const loadRate = loadedFirstByte ? stats.loaded * 1e3 / timeStreaming : 0;
    const fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbEstimate / 1e3;
    if (fragLoadedDelay <= bufferStarvationDelay) {
      return;
    }
    const bwe = loadRate ? loadRate * 8 : bwEstimate;
    let fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;
    let nextLoadLevel;
    for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
      const levelNextBitrate = levels[nextLoadLevel].maxBitrate;
      fragLevelNextLoadedDelay = this.getTimeToLoadFrag(ttfbEstimate / 1e3, bwe, duration5 * levelNextBitrate, !levels[nextLoadLevel].details);
      if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
        break;
      }
    }
    if (fragLevelNextLoadedDelay >= fragLoadedDelay) {
      return;
    }
    if (fragLevelNextLoadedDelay > duration5 * 10) {
      return;
    }
    hls.nextLoadLevel = nextLoadLevel;
    if (loadedFirstByte) {
      this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);
    } else {
      this.bwEstimator.sampleTTFB(timeLoading);
    }
    this.clearTimer();
    logger.warn(`[abr] Fragment ${frag.sn}${part ? " part " + part.index : ""} of level ${frag.level} is loading too slowly;
      Time to underbuffer: ${bufferStarvationDelay.toFixed(3)} s
      Estimated load time for current fragment: ${fragLoadedDelay.toFixed(3)} s
      Estimated load time for down switch fragment: ${fragLevelNextLoadedDelay.toFixed(3)} s
      TTFB estimate: ${ttfb}
      Current BW estimate: ${isFiniteNumber(bwEstimate) ? (bwEstimate / 1024).toFixed(3) : "Unknown"} Kb/s
      New BW estimate: ${(this.bwEstimator.getEstimate() / 1024).toFixed(3)} Kb/s
      Aborting and switching to level ${nextLoadLevel}`);
    if (frag.loader) {
      this.fragCurrent = this.partCurrent = null;
      frag.abortRequests();
    }
    hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {
      frag,
      part,
      stats
    });
  }
  onFragLoaded(event, {
    frag,
    part
  }) {
    const stats = part ? part.stats : frag.stats;
    if (frag.type === PlaylistLevelType.MAIN) {
      this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);
    }
    if (this.ignoreFragment(frag)) {
      return;
    }
    this.clearTimer();
    this.lastLoadedFragLevel = frag.level;
    this._nextAutoLevel = -1;
    if (this.hls.config.abrMaxWithRealBitrate) {
      const duration5 = part ? part.duration : frag.duration;
      const level = this.hls.levels[frag.level];
      const loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;
      const loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration5;
      level.loaded = {
        bytes: loadedBytes,
        duration: loadedDuration
      };
      level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
    }
    if (frag.bitrateTest) {
      const fragBufferedData = {
        stats,
        frag,
        part,
        id: frag.type
      };
      this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);
      frag.bitrateTest = false;
    }
  }
  onFragBuffered(event, data) {
    const {
      frag,
      part
    } = data;
    const stats = part != null && part.stats.loaded ? part.stats : frag.stats;
    if (stats.aborted) {
      return;
    }
    if (this.ignoreFragment(frag)) {
      return;
    }
    const processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());
    this.bwEstimator.sample(processingMs, stats.loaded);
    stats.bwEstimate = this.bwEstimator.getEstimate();
    if (frag.bitrateTest) {
      this.bitrateTestDelay = processingMs / 1e3;
    } else {
      this.bitrateTestDelay = 0;
    }
  }
  ignoreFragment(frag) {
    return frag.type !== PlaylistLevelType.MAIN || frag.sn === "initSegment";
  }
  clearTimer() {
    self.clearInterval(this.timer);
  }
  // return next auto level
  get nextAutoLevel() {
    const forcedAutoLevel = this._nextAutoLevel;
    const bwEstimator = this.bwEstimator;
    if (forcedAutoLevel !== -1 && !bwEstimator.canEstimate()) {
      return forcedAutoLevel;
    }
    let nextABRAutoLevel = this.getNextABRAutoLevel();
    if (forcedAutoLevel !== -1) {
      const levels = this.hls.levels;
      if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {
        return forcedAutoLevel;
      }
    }
    if (forcedAutoLevel !== -1) {
      nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);
    }
    return nextABRAutoLevel;
  }
  getNextABRAutoLevel() {
    const {
      fragCurrent,
      partCurrent,
      hls
    } = this;
    const {
      maxAutoLevel,
      config,
      minAutoLevel,
      media
    } = hls;
    const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
    const playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1;
    const avgbw = this.bwEstimator ? this.bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate;
    const bufferInfo = hls.mainForwardBufferInfo;
    const bufferStarvationDelay = (bufferInfo ? bufferInfo.len : 0) / playbackRate;
    let bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor);
    if (bestLevel >= 0) {
      return bestLevel;
    }
    logger.trace(`[abr] ${bufferStarvationDelay ? "rebuffering expected" : "buffer is empty"}, finding optimal quality level`);
    let maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;
    let bwFactor = config.abrBandWidthFactor;
    let bwUpFactor = config.abrBandWidthUpFactor;
    if (!bufferStarvationDelay) {
      const bitrateTestDelay = this.bitrateTestDelay;
      if (bitrateTestDelay) {
        const maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
        maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
        logger.trace(`[abr] bitrate test took ${Math.round(1e3 * bitrateTestDelay)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * maxStarvationDelay)} ms`);
        bwFactor = bwUpFactor = 1;
      }
    }
    bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor);
    return Math.max(bestLevel, 0);
  }
  findBestLevel(currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor) {
    var _level$details;
    const {
      fragCurrent,
      partCurrent,
      lastLoadedFragLevel: currentLevel
    } = this;
    const {
      levels
    } = this.hls;
    const level = levels[currentLevel];
    const live = !!(level != null && (_level$details = level.details) != null && _level$details.live);
    const currentCodecSet = level == null ? void 0 : level.codecSet;
    const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
    const ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1e3;
    let levelSkippedMin = minAutoLevel;
    let levelSkippedMax = -1;
    for (let i = maxAutoLevel; i >= minAutoLevel; i--) {
      const levelInfo = levels[i];
      if (!levelInfo || currentCodecSet && levelInfo.codecSet !== currentCodecSet) {
        if (levelInfo) {
          levelSkippedMin = Math.min(i, levelSkippedMin);
          levelSkippedMax = Math.max(i, levelSkippedMax);
        }
        continue;
      }
      if (levelSkippedMax !== -1) {
        logger.trace(`[abr] Skipped level(s) ${levelSkippedMin}-${levelSkippedMax} with CODECS:"${levels[levelSkippedMax].attrs.CODECS}"; not compatible with "${level.attrs.CODECS}"`);
      }
      const levelDetails = levelInfo.details;
      const avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;
      let adjustedbw;
      if (i <= currentLevel) {
        adjustedbw = bwFactor * currentBw;
      } else {
        adjustedbw = bwUpFactor * currentBw;
      }
      const bitrate = levels[i].maxBitrate;
      const fetchDuration = this.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === void 0);
      logger.trace(`[abr] level:${i} adjustedbw-bitrate:${Math.round(adjustedbw - bitrate)} avgDuration:${avgDuration.toFixed(1)} maxFetchDuration:${maxFetchDuration.toFixed(1)} fetchDuration:${fetchDuration.toFixed(1)}`);
      if (adjustedbw > bitrate && // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
      // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
      // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1
      (fetchDuration === 0 || !isFiniteNumber(fetchDuration) || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {
        return i;
      }
    }
    return -1;
  }
  set nextAutoLevel(nextLevel) {
    this._nextAutoLevel = nextLevel;
  }
};
var ChunkCache = class {
  constructor() {
    this.chunks = [];
    this.dataLength = 0;
  }
  push(chunk) {
    this.chunks.push(chunk);
    this.dataLength += chunk.length;
  }
  flush() {
    const {
      chunks,
      dataLength
    } = this;
    let result;
    if (!chunks.length) {
      return new Uint8Array(0);
    } else if (chunks.length === 1) {
      result = chunks[0];
    } else {
      result = concatUint8Arrays(chunks, dataLength);
    }
    this.reset();
    return result;
  }
  reset() {
    this.chunks.length = 0;
    this.dataLength = 0;
  }
};
function concatUint8Arrays(chunks, dataLength) {
  const result = new Uint8Array(dataLength);
  let offset = 0;
  for (let i = 0; i < chunks.length; i++) {
    const chunk = chunks[i];
    result.set(chunk, offset);
    offset += chunk.length;
  }
  return result;
}
var TICK_INTERVAL$1 = 100;
var AudioStreamController = class extends BaseStreamController {
  constructor(hls, fragmentTracker, keyLoader) {
    super(hls, fragmentTracker, keyLoader, "[audio-stream-controller]", PlaylistLevelType.AUDIO);
    this.videoBuffer = null;
    this.videoTrackCC = -1;
    this.waitingVideoCC = -1;
    this.bufferedTrack = null;
    this.switchingTrack = null;
    this.trackId = -1;
    this.waitingData = null;
    this.mainDetails = null;
    this.bufferFlushed = false;
    this.cachedTrackLoadedData = null;
    this._registerListeners();
  }
  onHandlerDestroying() {
    this._unregisterListeners();
    this.mainDetails = null;
    this.bufferedTrack = null;
    this.switchingTrack = null;
  }
  _registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    hls.on(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
    hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
    hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
    hls.on(Events.ERROR, this.onError, this);
    hls.on(Events.BUFFER_RESET, this.onBufferReset, this);
    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
    hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
    hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  _unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    hls.off(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
    hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
    hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
    hls.off(Events.ERROR, this.onError, this);
    hls.off(Events.BUFFER_RESET, this.onBufferReset, this);
    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
    hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
    hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value
  onInitPtsFound(event, {
    frag,
    id,
    initPTS,
    timescale: timescale2
  }) {
    if (id === "main") {
      const cc = frag.cc;
      this.initPTS[frag.cc] = {
        baseTime: initPTS,
        timescale: timescale2
      };
      this.log(`InitPTS for cc: ${cc} found from main: ${initPTS}`);
      this.videoTrackCC = cc;
      if (this.state === State.WAITING_INIT_PTS) {
        this.tick();
      }
    }
  }
  startLoad(startPosition) {
    if (!this.levels) {
      this.startPosition = startPosition;
      this.state = State.STOPPED;
      return;
    }
    const lastCurrentTime = this.lastCurrentTime;
    this.stopLoad();
    this.setInterval(TICK_INTERVAL$1);
    if (lastCurrentTime > 0 && startPosition === -1) {
      this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);
      startPosition = lastCurrentTime;
      this.state = State.IDLE;
    } else {
      this.loadedmetadata = false;
      this.state = State.WAITING_TRACK;
    }
    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
    this.tick();
  }
  doTick() {
    switch (this.state) {
      case State.IDLE:
        this.doTickIdle();
        break;
      case State.WAITING_TRACK: {
        var _levels$trackId;
        const {
          levels,
          trackId
        } = this;
        const details = levels == null ? void 0 : (_levels$trackId = levels[trackId]) == null ? void 0 : _levels$trackId.details;
        if (details) {
          if (this.waitForCdnTuneIn(details)) {
            break;
          }
          this.state = State.WAITING_INIT_PTS;
        }
        break;
      }
      case State.FRAG_LOADING_WAITING_RETRY: {
        var _this$media;
        const now2 = performance.now();
        const retryDate = this.retryDate;
        if (!retryDate || now2 >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {
          this.log("RetryDate reached, switch back to IDLE state");
          this.resetStartWhenNotLoaded(this.trackId);
          this.state = State.IDLE;
        }
        break;
      }
      case State.WAITING_INIT_PTS: {
        const waitingData = this.waitingData;
        if (waitingData) {
          const {
            frag,
            part,
            cache,
            complete
          } = waitingData;
          if (this.initPTS[frag.cc] !== void 0) {
            this.waitingData = null;
            this.waitingVideoCC = -1;
            this.state = State.FRAG_LOADING;
            const payload = cache.flush();
            const data = {
              frag,
              part,
              payload,
              networkDetails: null
            };
            this._handleFragmentLoadProgress(data);
            if (complete) {
              super._handleFragmentLoadComplete(data);
            }
          } else if (this.videoTrackCC !== this.waitingVideoCC) {
            this.log(`Waiting fragment cc (${frag.cc}) cancelled because video is at cc ${this.videoTrackCC}`);
            this.clearWaitingFragment();
          } else {
            const pos = this.getLoadPosition();
            const bufferInfo = BufferHelper.bufferInfo(this.mediaBuffer, pos, this.config.maxBufferHole);
            const waitingFragmentAtPosition = fragmentWithinToleranceTest(bufferInfo.end, this.config.maxFragLookUpTolerance, frag);
            if (waitingFragmentAtPosition < 0) {
              this.log(`Waiting fragment cc (${frag.cc}) @ ${frag.start} cancelled because another fragment at ${bufferInfo.end} is needed`);
              this.clearWaitingFragment();
            }
          }
        } else {
          this.state = State.IDLE;
        }
      }
    }
    this.onTickEnd();
  }
  clearWaitingFragment() {
    const waitingData = this.waitingData;
    if (waitingData) {
      this.fragmentTracker.removeFragment(waitingData.frag);
      this.waitingData = null;
      this.waitingVideoCC = -1;
      this.state = State.IDLE;
    }
  }
  resetLoadingState() {
    this.clearWaitingFragment();
    super.resetLoadingState();
  }
  onTickEnd() {
    const {
      media
    } = this;
    if (!(media != null && media.readyState)) {
      return;
    }
    this.lastCurrentTime = media.currentTime;
  }
  doTickIdle() {
    const {
      hls,
      levels,
      media,
      trackId
    } = this;
    const config = hls.config;
    if (!(levels != null && levels[trackId])) {
      return;
    }
    if (!media && (this.startFragRequested || !config.startFragPrefetch)) {
      return;
    }
    const levelInfo = levels[trackId];
    const trackDetails = levelInfo.details;
    if (!trackDetails || trackDetails.live && this.levelLastLoaded !== trackId || this.waitForCdnTuneIn(trackDetails)) {
      this.state = State.WAITING_TRACK;
      return;
    }
    const bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;
    if (this.bufferFlushed && bufferable) {
      this.bufferFlushed = false;
      this.afterBufferFlushed(bufferable, ElementaryStreamTypes.AUDIO, PlaylistLevelType.AUDIO);
    }
    const bufferInfo = this.getFwdBufferInfo(bufferable, PlaylistLevelType.AUDIO);
    if (bufferInfo === null) {
      return;
    }
    const {
      bufferedTrack,
      switchingTrack
    } = this;
    if (!switchingTrack && this._streamEnded(bufferInfo, trackDetails)) {
      hls.trigger(Events.BUFFER_EOS, {
        type: "audio"
      });
      this.state = State.ENDED;
      return;
    }
    const mainBufferInfo = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, PlaylistLevelType.MAIN);
    const bufferLen = bufferInfo.len;
    const maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len);
    if (bufferLen >= maxBufLen && !switchingTrack) {
      return;
    }
    const fragments = trackDetails.fragments;
    const start2 = fragments[0].start;
    let targetBufferTime = bufferInfo.end;
    if (switchingTrack && media) {
      const pos = this.getLoadPosition();
      if (bufferedTrack && switchingTrack.attrs !== bufferedTrack.attrs) {
        targetBufferTime = pos;
      }
      if (trackDetails.PTSKnown && pos < start2) {
        if (bufferInfo.end > start2 || bufferInfo.nextStart) {
          this.log("Alt audio track ahead of main track, seek to start of alt audio track");
          media.currentTime = start2 + 0.05;
        }
      }
    }
    let frag = this.getNextFragment(targetBufferTime, trackDetails);
    let atGap = false;
    if (frag && this.isLoopLoading(frag, targetBufferTime)) {
      atGap = !!frag.gap;
      frag = this.getNextFragmentLoopLoading(frag, trackDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);
    }
    if (!frag) {
      this.bufferFlushed = true;
      return;
    }
    const atBufferSyncLimit = mainBufferInfo && frag.start > mainBufferInfo.end + trackDetails.targetduration;
    if (atBufferSyncLimit || // Or wait for main buffer after buffing some audio
    !(mainBufferInfo != null && mainBufferInfo.len) && bufferInfo.len) {
      const mainFrag = this.getAppendedFrag(frag.start, PlaylistLevelType.MAIN);
      if (mainFrag === null) {
        return;
      }
      atGap || (atGap = !!mainFrag.gap || !!atBufferSyncLimit && mainBufferInfo.len === 0);
      if (atBufferSyncLimit && !atGap || atGap && bufferInfo.nextStart && bufferInfo.nextStart < mainFrag.end) {
        return;
      }
    }
    this.loadFragment(frag, levelInfo, targetBufferTime);
  }
  getMaxBufferLength(mainBufferLength) {
    const maxConfigBuffer = super.getMaxBufferLength();
    if (!mainBufferLength) {
      return maxConfigBuffer;
    }
    return Math.min(Math.max(maxConfigBuffer, mainBufferLength), this.config.maxMaxBufferLength);
  }
  onMediaDetaching() {
    this.videoBuffer = null;
    super.onMediaDetaching();
  }
  onAudioTracksUpdated(event, {
    audioTracks
  }) {
    this.resetTransmuxer();
    this.levels = audioTracks.map((mediaPlaylist) => new Level(mediaPlaylist));
  }
  onAudioTrackSwitching(event, data) {
    const altAudio = !!data.url;
    this.trackId = data.id;
    const {
      fragCurrent
    } = this;
    if (fragCurrent) {
      fragCurrent.abortRequests();
      this.removeUnbufferedFrags(fragCurrent.start);
    }
    this.resetLoadingState();
    if (!altAudio) {
      this.resetTransmuxer();
    } else {
      this.setInterval(TICK_INTERVAL$1);
    }
    if (altAudio) {
      this.switchingTrack = data;
      this.state = State.IDLE;
    } else {
      this.switchingTrack = null;
      this.bufferedTrack = data;
      this.state = State.STOPPED;
    }
    this.tick();
  }
  onManifestLoading() {
    this.fragmentTracker.removeAllFragments();
    this.startPosition = this.lastCurrentTime = 0;
    this.bufferFlushed = false;
    this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null;
    this.startFragRequested = false;
    this.trackId = this.videoTrackCC = this.waitingVideoCC = -1;
  }
  onLevelLoaded(event, data) {
    this.mainDetails = data.details;
    if (this.cachedTrackLoadedData !== null) {
      this.hls.trigger(Events.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData);
      this.cachedTrackLoadedData = null;
    }
  }
  onAudioTrackLoaded(event, data) {
    var _track$details;
    if (this.mainDetails == null) {
      this.cachedTrackLoadedData = data;
      return;
    }
    const {
      levels
    } = this;
    const {
      details: newDetails,
      id: trackId
    } = data;
    if (!levels) {
      this.warn(`Audio tracks were reset while loading level ${trackId}`);
      return;
    }
    this.log(`Track ${trackId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ""},duration:${newDetails.totalduration}`);
    const track = levels[trackId];
    let sliding = 0;
    if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {
      this.checkLiveUpdate(newDetails);
      const mainDetails = this.mainDetails;
      if (newDetails.deltaUpdateFailed || !mainDetails) {
        return;
      }
      if (!track.details && newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {
        alignMediaPlaylistByPDT(newDetails, mainDetails);
        sliding = newDetails.fragments[0].start;
      } else {
        sliding = this.alignPlaylists(newDetails, track.details);
      }
    }
    track.details = newDetails;
    this.levelLastLoaded = trackId;
    if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {
      this.setStartPosition(track.details, sliding);
    }
    if (this.state === State.WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {
      this.state = State.IDLE;
    }
    this.tick();
  }
  _handleFragmentLoadProgress(data) {
    var _frag$initSegment;
    const {
      frag,
      part,
      payload
    } = data;
    const {
      config,
      trackId,
      levels
    } = this;
    if (!levels) {
      this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);
      return;
    }
    const track = levels[trackId];
    if (!track) {
      this.warn("Audio track is undefined on fragment load progress");
      return;
    }
    const details = track.details;
    if (!details) {
      this.warn("Audio track details undefined on fragment load progress");
      this.removeUnbufferedFrags(frag.start);
      return;
    }
    const audioCodec = config.defaultAudioCodec || track.audioCodec || "mp4a.40.2";
    let transmuxer = this.transmuxer;
    if (!transmuxer) {
      transmuxer = this.transmuxer = new TransmuxerInterface(this.hls, PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
    }
    const initPTS = this.initPTS[frag.cc];
    const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;
    if (initPTS !== void 0) {
      const accurateTimeOffset = false;
      const partIndex = part ? part.index : -1;
      const partial = partIndex !== -1;
      const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
      transmuxer.push(payload, initSegmentData, audioCodec, "", frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
    } else {
      this.log(`Unknown video PTS for cc ${frag.cc}, waiting for video PTS before demuxing audio frag ${frag.sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);
      const {
        cache
      } = this.waitingData = this.waitingData || {
        frag,
        part,
        cache: new ChunkCache(),
        complete: false
      };
      cache.push(new Uint8Array(payload));
      this.waitingVideoCC = this.videoTrackCC;
      this.state = State.WAITING_INIT_PTS;
    }
  }
  _handleFragmentLoadComplete(fragLoadedData) {
    if (this.waitingData) {
      this.waitingData.complete = true;
      return;
    }
    super._handleFragmentLoadComplete(fragLoadedData);
  }
  onBufferReset() {
    this.mediaBuffer = this.videoBuffer = null;
    this.loadedmetadata = false;
  }
  onBufferCreated(event, data) {
    const audioTrack = data.tracks.audio;
    if (audioTrack) {
      this.mediaBuffer = audioTrack.buffer || null;
    }
    if (data.tracks.video) {
      this.videoBuffer = data.tracks.video.buffer || null;
    }
  }
  onFragBuffered(event, data) {
    const {
      frag,
      part
    } = data;
    if (frag.type !== PlaylistLevelType.AUDIO) {
      if (!this.loadedmetadata && frag.type === PlaylistLevelType.MAIN) {
        const bufferable = this.videoBuffer || this.media;
        if (bufferable) {
          const bufferedTimeRanges = BufferHelper.getBuffered(bufferable);
          if (bufferedTimeRanges.length) {
            this.loadedmetadata = true;
          }
        }
      }
      return;
    }
    if (this.fragContextChanged(frag)) {
      this.warn(`Fragment ${frag.sn}${part ? " p: " + part.index : ""} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : "false"}`);
      return;
    }
    if (frag.sn !== "initSegment") {
      this.fragPrevious = frag;
      const track = this.switchingTrack;
      if (track) {
        this.bufferedTrack = track;
        this.switchingTrack = null;
        this.hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, track));
      }
    }
    this.fragBufferedComplete(frag, part);
  }
  onError(event, data) {
    var _data$context;
    if (data.fatal) {
      this.state = State.ERROR;
      return;
    }
    switch (data.details) {
      case ErrorDetails.FRAG_GAP:
      case ErrorDetails.FRAG_PARSING_ERROR:
      case ErrorDetails.FRAG_DECRYPT_ERROR:
      case ErrorDetails.FRAG_LOAD_ERROR:
      case ErrorDetails.FRAG_LOAD_TIMEOUT:
      case ErrorDetails.KEY_LOAD_ERROR:
      case ErrorDetails.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(PlaylistLevelType.AUDIO, data);
        break;
      case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
      case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
      case ErrorDetails.LEVEL_PARSING_ERROR:
        if (!data.levelRetry && this.state === State.WAITING_TRACK && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.AUDIO_TRACK) {
          this.state = State.IDLE;
        }
        break;
      case ErrorDetails.BUFFER_FULL_ERROR:
        if (!data.parent || data.parent !== "audio") {
          return;
        }
        if (this.reduceLengthAndFlushBuffer(data)) {
          this.bufferedTrack = null;
          super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio");
        }
        break;
      case ErrorDetails.INTERNAL_EXCEPTION:
        this.recoverWorkerError(data);
        break;
    }
  }
  onBufferFlushed(event, {
    type: type2
  }) {
    if (type2 === ElementaryStreamTypes.AUDIO) {
      this.bufferFlushed = true;
      if (this.state === State.ENDED) {
        this.state = State.IDLE;
      }
    }
  }
  _handleTransmuxComplete(transmuxResult) {
    var _id3$samples;
    const id = "audio";
    const {
      hls
    } = this;
    const {
      remuxResult,
      chunkMeta
    } = transmuxResult;
    const context = this.getCurrentContext(chunkMeta);
    if (!context) {
      this.resetWhenMissingContext(chunkMeta);
      return;
    }
    const {
      frag,
      part,
      level
    } = context;
    const {
      details
    } = level;
    const {
      audio,
      text,
      id3,
      initSegment
    } = remuxResult;
    if (this.fragContextChanged(frag) || !details) {
      this.fragmentTracker.removeFragment(frag);
      return;
    }
    this.state = State.PARSING;
    if (this.switchingTrack && audio) {
      this.completeAudioSwitch(this.switchingTrack);
    }
    if (initSegment != null && initSegment.tracks) {
      const mapFragment = frag.initSegment || frag;
      this._bufferInitSegment(initSegment.tracks, mapFragment, chunkMeta);
      hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {
        frag: mapFragment,
        id,
        tracks: initSegment.tracks
      });
    }
    if (audio) {
      const {
        startPTS,
        endPTS,
        startDTS,
        endDTS
      } = audio;
      if (part) {
        part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {
          startPTS,
          endPTS,
          startDTS,
          endDTS
        };
      }
      frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);
      this.bufferFragmentData(audio, frag, part, chunkMeta);
    }
    if (id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {
      const emittedID3 = _extends({
        id,
        frag,
        details
      }, id3);
      hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);
    }
    if (text) {
      const emittedText = _extends({
        id,
        frag,
        details
      }, text);
      hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);
    }
  }
  _bufferInitSegment(tracks, frag, chunkMeta) {
    if (this.state !== State.PARSING) {
      return;
    }
    if (tracks.video) {
      delete tracks.video;
    }
    const track = tracks.audio;
    if (!track) {
      return;
    }
    track.levelCodec = track.codec;
    track.id = "audio";
    this.log(`Init audio buffer, container:${track.container}, codecs[parsed]=[${track.codec}]`);
    this.hls.trigger(Events.BUFFER_CODECS, tracks);
    const initSegment = track.initSegment;
    if (initSegment != null && initSegment.byteLength) {
      const segment = {
        type: "audio",
        frag,
        part: null,
        chunkMeta,
        parent: frag.type,
        data: initSegment
      };
      this.hls.trigger(Events.BUFFER_APPENDING, segment);
    }
    this.tick();
  }
  loadFragment(frag, track, targetBufferTime) {
    const fragState = this.fragmentTracker.getState(frag);
    this.fragCurrent = frag;
    if (this.switchingTrack || fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {
      var _track$details2;
      if (frag.sn === "initSegment") {
        this._loadInitSegment(frag, track);
      } else if ((_track$details2 = track.details) != null && _track$details2.live && !this.initPTS[frag.cc]) {
        this.log(`Waiting for video PTS in continuity counter ${frag.cc} of live stream before loading audio fragment ${frag.sn} of level ${this.trackId}`);
        this.state = State.WAITING_INIT_PTS;
      } else {
        this.startFragRequested = true;
        super.loadFragment(frag, track, targetBufferTime);
      }
    } else {
      this.clearTrackerIfNeeded(frag);
    }
  }
  completeAudioSwitch(switchingTrack) {
    const {
      hls,
      media,
      bufferedTrack
    } = this;
    const bufferedAttributes = bufferedTrack == null ? void 0 : bufferedTrack.attrs;
    const switchAttributes = switchingTrack.attrs;
    if (media && bufferedAttributes && (bufferedAttributes.CHANNELS !== switchAttributes.CHANNELS || bufferedAttributes.NAME !== switchAttributes.NAME || bufferedAttributes.LANGUAGE !== switchAttributes.LANGUAGE)) {
      this.log("Switching audio track : flushing all audio");
      super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio");
    }
    this.bufferedTrack = switchingTrack;
    this.switchingTrack = null;
    hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, switchingTrack));
  }
};
var AudioTrackController = class extends BasePlaylistController {
  constructor(hls) {
    super(hls, "[audio-track-controller]");
    this.tracks = [];
    this.groupId = null;
    this.tracksInGroup = [];
    this.trackId = -1;
    this.currentTrack = null;
    this.selectDefaultTrack = true;
    this.registerListeners();
  }
  registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
    hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
    hls.on(Events.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
    hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
    hls.off(Events.ERROR, this.onError, this);
  }
  destroy() {
    this.unregisterListeners();
    this.tracks.length = 0;
    this.tracksInGroup.length = 0;
    this.currentTrack = null;
    super.destroy();
  }
  onManifestLoading() {
    this.tracks = [];
    this.groupId = null;
    this.tracksInGroup = [];
    this.trackId = -1;
    this.currentTrack = null;
    this.selectDefaultTrack = true;
  }
  onManifestParsed(event, data) {
    this.tracks = data.audioTracks || [];
  }
  onAudioTrackLoaded(event, data) {
    const {
      id,
      groupId,
      details
    } = data;
    const trackInActiveGroup = this.tracksInGroup[id];
    if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {
      this.warn(`Track with id:${id} and group:${groupId} not found in active group ${trackInActiveGroup.groupId}`);
      return;
    }
    const curDetails = trackInActiveGroup.details;
    trackInActiveGroup.details = data.details;
    this.log(`audio-track ${id} "${trackInActiveGroup.name}" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);
    if (id === this.trackId) {
      this.playlistLoaded(id, data, curDetails);
    }
  }
  onLevelLoading(event, data) {
    this.switchLevel(data.level);
  }
  onLevelSwitching(event, data) {
    this.switchLevel(data.level);
  }
  switchLevel(levelIndex) {
    const levelInfo = this.hls.levels[levelIndex];
    if (!(levelInfo != null && levelInfo.audioGroupIds)) {
      return;
    }
    const audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];
    if (this.groupId !== audioGroupId) {
      this.groupId = audioGroupId || null;
      const audioTracks = this.tracks.filter((track) => !audioGroupId || track.groupId === audioGroupId);
      if (this.selectDefaultTrack && !audioTracks.some((track) => track.default)) {
        this.selectDefaultTrack = false;
      }
      this.tracksInGroup = audioTracks;
      const audioTracksUpdated = {
        audioTracks
      };
      this.log(`Updating audio tracks, ${audioTracks.length} track(s) found in group:${audioGroupId}`);
      this.hls.trigger(Events.AUDIO_TRACKS_UPDATED, audioTracksUpdated);
      this.selectInitialTrack();
    } else if (this.shouldReloadPlaylist(this.currentTrack)) {
      this.setAudioTrack(this.trackId);
    }
  }
  onError(event, data) {
    if (data.fatal || !data.context) {
      return;
    }
    if (data.context.type === PlaylistContextType.AUDIO_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {
      this.requestScheduled = -1;
      this.checkRetry(data);
    }
  }
  get audioTracks() {
    return this.tracksInGroup;
  }
  get audioTrack() {
    return this.trackId;
  }
  set audioTrack(newId) {
    this.selectDefaultTrack = false;
    this.setAudioTrack(newId);
  }
  setAudioTrack(newId) {
    const tracks = this.tracksInGroup;
    if (newId < 0 || newId >= tracks.length) {
      this.warn("Invalid id passed to audio-track controller");
      return;
    }
    this.clearTimer();
    const lastTrack = this.currentTrack;
    tracks[this.trackId];
    const track = tracks[newId];
    const {
      groupId,
      name
    } = track;
    this.log(`Switching to audio-track ${newId} "${name}" lang:${track.lang} group:${groupId}`);
    this.trackId = newId;
    this.currentTrack = track;
    this.selectDefaultTrack = false;
    this.hls.trigger(Events.AUDIO_TRACK_SWITCHING, _objectSpread2({}, track));
    if (track.details && !track.details.live) {
      return;
    }
    const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details);
    this.loadPlaylist(hlsUrlParameters);
  }
  selectInitialTrack() {
    const audioTracks = this.tracksInGroup;
    const trackId = this.findTrackId(this.currentTrack) | this.findTrackId(null);
    if (trackId !== -1) {
      this.setAudioTrack(trackId);
    } else {
      const error = new Error(`No track found for running audio group-ID: ${this.groupId} track count: ${audioTracks.length}`);
      this.warn(error.message);
      this.hls.trigger(Events.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.AUDIO_TRACK_LOAD_ERROR,
        fatal: true,
        error
      });
    }
  }
  findTrackId(currentTrack) {
    const audioTracks = this.tracksInGroup;
    for (let i = 0; i < audioTracks.length; i++) {
      const track = audioTracks[i];
      if (!this.selectDefaultTrack || track.default) {
        if (!currentTrack || currentTrack.attrs["STABLE-RENDITION-ID"] !== void 0 && currentTrack.attrs["STABLE-RENDITION-ID"] === track.attrs["STABLE-RENDITION-ID"]) {
          return track.id;
        }
        if (currentTrack.name === track.name && currentTrack.lang === track.lang) {
          return track.id;
        }
      }
    }
    return -1;
  }
  loadPlaylist(hlsUrlParameters) {
    super.loadPlaylist();
    const audioTrack = this.tracksInGroup[this.trackId];
    if (this.shouldLoadPlaylist(audioTrack)) {
      const id = audioTrack.id;
      const groupId = audioTrack.groupId;
      let url = audioTrack.url;
      if (hlsUrlParameters) {
        try {
          url = hlsUrlParameters.addDirectives(url);
        } catch (error) {
          this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);
        }
      }
      this.log(`loading audio-track playlist ${id} "${audioTrack.name}" lang:${audioTrack.lang} group:${groupId}`);
      this.clearTimer();
      this.hls.trigger(Events.AUDIO_TRACK_LOADING, {
        url,
        id,
        groupId,
        deliveryDirectives: hlsUrlParameters || null
      });
    }
  }
};
function subtitleOptionsIdentical(trackList1, trackList2) {
  if (trackList1.length !== trackList2.length) {
    return false;
  }
  for (let i = 0; i < trackList1.length; i++) {
    if (!subtitleAttributesIdentical(trackList1[i].attrs, trackList2[i].attrs)) {
      return false;
    }
  }
  return true;
}
function subtitleAttributesIdentical(attrs1, attrs2) {
  const stableRenditionId = attrs1["STABLE-RENDITION-ID"];
  if (stableRenditionId) {
    return stableRenditionId === attrs2["STABLE-RENDITION-ID"];
  }
  return !["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED"].some((subtitleAttribute) => attrs1[subtitleAttribute] !== attrs2[subtitleAttribute]);
}
var TICK_INTERVAL = 500;
var SubtitleStreamController = class extends BaseStreamController {
  constructor(hls, fragmentTracker, keyLoader) {
    super(hls, fragmentTracker, keyLoader, "[subtitle-stream-controller]", PlaylistLevelType.SUBTITLE);
    this.levels = [];
    this.currentTrackId = -1;
    this.tracksBuffered = [];
    this.mainDetails = null;
    this._registerListeners();
  }
  onHandlerDestroying() {
    this._unregisterListeners();
    this.mainDetails = null;
  }
  _registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    hls.on(Events.ERROR, this.onError, this);
    hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
    hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
    hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
    hls.on(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  _unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    hls.off(Events.ERROR, this.onError, this);
    hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
    hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
    hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
    hls.off(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  startLoad(startPosition) {
    this.stopLoad();
    this.state = State.IDLE;
    this.setInterval(TICK_INTERVAL);
    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
    this.tick();
  }
  onManifestLoading() {
    this.mainDetails = null;
    this.fragmentTracker.removeAllFragments();
  }
  onMediaDetaching() {
    this.tracksBuffered = [];
    super.onMediaDetaching();
  }
  onLevelLoaded(event, data) {
    this.mainDetails = data.details;
  }
  onSubtitleFragProcessed(event, data) {
    const {
      frag,
      success
    } = data;
    this.fragPrevious = frag;
    this.state = State.IDLE;
    if (!success) {
      return;
    }
    const buffered = this.tracksBuffered[this.currentTrackId];
    if (!buffered) {
      return;
    }
    let timeRange;
    const fragStart = frag.start;
    for (let i = 0; i < buffered.length; i++) {
      if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {
        timeRange = buffered[i];
        break;
      }
    }
    const fragEnd = frag.start + frag.duration;
    if (timeRange) {
      timeRange.end = fragEnd;
    } else {
      timeRange = {
        start: fragStart,
        end: fragEnd
      };
      buffered.push(timeRange);
    }
    this.fragmentTracker.fragBuffered(frag);
  }
  onBufferFlushing(event, data) {
    const {
      startOffset,
      endOffset
    } = data;
    if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {
      const endOffsetSubtitles = endOffset - 1;
      if (endOffsetSubtitles <= 0) {
        return;
      }
      data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);
      this.tracksBuffered.forEach((buffered) => {
        for (let i = 0; i < buffered.length; ) {
          if (buffered[i].end <= endOffsetSubtitles) {
            buffered.shift();
            continue;
          } else if (buffered[i].start < endOffsetSubtitles) {
            buffered[i].start = endOffsetSubtitles;
          } else {
            break;
          }
          i++;
        }
      });
      this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, PlaylistLevelType.SUBTITLE);
    }
  }
  onFragBuffered(event, data) {
    if (!this.loadedmetadata && data.frag.type === PlaylistLevelType.MAIN) {
      var _this$media;
      if ((_this$media = this.media) != null && _this$media.buffered.length) {
        this.loadedmetadata = true;
      }
    }
  }
  // If something goes wrong, proceed to next frag, if we were processing one.
  onError(event, data) {
    const frag = data.frag;
    if ((frag == null ? void 0 : frag.type) === PlaylistLevelType.SUBTITLE) {
      if (this.fragCurrent) {
        this.fragCurrent.abortRequests();
      }
      if (this.state !== State.STOPPED) {
        this.state = State.IDLE;
      }
    }
  }
  // Got all new subtitle levels.
  onSubtitleTracksUpdated(event, {
    subtitleTracks
  }) {
    if (subtitleOptionsIdentical(this.levels, subtitleTracks)) {
      this.levels = subtitleTracks.map((mediaPlaylist) => new Level(mediaPlaylist));
      return;
    }
    this.tracksBuffered = [];
    this.levels = subtitleTracks.map((mediaPlaylist) => {
      const level = new Level(mediaPlaylist);
      this.tracksBuffered[level.id] = [];
      return level;
    });
    this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, PlaylistLevelType.SUBTITLE);
    this.fragPrevious = null;
    this.mediaBuffer = null;
  }
  onSubtitleTrackSwitch(event, data) {
    this.currentTrackId = data.id;
    if (!this.levels.length || this.currentTrackId === -1) {
      this.clearInterval();
      return;
    }
    const currentTrack = this.levels[this.currentTrackId];
    if (currentTrack != null && currentTrack.details) {
      this.mediaBuffer = this.mediaBufferTimeRanges;
    } else {
      this.mediaBuffer = null;
    }
    if (currentTrack) {
      this.setInterval(TICK_INTERVAL);
    }
  }
  // Got a new set of subtitle fragments.
  onSubtitleTrackLoaded(event, data) {
    var _track$details;
    const {
      details: newDetails,
      id: trackId
    } = data;
    const {
      currentTrackId,
      levels
    } = this;
    if (!levels.length) {
      return;
    }
    const track = levels[currentTrackId];
    if (trackId >= levels.length || trackId !== currentTrackId || !track) {
      return;
    }
    this.mediaBuffer = this.mediaBufferTimeRanges;
    let sliding = 0;
    if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {
      const mainDetails = this.mainDetails;
      if (newDetails.deltaUpdateFailed || !mainDetails) {
        return;
      }
      const mainSlidingStartFragment = mainDetails.fragments[0];
      if (!track.details) {
        if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {
          alignMediaPlaylistByPDT(newDetails, mainDetails);
          sliding = newDetails.fragments[0].start;
        } else if (mainSlidingStartFragment) {
          sliding = mainSlidingStartFragment.start;
          addSliding(newDetails, sliding);
        }
      } else {
        sliding = this.alignPlaylists(newDetails, track.details);
        if (sliding === 0 && mainSlidingStartFragment) {
          sliding = mainSlidingStartFragment.start;
          addSliding(newDetails, sliding);
        }
      }
    }
    track.details = newDetails;
    this.levelLastLoaded = trackId;
    if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {
      this.setStartPosition(track.details, sliding);
    }
    this.tick();
    if (newDetails.live && !this.fragCurrent && this.media && this.state === State.IDLE) {
      const foundFrag = findFragmentByPTS(null, newDetails.fragments, this.media.currentTime, 0);
      if (!foundFrag) {
        this.warn("Subtitle playlist not aligned with playback");
        track.details = void 0;
      }
    }
  }
  _handleFragmentLoadComplete(fragLoadedData) {
    const {
      frag,
      payload
    } = fragLoadedData;
    const decryptData = frag.decryptdata;
    const hls = this.hls;
    if (this.fragContextChanged(frag)) {
      return;
    }
    if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === "AES-128") {
      const startTime = performance.now();
      this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch((err) => {
        hls.trigger(Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.FRAG_DECRYPT_ERROR,
          fatal: false,
          error: err,
          reason: err.message,
          frag
        });
        throw err;
      }).then((decryptedData) => {
        const endTime = performance.now();
        hls.trigger(Events.FRAG_DECRYPTED, {
          frag,
          payload: decryptedData,
          stats: {
            tstart: startTime,
            tdecrypt: endTime
          }
        });
      }).catch((err) => {
        this.warn(`${err.name}: ${err.message}`);
        this.state = State.IDLE;
      });
    }
  }
  doTick() {
    if (!this.media) {
      this.state = State.IDLE;
      return;
    }
    if (this.state === State.IDLE) {
      const {
        currentTrackId,
        levels
      } = this;
      const track = levels[currentTrackId];
      if (!levels.length || !track || !track.details) {
        return;
      }
      const {
        config
      } = this;
      const currentTime = this.getLoadPosition();
      const bufferedInfo = BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], currentTime, config.maxBufferHole);
      const {
        end: targetBufferTime,
        len: bufferLen
      } = bufferedInfo;
      const mainBufferInfo = this.getFwdBufferInfo(this.media, PlaylistLevelType.MAIN);
      const trackDetails = track.details;
      const maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len) + trackDetails.levelTargetDuration;
      if (bufferLen > maxBufLen) {
        return;
      }
      const fragments = trackDetails.fragments;
      const fragLen = fragments.length;
      const end = trackDetails.edge;
      let foundFrag = null;
      const fragPrevious = this.fragPrevious;
      if (targetBufferTime < end) {
        const tolerance = config.maxFragLookUpTolerance;
        const lookupTolerance = targetBufferTime > end - tolerance ? 0 : tolerance;
        foundFrag = findFragmentByPTS(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), lookupTolerance);
        if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {
          foundFrag = fragments[0];
        }
      } else {
        foundFrag = fragments[fragLen - 1];
      }
      if (!foundFrag) {
        return;
      }
      foundFrag = this.mapToInitFragWhenRequired(foundFrag);
      if (foundFrag.sn !== "initSegment") {
        const curSNIdx = foundFrag.sn - trackDetails.startSN;
        const prevFrag = fragments[curSNIdx - 1];
        if (prevFrag && prevFrag.cc === foundFrag.cc && this.fragmentTracker.getState(prevFrag) === FragmentState.NOT_LOADED) {
          foundFrag = prevFrag;
        }
      }
      if (this.fragmentTracker.getState(foundFrag) === FragmentState.NOT_LOADED) {
        this.loadFragment(foundFrag, track, targetBufferTime);
      }
    }
  }
  getMaxBufferLength(mainBufferLength) {
    const maxConfigBuffer = super.getMaxBufferLength();
    if (!mainBufferLength) {
      return maxConfigBuffer;
    }
    return Math.max(maxConfigBuffer, mainBufferLength);
  }
  loadFragment(frag, level, targetBufferTime) {
    this.fragCurrent = frag;
    if (frag.sn === "initSegment") {
      this._loadInitSegment(frag, level);
    } else {
      this.startFragRequested = true;
      super.loadFragment(frag, level, targetBufferTime);
    }
  }
  get mediaBufferTimeRanges() {
    return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);
  }
};
var BufferableInstance = class {
  constructor(timeranges) {
    this.buffered = void 0;
    const getRange2 = (name, index, length) => {
      index = index >>> 0;
      if (index > length - 1) {
        throw new DOMException(`Failed to execute '${name}' on 'TimeRanges': The index provided (${index}) is greater than the maximum bound (${length})`);
      }
      return timeranges[index][name];
    };
    this.buffered = {
      get length() {
        return timeranges.length;
      },
      end(index) {
        return getRange2("end", index, timeranges.length);
      },
      start(index) {
        return getRange2("start", index, timeranges.length);
      }
    };
  }
};
var SubtitleTrackController = class extends BasePlaylistController {
  constructor(hls) {
    super(hls, "[subtitle-track-controller]");
    this.media = null;
    this.tracks = [];
    this.groupId = null;
    this.tracksInGroup = [];
    this.trackId = -1;
    this.selectDefaultTrack = true;
    this.queuedDefaultTrack = -1;
    this.trackChangeListener = () => this.onTextTracksChanged();
    this.asyncPollTrackChange = () => this.pollTrackChange(0);
    this.useTextTrackPolling = false;
    this.subtitlePollingInterval = -1;
    this._subtitleDisplay = true;
    this.registerListeners();
  }
  destroy() {
    this.unregisterListeners();
    this.tracks.length = 0;
    this.tracksInGroup.length = 0;
    this.trackChangeListener = this.asyncPollTrackChange = null;
    super.destroy();
  }
  get subtitleDisplay() {
    return this._subtitleDisplay;
  }
  set subtitleDisplay(value) {
    this._subtitleDisplay = value;
    if (this.trackId > -1) {
      this.toggleTrackModes(this.trackId);
    }
  }
  registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
    hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
    hls.on(Events.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
    hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
    hls.off(Events.ERROR, this.onError, this);
  }
  // Listen for subtitle track change, then extract the current track ID.
  onMediaAttached(event, data) {
    this.media = data.media;
    if (!this.media) {
      return;
    }
    if (this.queuedDefaultTrack > -1) {
      this.subtitleTrack = this.queuedDefaultTrack;
      this.queuedDefaultTrack = -1;
    }
    this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks);
    if (this.useTextTrackPolling) {
      this.pollTrackChange(500);
    } else {
      this.media.textTracks.addEventListener("change", this.asyncPollTrackChange);
    }
  }
  pollTrackChange(timeout) {
    self.clearInterval(this.subtitlePollingInterval);
    this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, timeout);
  }
  onMediaDetaching() {
    if (!this.media) {
      return;
    }
    self.clearInterval(this.subtitlePollingInterval);
    if (!this.useTextTrackPolling) {
      this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange);
    }
    if (this.trackId > -1) {
      this.queuedDefaultTrack = this.trackId;
    }
    const textTracks = filterSubtitleTracks(this.media.textTracks);
    textTracks.forEach((track) => {
      clearCurrentCues(track);
    });
    this.subtitleTrack = -1;
    this.media = null;
  }
  onManifestLoading() {
    this.tracks = [];
    this.groupId = null;
    this.tracksInGroup = [];
    this.trackId = -1;
    this.selectDefaultTrack = true;
  }
  // Fired whenever a new manifest is loaded.
  onManifestParsed(event, data) {
    this.tracks = data.subtitleTracks;
  }
  onSubtitleTrackLoaded(event, data) {
    const {
      id,
      details
    } = data;
    const {
      trackId
    } = this;
    const currentTrack = this.tracksInGroup[trackId];
    if (!currentTrack) {
      this.warn(`Invalid subtitle track id ${id}`);
      return;
    }
    const curDetails = currentTrack.details;
    currentTrack.details = data.details;
    this.log(`subtitle track ${id} loaded [${details.startSN}-${details.endSN}]`);
    if (id === this.trackId) {
      this.playlistLoaded(id, data, curDetails);
    }
  }
  onLevelLoading(event, data) {
    this.switchLevel(data.level);
  }
  onLevelSwitching(event, data) {
    this.switchLevel(data.level);
  }
  switchLevel(levelIndex) {
    const levelInfo = this.hls.levels[levelIndex];
    if (!(levelInfo != null && levelInfo.textGroupIds)) {
      return;
    }
    const textGroupId = levelInfo.textGroupIds[levelInfo.urlId];
    const lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
    if (this.groupId !== textGroupId) {
      const subtitleTracks = this.tracks.filter((track) => !textGroupId || track.groupId === textGroupId);
      this.tracksInGroup = subtitleTracks;
      const initialTrackId = this.findTrackId(lastTrack == null ? void 0 : lastTrack.name) || this.findTrackId();
      this.groupId = textGroupId || null;
      const subtitleTracksUpdated = {
        subtitleTracks
      };
      this.log(`Updating subtitle tracks, ${subtitleTracks.length} track(s) found in "${textGroupId}" group-id`);
      this.hls.trigger(Events.SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);
      if (initialTrackId !== -1) {
        this.setSubtitleTrack(initialTrackId, lastTrack);
      }
    } else if (this.shouldReloadPlaylist(lastTrack)) {
      this.setSubtitleTrack(this.trackId, lastTrack);
    }
  }
  findTrackId(name) {
    const textTracks = this.tracksInGroup;
    for (let i = 0; i < textTracks.length; i++) {
      const track = textTracks[i];
      if (!this.selectDefaultTrack || track.default) {
        if (!name || name === track.name) {
          return track.id;
        }
      }
    }
    return -1;
  }
  onError(event, data) {
    if (data.fatal || !data.context) {
      return;
    }
    if (data.context.type === PlaylistContextType.SUBTITLE_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {
      this.checkRetry(data);
    }
  }
  /** get alternate subtitle tracks list from playlist **/
  get subtitleTracks() {
    return this.tracksInGroup;
  }
  /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/
  get subtitleTrack() {
    return this.trackId;
  }
  set subtitleTrack(newId) {
    this.selectDefaultTrack = false;
    const lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
    this.setSubtitleTrack(newId, lastTrack);
  }
  loadPlaylist(hlsUrlParameters) {
    super.loadPlaylist();
    const currentTrack = this.tracksInGroup[this.trackId];
    if (this.shouldLoadPlaylist(currentTrack)) {
      const id = currentTrack.id;
      const groupId = currentTrack.groupId;
      let url = currentTrack.url;
      if (hlsUrlParameters) {
        try {
          url = hlsUrlParameters.addDirectives(url);
        } catch (error) {
          this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);
        }
      }
      this.log(`Loading subtitle playlist for id ${id}`);
      this.hls.trigger(Events.SUBTITLE_TRACK_LOADING, {
        url,
        id,
        groupId,
        deliveryDirectives: hlsUrlParameters || null
      });
    }
  }
  /**
   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.
   * This operates on the DOM textTracks.
   * A value of -1 will disable all subtitle tracks.
   */
  toggleTrackModes(newId) {
    const {
      media,
      trackId
    } = this;
    if (!media) {
      return;
    }
    const textTracks = filterSubtitleTracks(media.textTracks);
    const groupTracks = textTracks.filter((track) => track.groupId === this.groupId);
    if (newId === -1) {
      [].slice.call(textTracks).forEach((track) => {
        track.mode = "disabled";
      });
    } else {
      const oldTrack = groupTracks[trackId];
      if (oldTrack) {
        oldTrack.mode = "disabled";
      }
    }
    const nextTrack = groupTracks[newId];
    if (nextTrack) {
      nextTrack.mode = this.subtitleDisplay ? "showing" : "hidden";
    }
  }
  /**
   * This method is responsible for validating the subtitle index and periodically reloading if live.
   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.
   */
  setSubtitleTrack(newId, lastTrack) {
    var _tracks$newId;
    const tracks = this.tracksInGroup;
    if (!this.media) {
      this.queuedDefaultTrack = newId;
      return;
    }
    if (this.trackId !== newId) {
      this.toggleTrackModes(newId);
    }
    if (this.trackId === newId && (newId === -1 || (_tracks$newId = tracks[newId]) != null && _tracks$newId.details) || newId < -1 || newId >= tracks.length) {
      return;
    }
    this.clearTimer();
    const track = tracks[newId];
    this.log(`Switching to subtitle-track ${newId}` + (track ? ` "${track.name}" lang:${track.lang} group:${track.groupId}` : ""));
    this.trackId = newId;
    if (track) {
      const {
        id,
        groupId = "",
        name,
        type: type2,
        url
      } = track;
      this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {
        id,
        groupId,
        name,
        type: type2,
        url
      });
      const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details);
      this.loadPlaylist(hlsUrlParameters);
    } else {
      this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {
        id: newId
      });
    }
  }
  onTextTracksChanged() {
    if (!this.useTextTrackPolling) {
      self.clearInterval(this.subtitlePollingInterval);
    }
    if (!this.media || !this.hls.config.renderTextTracksNatively) {
      return;
    }
    let trackId = -1;
    const tracks = filterSubtitleTracks(this.media.textTracks);
    for (let id = 0; id < tracks.length; id++) {
      if (tracks[id].mode === "hidden") {
        trackId = id;
      } else if (tracks[id].mode === "showing") {
        trackId = id;
        break;
      }
    }
    if (this.subtitleTrack !== trackId) {
      this.subtitleTrack = trackId;
    }
  }
};
function filterSubtitleTracks(textTrackList) {
  const tracks = [];
  for (let i = 0; i < textTrackList.length; i++) {
    const track = textTrackList[i];
    if ((track.kind === "subtitles" || track.kind === "captions") && track.label) {
      tracks.push(textTrackList[i]);
    }
  }
  return tracks;
}
var BufferOperationQueue = class {
  constructor(sourceBufferReference) {
    this.buffers = void 0;
    this.queues = {
      video: [],
      audio: [],
      audiovideo: []
    };
    this.buffers = sourceBufferReference;
  }
  append(operation, type2) {
    const queue = this.queues[type2];
    queue.push(operation);
    if (queue.length === 1 && this.buffers[type2]) {
      this.executeNext(type2);
    }
  }
  insertAbort(operation, type2) {
    const queue = this.queues[type2];
    queue.unshift(operation);
    this.executeNext(type2);
  }
  appendBlocker(type2) {
    let execute;
    const promise = new Promise((resolve) => {
      execute = resolve;
    });
    const operation = {
      execute,
      onStart: () => {
      },
      onComplete: () => {
      },
      onError: () => {
      }
    };
    this.append(operation, type2);
    return promise;
  }
  executeNext(type2) {
    const {
      buffers,
      queues
    } = this;
    const sb = buffers[type2];
    const queue = queues[type2];
    if (queue.length) {
      const operation = queue[0];
      try {
        operation.execute();
      } catch (e) {
        logger.warn("[buffer-operation-queue]: Unhandled exception executing the current operation");
        operation.onError(e);
        if (!(sb != null && sb.updating)) {
          queue.shift();
          this.executeNext(type2);
        }
      }
    }
  }
  shiftAndExecuteNext(type2) {
    this.queues[type2].shift();
    this.executeNext(type2);
  }
  current(type2) {
    return this.queues[type2][0];
  }
};
var MediaSource = getMediaSource();
var VIDEO_CODEC_PROFILE_REPACE = /([ha]vc.)(?:\.[^.,]+)+/;
var BufferController = class {
  // The level details used to determine duration, target-duration and live
  // cache the self generated object url to detect hijack of video tag
  // A queue of buffer operations which require the SourceBuffer to not be updating upon execution
  // References to event listeners for each SourceBuffer, so that they can be referenced for event removal
  // The number of BUFFER_CODEC events received before any sourceBuffers are created
  // The total number of BUFFER_CODEC events received
  // A reference to the attached media element
  // A reference to the active media source
  // Last MP3 audio chunk appended
  // counters
  constructor(hls) {
    this.details = null;
    this._objectUrl = null;
    this.operationQueue = void 0;
    this.listeners = void 0;
    this.hls = void 0;
    this.bufferCodecEventsExpected = 0;
    this._bufferCodecEventsTotal = 0;
    this.media = null;
    this.mediaSource = null;
    this.lastMpegAudioChunk = null;
    this.appendError = 0;
    this.tracks = {};
    this.pendingTracks = {};
    this.sourceBuffer = void 0;
    this._onMediaSourceOpen = () => {
      const {
        media,
        mediaSource
      } = this;
      logger.log("[buffer-controller]: Media source opened");
      if (media) {
        media.removeEventListener("emptied", this._onMediaEmptied);
        this.updateMediaElementDuration();
        this.hls.trigger(Events.MEDIA_ATTACHED, {
          media
        });
      }
      if (mediaSource) {
        mediaSource.removeEventListener("sourceopen", this._onMediaSourceOpen);
      }
      this.checkPendingTracks();
    };
    this._onMediaSourceClose = () => {
      logger.log("[buffer-controller]: Media source closed");
    };
    this._onMediaSourceEnded = () => {
      logger.log("[buffer-controller]: Media source ended");
    };
    this._onMediaEmptied = () => {
      const {
        media,
        _objectUrl
      } = this;
      if (media && media.src !== _objectUrl) {
        logger.error(`Media element src was set while attaching MediaSource (${_objectUrl} > ${media.src})`);
      }
    };
    this.hls = hls;
    this._initSourceBuffer();
    this.registerListeners();
  }
  hasSourceTypes() {
    return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;
  }
  destroy() {
    this.unregisterListeners();
    this.details = null;
    this.lastMpegAudioChunk = null;
  }
  registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.on(Events.BUFFER_RESET, this.onBufferReset, this);
    hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);
    hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);
    hls.on(Events.BUFFER_EOS, this.onBufferEos, this);
    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
    hls.on(Events.FRAG_PARSED, this.onFragParsed, this);
    hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);
  }
  unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.off(Events.BUFFER_RESET, this.onBufferReset, this);
    hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);
    hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);
    hls.off(Events.BUFFER_EOS, this.onBufferEos, this);
    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
    hls.off(Events.FRAG_PARSED, this.onFragParsed, this);
    hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);
  }
  _initSourceBuffer() {
    this.sourceBuffer = {};
    this.operationQueue = new BufferOperationQueue(this.sourceBuffer);
    this.listeners = {
      audio: [],
      video: [],
      audiovideo: []
    };
    this.lastMpegAudioChunk = null;
  }
  onManifestLoading() {
    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0;
    this.details = null;
  }
  onManifestParsed(event, data) {
    let codecEvents = 2;
    if (data.audio && !data.video || !data.altAudio || false) {
      codecEvents = 1;
    }
    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;
    logger.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`);
  }
  onMediaAttaching(event, data) {
    const media = this.media = data.media;
    if (media && MediaSource) {
      const ms = this.mediaSource = new MediaSource();
      ms.addEventListener("sourceopen", this._onMediaSourceOpen);
      ms.addEventListener("sourceended", this._onMediaSourceEnded);
      ms.addEventListener("sourceclose", this._onMediaSourceClose);
      media.src = self.URL.createObjectURL(ms);
      this._objectUrl = media.src;
      media.addEventListener("emptied", this._onMediaEmptied);
    }
  }
  onMediaDetaching() {
    const {
      media,
      mediaSource,
      _objectUrl
    } = this;
    if (mediaSource) {
      logger.log("[buffer-controller]: media source detaching");
      if (mediaSource.readyState === "open") {
        try {
          mediaSource.endOfStream();
        } catch (err) {
          logger.warn(`[buffer-controller]: onMediaDetaching: ${err.message} while calling endOfStream`);
        }
      }
      this.onBufferReset();
      mediaSource.removeEventListener("sourceopen", this._onMediaSourceOpen);
      mediaSource.removeEventListener("sourceended", this._onMediaSourceEnded);
      mediaSource.removeEventListener("sourceclose", this._onMediaSourceClose);
      if (media) {
        media.removeEventListener("emptied", this._onMediaEmptied);
        if (_objectUrl) {
          self.URL.revokeObjectURL(_objectUrl);
        }
        if (media.src === _objectUrl) {
          media.removeAttribute("src");
          media.load();
        } else {
          logger.warn("[buffer-controller]: media.src was changed by a third party - skip cleanup");
        }
      }
      this.mediaSource = null;
      this.media = null;
      this._objectUrl = null;
      this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;
      this.pendingTracks = {};
      this.tracks = {};
    }
    this.hls.trigger(Events.MEDIA_DETACHED, void 0);
  }
  onBufferReset() {
    this.getSourceBufferTypes().forEach((type2) => {
      const sb = this.sourceBuffer[type2];
      try {
        if (sb) {
          this.removeBufferListeners(type2);
          if (this.mediaSource) {
            this.mediaSource.removeSourceBuffer(sb);
          }
          this.sourceBuffer[type2] = void 0;
        }
      } catch (err) {
        logger.warn(`[buffer-controller]: Failed to reset the ${type2} buffer`, err);
      }
    });
    this._initSourceBuffer();
  }
  onBufferCodecs(event, data) {
    const sourceBufferCount = this.getSourceBufferTypes().length;
    Object.keys(data).forEach((trackName) => {
      if (sourceBufferCount) {
        const track = this.tracks[trackName];
        if (track && typeof track.buffer.changeType === "function") {
          const {
            id,
            codec,
            levelCodec,
            container,
            metadata
          } = data[trackName];
          const currentCodec = (track.levelCodec || track.codec).replace(VIDEO_CODEC_PROFILE_REPACE, "$1");
          const nextCodec = (levelCodec || codec).replace(VIDEO_CODEC_PROFILE_REPACE, "$1");
          if (currentCodec !== nextCodec) {
            const mimeType = `${container};codecs=${levelCodec || codec}`;
            this.appendChangeType(trackName, mimeType);
            logger.log(`[buffer-controller]: switching codec ${currentCodec} to ${nextCodec}`);
            this.tracks[trackName] = {
              buffer: track.buffer,
              codec,
              container,
              levelCodec,
              metadata,
              id
            };
          }
        }
      } else {
        this.pendingTracks[trackName] = data[trackName];
      }
    });
    if (sourceBufferCount) {
      return;
    }
    this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);
    if (this.mediaSource && this.mediaSource.readyState === "open") {
      this.checkPendingTracks();
    }
  }
  appendChangeType(type2, mimeType) {
    const {
      operationQueue
    } = this;
    const operation = {
      execute: () => {
        const sb = this.sourceBuffer[type2];
        if (sb) {
          logger.log(`[buffer-controller]: changing ${type2} sourceBuffer type to ${mimeType}`);
          sb.changeType(mimeType);
        }
        operationQueue.shiftAndExecuteNext(type2);
      },
      onStart: () => {
      },
      onComplete: () => {
      },
      onError: (e) => {
        logger.warn(`[buffer-controller]: Failed to change ${type2} SourceBuffer type`, e);
      }
    };
    operationQueue.append(operation, type2);
  }
  onBufferAppending(event, eventData) {
    const {
      hls,
      operationQueue,
      tracks
    } = this;
    const {
      data,
      type: type2,
      frag,
      part,
      chunkMeta
    } = eventData;
    const chunkStats = chunkMeta.buffering[type2];
    const bufferAppendingStart = self.performance.now();
    chunkStats.start = bufferAppendingStart;
    const fragBuffering = frag.stats.buffering;
    const partBuffering = part ? part.stats.buffering : null;
    if (fragBuffering.start === 0) {
      fragBuffering.start = bufferAppendingStart;
    }
    if (partBuffering && partBuffering.start === 0) {
      partBuffering.start = bufferAppendingStart;
    }
    const audioTrack = tracks.audio;
    let checkTimestampOffset = false;
    if (type2 === "audio" && (audioTrack == null ? void 0 : audioTrack.container) === "audio/mpeg") {
      checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;
      this.lastMpegAudioChunk = chunkMeta;
    }
    const fragStart = frag.start;
    const operation = {
      execute: () => {
        chunkStats.executeStart = self.performance.now();
        if (checkTimestampOffset) {
          const sb = this.sourceBuffer[type2];
          if (sb) {
            const delta = fragStart - sb.timestampOffset;
            if (Math.abs(delta) >= 0.1) {
              logger.log(`[buffer-controller]: Updating audio SourceBuffer timestampOffset to ${fragStart} (delta: ${delta}) sn: ${frag.sn})`);
              sb.timestampOffset = fragStart;
            }
          }
        }
        this.appendExecutor(data, type2);
      },
      onStart: () => {
      },
      onComplete: () => {
        const end = self.performance.now();
        chunkStats.executeEnd = chunkStats.end = end;
        if (fragBuffering.first === 0) {
          fragBuffering.first = end;
        }
        if (partBuffering && partBuffering.first === 0) {
          partBuffering.first = end;
        }
        const {
          sourceBuffer
        } = this;
        const timeRanges = {};
        for (const type3 in sourceBuffer) {
          timeRanges[type3] = BufferHelper.getBuffered(sourceBuffer[type3]);
        }
        this.appendError = 0;
        this.hls.trigger(Events.BUFFER_APPENDED, {
          type: type2,
          frag,
          part,
          chunkMeta,
          parent: frag.type,
          timeRanges
        });
      },
      onError: (err) => {
        logger.error(`[buffer-controller]: Error encountered while trying to append to the ${type2} SourceBuffer`, err);
        const event2 = {
          type: ErrorTypes.MEDIA_ERROR,
          parent: frag.type,
          details: ErrorDetails.BUFFER_APPEND_ERROR,
          frag,
          part,
          chunkMeta,
          error: err,
          err,
          fatal: false
        };
        if (err.code === DOMException.QUOTA_EXCEEDED_ERR) {
          event2.details = ErrorDetails.BUFFER_FULL_ERROR;
        } else {
          this.appendError++;
          event2.details = ErrorDetails.BUFFER_APPEND_ERROR;
          if (this.appendError > hls.config.appendErrorMaxRetry) {
            logger.error(`[buffer-controller]: Failed ${hls.config.appendErrorMaxRetry} times to append segment in sourceBuffer`);
            event2.fatal = true;
          }
        }
        hls.trigger(Events.ERROR, event2);
      }
    };
    operationQueue.append(operation, type2);
  }
  onBufferFlushing(event, data) {
    const {
      operationQueue
    } = this;
    const flushOperation = (type2) => ({
      execute: this.removeExecutor.bind(this, type2, data.startOffset, data.endOffset),
      onStart: () => {
      },
      onComplete: () => {
        this.hls.trigger(Events.BUFFER_FLUSHED, {
          type: type2
        });
      },
      onError: (e) => {
        logger.warn(`[buffer-controller]: Failed to remove from ${type2} SourceBuffer`, e);
      }
    });
    if (data.type) {
      operationQueue.append(flushOperation(data.type), data.type);
    } else {
      this.getSourceBufferTypes().forEach((type2) => {
        operationQueue.append(flushOperation(type2), type2);
      });
    }
  }
  onFragParsed(event, data) {
    const {
      frag,
      part
    } = data;
    const buffersAppendedTo = [];
    const elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;
    if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {
      buffersAppendedTo.push("audiovideo");
    } else {
      if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {
        buffersAppendedTo.push("audio");
      }
      if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {
        buffersAppendedTo.push("video");
      }
    }
    const onUnblocked = () => {
      const now2 = self.performance.now();
      frag.stats.buffering.end = now2;
      if (part) {
        part.stats.buffering.end = now2;
      }
      const stats = part ? part.stats : frag.stats;
      this.hls.trigger(Events.FRAG_BUFFERED, {
        frag,
        part,
        stats,
        id: frag.type
      });
    };
    if (buffersAppendedTo.length === 0) {
      logger.warn(`Fragments must have at least one ElementaryStreamType set. type: ${frag.type} level: ${frag.level} sn: ${frag.sn}`);
    }
    this.blockBuffers(onUnblocked, buffersAppendedTo);
  }
  onFragChanged(event, data) {
    this.flushBackBuffer();
  }
  // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()
  // an undefined data.type will mark all buffers as EOS.
  onBufferEos(event, data) {
    const ended = this.getSourceBufferTypes().reduce((acc, type2) => {
      const sb = this.sourceBuffer[type2];
      if (sb && (!data.type || data.type === type2)) {
        sb.ending = true;
        if (!sb.ended) {
          sb.ended = true;
          logger.log(`[buffer-controller]: ${type2} sourceBuffer now EOS`);
        }
      }
      return acc && !!(!sb || sb.ended);
    }, true);
    if (ended) {
      logger.log(`[buffer-controller]: Queueing mediaSource.endOfStream()`);
      this.blockBuffers(() => {
        this.getSourceBufferTypes().forEach((type2) => {
          const sb = this.sourceBuffer[type2];
          if (sb) {
            sb.ending = false;
          }
        });
        const {
          mediaSource
        } = this;
        if (!mediaSource || mediaSource.readyState !== "open") {
          if (mediaSource) {
            logger.info(`[buffer-controller]: Could not call mediaSource.endOfStream(). mediaSource.readyState: ${mediaSource.readyState}`);
          }
          return;
        }
        logger.log(`[buffer-controller]: Calling mediaSource.endOfStream()`);
        mediaSource.endOfStream();
      });
    }
  }
  onLevelUpdated(event, {
    details
  }) {
    if (!details.fragments.length) {
      return;
    }
    this.details = details;
    if (this.getSourceBufferTypes().length) {
      this.blockBuffers(this.updateMediaElementDuration.bind(this));
    } else {
      this.updateMediaElementDuration();
    }
  }
  flushBackBuffer() {
    const {
      hls,
      details,
      media,
      sourceBuffer
    } = this;
    if (!media || details === null) {
      return;
    }
    const sourceBufferTypes = this.getSourceBufferTypes();
    if (!sourceBufferTypes.length) {
      return;
    }
    const backBufferLength = details.live && hls.config.liveBackBufferLength !== null ? hls.config.liveBackBufferLength : hls.config.backBufferLength;
    if (!isFiniteNumber(backBufferLength) || backBufferLength < 0) {
      return;
    }
    const currentTime = media.currentTime;
    const targetDuration = details.levelTargetDuration;
    const maxBackBufferLength = Math.max(backBufferLength, targetDuration);
    const targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;
    sourceBufferTypes.forEach((type2) => {
      const sb = sourceBuffer[type2];
      if (sb) {
        const buffered = BufferHelper.getBuffered(sb);
        if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {
          hls.trigger(Events.BACK_BUFFER_REACHED, {
            bufferEnd: targetBackBufferPosition
          });
          if (details.live) {
            hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {
              bufferEnd: targetBackBufferPosition
            });
          } else if (sb.ended && buffered.end(buffered.length - 1) - currentTime < targetDuration * 2) {
            logger.info(`[buffer-controller]: Cannot flush ${type2} back buffer while SourceBuffer is in ended state`);
            return;
          }
          hls.trigger(Events.BUFFER_FLUSHING, {
            startOffset: 0,
            endOffset: targetBackBufferPosition,
            type: type2
          });
        }
      }
    });
  }
  /**
   * Update Media Source duration to current level duration or override to Infinity if configuration parameter
   * 'liveDurationInfinity` is set to `true`
   * More details: https://github.com/video-dev/hls.js/issues/355
   */
  updateMediaElementDuration() {
    if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== "open") {
      return;
    }
    const {
      details,
      hls,
      media,
      mediaSource
    } = this;
    const levelDuration = details.fragments[0].start + details.totalduration;
    const mediaDuration3 = media.duration;
    const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;
    if (details.live && hls.config.liveDurationInfinity) {
      logger.log("[buffer-controller]: Media Source duration is set to Infinity");
      mediaSource.duration = Infinity;
      this.updateSeekableRange(details);
    } else if (levelDuration > msDuration && levelDuration > mediaDuration3 || !isFiniteNumber(mediaDuration3)) {
      logger.log(`[buffer-controller]: Updating Media Source duration to ${levelDuration.toFixed(3)}`);
      mediaSource.duration = levelDuration;
    }
  }
  updateSeekableRange(levelDetails) {
    const mediaSource = this.mediaSource;
    const fragments = levelDetails.fragments;
    const len = fragments.length;
    if (len && levelDetails.live && mediaSource != null && mediaSource.setLiveSeekableRange) {
      const start2 = Math.max(0, fragments[0].start);
      const end = Math.max(start2, start2 + levelDetails.totalduration);
      mediaSource.setLiveSeekableRange(start2, end);
    }
  }
  checkPendingTracks() {
    const {
      bufferCodecEventsExpected,
      operationQueue,
      pendingTracks
    } = this;
    const pendingTracksCount = Object.keys(pendingTracks).length;
    if (pendingTracksCount && !bufferCodecEventsExpected || pendingTracksCount === 2) {
      this.createSourceBuffers(pendingTracks);
      this.pendingTracks = {};
      const buffers = this.getSourceBufferTypes();
      if (buffers.length) {
        this.hls.trigger(Events.BUFFER_CREATED, {
          tracks: this.tracks
        });
        buffers.forEach((type2) => {
          operationQueue.executeNext(type2);
        });
      } else {
        const error = new Error("could not create source buffer for media codec(s)");
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,
          fatal: true,
          error,
          reason: error.message
        });
      }
    }
  }
  createSourceBuffers(tracks) {
    const {
      sourceBuffer,
      mediaSource
    } = this;
    if (!mediaSource) {
      throw Error("createSourceBuffers called when mediaSource was null");
    }
    for (const trackName in tracks) {
      if (!sourceBuffer[trackName]) {
        const track = tracks[trackName];
        if (!track) {
          throw Error(`source buffer exists for track ${trackName}, however track does not`);
        }
        const codec = track.levelCodec || track.codec;
        const mimeType = `${track.container};codecs=${codec}`;
        logger.log(`[buffer-controller]: creating sourceBuffer(${mimeType})`);
        try {
          const sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
          const sbName = trackName;
          this.addBufferListener(sbName, "updatestart", this._onSBUpdateStart);
          this.addBufferListener(sbName, "updateend", this._onSBUpdateEnd);
          this.addBufferListener(sbName, "error", this._onSBUpdateError);
          this.tracks[trackName] = {
            buffer: sb,
            codec,
            container: track.container,
            levelCodec: track.levelCodec,
            metadata: track.metadata,
            id: track.id
          };
        } catch (err) {
          logger.error(`[buffer-controller]: error while trying to add sourceBuffer: ${err.message}`);
          this.hls.trigger(Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,
            fatal: false,
            error: err,
            mimeType
          });
        }
      }
    }
  }
  _onSBUpdateStart(type2) {
    const {
      operationQueue
    } = this;
    const operation = operationQueue.current(type2);
    operation.onStart();
  }
  _onSBUpdateEnd(type2) {
    const {
      operationQueue
    } = this;
    const operation = operationQueue.current(type2);
    operation.onComplete();
    operationQueue.shiftAndExecuteNext(type2);
  }
  _onSBUpdateError(type2, event) {
    const error = new Error(`${type2} SourceBuffer error`);
    logger.error(`[buffer-controller]: ${error}`, event);
    this.hls.trigger(Events.ERROR, {
      type: ErrorTypes.MEDIA_ERROR,
      details: ErrorDetails.BUFFER_APPENDING_ERROR,
      error,
      fatal: false
    });
    const operation = this.operationQueue.current(type2);
    if (operation) {
      operation.onError(event);
    }
  }
  // This method must result in an updateend event; if remove is not called, _onSBUpdateEnd must be called manually
  removeExecutor(type2, startOffset, endOffset) {
    const {
      media,
      mediaSource,
      operationQueue,
      sourceBuffer
    } = this;
    const sb = sourceBuffer[type2];
    if (!media || !mediaSource || !sb) {
      logger.warn(`[buffer-controller]: Attempting to remove from the ${type2} SourceBuffer, but it does not exist`);
      operationQueue.shiftAndExecuteNext(type2);
      return;
    }
    const mediaDuration3 = isFiniteNumber(media.duration) ? media.duration : Infinity;
    const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;
    const removeStart = Math.max(0, startOffset);
    const removeEnd = Math.min(endOffset, mediaDuration3, msDuration);
    if (removeEnd > removeStart && !sb.ending) {
      sb.ended = false;
      logger.log(`[buffer-controller]: Removing [${removeStart},${removeEnd}] from the ${type2} SourceBuffer`);
      sb.remove(removeStart, removeEnd);
    } else {
      operationQueue.shiftAndExecuteNext(type2);
    }
  }
  // This method must result in an updateend event; if append is not called, _onSBUpdateEnd must be called manually
  appendExecutor(data, type2) {
    const {
      operationQueue,
      sourceBuffer
    } = this;
    const sb = sourceBuffer[type2];
    if (!sb) {
      logger.warn(`[buffer-controller]: Attempting to append to the ${type2} SourceBuffer, but it does not exist`);
      operationQueue.shiftAndExecuteNext(type2);
      return;
    }
    sb.ended = false;
    sb.appendBuffer(data);
  }
  // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises
  // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue
  // upon completion, since we already do it here
  blockBuffers(onUnblocked, buffers = this.getSourceBufferTypes()) {
    if (!buffers.length) {
      logger.log("[buffer-controller]: Blocking operation requested, but no SourceBuffers exist");
      Promise.resolve().then(onUnblocked);
      return;
    }
    const {
      operationQueue
    } = this;
    const blockingOperations = buffers.map((type2) => operationQueue.appendBlocker(type2));
    Promise.all(blockingOperations).then(() => {
      onUnblocked();
      buffers.forEach((type2) => {
        const sb = this.sourceBuffer[type2];
        if (!(sb != null && sb.updating)) {
          operationQueue.shiftAndExecuteNext(type2);
        }
      });
    });
  }
  getSourceBufferTypes() {
    return Object.keys(this.sourceBuffer);
  }
  addBufferListener(type2, event, fn) {
    const buffer = this.sourceBuffer[type2];
    if (!buffer) {
      return;
    }
    const listener = fn.bind(this, type2);
    this.listeners[type2].push({
      event,
      listener
    });
    buffer.addEventListener(event, listener);
  }
  removeBufferListeners(type2) {
    const buffer = this.sourceBuffer[type2];
    if (!buffer) {
      return;
    }
    this.listeners[type2].forEach((l) => {
      buffer.removeEventListener(l.event, l.listener);
    });
  }
};
var specialCea608CharsCodes = {
  42: 225,
  // lowercase a, acute accent
  92: 233,
  // lowercase e, acute accent
  94: 237,
  // lowercase i, acute accent
  95: 243,
  // lowercase o, acute accent
  96: 250,
  // lowercase u, acute accent
  123: 231,
  // lowercase c with cedilla
  124: 247,
  // division symbol
  125: 209,
  // uppercase N tilde
  126: 241,
  // lowercase n tilde
  127: 9608,
  // Full block
  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
  // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
  128: 174,
  // Registered symbol (R)
  129: 176,
  // degree sign
  130: 189,
  // 1/2 symbol
  131: 191,
  // Inverted (open) question mark
  132: 8482,
  // Trademark symbol (TM)
  133: 162,
  // Cents symbol
  134: 163,
  // Pounds sterling
  135: 9834,
  // Music 8'th note
  136: 224,
  // lowercase a, grave accent
  137: 32,
  // transparent space (regular)
  138: 232,
  // lowercase e, grave accent
  139: 226,
  // lowercase a, circumflex accent
  140: 234,
  // lowercase e, circumflex accent
  141: 238,
  // lowercase i, circumflex accent
  142: 244,
  // lowercase o, circumflex accent
  143: 251,
  // lowercase u, circumflex accent
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
  144: 193,
  // capital letter A with acute
  145: 201,
  // capital letter E with acute
  146: 211,
  // capital letter O with acute
  147: 218,
  // capital letter U with acute
  148: 220,
  // capital letter U with diaresis
  149: 252,
  // lowercase letter U with diaeresis
  150: 8216,
  // opening single quote
  151: 161,
  // inverted exclamation mark
  152: 42,
  // asterisk
  153: 8217,
  // closing single quote
  154: 9473,
  // box drawings heavy horizontal
  155: 169,
  // copyright sign
  156: 8480,
  // Service mark
  157: 8226,
  // (round) bullet
  158: 8220,
  // Left double quotation mark
  159: 8221,
  // Right double quotation mark
  160: 192,
  // uppercase A, grave accent
  161: 194,
  // uppercase A, circumflex
  162: 199,
  // uppercase C with cedilla
  163: 200,
  // uppercase E, grave accent
  164: 202,
  // uppercase E, circumflex
  165: 203,
  // capital letter E with diaresis
  166: 235,
  // lowercase letter e with diaresis
  167: 206,
  // uppercase I, circumflex
  168: 207,
  // uppercase I, with diaresis
  169: 239,
  // lowercase i, with diaresis
  170: 212,
  // uppercase O, circumflex
  171: 217,
  // uppercase U, grave accent
  172: 249,
  // lowercase u, grave accent
  173: 219,
  // uppercase U, circumflex
  174: 171,
  // left-pointing double angle quotation mark
  175: 187,
  // right-pointing double angle quotation mark
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
  176: 195,
  // Uppercase A, tilde
  177: 227,
  // Lowercase a, tilde
  178: 205,
  // Uppercase I, acute accent
  179: 204,
  // Uppercase I, grave accent
  180: 236,
  // Lowercase i, grave accent
  181: 210,
  // Uppercase O, grave accent
  182: 242,
  // Lowercase o, grave accent
  183: 213,
  // Uppercase O, tilde
  184: 245,
  // Lowercase o, tilde
  185: 123,
  // Open curly brace
  186: 125,
  // Closing curly brace
  187: 92,
  // Backslash
  188: 94,
  // Caret
  189: 95,
  // Underscore
  190: 124,
  // Pipe (vertical line)
  191: 8764,
  // Tilde operator
  192: 196,
  // Uppercase A, umlaut
  193: 228,
  // Lowercase A, umlaut
  194: 214,
  // Uppercase O, umlaut
  195: 246,
  // Lowercase o, umlaut
  196: 223,
  // Esszett (sharp S)
  197: 165,
  // Yen symbol
  198: 164,
  // Generic currency sign
  199: 9475,
  // Box drawings heavy vertical
  200: 197,
  // Uppercase A, ring
  201: 229,
  // Lowercase A, ring
  202: 216,
  // Uppercase O, stroke
  203: 248,
  // Lowercase o, strok
  204: 9487,
  // Box drawings heavy down and right
  205: 9491,
  // Box drawings heavy down and left
  206: 9495,
  // Box drawings heavy up and right
  207: 9499
  // Box drawings heavy up and left
};
var getCharForByte = function getCharForByte2(byte) {
  let charCode = byte;
  if (specialCea608CharsCodes.hasOwnProperty(byte)) {
    charCode = specialCea608CharsCodes[byte];
  }
  return String.fromCharCode(charCode);
};
var NR_ROWS = 15;
var NR_COLS = 100;
var rowsLowCh1 = {
  17: 1,
  18: 3,
  21: 5,
  22: 7,
  23: 9,
  16: 11,
  19: 12,
  20: 14
};
var rowsHighCh1 = {
  17: 2,
  18: 4,
  21: 6,
  22: 8,
  23: 10,
  19: 13,
  20: 15
};
var rowsLowCh2 = {
  25: 1,
  26: 3,
  29: 5,
  30: 7,
  31: 9,
  24: 11,
  27: 12,
  28: 14
};
var rowsHighCh2 = {
  25: 2,
  26: 4,
  29: 6,
  30: 8,
  31: 10,
  27: 13,
  28: 15
};
var backgroundColors = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
var CaptionsLogger = class {
  constructor() {
    this.time = null;
    this.verboseLevel = 0;
  }
  log(severity, msg) {
    if (this.verboseLevel >= severity) {
      const m = typeof msg === "function" ? msg() : msg;
      logger.log(`${this.time} [${severity}] ${m}`);
    }
  }
};
var numArrayToHexArray = function numArrayToHexArray2(numArray) {
  const hexArray = [];
  for (let j = 0; j < numArray.length; j++) {
    hexArray.push(numArray[j].toString(16));
  }
  return hexArray;
};
var PenState = class {
  constructor(foreground, underline, italics, background, flash) {
    this.foreground = void 0;
    this.underline = void 0;
    this.italics = void 0;
    this.background = void 0;
    this.flash = void 0;
    this.foreground = foreground || "white";
    this.underline = underline || false;
    this.italics = italics || false;
    this.background = background || "black";
    this.flash = flash || false;
  }
  reset() {
    this.foreground = "white";
    this.underline = false;
    this.italics = false;
    this.background = "black";
    this.flash = false;
  }
  setStyles(styles) {
    const attribs = ["foreground", "underline", "italics", "background", "flash"];
    for (let i = 0; i < attribs.length; i++) {
      const style = attribs[i];
      if (styles.hasOwnProperty(style)) {
        this[style] = styles[style];
      }
    }
  }
  isDefault() {
    return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
  }
  equals(other) {
    return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
  }
  copy(newPenState) {
    this.foreground = newPenState.foreground;
    this.underline = newPenState.underline;
    this.italics = newPenState.italics;
    this.background = newPenState.background;
    this.flash = newPenState.flash;
  }
  toString() {
    return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
  }
};
var StyledUnicodeChar = class {
  constructor(uchar, foreground, underline, italics, background, flash) {
    this.uchar = void 0;
    this.penState = void 0;
    this.uchar = uchar || " ";
    this.penState = new PenState(foreground, underline, italics, background, flash);
  }
  reset() {
    this.uchar = " ";
    this.penState.reset();
  }
  setChar(uchar, newPenState) {
    this.uchar = uchar;
    this.penState.copy(newPenState);
  }
  setPenState(newPenState) {
    this.penState.copy(newPenState);
  }
  equals(other) {
    return this.uchar === other.uchar && this.penState.equals(other.penState);
  }
  copy(newChar) {
    this.uchar = newChar.uchar;
    this.penState.copy(newChar.penState);
  }
  isEmpty() {
    return this.uchar === " " && this.penState.isDefault();
  }
};
var Row = class {
  constructor(logger4) {
    this.chars = void 0;
    this.pos = void 0;
    this.currPenState = void 0;
    this.cueStartTime = void 0;
    this.logger = void 0;
    this.chars = [];
    for (let i = 0; i < NR_COLS; i++) {
      this.chars.push(new StyledUnicodeChar());
    }
    this.logger = logger4;
    this.pos = 0;
    this.currPenState = new PenState();
  }
  equals(other) {
    let equal = true;
    for (let i = 0; i < NR_COLS; i++) {
      if (!this.chars[i].equals(other.chars[i])) {
        equal = false;
        break;
      }
    }
    return equal;
  }
  copy(other) {
    for (let i = 0; i < NR_COLS; i++) {
      this.chars[i].copy(other.chars[i]);
    }
  }
  isEmpty() {
    let empty = true;
    for (let i = 0; i < NR_COLS; i++) {
      if (!this.chars[i].isEmpty()) {
        empty = false;
        break;
      }
    }
    return empty;
  }
  /**
   *  Set the cursor to a valid column.
   */
  setCursor(absPos) {
    if (this.pos !== absPos) {
      this.pos = absPos;
    }
    if (this.pos < 0) {
      this.logger.log(3, "Negative cursor position " + this.pos);
      this.pos = 0;
    } else if (this.pos > NR_COLS) {
      this.logger.log(3, "Too large cursor position " + this.pos);
      this.pos = NR_COLS;
    }
  }
  /**
   * Move the cursor relative to current position.
   */
  moveCursor(relPos) {
    const newPos = this.pos + relPos;
    if (relPos > 1) {
      for (let i = this.pos + 1; i < newPos + 1; i++) {
        this.chars[i].setPenState(this.currPenState);
      }
    }
    this.setCursor(newPos);
  }
  /**
   * Backspace, move one step back and clear character.
   */
  backSpace() {
    this.moveCursor(-1);
    this.chars[this.pos].setChar(" ", this.currPenState);
  }
  insertChar(byte) {
    if (byte >= 144) {
      this.backSpace();
    }
    const char = getCharForByte(byte);
    if (this.pos >= NR_COLS) {
      this.logger.log(0, () => "Cannot insert " + byte.toString(16) + " (" + char + ") at position " + this.pos + ". Skipping it!");
      return;
    }
    this.chars[this.pos].setChar(char, this.currPenState);
    this.moveCursor(1);
  }
  clearFromPos(startPos) {
    let i;
    for (i = startPos; i < NR_COLS; i++) {
      this.chars[i].reset();
    }
  }
  clear() {
    this.clearFromPos(0);
    this.pos = 0;
    this.currPenState.reset();
  }
  clearToEndOfRow() {
    this.clearFromPos(this.pos);
  }
  getTextString() {
    const chars = [];
    let empty = true;
    for (let i = 0; i < NR_COLS; i++) {
      const char = this.chars[i].uchar;
      if (char !== " ") {
        empty = false;
      }
      chars.push(char);
    }
    if (empty) {
      return "";
    } else {
      return chars.join("");
    }
  }
  setPenStyles(styles) {
    this.currPenState.setStyles(styles);
    const currChar = this.chars[this.pos];
    currChar.setPenState(this.currPenState);
  }
};
var CaptionScreen = class {
  constructor(logger4) {
    this.rows = void 0;
    this.currRow = void 0;
    this.nrRollUpRows = void 0;
    this.lastOutputScreen = void 0;
    this.logger = void 0;
    this.rows = [];
    for (let i = 0; i < NR_ROWS; i++) {
      this.rows.push(new Row(logger4));
    }
    this.logger = logger4;
    this.currRow = NR_ROWS - 1;
    this.nrRollUpRows = null;
    this.lastOutputScreen = null;
    this.reset();
  }
  reset() {
    for (let i = 0; i < NR_ROWS; i++) {
      this.rows[i].clear();
    }
    this.currRow = NR_ROWS - 1;
  }
  equals(other) {
    let equal = true;
    for (let i = 0; i < NR_ROWS; i++) {
      if (!this.rows[i].equals(other.rows[i])) {
        equal = false;
        break;
      }
    }
    return equal;
  }
  copy(other) {
    for (let i = 0; i < NR_ROWS; i++) {
      this.rows[i].copy(other.rows[i]);
    }
  }
  isEmpty() {
    let empty = true;
    for (let i = 0; i < NR_ROWS; i++) {
      if (!this.rows[i].isEmpty()) {
        empty = false;
        break;
      }
    }
    return empty;
  }
  backSpace() {
    const row = this.rows[this.currRow];
    row.backSpace();
  }
  clearToEndOfRow() {
    const row = this.rows[this.currRow];
    row.clearToEndOfRow();
  }
  /**
   * Insert a character (without styling) in the current row.
   */
  insertChar(char) {
    const row = this.rows[this.currRow];
    row.insertChar(char);
  }
  setPen(styles) {
    const row = this.rows[this.currRow];
    row.setPenStyles(styles);
  }
  moveCursor(relPos) {
    const row = this.rows[this.currRow];
    row.moveCursor(relPos);
  }
  setCursor(absPos) {
    this.logger.log(2, "setCursor: " + absPos);
    const row = this.rows[this.currRow];
    row.setCursor(absPos);
  }
  setPAC(pacData) {
    this.logger.log(2, () => "pacData = " + JSON.stringify(pacData));
    let newRow = pacData.row - 1;
    if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
      newRow = this.nrRollUpRows - 1;
    }
    if (this.nrRollUpRows && this.currRow !== newRow) {
      for (let i = 0; i < NR_ROWS; i++) {
        this.rows[i].clear();
      }
      const topRowIndex = this.currRow + 1 - this.nrRollUpRows;
      const lastOutputScreen = this.lastOutputScreen;
      if (lastOutputScreen) {
        const prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
        const time = this.logger.time;
        if (prevLineTime && time !== null && prevLineTime < time) {
          for (let i = 0; i < this.nrRollUpRows; i++) {
            this.rows[newRow - this.nrRollUpRows + i + 1].copy(lastOutputScreen.rows[topRowIndex + i]);
          }
        }
      }
    }
    this.currRow = newRow;
    const row = this.rows[this.currRow];
    if (pacData.indent !== null) {
      const indent = pacData.indent;
      const prevPos = Math.max(indent - 1, 0);
      row.setCursor(pacData.indent);
      pacData.color = row.chars[prevPos].penState.foreground;
    }
    const styles = {
      foreground: pacData.color,
      underline: pacData.underline,
      italics: pacData.italics,
      background: "black",
      flash: false
    };
    this.setPen(styles);
  }
  /**
   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
   */
  setBkgData(bkgData) {
    this.logger.log(2, () => "bkgData = " + JSON.stringify(bkgData));
    this.backSpace();
    this.setPen(bkgData);
    this.insertChar(32);
  }
  setRollUpRows(nrRows) {
    this.nrRollUpRows = nrRows;
  }
  rollUp() {
    if (this.nrRollUpRows === null) {
      this.logger.log(3, "roll_up but nrRollUpRows not set yet");
      return;
    }
    this.logger.log(1, () => this.getDisplayText());
    const topRowIndex = this.currRow + 1 - this.nrRollUpRows;
    const topRow = this.rows.splice(topRowIndex, 1)[0];
    topRow.clear();
    this.rows.splice(this.currRow, 0, topRow);
    this.logger.log(2, "Rolling up");
  }
  /**
   * Get all non-empty rows with as unicode text.
   */
  getDisplayText(asOneRow) {
    asOneRow = asOneRow || false;
    const displayText = [];
    let text = "";
    let rowNr = -1;
    for (let i = 0; i < NR_ROWS; i++) {
      const rowText = this.rows[i].getTextString();
      if (rowText) {
        rowNr = i + 1;
        if (asOneRow) {
          displayText.push("Row " + rowNr + ": '" + rowText + "'");
        } else {
          displayText.push(rowText.trim());
        }
      }
    }
    if (displayText.length > 0) {
      if (asOneRow) {
        text = "[" + displayText.join(" | ") + "]";
      } else {
        text = displayText.join("\n");
      }
    }
    return text;
  }
  getTextAndFormat() {
    return this.rows;
  }
};
var Cea608Channel = class {
  constructor(channelNumber, outputFilter, logger4) {
    this.chNr = void 0;
    this.outputFilter = void 0;
    this.mode = void 0;
    this.verbose = void 0;
    this.displayedMemory = void 0;
    this.nonDisplayedMemory = void 0;
    this.lastOutputScreen = void 0;
    this.currRollUpRow = void 0;
    this.writeScreen = void 0;
    this.cueStartTime = void 0;
    this.logger = void 0;
    this.chNr = channelNumber;
    this.outputFilter = outputFilter;
    this.mode = null;
    this.verbose = 0;
    this.displayedMemory = new CaptionScreen(logger4);
    this.nonDisplayedMemory = new CaptionScreen(logger4);
    this.lastOutputScreen = new CaptionScreen(logger4);
    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
    this.writeScreen = this.displayedMemory;
    this.mode = null;
    this.cueStartTime = null;
    this.logger = logger4;
  }
  reset() {
    this.mode = null;
    this.displayedMemory.reset();
    this.nonDisplayedMemory.reset();
    this.lastOutputScreen.reset();
    this.outputFilter.reset();
    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
    this.writeScreen = this.displayedMemory;
    this.mode = null;
    this.cueStartTime = null;
  }
  getHandler() {
    return this.outputFilter;
  }
  setHandler(newHandler) {
    this.outputFilter = newHandler;
  }
  setPAC(pacData) {
    this.writeScreen.setPAC(pacData);
  }
  setBkgData(bkgData) {
    this.writeScreen.setBkgData(bkgData);
  }
  setMode(newMode) {
    if (newMode === this.mode) {
      return;
    }
    this.mode = newMode;
    this.logger.log(2, () => "MODE=" + newMode);
    if (this.mode === "MODE_POP-ON") {
      this.writeScreen = this.nonDisplayedMemory;
    } else {
      this.writeScreen = this.displayedMemory;
      this.writeScreen.reset();
    }
    if (this.mode !== "MODE_ROLL-UP") {
      this.displayedMemory.nrRollUpRows = null;
      this.nonDisplayedMemory.nrRollUpRows = null;
    }
    this.mode = newMode;
  }
  insertChars(chars) {
    for (let i = 0; i < chars.length; i++) {
      this.writeScreen.insertChar(chars[i]);
    }
    const screen = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
    this.logger.log(2, () => screen + ": " + this.writeScreen.getDisplayText(true));
    if (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") {
      this.logger.log(1, () => "DISPLAYED: " + this.displayedMemory.getDisplayText(true));
      this.outputDataUpdate();
    }
  }
  ccRCL() {
    this.logger.log(2, "RCL - Resume Caption Loading");
    this.setMode("MODE_POP-ON");
  }
  ccBS() {
    this.logger.log(2, "BS - BackSpace");
    if (this.mode === "MODE_TEXT") {
      return;
    }
    this.writeScreen.backSpace();
    if (this.writeScreen === this.displayedMemory) {
      this.outputDataUpdate();
    }
  }
  ccAOF() {
  }
  ccAON() {
  }
  ccDER() {
    this.logger.log(2, "DER- Delete to End of Row");
    this.writeScreen.clearToEndOfRow();
    this.outputDataUpdate();
  }
  ccRU(nrRows) {
    this.logger.log(2, "RU(" + nrRows + ") - Roll Up");
    this.writeScreen = this.displayedMemory;
    this.setMode("MODE_ROLL-UP");
    this.writeScreen.setRollUpRows(nrRows);
  }
  ccFON() {
    this.logger.log(2, "FON - Flash On");
    this.writeScreen.setPen({
      flash: true
    });
  }
  ccRDC() {
    this.logger.log(2, "RDC - Resume Direct Captioning");
    this.setMode("MODE_PAINT-ON");
  }
  ccTR() {
    this.logger.log(2, "TR");
    this.setMode("MODE_TEXT");
  }
  ccRTD() {
    this.logger.log(2, "RTD");
    this.setMode("MODE_TEXT");
  }
  ccEDM() {
    this.logger.log(2, "EDM - Erase Displayed Memory");
    this.displayedMemory.reset();
    this.outputDataUpdate(true);
  }
  ccCR() {
    this.logger.log(2, "CR - Carriage Return");
    this.writeScreen.rollUp();
    this.outputDataUpdate(true);
  }
  ccENM() {
    this.logger.log(2, "ENM - Erase Non-displayed Memory");
    this.nonDisplayedMemory.reset();
  }
  ccEOC() {
    this.logger.log(2, "EOC - End Of Caption");
    if (this.mode === "MODE_POP-ON") {
      const tmp = this.displayedMemory;
      this.displayedMemory = this.nonDisplayedMemory;
      this.nonDisplayedMemory = tmp;
      this.writeScreen = this.nonDisplayedMemory;
      this.logger.log(1, () => "DISP: " + this.displayedMemory.getDisplayText());
    }
    this.outputDataUpdate(true);
  }
  ccTO(nrCols) {
    this.logger.log(2, "TO(" + nrCols + ") - Tab Offset");
    this.writeScreen.moveCursor(nrCols);
  }
  ccMIDROW(secondByte) {
    const styles = {
      flash: false
    };
    styles.underline = secondByte % 2 === 1;
    styles.italics = secondByte >= 46;
    if (!styles.italics) {
      const colorIndex = Math.floor(secondByte / 2) - 16;
      const colors = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
      styles.foreground = colors[colorIndex];
    } else {
      styles.foreground = "white";
    }
    this.logger.log(2, "MIDROW: " + JSON.stringify(styles));
    this.writeScreen.setPen(styles);
  }
  outputDataUpdate(dispatch = false) {
    const time = this.logger.time;
    if (time === null) {
      return;
    }
    if (this.outputFilter) {
      if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
        this.cueStartTime = time;
      } else {
        if (!this.displayedMemory.equals(this.lastOutputScreen)) {
          this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);
          if (dispatch && this.outputFilter.dispatchCue) {
            this.outputFilter.dispatchCue();
          }
          this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;
        }
      }
      this.lastOutputScreen.copy(this.displayedMemory);
    }
  }
  cueSplitAtTime(t2) {
    if (this.outputFilter) {
      if (!this.displayedMemory.isEmpty()) {
        if (this.outputFilter.newCue) {
          this.outputFilter.newCue(this.cueStartTime, t2, this.displayedMemory);
        }
        this.cueStartTime = t2;
      }
    }
  }
};
var Cea608Parser = class {
  constructor(field, out1, out2) {
    this.channels = void 0;
    this.currentChannel = 0;
    this.cmdHistory = void 0;
    this.logger = void 0;
    const logger4 = new CaptionsLogger();
    this.channels = [null, new Cea608Channel(field, out1, logger4), new Cea608Channel(field + 1, out2, logger4)];
    this.cmdHistory = createCmdHistory();
    this.logger = logger4;
  }
  getHandler(channel) {
    return this.channels[channel].getHandler();
  }
  setHandler(channel, newHandler) {
    this.channels[channel].setHandler(newHandler);
  }
  /**
   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
   */
  addData(time, byteList) {
    let cmdFound;
    let a;
    let b;
    let charsFound = false;
    this.logger.time = time;
    for (let i = 0; i < byteList.length; i += 2) {
      a = byteList[i] & 127;
      b = byteList[i + 1] & 127;
      if (a === 0 && b === 0) {
        continue;
      } else {
        this.logger.log(3, "[" + numArrayToHexArray([byteList[i], byteList[i + 1]]) + "] -> (" + numArrayToHexArray([a, b]) + ")");
      }
      cmdFound = this.parseCmd(a, b);
      if (!cmdFound) {
        cmdFound = this.parseMidrow(a, b);
      }
      if (!cmdFound) {
        cmdFound = this.parsePAC(a, b);
      }
      if (!cmdFound) {
        cmdFound = this.parseBackgroundAttributes(a, b);
      }
      if (!cmdFound) {
        charsFound = this.parseChars(a, b);
        if (charsFound) {
          const currChNr = this.currentChannel;
          if (currChNr && currChNr > 0) {
            const channel = this.channels[currChNr];
            channel.insertChars(charsFound);
          } else {
            this.logger.log(2, "No channel found yet. TEXT-MODE?");
          }
        }
      }
      if (!cmdFound && !charsFound) {
        this.logger.log(2, "Couldn't parse cleaned data " + numArrayToHexArray([a, b]) + " orig: " + numArrayToHexArray([byteList[i], byteList[i + 1]]));
      }
    }
  }
  /**
   * Parse Command.
   * @returns True if a command was found
   */
  parseCmd(a, b) {
    const {
      cmdHistory
    } = this;
    const cond1 = (a === 20 || a === 28 || a === 21 || a === 29) && b >= 32 && b <= 47;
    const cond2 = (a === 23 || a === 31) && b >= 33 && b <= 35;
    if (!(cond1 || cond2)) {
      return false;
    }
    if (hasCmdRepeated(a, b, cmdHistory)) {
      setLastCmd(null, null, cmdHistory);
      this.logger.log(3, "Repeated command (" + numArrayToHexArray([a, b]) + ") is dropped");
      return true;
    }
    const chNr = a === 20 || a === 21 || a === 23 ? 1 : 2;
    const channel = this.channels[chNr];
    if (a === 20 || a === 21 || a === 28 || a === 29) {
      if (b === 32) {
        channel.ccRCL();
      } else if (b === 33) {
        channel.ccBS();
      } else if (b === 34) {
        channel.ccAOF();
      } else if (b === 35) {
        channel.ccAON();
      } else if (b === 36) {
        channel.ccDER();
      } else if (b === 37) {
        channel.ccRU(2);
      } else if (b === 38) {
        channel.ccRU(3);
      } else if (b === 39) {
        channel.ccRU(4);
      } else if (b === 40) {
        channel.ccFON();
      } else if (b === 41) {
        channel.ccRDC();
      } else if (b === 42) {
        channel.ccTR();
      } else if (b === 43) {
        channel.ccRTD();
      } else if (b === 44) {
        channel.ccEDM();
      } else if (b === 45) {
        channel.ccCR();
      } else if (b === 46) {
        channel.ccENM();
      } else if (b === 47) {
        channel.ccEOC();
      }
    } else {
      channel.ccTO(b - 32);
    }
    setLastCmd(a, b, cmdHistory);
    this.currentChannel = chNr;
    return true;
  }
  /**
   * Parse midrow styling command
   */
  parseMidrow(a, b) {
    let chNr = 0;
    if ((a === 17 || a === 25) && b >= 32 && b <= 47) {
      if (a === 17) {
        chNr = 1;
      } else {
        chNr = 2;
      }
      if (chNr !== this.currentChannel) {
        this.logger.log(0, "Mismatch channel in midrow parsing");
        return false;
      }
      const channel = this.channels[chNr];
      if (!channel) {
        return false;
      }
      channel.ccMIDROW(b);
      this.logger.log(3, "MIDROW (" + numArrayToHexArray([a, b]) + ")");
      return true;
    }
    return false;
  }
  /**
   * Parse Preable Access Codes (Table 53).
   * @returns {Boolean} Tells if PAC found
   */
  parsePAC(a, b) {
    let row;
    const cmdHistory = this.cmdHistory;
    const case1 = (a >= 17 && a <= 23 || a >= 25 && a <= 31) && b >= 64 && b <= 127;
    const case2 = (a === 16 || a === 24) && b >= 64 && b <= 95;
    if (!(case1 || case2)) {
      return false;
    }
    if (hasCmdRepeated(a, b, cmdHistory)) {
      setLastCmd(null, null, cmdHistory);
      return true;
    }
    const chNr = a <= 23 ? 1 : 2;
    if (b >= 64 && b <= 95) {
      row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
    } else {
      row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
    }
    const channel = this.channels[chNr];
    if (!channel) {
      return false;
    }
    channel.setPAC(this.interpretPAC(row, b));
    setLastCmd(a, b, cmdHistory);
    this.currentChannel = chNr;
    return true;
  }
  /**
   * Interpret the second byte of the pac, and return the information.
   * @returns pacData with style parameters
   */
  interpretPAC(row, byte) {
    let pacIndex;
    const pacData = {
      color: null,
      italics: false,
      indent: null,
      underline: false,
      row
    };
    if (byte > 95) {
      pacIndex = byte - 96;
    } else {
      pacIndex = byte - 64;
    }
    pacData.underline = (pacIndex & 1) === 1;
    if (pacIndex <= 13) {
      pacData.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(pacIndex / 2)];
    } else if (pacIndex <= 15) {
      pacData.italics = true;
      pacData.color = "white";
    } else {
      pacData.indent = Math.floor((pacIndex - 16) / 2) * 4;
    }
    return pacData;
  }
  /**
   * Parse characters.
   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
   */
  parseChars(a, b) {
    let channelNr;
    let charCodes = null;
    let charCode1 = null;
    if (a >= 25) {
      channelNr = 2;
      charCode1 = a - 8;
    } else {
      channelNr = 1;
      charCode1 = a;
    }
    if (charCode1 >= 17 && charCode1 <= 19) {
      let oneCode;
      if (charCode1 === 17) {
        oneCode = b + 80;
      } else if (charCode1 === 18) {
        oneCode = b + 112;
      } else {
        oneCode = b + 144;
      }
      this.logger.log(2, "Special char '" + getCharForByte(oneCode) + "' in channel " + channelNr);
      charCodes = [oneCode];
    } else if (a >= 32 && a <= 127) {
      charCodes = b === 0 ? [a] : [a, b];
    }
    if (charCodes) {
      const hexCodes = numArrayToHexArray(charCodes);
      this.logger.log(3, "Char codes =  " + hexCodes.join(","));
      setLastCmd(a, b, this.cmdHistory);
    }
    return charCodes;
  }
  /**
   * Parse extended background attributes as well as new foreground color black.
   * @returns True if background attributes are found
   */
  parseBackgroundAttributes(a, b) {
    const case1 = (a === 16 || a === 24) && b >= 32 && b <= 47;
    const case2 = (a === 23 || a === 31) && b >= 45 && b <= 47;
    if (!(case1 || case2)) {
      return false;
    }
    let index;
    const bkgData = {};
    if (a === 16 || a === 24) {
      index = Math.floor((b - 32) / 2);
      bkgData.background = backgroundColors[index];
      if (b % 2 === 1) {
        bkgData.background = bkgData.background + "_semi";
      }
    } else if (b === 45) {
      bkgData.background = "transparent";
    } else {
      bkgData.foreground = "black";
      if (b === 47) {
        bkgData.underline = true;
      }
    }
    const chNr = a <= 23 ? 1 : 2;
    const channel = this.channels[chNr];
    channel.setBkgData(bkgData);
    setLastCmd(a, b, this.cmdHistory);
    return true;
  }
  /**
   * Reset state of parser and its channels.
   */
  reset() {
    for (let i = 0; i < Object.keys(this.channels).length; i++) {
      const channel = this.channels[i];
      if (channel) {
        channel.reset();
      }
    }
    this.cmdHistory = createCmdHistory();
  }
  /**
   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
   */
  cueSplitAtTime(t2) {
    for (let i = 0; i < this.channels.length; i++) {
      const channel = this.channels[i];
      if (channel) {
        channel.cueSplitAtTime(t2);
      }
    }
  }
};
function setLastCmd(a, b, cmdHistory) {
  cmdHistory.a = a;
  cmdHistory.b = b;
}
function hasCmdRepeated(a, b, cmdHistory) {
  return cmdHistory.a === a && cmdHistory.b === b;
}
function createCmdHistory() {
  return {
    a: null,
    b: null
  };
}
var OutputFilter = class {
  constructor(timelineController, trackName) {
    this.timelineController = void 0;
    this.cueRanges = [];
    this.trackName = void 0;
    this.startTime = null;
    this.endTime = null;
    this.screen = null;
    this.timelineController = timelineController;
    this.trackName = trackName;
  }
  dispatchCue() {
    if (this.startTime === null) {
      return;
    }
    this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);
    this.startTime = null;
  }
  newCue(startTime, endTime, screen) {
    if (this.startTime === null || this.startTime > startTime) {
      this.startTime = startTime;
    }
    this.endTime = endTime;
    this.screen = screen;
    this.timelineController.createCaptionsTrack(this.trackName);
  }
  reset() {
    this.cueRanges = [];
    this.startTime = null;
  }
};
var VTTCue = function() {
  if (typeof self !== "undefined" && self.VTTCue) {
    return self.VTTCue;
  }
  const AllowedDirections = ["", "lr", "rl"];
  const AllowedAlignments = ["start", "middle", "end", "left", "right"];
  function isAllowedValue(allowed, value) {
    if (typeof value !== "string") {
      return false;
    }
    if (!Array.isArray(allowed)) {
      return false;
    }
    const lcValue = value.toLowerCase();
    if (~allowed.indexOf(lcValue)) {
      return lcValue;
    }
    return false;
  }
  function findDirectionSetting(value) {
    return isAllowedValue(AllowedDirections, value);
  }
  function findAlignSetting(value) {
    return isAllowedValue(AllowedAlignments, value);
  }
  function extend3(obj, ...rest) {
    let i = 1;
    for (; i < arguments.length; i++) {
      const cobj = arguments[i];
      for (const p in cobj) {
        obj[p] = cobj[p];
      }
    }
    return obj;
  }
  function VTTCue2(startTime, endTime, text) {
    const cue = this;
    const baseObj = {
      enumerable: true
    };
    cue.hasBeenReset = false;
    let _id = "";
    let _pauseOnExit = false;
    let _startTime = startTime;
    let _endTime = endTime;
    let _text = text;
    let _region = null;
    let _vertical = "";
    let _snapToLines = true;
    let _line = "auto";
    let _lineAlign = "start";
    let _position = 50;
    let _positionAlign = "middle";
    let _size = 50;
    let _align = "middle";
    Object.defineProperty(cue, "id", extend3({}, baseObj, {
      get: function() {
        return _id;
      },
      set: function(value) {
        _id = "" + value;
      }
    }));
    Object.defineProperty(cue, "pauseOnExit", extend3({}, baseObj, {
      get: function() {
        return _pauseOnExit;
      },
      set: function(value) {
        _pauseOnExit = !!value;
      }
    }));
    Object.defineProperty(cue, "startTime", extend3({}, baseObj, {
      get: function() {
        return _startTime;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("Start time must be set to a number.");
        }
        _startTime = value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "endTime", extend3({}, baseObj, {
      get: function() {
        return _endTime;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("End time must be set to a number.");
        }
        _endTime = value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "text", extend3({}, baseObj, {
      get: function() {
        return _text;
      },
      set: function(value) {
        _text = "" + value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "region", extend3({}, baseObj, {
      get: function() {
        return _region;
      },
      set: function(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "vertical", extend3({}, baseObj, {
      get: function() {
        return _vertical;
      },
      set: function(value) {
        const setting = findDirectionSetting(value);
        if (setting === false) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _vertical = setting;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "snapToLines", extend3({}, baseObj, {
      get: function() {
        return _snapToLines;
      },
      set: function(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "line", extend3({}, baseObj, {
      get: function() {
        return _line;
      },
      set: function(value) {
        if (typeof value !== "number" && value !== "auto") {
          throw new SyntaxError("An invalid number or illegal string was specified.");
        }
        _line = value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "lineAlign", extend3({}, baseObj, {
      get: function() {
        return _lineAlign;
      },
      set: function(value) {
        const setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "position", extend3({}, baseObj, {
      get: function() {
        return _position;
      },
      set: function(value) {
        if (value < 0 || value > 100) {
          throw new Error("Position must be between 0 and 100.");
        }
        _position = value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "positionAlign", extend3({}, baseObj, {
      get: function() {
        return _positionAlign;
      },
      set: function(value) {
        const setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _positionAlign = setting;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "size", extend3({}, baseObj, {
      get: function() {
        return _size;
      },
      set: function(value) {
        if (value < 0 || value > 100) {
          throw new Error("Size must be between 0 and 100.");
        }
        _size = value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "align", extend3({}, baseObj, {
      get: function() {
        return _align;
      },
      set: function(value) {
        const setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _align = setting;
        this.hasBeenReset = true;
      }
    }));
    cue.displayState = void 0;
  }
  VTTCue2.prototype.getCueAsHTML = function() {
    const WebVTT2 = self.WebVTT;
    return WebVTT2.convertCueToDOMTree(self, this.text);
  };
  return VTTCue2;
}();
var StringDecoder = class {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  decode(data, options) {
    if (!data) {
      return "";
    }
    if (typeof data !== "string") {
      throw new Error("Error - expected string data.");
    }
    return decodeURIComponent(encodeURIComponent(data));
  }
};
function parseTimeStamp(input) {
  function computeSeconds(h, m2, s, f) {
    return (h | 0) * 3600 + (m2 | 0) * 60 + (s | 0) + parseFloat(f || 0);
  }
  const m = input.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
  if (!m) {
    return null;
  }
  if (parseFloat(m[2]) > 59) {
    return computeSeconds(m[2], m[3], 0, m[4]);
  }
  return computeSeconds(m[1], m[2], m[3], m[4]);
}
var Settings = class {
  constructor() {
    this.values = /* @__PURE__ */ Object.create(null);
  }
  // Only accept the first assignment to any key.
  set(k, v) {
    if (!this.get(k) && v !== "") {
      this.values[k] = v;
    }
  }
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get(k, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k) ? this.values[k] : dflt[defaultKey];
    }
    return this.has(k) ? this.values[k] : dflt;
  }
  // Check whether we have a value for a key.
  has(k) {
    return k in this.values;
  }
  // Accept a setting if its one of the given alternatives.
  alt(k, v, a) {
    for (let n = 0; n < a.length; ++n) {
      if (v === a[n]) {
        this.set(k, v);
        break;
      }
    }
  }
  // Accept a setting if its a valid (signed) integer.
  integer(k, v) {
    if (/^-?\d+$/.test(v)) {
      this.set(k, parseInt(v, 10));
    }
  }
  // Accept a setting if its a valid percentage.
  percent(k, v) {
    if (/^([\d]{1,3})(\.[\d]*)?%$/.test(v)) {
      const percent = parseFloat(v);
      if (percent >= 0 && percent <= 100) {
        this.set(k, percent);
        return true;
      }
    }
    return false;
  }
};
function parseOptions(input, callback2, keyValueDelim, groupDelim) {
  const groups = groupDelim ? input.split(groupDelim) : [input];
  for (const i in groups) {
    if (typeof groups[i] !== "string") {
      continue;
    }
    const kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) {
      continue;
    }
    const k = kv[0];
    const v = kv[1];
    callback2(k, v);
  }
}
var defaults = new VTTCue(0, 0, "");
var center = defaults.align === "middle" ? "middle" : "center";
function parseCue(input, cue, regionList) {
  const oInput = input;
  function consumeTimeStamp() {
    const ts2 = parseTimeStamp(input);
    if (ts2 === null) {
      throw new Error("Malformed timestamp: " + oInput);
    }
    input = input.replace(/^[^\sa-zA-Z-]+/, "");
    return ts2;
  }
  function consumeCueSettings(input2, cue2) {
    const settings = new Settings();
    parseOptions(input2, function(k, v) {
      let vals;
      switch (k) {
        case "region":
          for (let i = regionList.length - 1; i >= 0; i--) {
            if (regionList[i].id === v) {
              settings.set(k, regionList[i].region);
              break;
            }
          }
          break;
        case "vertical":
          settings.alt(k, v, ["rl", "lr"]);
          break;
        case "line":
          vals = v.split(",");
          settings.integer(k, vals[0]);
          if (settings.percent(k, vals[0])) {
            settings.set("snapToLines", false);
          }
          settings.alt(k, vals[0], ["auto"]);
          if (vals.length === 2) {
            settings.alt("lineAlign", vals[1], ["start", center, "end"]);
          }
          break;
        case "position":
          vals = v.split(",");
          settings.percent(k, vals[0]);
          if (vals.length === 2) {
            settings.alt("positionAlign", vals[1], ["start", center, "end", "line-left", "line-right", "auto"]);
          }
          break;
        case "size":
          settings.percent(k, v);
          break;
        case "align":
          settings.alt(k, v, ["start", center, "end", "left", "right"]);
          break;
      }
    }, /:/, /\s/);
    cue2.region = settings.get("region", null);
    cue2.vertical = settings.get("vertical", "");
    let line = settings.get("line", "auto");
    if (line === "auto" && defaults.line === -1) {
      line = -1;
    }
    cue2.line = line;
    cue2.lineAlign = settings.get("lineAlign", "start");
    cue2.snapToLines = settings.get("snapToLines", true);
    cue2.size = settings.get("size", 100);
    cue2.align = settings.get("align", center);
    let position = settings.get("position", "auto");
    if (position === "auto" && defaults.position === 50) {
      position = cue2.align === "start" || cue2.align === "left" ? 0 : cue2.align === "end" || cue2.align === "right" ? 100 : 50;
    }
    cue2.position = position;
  }
  function skipWhitespace() {
    input = input.replace(/^\s+/, "");
  }
  skipWhitespace();
  cue.startTime = consumeTimeStamp();
  skipWhitespace();
  if (input.slice(0, 3) !== "-->") {
    throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + oInput);
  }
  input = input.slice(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp();
  skipWhitespace();
  consumeCueSettings(input, cue);
}
function fixLineBreaks(input) {
  return input.replace(/<br(?: \/)?>/gi, "\n");
}
var VTTParser = class {
  constructor() {
    this.state = "INITIAL";
    this.buffer = "";
    this.decoder = new StringDecoder();
    this.regionList = [];
    this.cue = null;
    this.oncue = void 0;
    this.onparsingerror = void 0;
    this.onflush = void 0;
  }
  parse(data) {
    const _this = this;
    if (data) {
      _this.buffer += _this.decoder.decode(data, {
        stream: true
      });
    }
    function collectNextLine() {
      let buffer = _this.buffer;
      let pos = 0;
      buffer = fixLineBreaks(buffer);
      while (pos < buffer.length && buffer[pos] !== "\r" && buffer[pos] !== "\n") {
        ++pos;
      }
      const line = buffer.slice(0, pos);
      if (buffer[pos] === "\r") {
        ++pos;
      }
      if (buffer[pos] === "\n") {
        ++pos;
      }
      _this.buffer = buffer.slice(pos);
      return line;
    }
    function parseHeader2(input) {
      parseOptions(input, function(k, v) {
      }, /:/);
    }
    try {
      let line = "";
      if (_this.state === "INITIAL") {
        if (!/\r\n|\n/.test(_this.buffer)) {
          return this;
        }
        line = collectNextLine();
        const m = line.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
        if (!(m != null && m[0])) {
          throw new Error("Malformed WebVTT signature.");
        }
        _this.state = "HEADER";
      }
      let alreadyCollectedLine = false;
      while (_this.buffer) {
        if (!/\r\n|\n/.test(_this.buffer)) {
          return this;
        }
        if (!alreadyCollectedLine) {
          line = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }
        switch (_this.state) {
          case "HEADER":
            if (/:/.test(line)) {
              parseHeader2(line);
            } else if (!line) {
              _this.state = "ID";
            }
            continue;
          case "NOTE":
            if (!line) {
              _this.state = "ID";
            }
            continue;
          case "ID":
            if (/^NOTE($|[ \t])/.test(line)) {
              _this.state = "NOTE";
              break;
            }
            if (!line) {
              continue;
            }
            _this.cue = new VTTCue(0, 0, "");
            _this.state = "CUE";
            if (line.indexOf("-->") === -1) {
              _this.cue.id = line;
              continue;
            }
          case "CUE":
            if (!_this.cue) {
              _this.state = "BADCUE";
              continue;
            }
            try {
              parseCue(line, _this.cue, _this.regionList);
            } catch (e) {
              _this.cue = null;
              _this.state = "BADCUE";
              continue;
            }
            _this.state = "CUETEXT";
            continue;
          case "CUETEXT":
            {
              const hasSubstring = line.indexOf("-->") !== -1;
              if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                if (_this.oncue && _this.cue) {
                  _this.oncue(_this.cue);
                }
                _this.cue = null;
                _this.state = "ID";
                continue;
              }
              if (_this.cue === null) {
                continue;
              }
              if (_this.cue.text) {
                _this.cue.text += "\n";
              }
              _this.cue.text += line;
            }
            continue;
          case "BADCUE":
            if (!line) {
              _this.state = "ID";
            }
        }
      }
    } catch (e) {
      if (_this.state === "CUETEXT" && _this.cue && _this.oncue) {
        _this.oncue(_this.cue);
      }
      _this.cue = null;
      _this.state = _this.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
    }
    return this;
  }
  flush() {
    const _this = this;
    try {
      if (_this.cue || _this.state === "HEADER") {
        _this.buffer += "\n\n";
        _this.parse();
      }
      if (_this.state === "INITIAL" || _this.state === "BADWEBVTT") {
        throw new Error("Malformed WebVTT signature.");
      }
    } catch (e) {
      if (_this.onparsingerror) {
        _this.onparsingerror(e);
      }
    }
    if (_this.onflush) {
      _this.onflush();
    }
    return this;
  }
};
var LINEBREAKS = /\r\n|\n\r|\n|\r/g;
var startsWith = function startsWith2(inputString, searchString, position = 0) {
  return inputString.slice(position, position + searchString.length) === searchString;
};
var cueString2millis = function cueString2millis2(timeString) {
  let ts2 = parseInt(timeString.slice(-3));
  const secs = parseInt(timeString.slice(-6, -4));
  const mins = parseInt(timeString.slice(-9, -7));
  const hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(":"))) : 0;
  if (!isFiniteNumber(ts2) || !isFiniteNumber(secs) || !isFiniteNumber(mins) || !isFiniteNumber(hours)) {
    throw Error(`Malformed X-TIMESTAMP-MAP: Local:${timeString}`);
  }
  ts2 += 1e3 * secs;
  ts2 += 60 * 1e3 * mins;
  ts2 += 60 * 60 * 1e3 * hours;
  return ts2;
};
var hash = function hash2(text) {
  let _hash = 5381;
  let i = text.length;
  while (i) {
    _hash = _hash * 33 ^ text.charCodeAt(--i);
  }
  return (_hash >>> 0).toString();
};
function generateCueId(startTime, endTime, text) {
  return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);
}
var calculateOffset = function calculateOffset2(vttCCs, cc, presentationTime) {
  let currCC = vttCCs[cc];
  let prevCC = vttCCs[currCC.prevCC];
  if (!prevCC || !prevCC.new && currCC.new) {
    vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
    currCC.new = false;
    return;
  }
  while ((_prevCC = prevCC) != null && _prevCC.new) {
    var _prevCC;
    vttCCs.ccOffset += currCC.start - prevCC.start;
    currCC.new = false;
    currCC = prevCC;
    prevCC = vttCCs[currCC.prevCC];
  }
  vttCCs.presentationOffset = presentationTime;
};
function parseWebVTT(vttByteArray, initPTS, vttCCs, cc, timeOffset, callBack, errorCallBack) {
  const parser6 = new VTTParser();
  const vttLines = utf8ArrayToStr(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, "\n").split("\n");
  const cues = [];
  const init90kHz = initPTS ? toMpegTsClockFromTimescale(initPTS.baseTime, initPTS.timescale) : 0;
  let cueTime = "00:00.000";
  let timestampMapMPEGTS = 0;
  let timestampMapLOCAL = 0;
  let parsingError;
  let inHeader = true;
  parser6.oncue = function(cue) {
    const currCC = vttCCs[cc];
    let cueOffset = vttCCs.ccOffset;
    const webVttMpegTsMapOffset = (timestampMapMPEGTS - init90kHz) / 9e4;
    if (currCC != null && currCC.new) {
      if (timestampMapLOCAL !== void 0) {
        cueOffset = vttCCs.ccOffset = currCC.start;
      } else {
        calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);
      }
    }
    if (webVttMpegTsMapOffset) {
      if (!initPTS) {
        parsingError = new Error("Missing initPTS for VTT MPEGTS");
        return;
      }
      cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;
    }
    const duration5 = cue.endTime - cue.startTime;
    const startTime = normalizePts((cue.startTime + cueOffset - timestampMapLOCAL) * 9e4, timeOffset * 9e4) / 9e4;
    cue.startTime = Math.max(startTime, 0);
    cue.endTime = Math.max(startTime + duration5, 0);
    const text = cue.text.trim();
    cue.text = decodeURIComponent(encodeURIComponent(text));
    if (!cue.id) {
      cue.id = generateCueId(cue.startTime, cue.endTime, text);
    }
    if (cue.endTime > 0) {
      cues.push(cue);
    }
  };
  parser6.onparsingerror = function(error) {
    parsingError = error;
  };
  parser6.onflush = function() {
    if (parsingError) {
      errorCallBack(parsingError);
      return;
    }
    callBack(cues);
  };
  vttLines.forEach((line) => {
    if (inHeader) {
      if (startsWith(line, "X-TIMESTAMP-MAP=")) {
        inHeader = false;
        line.slice(16).split(",").forEach((timestamp) => {
          if (startsWith(timestamp, "LOCAL:")) {
            cueTime = timestamp.slice(6);
          } else if (startsWith(timestamp, "MPEGTS:")) {
            timestampMapMPEGTS = parseInt(timestamp.slice(7));
          }
        });
        try {
          timestampMapLOCAL = cueString2millis(cueTime) / 1e3;
        } catch (error) {
          parsingError = error;
        }
        return;
      } else if (line === "") {
        inHeader = false;
      }
    }
    parser6.parse(line + "\n");
  });
  parser6.flush();
}
var IMSC1_CODEC = "stpp.ttml.im1t";
var HMSF_REGEX = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/;
var TIME_UNIT_REGEX = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/;
var textAlignToLineAlign = {
  left: "start",
  center: "center",
  right: "end",
  start: "start",
  end: "end"
};
function parseIMSC1(payload, initPTS, callBack, errorCallBack) {
  const results = findBox(new Uint8Array(payload), ["mdat"]);
  if (results.length === 0) {
    errorCallBack(new Error("Could not parse IMSC1 mdat"));
    return;
  }
  const ttmlList = results.map((mdat) => utf8ArrayToStr(mdat));
  const syncTime = toTimescaleFromScale(initPTS.baseTime, 1, initPTS.timescale);
  try {
    ttmlList.forEach((ttml) => callBack(parseTTML(ttml, syncTime)));
  } catch (error) {
    errorCallBack(error);
  }
}
function parseTTML(ttml, syncTime) {
  const parser6 = new DOMParser();
  const xmlDoc = parser6.parseFromString(ttml, "text/xml");
  const tt = xmlDoc.getElementsByTagName("tt")[0];
  if (!tt) {
    throw new Error("Invalid ttml");
  }
  const defaultRateInfo = {
    frameRate: 30,
    subFrameRate: 1,
    frameRateMultiplier: 0,
    tickRate: 0
  };
  const rateInfo = Object.keys(defaultRateInfo).reduce((result, key) => {
    result[key] = tt.getAttribute(`ttp:${key}`) || defaultRateInfo[key];
    return result;
  }, {});
  const trim = tt.getAttribute("xml:space") !== "preserve";
  const styleElements = collectionToDictionary(getElementCollection(tt, "styling", "style"));
  const regionElements = collectionToDictionary(getElementCollection(tt, "layout", "region"));
  const cueElements = getElementCollection(tt, "body", "[begin]");
  return [].map.call(cueElements, (cueElement) => {
    const cueText = getTextContent(cueElement, trim);
    if (!cueText || !cueElement.hasAttribute("begin")) {
      return null;
    }
    const startTime = parseTtmlTime(cueElement.getAttribute("begin"), rateInfo);
    const duration5 = parseTtmlTime(cueElement.getAttribute("dur"), rateInfo);
    let endTime = parseTtmlTime(cueElement.getAttribute("end"), rateInfo);
    if (startTime === null) {
      throw timestampParsingError(cueElement);
    }
    if (endTime === null) {
      if (duration5 === null) {
        throw timestampParsingError(cueElement);
      }
      endTime = startTime + duration5;
    }
    const cue = new VTTCue(startTime - syncTime, endTime - syncTime, cueText);
    cue.id = generateCueId(cue.startTime, cue.endTime, cue.text);
    const region = regionElements[cueElement.getAttribute("region")];
    const style = styleElements[cueElement.getAttribute("style")];
    const styles = getTtmlStyles(region, style, styleElements);
    const {
      textAlign
    } = styles;
    if (textAlign) {
      const lineAlign = textAlignToLineAlign[textAlign];
      if (lineAlign) {
        cue.lineAlign = lineAlign;
      }
      cue.align = textAlign;
    }
    _extends(cue, styles);
    return cue;
  }).filter((cue) => cue !== null);
}
function getElementCollection(fromElement, parentName, childName) {
  const parent = fromElement.getElementsByTagName(parentName)[0];
  if (parent) {
    return [].slice.call(parent.querySelectorAll(childName));
  }
  return [];
}
function collectionToDictionary(elementsWithId) {
  return elementsWithId.reduce((dict, element) => {
    const id = element.getAttribute("xml:id");
    if (id) {
      dict[id] = element;
    }
    return dict;
  }, {});
}
function getTextContent(element, trim) {
  return [].slice.call(element.childNodes).reduce((str, node, i) => {
    var _node$childNodes;
    if (node.nodeName === "br" && i) {
      return str + "\n";
    }
    if ((_node$childNodes = node.childNodes) != null && _node$childNodes.length) {
      return getTextContent(node, trim);
    } else if (trim) {
      return str + node.textContent.trim().replace(/\s+/g, " ");
    }
    return str + node.textContent;
  }, "");
}
function getTtmlStyles(region, style, styleElements) {
  const ttsNs = "http://www.w3.org/ns/ttml#styling";
  let regionStyle = null;
  const styleAttributes = [
    "displayAlign",
    "textAlign",
    "color",
    "backgroundColor",
    "fontSize",
    "fontFamily"
    // 'fontWeight',
    // 'lineHeight',
    // 'wrapOption',
    // 'fontStyle',
    // 'direction',
    // 'writingMode'
  ];
  const regionStyleName = region != null && region.hasAttribute("style") ? region.getAttribute("style") : null;
  if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {
    regionStyle = styleElements[regionStyleName];
  }
  return styleAttributes.reduce((styles, name) => {
    const value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);
    if (value) {
      styles[name] = value;
    }
    return styles;
  }, {});
}
function getAttributeNS(element, ns, name) {
  if (!element) {
    return null;
  }
  return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;
}
function timestampParsingError(node) {
  return new Error(`Could not parse ttml timestamp ${node}`);
}
function parseTtmlTime(timeAttributeValue, rateInfo) {
  if (!timeAttributeValue) {
    return null;
  }
  let seconds = parseTimeStamp(timeAttributeValue);
  if (seconds === null) {
    if (HMSF_REGEX.test(timeAttributeValue)) {
      seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);
    } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {
      seconds = parseTimeUnits(timeAttributeValue, rateInfo);
    }
  }
  return seconds;
}
function parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {
  const m = HMSF_REGEX.exec(timeAttributeValue);
  const frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;
  return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;
}
function parseTimeUnits(timeAttributeValue, rateInfo) {
  const m = TIME_UNIT_REGEX.exec(timeAttributeValue);
  const value = Number(m[1]);
  const unit = m[2];
  switch (unit) {
    case "h":
      return value * 3600;
    case "m":
      return value * 60;
    case "ms":
      return value * 1e3;
    case "f":
      return value / rateInfo.frameRate;
    case "t":
      return value / rateInfo.tickRate;
  }
  return value;
}
var TimelineController = class {
  constructor(hls) {
    this.hls = void 0;
    this.media = null;
    this.config = void 0;
    this.enabled = true;
    this.Cues = void 0;
    this.textTracks = [];
    this.tracks = [];
    this.initPTS = [];
    this.unparsedVttFrags = [];
    this.captionsTracks = {};
    this.nonNativeCaptionsTracks = {};
    this.cea608Parser1 = void 0;
    this.cea608Parser2 = void 0;
    this.lastSn = -1;
    this.lastPartIndex = -1;
    this.prevCC = -1;
    this.vttCCs = newVTTCCs();
    this.captionsProperties = void 0;
    this.hls = hls;
    this.config = hls.config;
    this.Cues = hls.config.cueHandler;
    this.captionsProperties = {
      textTrack1: {
        label: this.config.captionsTextTrack1Label,
        languageCode: this.config.captionsTextTrack1LanguageCode
      },
      textTrack2: {
        label: this.config.captionsTextTrack2Label,
        languageCode: this.config.captionsTextTrack2LanguageCode
      },
      textTrack3: {
        label: this.config.captionsTextTrack3Label,
        languageCode: this.config.captionsTextTrack3LanguageCode
      },
      textTrack4: {
        label: this.config.captionsTextTrack4Label,
        languageCode: this.config.captionsTextTrack4LanguageCode
      }
    };
    if (this.config.enableCEA708Captions) {
      const channel1 = new OutputFilter(this, "textTrack1");
      const channel2 = new OutputFilter(this, "textTrack2");
      const channel3 = new OutputFilter(this, "textTrack3");
      const channel4 = new OutputFilter(this, "textTrack4");
      this.cea608Parser1 = new Cea608Parser(1, channel1, channel2);
      this.cea608Parser2 = new Cea608Parser(3, channel3, channel4);
    }
    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
    hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
    hls.on(Events.FRAG_LOADING, this.onFragLoading, this);
    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
    hls.on(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
    hls.on(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);
    hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
    hls.on(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
  }
  destroy() {
    const {
      hls
    } = this;
    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
    hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
    hls.off(Events.FRAG_LOADING, this.onFragLoading, this);
    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
    hls.off(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
    hls.off(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);
    hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
    hls.off(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null;
  }
  addCues(trackName, startTime, endTime, screen, cueRanges) {
    let merged = false;
    for (let i = cueRanges.length; i--; ) {
      const cueRange = cueRanges[i];
      const overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
      if (overlap >= 0) {
        cueRange[0] = Math.min(cueRange[0], startTime);
        cueRange[1] = Math.max(cueRange[1], endTime);
        merged = true;
        if (overlap / (endTime - startTime) > 0.5) {
          return;
        }
      }
    }
    if (!merged) {
      cueRanges.push([startTime, endTime]);
    }
    if (this.config.renderTextTracksNatively) {
      const track = this.captionsTracks[trackName];
      this.Cues.newCue(track, startTime, endTime, screen);
    } else {
      const cues = this.Cues.newCue(null, startTime, endTime, screen);
      this.hls.trigger(Events.CUES_PARSED, {
        type: "captions",
        cues,
        track: trackName
      });
    }
  }
  // Triggered when an initial PTS is found; used for synchronisation of WebVTT.
  onInitPtsFound(event, {
    frag,
    id,
    initPTS,
    timescale: timescale2
  }) {
    const {
      unparsedVttFrags
    } = this;
    if (id === "main") {
      this.initPTS[frag.cc] = {
        baseTime: initPTS,
        timescale: timescale2
      };
    }
    if (unparsedVttFrags.length) {
      this.unparsedVttFrags = [];
      unparsedVttFrags.forEach((frag2) => {
        this.onFragLoaded(Events.FRAG_LOADED, frag2);
      });
    }
  }
  getExistingTrack(trackName) {
    const {
      media
    } = this;
    if (media) {
      for (let i = 0; i < media.textTracks.length; i++) {
        const textTrack = media.textTracks[i];
        if (textTrack[trackName]) {
          return textTrack;
        }
      }
    }
    return null;
  }
  createCaptionsTrack(trackName) {
    if (this.config.renderTextTracksNatively) {
      this.createNativeTrack(trackName);
    } else {
      this.createNonNativeTrack(trackName);
    }
  }
  createNativeTrack(trackName) {
    if (this.captionsTracks[trackName]) {
      return;
    }
    const {
      captionsProperties,
      captionsTracks,
      media
    } = this;
    const {
      label,
      languageCode
    } = captionsProperties[trackName];
    const existingTrack = this.getExistingTrack(trackName);
    if (!existingTrack) {
      const textTrack = this.createTextTrack("captions", label, languageCode);
      if (textTrack) {
        textTrack[trackName] = true;
        captionsTracks[trackName] = textTrack;
      }
    } else {
      captionsTracks[trackName] = existingTrack;
      clearCurrentCues(captionsTracks[trackName]);
      sendAddTrackEvent(captionsTracks[trackName], media);
    }
  }
  createNonNativeTrack(trackName) {
    if (this.nonNativeCaptionsTracks[trackName]) {
      return;
    }
    const trackProperties = this.captionsProperties[trackName];
    if (!trackProperties) {
      return;
    }
    const label = trackProperties.label;
    const track = {
      _id: trackName,
      label,
      kind: "captions",
      default: trackProperties.media ? !!trackProperties.media.default : false,
      closedCaptions: trackProperties.media
    };
    this.nonNativeCaptionsTracks[trackName] = track;
    this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
      tracks: [track]
    });
  }
  createTextTrack(kind, label, lang) {
    const media = this.media;
    if (!media) {
      return;
    }
    return media.addTextTrack(kind, label, lang);
  }
  onMediaAttaching(event, data) {
    this.media = data.media;
    this._cleanTracks();
  }
  onMediaDetaching() {
    const {
      captionsTracks
    } = this;
    Object.keys(captionsTracks).forEach((trackName) => {
      clearCurrentCues(captionsTracks[trackName]);
      delete captionsTracks[trackName];
    });
    this.nonNativeCaptionsTracks = {};
  }
  onManifestLoading() {
    this.lastSn = -1;
    this.lastPartIndex = -1;
    this.prevCC = -1;
    this.vttCCs = newVTTCCs();
    this._cleanTracks();
    this.tracks = [];
    this.captionsTracks = {};
    this.nonNativeCaptionsTracks = {};
    this.textTracks = [];
    this.unparsedVttFrags = [];
    this.initPTS = [];
    if (this.cea608Parser1 && this.cea608Parser2) {
      this.cea608Parser1.reset();
      this.cea608Parser2.reset();
    }
  }
  _cleanTracks() {
    const {
      media
    } = this;
    if (!media) {
      return;
    }
    const textTracks = media.textTracks;
    if (textTracks) {
      for (let i = 0; i < textTracks.length; i++) {
        clearCurrentCues(textTracks[i]);
      }
    }
  }
  onSubtitleTracksUpdated(event, data) {
    const tracks = data.subtitleTracks || [];
    const hasIMSC1 = tracks.some((track) => track.textCodec === IMSC1_CODEC);
    if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {
      const listIsIdentical = subtitleOptionsIdentical(this.tracks, tracks);
      if (listIsIdentical) {
        this.tracks = tracks;
        return;
      }
      this.textTracks = [];
      this.tracks = tracks;
      if (this.config.renderTextTracksNatively) {
        const inUseTracks = this.media ? this.media.textTracks : null;
        this.tracks.forEach((track, index) => {
          let textTrack;
          if (inUseTracks && index < inUseTracks.length) {
            let inUseTrack = null;
            for (let i = 0; i < inUseTracks.length; i++) {
              if (canReuseVttTextTrack(inUseTracks[i], track)) {
                inUseTrack = inUseTracks[i];
                break;
              }
            }
            if (inUseTrack) {
              textTrack = inUseTrack;
            }
          }
          if (textTrack) {
            clearCurrentCues(textTrack);
          } else {
            const textTrackKind = this._captionsOrSubtitlesFromCharacteristics(track);
            textTrack = this.createTextTrack(textTrackKind, track.name, track.lang);
            if (textTrack) {
              textTrack.mode = "disabled";
            }
          }
          if (textTrack) {
            textTrack.groupId = track.groupId;
            this.textTracks.push(textTrack);
          }
        });
      } else if (this.tracks.length) {
        const tracksList = this.tracks.map((track) => {
          return {
            label: track.name,
            kind: track.type.toLowerCase(),
            default: track.default,
            subtitleTrack: track
          };
        });
        this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
          tracks: tracksList
        });
      }
    }
  }
  _captionsOrSubtitlesFromCharacteristics(track) {
    if (track.attrs.CHARACTERISTICS) {
      const transcribesSpokenDialog = /transcribes-spoken-dialog/gi.test(track.attrs.CHARACTERISTICS);
      const describesMusicAndSound = /describes-music-and-sound/gi.test(track.attrs.CHARACTERISTICS);
      if (transcribesSpokenDialog && describesMusicAndSound) {
        return "captions";
      }
    }
    return "subtitles";
  }
  onManifestLoaded(event, data) {
    if (this.config.enableCEA708Captions && data.captions) {
      data.captions.forEach((captionsTrack) => {
        const instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);
        if (!instreamIdMatch) {
          return;
        }
        const trackName = `textTrack${instreamIdMatch[1]}`;
        const trackProperties = this.captionsProperties[trackName];
        if (!trackProperties) {
          return;
        }
        trackProperties.label = captionsTrack.name;
        if (captionsTrack.lang) {
          trackProperties.languageCode = captionsTrack.lang;
        }
        trackProperties.media = captionsTrack;
      });
    }
  }
  closedCaptionsForLevel(frag) {
    const level = this.hls.levels[frag.level];
    return level == null ? void 0 : level.attrs["CLOSED-CAPTIONS"];
  }
  onFragLoading(event, data) {
    const {
      cea608Parser1,
      cea608Parser2,
      lastSn,
      lastPartIndex
    } = this;
    if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {
      return;
    }
    if (data.frag.type === PlaylistLevelType.MAIN) {
      var _data$part$index, _data$part;
      const sn = data.frag.sn;
      const partIndex = (_data$part$index = data == null ? void 0 : (_data$part = data.part) == null ? void 0 : _data$part.index) != null ? _data$part$index : -1;
      if (!(sn === lastSn + 1 || sn === lastSn && partIndex === lastPartIndex + 1)) {
        cea608Parser1.reset();
        cea608Parser2.reset();
      }
      this.lastSn = sn;
      this.lastPartIndex = partIndex;
    }
  }
  onFragLoaded(event, data) {
    const {
      frag,
      payload
    } = data;
    if (frag.type === PlaylistLevelType.SUBTITLE) {
      if (payload.byteLength) {
        const decryptData = frag.decryptdata;
        const decrypted = "stats" in data;
        if (decryptData == null || !decryptData.encrypted || decrypted) {
          const trackPlaylistMedia = this.tracks[frag.level];
          const vttCCs = this.vttCCs;
          if (!vttCCs[frag.cc]) {
            vttCCs[frag.cc] = {
              start: frag.start,
              prevCC: this.prevCC,
              new: true
            };
            this.prevCC = frag.cc;
          }
          if (trackPlaylistMedia && trackPlaylistMedia.textCodec === IMSC1_CODEC) {
            this._parseIMSC1(frag, payload);
          } else {
            this._parseVTTs(data);
          }
        }
      } else {
        this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
          success: false,
          frag,
          error: new Error("Empty subtitle payload")
        });
      }
    }
  }
  _parseIMSC1(frag, payload) {
    const hls = this.hls;
    parseIMSC1(payload, this.initPTS[frag.cc], (cues) => {
      this._appendCues(cues, frag.level);
      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
        success: true,
        frag
      });
    }, (error) => {
      logger.log(`Failed to parse IMSC1: ${error}`);
      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
        success: false,
        frag,
        error
      });
    });
  }
  _parseVTTs(data) {
    var _frag$initSegment;
    const {
      frag,
      payload
    } = data;
    const {
      initPTS,
      unparsedVttFrags
    } = this;
    const maxAvCC = initPTS.length - 1;
    if (!initPTS[frag.cc] && maxAvCC === -1) {
      unparsedVttFrags.push(data);
      return;
    }
    const hls = this.hls;
    const payloadWebVTT = (_frag$initSegment = frag.initSegment) != null && _frag$initSegment.data ? appendUint8Array(frag.initSegment.data, new Uint8Array(payload)) : payload;
    parseWebVTT(payloadWebVTT, this.initPTS[frag.cc], this.vttCCs, frag.cc, frag.start, (cues) => {
      this._appendCues(cues, frag.level);
      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
        success: true,
        frag
      });
    }, (error) => {
      const missingInitPTS = error.message === "Missing initPTS for VTT MPEGTS";
      if (missingInitPTS) {
        unparsedVttFrags.push(data);
      } else {
        this._fallbackToIMSC1(frag, payload);
      }
      logger.log(`Failed to parse VTT cue: ${error}`);
      if (missingInitPTS && maxAvCC > frag.cc) {
        return;
      }
      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
        success: false,
        frag,
        error
      });
    });
  }
  _fallbackToIMSC1(frag, payload) {
    const trackPlaylistMedia = this.tracks[frag.level];
    if (!trackPlaylistMedia.textCodec) {
      parseIMSC1(payload, this.initPTS[frag.cc], () => {
        trackPlaylistMedia.textCodec = IMSC1_CODEC;
        this._parseIMSC1(frag, payload);
      }, () => {
        trackPlaylistMedia.textCodec = "wvtt";
      });
    }
  }
  _appendCues(cues, fragLevel) {
    const hls = this.hls;
    if (this.config.renderTextTracksNatively) {
      const textTrack = this.textTracks[fragLevel];
      if (!textTrack || textTrack.mode === "disabled") {
        return;
      }
      cues.forEach((cue) => addCueToTrack(textTrack, cue));
    } else {
      const currentTrack = this.tracks[fragLevel];
      if (!currentTrack) {
        return;
      }
      const track = currentTrack.default ? "default" : "subtitles" + fragLevel;
      hls.trigger(Events.CUES_PARSED, {
        type: "subtitles",
        cues,
        track
      });
    }
  }
  onFragDecrypted(event, data) {
    const {
      frag
    } = data;
    if (frag.type === PlaylistLevelType.SUBTITLE) {
      this.onFragLoaded(Events.FRAG_LOADED, data);
    }
  }
  onSubtitleTracksCleared() {
    this.tracks = [];
    this.captionsTracks = {};
  }
  onFragParsingUserdata(event, data) {
    const {
      cea608Parser1,
      cea608Parser2
    } = this;
    if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {
      return;
    }
    const {
      frag,
      samples
    } = data;
    if (frag.type === PlaylistLevelType.MAIN && this.closedCaptionsForLevel(frag) === "NONE") {
      return;
    }
    for (let i = 0; i < samples.length; i++) {
      const ccBytes = samples[i].bytes;
      if (ccBytes) {
        const ccdatas = this.extractCea608Data(ccBytes);
        cea608Parser1.addData(samples[i].pts, ccdatas[0]);
        cea608Parser2.addData(samples[i].pts, ccdatas[1]);
      }
    }
  }
  onBufferFlushing(event, {
    startOffset,
    endOffset,
    endOffsetSubtitles,
    type: type2
  }) {
    const {
      media
    } = this;
    if (!media || media.currentTime < endOffset) {
      return;
    }
    if (!type2 || type2 === "video") {
      const {
        captionsTracks
      } = this;
      Object.keys(captionsTracks).forEach((trackName) => removeCuesInRange(captionsTracks[trackName], startOffset, endOffset));
    }
    if (this.config.renderTextTracksNatively) {
      if (startOffset === 0 && endOffsetSubtitles !== void 0) {
        const {
          textTracks
        } = this;
        Object.keys(textTracks).forEach((trackName) => removeCuesInRange(textTracks[trackName], startOffset, endOffsetSubtitles));
      }
    }
  }
  extractCea608Data(byteArray) {
    const actualCCBytes = [[], []];
    const count = byteArray[0] & 31;
    let position = 2;
    for (let j = 0; j < count; j++) {
      const tmpByte = byteArray[position++];
      const ccbyte1 = 127 & byteArray[position++];
      const ccbyte2 = 127 & byteArray[position++];
      if (ccbyte1 === 0 && ccbyte2 === 0) {
        continue;
      }
      const ccValid = (4 & tmpByte) !== 0;
      if (ccValid) {
        const ccType = 3 & tmpByte;
        if (0 === ccType || 1 === ccType) {
          actualCCBytes[ccType].push(ccbyte1);
          actualCCBytes[ccType].push(ccbyte2);
        }
      }
    }
    return actualCCBytes;
  }
};
function canReuseVttTextTrack(inUseTrack, manifestTrack) {
  return !!inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
}
function intersection(x1, x2, y1, y2) {
  return Math.min(x2, y2) - Math.max(x1, y1);
}
function newVTTCCs() {
  return {
    ccOffset: 0,
    presentationOffset: 0,
    0: {
      start: 0,
      prevCC: -1,
      new: true
    }
  };
}
var CapLevelController = class _CapLevelController {
  constructor(hls) {
    this.hls = void 0;
    this.autoLevelCapping = void 0;
    this.firstLevel = void 0;
    this.media = void 0;
    this.restrictedLevels = void 0;
    this.timer = void 0;
    this.clientRect = void 0;
    this.streamController = void 0;
    this.hls = hls;
    this.autoLevelCapping = Number.POSITIVE_INFINITY;
    this.firstLevel = -1;
    this.media = null;
    this.restrictedLevels = [];
    this.timer = void 0;
    this.clientRect = null;
    this.registerListeners();
  }
  setStreamController(streamController) {
    this.streamController = streamController;
  }
  destroy() {
    this.unregisterListener();
    if (this.hls.config.capLevelToPlayerSize) {
      this.stopCapping();
    }
    this.media = null;
    this.clientRect = null;
    this.hls = this.streamController = null;
  }
  registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);
    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  unregisterListener() {
    const {
      hls
    } = this;
    hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);
    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  onFpsDropLevelCapping(event, data) {
    const level = this.hls.levels[data.droppedLevel];
    if (this.isLevelAllowed(level)) {
      this.restrictedLevels.push({
        bitrate: level.bitrate,
        height: level.height,
        width: level.width
      });
    }
  }
  onMediaAttaching(event, data) {
    this.media = data.media instanceof HTMLVideoElement ? data.media : null;
    this.clientRect = null;
  }
  onManifestParsed(event, data) {
    const hls = this.hls;
    this.restrictedLevels = [];
    this.firstLevel = data.firstLevel;
    if (hls.config.capLevelToPlayerSize && data.video) {
      this.startCapping();
    }
  }
  // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted
  // to the first level
  onBufferCodecs(event, data) {
    const hls = this.hls;
    if (hls.config.capLevelToPlayerSize && data.video) {
      this.startCapping();
    }
  }
  onMediaDetaching() {
    this.stopCapping();
  }
  detectPlayerSize() {
    if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {
      const levels = this.hls.levels;
      if (levels.length) {
        const hls = this.hls;
        hls.autoLevelCapping = this.getMaxLevel(levels.length - 1);
        if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {
          this.streamController.nextLevelSwitch();
        }
        this.autoLevelCapping = hls.autoLevelCapping;
      }
    }
  }
  /*
   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
   */
  getMaxLevel(capLevelIndex) {
    const levels = this.hls.levels;
    if (!levels.length) {
      return -1;
    }
    const validLevels = levels.filter((level, index) => this.isLevelAllowed(level) && index <= capLevelIndex);
    this.clientRect = null;
    return _CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
  }
  startCapping() {
    if (this.timer) {
      return;
    }
    this.autoLevelCapping = Number.POSITIVE_INFINITY;
    this.hls.firstLevel = this.getMaxLevel(this.firstLevel);
    self.clearInterval(this.timer);
    this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3);
    this.detectPlayerSize();
  }
  stopCapping() {
    this.restrictedLevels = [];
    this.firstLevel = -1;
    this.autoLevelCapping = Number.POSITIVE_INFINITY;
    if (this.timer) {
      self.clearInterval(this.timer);
      this.timer = void 0;
    }
  }
  getDimensions() {
    if (this.clientRect) {
      return this.clientRect;
    }
    const media = this.media;
    const boundsRect = {
      width: 0,
      height: 0
    };
    if (media) {
      const clientRect = media.getBoundingClientRect();
      boundsRect.width = clientRect.width;
      boundsRect.height = clientRect.height;
      if (!boundsRect.width && !boundsRect.height) {
        boundsRect.width = clientRect.right - clientRect.left || media.width || 0;
        boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;
      }
    }
    this.clientRect = boundsRect;
    return boundsRect;
  }
  get mediaWidth() {
    return this.getDimensions().width * this.contentScaleFactor;
  }
  get mediaHeight() {
    return this.getDimensions().height * this.contentScaleFactor;
  }
  get contentScaleFactor() {
    let pixelRatio = 1;
    if (!this.hls.config.ignoreDevicePixelRatio) {
      try {
        pixelRatio = self.devicePixelRatio;
      } catch (e) {
      }
    }
    return pixelRatio;
  }
  isLevelAllowed(level) {
    const restrictedLevels = this.restrictedLevels;
    return !restrictedLevels.some((restrictedLevel) => {
      return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;
    });
  }
  static getMaxLevelByMediaSize(levels, width2, height2) {
    if (!(levels != null && levels.length)) {
      return -1;
    }
    const atGreatestBandwidth = (curLevel, nextLevel) => {
      if (!nextLevel) {
        return true;
      }
      return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
    };
    let maxLevelIndex = levels.length - 1;
    for (let i = 0; i < levels.length; i += 1) {
      const level = levels[i];
      if ((level.width >= width2 || level.height >= height2) && atGreatestBandwidth(level, levels[i + 1])) {
        maxLevelIndex = i;
        break;
      }
    }
    return maxLevelIndex;
  }
};
var FPSController = class {
  // stream controller must be provided as a dependency!
  constructor(hls) {
    this.hls = void 0;
    this.isVideoPlaybackQualityAvailable = false;
    this.timer = void 0;
    this.media = null;
    this.lastTime = void 0;
    this.lastDroppedFrames = 0;
    this.lastDecodedFrames = 0;
    this.streamController = void 0;
    this.hls = hls;
    this.registerListeners();
  }
  setStreamController(streamController) {
    this.streamController = streamController;
  }
  registerListeners() {
    this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
  }
  unregisterListeners() {
    this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
  }
  destroy() {
    if (this.timer) {
      clearInterval(this.timer);
    }
    this.unregisterListeners();
    this.isVideoPlaybackQualityAvailable = false;
    this.media = null;
  }
  onMediaAttaching(event, data) {
    const config = this.hls.config;
    if (config.capLevelOnFPSDrop) {
      const media = data.media instanceof self.HTMLVideoElement ? data.media : null;
      this.media = media;
      if (media && typeof media.getVideoPlaybackQuality === "function") {
        this.isVideoPlaybackQualityAvailable = true;
      }
      self.clearInterval(this.timer);
      this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
    }
  }
  checkFPS(video, decodedFrames, droppedFrames) {
    const currentTime = performance.now();
    if (decodedFrames) {
      if (this.lastTime) {
        const currentPeriod = currentTime - this.lastTime;
        const currentDropped = droppedFrames - this.lastDroppedFrames;
        const currentDecoded = decodedFrames - this.lastDecodedFrames;
        const droppedFPS = 1e3 * currentDropped / currentPeriod;
        const hls = this.hls;
        hls.trigger(Events.FPS_DROP, {
          currentDropped,
          currentDecoded,
          totalDroppedFrames: droppedFrames
        });
        if (droppedFPS > 0) {
          if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
            let currentLevel = hls.currentLevel;
            logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + currentLevel);
            if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
              currentLevel = currentLevel - 1;
              hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {
                level: currentLevel,
                droppedLevel: hls.currentLevel
              });
              hls.autoLevelCapping = currentLevel;
              this.streamController.nextLevelSwitch();
            }
          }
        }
      }
      this.lastTime = currentTime;
      this.lastDroppedFrames = droppedFrames;
      this.lastDecodedFrames = decodedFrames;
    }
  }
  checkFPSInterval() {
    const video = this.media;
    if (video) {
      if (this.isVideoPlaybackQualityAvailable) {
        const videoPlaybackQuality = video.getVideoPlaybackQuality();
        this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
      } else {
        this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
      }
    }
  }
};
var LOGGER_PREFIX = "[eme]";
var EMEController = class _EMEController {
  constructor(hls) {
    this.hls = void 0;
    this.config = void 0;
    this.media = null;
    this.keyFormatPromise = null;
    this.keySystemAccessPromises = {};
    this._requestLicenseFailureCount = 0;
    this.mediaKeySessions = [];
    this.keyIdToKeySessionPromise = {};
    this.setMediaKeysQueue = _EMEController.CDMCleanupPromise ? [_EMEController.CDMCleanupPromise] : [];
    this.onMediaEncrypted = this._onMediaEncrypted.bind(this);
    this.onWaitingForKey = this._onWaitingForKey.bind(this);
    this.debug = logger.debug.bind(logger, LOGGER_PREFIX);
    this.log = logger.log.bind(logger, LOGGER_PREFIX);
    this.warn = logger.warn.bind(logger, LOGGER_PREFIX);
    this.error = logger.error.bind(logger, LOGGER_PREFIX);
    this.hls = hls;
    this.config = hls.config;
    this.registerListeners();
  }
  destroy() {
    this.unregisterListeners();
    this.onMediaDetached();
    const config = this.config;
    config.requestMediaKeySystemAccessFunc = null;
    config.licenseXhrSetup = config.licenseResponseCallback = void 0;
    config.drmSystems = config.drmSystemOptions = {};
    this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null;
    this.config = null;
  }
  registerListeners() {
    this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    this.hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);
    this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    this.hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
  }
  unregisterListeners() {
    this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    this.hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);
    this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
  }
  getLicenseServerUrl(keySystem) {
    const {
      drmSystems,
      widevineLicenseUrl
    } = this.config;
    const keySystemConfiguration = drmSystems[keySystem];
    if (keySystemConfiguration) {
      return keySystemConfiguration.licenseUrl;
    }
    if (keySystem === KeySystems.WIDEVINE && widevineLicenseUrl) {
      return widevineLicenseUrl;
    }
    throw new Error(`no license server URL configured for key-system "${keySystem}"`);
  }
  getServerCertificateUrl(keySystem) {
    const {
      drmSystems
    } = this.config;
    const keySystemConfiguration = drmSystems[keySystem];
    if (keySystemConfiguration) {
      return keySystemConfiguration.serverCertificateUrl;
    } else {
      this.log(`No Server Certificate in config.drmSystems["${keySystem}"]`);
    }
  }
  attemptKeySystemAccess(keySystemsToAttempt) {
    const levels = this.hls.levels;
    const uniqueCodec = (value, i, a) => !!value && a.indexOf(value) === i;
    const audioCodecs = levels.map((level) => level.audioCodec).filter(uniqueCodec);
    const videoCodecs = levels.map((level) => level.videoCodec).filter(uniqueCodec);
    if (audioCodecs.length + videoCodecs.length === 0) {
      videoCodecs.push("avc1.42e01e");
    }
    return new Promise((resolve, reject) => {
      const attempt = (keySystems) => {
        const keySystem = keySystems.shift();
        this.getMediaKeysPromise(keySystem, audioCodecs, videoCodecs).then((mediaKeys) => resolve({
          keySystem,
          mediaKeys
        })).catch((error) => {
          if (keySystems.length) {
            attempt(keySystems);
          } else if (error instanceof EMEKeyError) {
            reject(error);
          } else {
            reject(new EMEKeyError({
              type: ErrorTypes.KEY_SYSTEM_ERROR,
              details: ErrorDetails.KEY_SYSTEM_NO_ACCESS,
              error,
              fatal: true
            }, error.message));
          }
        });
      };
      attempt(keySystemsToAttempt);
    });
  }
  requestMediaKeySystemAccess(keySystem, supportedConfigurations) {
    const {
      requestMediaKeySystemAccessFunc
    } = this.config;
    if (!(typeof requestMediaKeySystemAccessFunc === "function")) {
      let errMessage = `Configured requestMediaKeySystemAccess is not a function ${requestMediaKeySystemAccessFunc}`;
      if (requestMediaKeySystemAccess === null && self.location.protocol === "http:") {
        errMessage = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`;
      }
      return Promise.reject(new Error(errMessage));
    }
    return requestMediaKeySystemAccessFunc(keySystem, supportedConfigurations);
  }
  getMediaKeysPromise(keySystem, audioCodecs, videoCodecs) {
    const mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this.config.drmSystemOptions);
    const keySystemAccessPromises = this.keySystemAccessPromises[keySystem];
    let keySystemAccess = keySystemAccessPromises == null ? void 0 : keySystemAccessPromises.keySystemAccess;
    if (!keySystemAccess) {
      this.log(`Requesting encrypted media "${keySystem}" key-system access with config: ${JSON.stringify(mediaKeySystemConfigs)}`);
      keySystemAccess = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);
      const _keySystemAccessPromises = this.keySystemAccessPromises[keySystem] = {
        keySystemAccess
      };
      keySystemAccess.catch((error) => {
        this.log(`Failed to obtain access to key-system "${keySystem}": ${error}`);
      });
      return keySystemAccess.then((mediaKeySystemAccess) => {
        this.log(`Access for key-system "${mediaKeySystemAccess.keySystem}" obtained`);
        const certificateRequest = this.fetchServerCertificate(keySystem);
        this.log(`Create media-keys for "${keySystem}"`);
        _keySystemAccessPromises.mediaKeys = mediaKeySystemAccess.createMediaKeys().then((mediaKeys) => {
          this.log(`Media-keys created for "${keySystem}"`);
          return certificateRequest.then((certificate) => {
            if (certificate) {
              return this.setMediaKeysServerCertificate(mediaKeys, keySystem, certificate);
            }
            return mediaKeys;
          });
        });
        _keySystemAccessPromises.mediaKeys.catch((error) => {
          this.error(`Failed to create media-keys for "${keySystem}"}: ${error}`);
        });
        return _keySystemAccessPromises.mediaKeys;
      });
    }
    return keySystemAccess.then(() => keySystemAccessPromises.mediaKeys);
  }
  createMediaKeySessionContext({
    decryptdata,
    keySystem,
    mediaKeys
  }) {
    this.log(`Creating key-system session "${keySystem}" keyId: ${Hex.hexDump(decryptdata.keyId || [])}`);
    const mediaKeysSession = mediaKeys.createSession();
    const mediaKeySessionContext = {
      decryptdata,
      keySystem,
      mediaKeys,
      mediaKeysSession,
      keyStatus: "status-pending"
    };
    this.mediaKeySessions.push(mediaKeySessionContext);
    return mediaKeySessionContext;
  }
  renewKeySession(mediaKeySessionContext) {
    const decryptdata = mediaKeySessionContext.decryptdata;
    if (decryptdata.pssh) {
      const keySessionContext = this.createMediaKeySessionContext(mediaKeySessionContext);
      const keyId = this.getKeyIdString(decryptdata);
      const scheme = "cenc";
      this.keyIdToKeySessionPromise[keyId] = this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, "expired");
    } else {
      this.warn(`Could not renew expired session. Missing pssh initData.`);
    }
    this.removeSession(mediaKeySessionContext);
  }
  getKeyIdString(decryptdata) {
    if (!decryptdata) {
      throw new Error("Could not read keyId of undefined decryptdata");
    }
    if (decryptdata.keyId === null) {
      throw new Error("keyId is null");
    }
    return Hex.hexDump(decryptdata.keyId);
  }
  updateKeySession(mediaKeySessionContext, data) {
    var _mediaKeySessionConte;
    const keySession = mediaKeySessionContext.mediaKeysSession;
    this.log(`Updating key-session "${keySession.sessionId}" for keyID ${Hex.hexDump(((_mediaKeySessionConte = mediaKeySessionContext.decryptdata) == null ? void 0 : _mediaKeySessionConte.keyId) || [])}
      } (data length: ${data ? data.byteLength : data})`);
    return keySession.update(data);
  }
  selectKeySystemFormat(frag) {
    const keyFormats = Object.keys(frag.levelkeys || {});
    if (!this.keyFormatPromise) {
      this.log(`Selecting key-system from fragment (sn: ${frag.sn} ${frag.type}: ${frag.level}) key formats ${keyFormats.join(", ")}`);
      this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);
    }
    return this.keyFormatPromise;
  }
  getKeyFormatPromise(keyFormats) {
    return new Promise((resolve, reject) => {
      const keySystemsInConfig = getKeySystemsForConfig(this.config);
      const keySystemsToAttempt = keyFormats.map(keySystemFormatToKeySystemDomain).filter((value) => !!value && keySystemsInConfig.indexOf(value) !== -1);
      return this.getKeySystemSelectionPromise(keySystemsToAttempt).then(({
        keySystem
      }) => {
        const keySystemFormat = keySystemDomainToKeySystemFormat(keySystem);
        if (keySystemFormat) {
          resolve(keySystemFormat);
        } else {
          reject(new Error(`Unable to find format for key-system "${keySystem}"`));
        }
      }).catch(reject);
    });
  }
  loadKey(data) {
    const decryptdata = data.keyInfo.decryptdata;
    const keyId = this.getKeyIdString(decryptdata);
    const keyDetails = `(keyId: ${keyId} format: "${decryptdata.keyFormat}" method: ${decryptdata.method} uri: ${decryptdata.uri})`;
    this.log(`Starting session for key ${keyDetails}`);
    let keySessionContextPromise = this.keyIdToKeySessionPromise[keyId];
    if (!keySessionContextPromise) {
      keySessionContextPromise = this.keyIdToKeySessionPromise[keyId] = this.getKeySystemForKeyPromise(decryptdata).then(({
        keySystem,
        mediaKeys
      }) => {
        this.throwIfDestroyed();
        this.log(`Handle encrypted media sn: ${data.frag.sn} ${data.frag.type}: ${data.frag.level} using key ${keyDetails}`);
        return this.attemptSetMediaKeys(keySystem, mediaKeys).then(() => {
          this.throwIfDestroyed();
          const keySessionContext = this.createMediaKeySessionContext({
            keySystem,
            mediaKeys,
            decryptdata
          });
          const scheme = "cenc";
          return this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, "playlist-key");
        });
      });
      keySessionContextPromise.catch((error) => this.handleError(error));
    }
    return keySessionContextPromise;
  }
  throwIfDestroyed(message = "Invalid state") {
    if (!this.hls) {
      throw new Error("invalid state");
    }
  }
  handleError(error) {
    if (!this.hls) {
      return;
    }
    this.error(error.message);
    if (error instanceof EMEKeyError) {
      this.hls.trigger(Events.ERROR, error.data);
    } else {
      this.hls.trigger(Events.ERROR, {
        type: ErrorTypes.KEY_SYSTEM_ERROR,
        details: ErrorDetails.KEY_SYSTEM_NO_KEYS,
        error,
        fatal: true
      });
    }
  }
  getKeySystemForKeyPromise(decryptdata) {
    const keyId = this.getKeyIdString(decryptdata);
    const mediaKeySessionContext = this.keyIdToKeySessionPromise[keyId];
    if (!mediaKeySessionContext) {
      const keySystem = keySystemFormatToKeySystemDomain(decryptdata.keyFormat);
      const keySystemsToAttempt = keySystem ? [keySystem] : getKeySystemsForConfig(this.config);
      return this.attemptKeySystemAccess(keySystemsToAttempt);
    }
    return mediaKeySessionContext;
  }
  getKeySystemSelectionPromise(keySystemsToAttempt) {
    if (!keySystemsToAttempt.length) {
      keySystemsToAttempt = getKeySystemsForConfig(this.config);
    }
    if (keySystemsToAttempt.length === 0) {
      throw new EMEKeyError({
        type: ErrorTypes.KEY_SYSTEM_ERROR,
        details: ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
        fatal: true
      }, `Missing key-system license configuration options ${JSON.stringify({
        drmSystems: this.config.drmSystems
      })}`);
    }
    return this.attemptKeySystemAccess(keySystemsToAttempt);
  }
  _onMediaEncrypted(event) {
    const {
      initDataType,
      initData
    } = event;
    this.debug(`"${event.type}" event: init data type: "${initDataType}"`);
    if (initData === null) {
      return;
    }
    let keyId;
    let keySystemDomain;
    if (initDataType === "sinf" && this.config.drmSystems[KeySystems.FAIRPLAY]) {
      const json = bin2str(new Uint8Array(initData));
      try {
        const sinf = base64Decode(JSON.parse(json).sinf);
        const tenc = parseSinf(new Uint8Array(sinf));
        if (!tenc) {
          return;
        }
        keyId = tenc.subarray(8, 24);
        keySystemDomain = KeySystems.FAIRPLAY;
      } catch (error) {
        this.warn('Failed to parse sinf "encrypted" event message initData');
        return;
      }
    } else {
      const psshInfo = parsePssh(initData);
      if (psshInfo === null) {
        return;
      }
      if (psshInfo.version === 0 && psshInfo.systemId === KeySystemIds.WIDEVINE && psshInfo.data) {
        keyId = psshInfo.data.subarray(8, 24);
      }
      keySystemDomain = keySystemIdToKeySystemDomain(psshInfo.systemId);
    }
    if (!keySystemDomain || !keyId) {
      return;
    }
    const keyIdHex = Hex.hexDump(keyId);
    const {
      keyIdToKeySessionPromise,
      mediaKeySessions
    } = this;
    let keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex];
    for (let i = 0; i < mediaKeySessions.length; i++) {
      const keyContext = mediaKeySessions[i];
      const decryptdata = keyContext.decryptdata;
      if (decryptdata.pssh || !decryptdata.keyId) {
        continue;
      }
      const oldKeyIdHex = Hex.hexDump(decryptdata.keyId);
      if (keyIdHex === oldKeyIdHex || decryptdata.uri.replace(/-/g, "").indexOf(keyIdHex) !== -1) {
        keySessionContextPromise = keyIdToKeySessionPromise[oldKeyIdHex];
        delete keyIdToKeySessionPromise[oldKeyIdHex];
        decryptdata.pssh = new Uint8Array(initData);
        decryptdata.keyId = keyId;
        keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = keySessionContextPromise.then(() => {
          return this.generateRequestWithPreferredKeySession(keyContext, initDataType, initData, "encrypted-event-key-match");
        });
        break;
      }
    }
    if (!keySessionContextPromise) {
      keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = this.getKeySystemSelectionPromise([keySystemDomain]).then(({
        keySystem,
        mediaKeys
      }) => {
        var _keySystemToKeySystem;
        this.throwIfDestroyed();
        const decryptdata = new LevelKey("ISO-23001-7", keyIdHex, (_keySystemToKeySystem = keySystemDomainToKeySystemFormat(keySystem)) != null ? _keySystemToKeySystem : "");
        decryptdata.pssh = new Uint8Array(initData);
        decryptdata.keyId = keyId;
        return this.attemptSetMediaKeys(keySystem, mediaKeys).then(() => {
          this.throwIfDestroyed();
          const keySessionContext = this.createMediaKeySessionContext({
            decryptdata,
            keySystem,
            mediaKeys
          });
          return this.generateRequestWithPreferredKeySession(keySessionContext, initDataType, initData, "encrypted-event-no-match");
        });
      });
    }
    keySessionContextPromise.catch((error) => this.handleError(error));
  }
  _onWaitingForKey(event) {
    this.log(`"${event.type}" event`);
  }
  attemptSetMediaKeys(keySystem, mediaKeys) {
    const queue = this.setMediaKeysQueue.slice();
    this.log(`Setting media-keys for "${keySystem}"`);
    const setMediaKeysPromise = Promise.all(queue).then(() => {
      if (!this.media) {
        throw new Error("Attempted to set mediaKeys without media element attached");
      }
      return this.media.setMediaKeys(mediaKeys);
    });
    this.setMediaKeysQueue.push(setMediaKeysPromise);
    return setMediaKeysPromise.then(() => {
      this.log(`Media-keys set for "${keySystem}"`);
      queue.push(setMediaKeysPromise);
      this.setMediaKeysQueue = this.setMediaKeysQueue.filter((p) => queue.indexOf(p) === -1);
    });
  }
  generateRequestWithPreferredKeySession(context, initDataType, initData, reason) {
    var _this$config$drmSyste, _this$config$drmSyste2;
    const generateRequestFilter = (_this$config$drmSyste = this.config.drmSystems) == null ? void 0 : (_this$config$drmSyste2 = _this$config$drmSyste[context.keySystem]) == null ? void 0 : _this$config$drmSyste2.generateRequest;
    if (generateRequestFilter) {
      try {
        const mappedInitData = generateRequestFilter.call(this.hls, initDataType, initData, context);
        if (!mappedInitData) {
          throw new Error("Invalid response from configured generateRequest filter");
        }
        initDataType = mappedInitData.initDataType;
        initData = context.decryptdata.pssh = mappedInitData.initData ? new Uint8Array(mappedInitData.initData) : null;
      } catch (error) {
        var _this$hls;
        this.warn(error.message);
        if ((_this$hls = this.hls) != null && _this$hls.config.debug) {
          throw error;
        }
      }
    }
    if (initData === null) {
      this.log(`Skipping key-session request for "${reason}" (no initData)`);
      return Promise.resolve(context);
    }
    const keyId = this.getKeyIdString(context.decryptdata);
    this.log(`Generating key-session request for "${reason}": ${keyId} (init data type: ${initDataType} length: ${initData ? initData.byteLength : null})`);
    const licenseStatus = new EventEmitter();
    context.mediaKeysSession.onmessage = (event) => {
      const keySession = context.mediaKeysSession;
      if (!keySession) {
        licenseStatus.emit("error", new Error("invalid state"));
        return;
      }
      const {
        messageType,
        message
      } = event;
      this.log(`"${messageType}" message event for session "${keySession.sessionId}" message size: ${message.byteLength}`);
      if (messageType === "license-request" || messageType === "license-renewal") {
        this.renewLicense(context, message).catch((error) => {
          this.handleError(error);
          licenseStatus.emit("error", error);
        });
      } else if (messageType === "license-release") {
        if (context.keySystem === KeySystems.FAIRPLAY) {
          this.updateKeySession(context, strToUtf8array("acknowledged"));
          this.removeSession(context);
        }
      } else {
        this.warn(`unhandled media key message type "${messageType}"`);
      }
    };
    context.mediaKeysSession.onkeystatuseschange = (event) => {
      const keySession = context.mediaKeysSession;
      if (!keySession) {
        licenseStatus.emit("error", new Error("invalid state"));
        return;
      }
      this.onKeyStatusChange(context);
      const keyStatus = context.keyStatus;
      licenseStatus.emit("keyStatus", keyStatus);
      if (keyStatus === "expired") {
        this.warn(`${context.keySystem} expired for key ${keyId}`);
        this.renewKeySession(context);
      }
    };
    const keyUsablePromise = new Promise((resolve, reject) => {
      licenseStatus.on("error", reject);
      licenseStatus.on("keyStatus", (keyStatus) => {
        if (keyStatus.startsWith("usable")) {
          resolve();
        } else if (keyStatus === "output-restricted") {
          reject(new EMEKeyError({
            type: ErrorTypes.KEY_SYSTEM_ERROR,
            details: ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
            fatal: false
          }, "HDCP level output restricted"));
        } else if (keyStatus === "internal-error") {
          reject(new EMEKeyError({
            type: ErrorTypes.KEY_SYSTEM_ERROR,
            details: ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
            fatal: true
          }, `key status changed to "${keyStatus}"`));
        } else if (keyStatus === "expired") {
          reject(new Error("key expired while generating request"));
        } else {
          this.warn(`unhandled key status change "${keyStatus}"`);
        }
      });
    });
    return context.mediaKeysSession.generateRequest(initDataType, initData).then(() => {
      var _context$mediaKeysSes;
      this.log(`Request generated for key-session "${(_context$mediaKeysSes = context.mediaKeysSession) == null ? void 0 : _context$mediaKeysSes.sessionId}" keyId: ${keyId}`);
    }).catch((error) => {
      throw new EMEKeyError({
        type: ErrorTypes.KEY_SYSTEM_ERROR,
        details: ErrorDetails.KEY_SYSTEM_NO_SESSION,
        error,
        fatal: false
      }, `Error generating key-session request: ${error}`);
    }).then(() => keyUsablePromise).catch((error) => {
      licenseStatus.removeAllListeners();
      this.removeSession(context);
      throw error;
    }).then(() => {
      licenseStatus.removeAllListeners();
      return context;
    });
  }
  onKeyStatusChange(mediaKeySessionContext) {
    mediaKeySessionContext.mediaKeysSession.keyStatuses.forEach((status2, keyId) => {
      this.log(`key status change "${status2}" for keyStatuses keyId: ${Hex.hexDump("buffer" in keyId ? new Uint8Array(keyId.buffer, keyId.byteOffset, keyId.byteLength) : new Uint8Array(keyId))} session keyId: ${Hex.hexDump(new Uint8Array(mediaKeySessionContext.decryptdata.keyId || []))} uri: ${mediaKeySessionContext.decryptdata.uri}`);
      mediaKeySessionContext.keyStatus = status2;
    });
  }
  fetchServerCertificate(keySystem) {
    const config = this.config;
    const Loader = config.loader;
    const certLoader = new Loader(config);
    const url = this.getServerCertificateUrl(keySystem);
    if (!url) {
      return Promise.resolve();
    }
    this.log(`Fetching serverCertificate for "${keySystem}"`);
    return new Promise((resolve, reject) => {
      const loaderContext = {
        responseType: "arraybuffer",
        url
      };
      const loadPolicy = config.certLoadPolicy.default;
      const loaderConfig = {
        loadPolicy,
        timeout: loadPolicy.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0
      };
      const loaderCallbacks = {
        onSuccess: (response, stats, context, networkDetails) => {
          resolve(response.data);
        },
        onError: (response, contex, networkDetails, stats) => {
          reject(new EMEKeyError({
            type: ErrorTypes.KEY_SYSTEM_ERROR,
            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
            fatal: true,
            networkDetails,
            response: _objectSpread2({
              url: loaderContext.url,
              data: void 0
            }, response)
          }, `"${keySystem}" certificate request failed (${url}). Status: ${response.code} (${response.text})`));
        },
        onTimeout: (stats, context, networkDetails) => {
          reject(new EMEKeyError({
            type: ErrorTypes.KEY_SYSTEM_ERROR,
            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
            fatal: true,
            networkDetails,
            response: {
              url: loaderContext.url,
              data: void 0
            }
          }, `"${keySystem}" certificate request timed out (${url})`));
        },
        onAbort: (stats, context, networkDetails) => {
          reject(new Error("aborted"));
        }
      };
      certLoader.load(loaderContext, loaderConfig, loaderCallbacks);
    });
  }
  setMediaKeysServerCertificate(mediaKeys, keySystem, cert) {
    return new Promise((resolve, reject) => {
      mediaKeys.setServerCertificate(cert).then((success) => {
        this.log(`setServerCertificate ${success ? "success" : "not supported by CDM"} (${cert == null ? void 0 : cert.byteLength}) on "${keySystem}"`);
        resolve(mediaKeys);
      }).catch((error) => {
        reject(new EMEKeyError({
          type: ErrorTypes.KEY_SYSTEM_ERROR,
          details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
          error,
          fatal: true
        }, error.message));
      });
    });
  }
  renewLicense(context, keyMessage) {
    return this.requestLicense(context, new Uint8Array(keyMessage)).then((data) => {
      return this.updateKeySession(context, new Uint8Array(data)).catch((error) => {
        throw new EMEKeyError({
          type: ErrorTypes.KEY_SYSTEM_ERROR,
          details: ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,
          error,
          fatal: true
        }, error.message);
      });
    });
  }
  setupLicenseXHR(xhr, url, keysListItem, licenseChallenge) {
    const licenseXhrSetup = this.config.licenseXhrSetup;
    if (!licenseXhrSetup) {
      xhr.open("POST", url, true);
      return Promise.resolve({
        xhr,
        licenseChallenge
      });
    }
    return Promise.resolve().then(() => {
      if (!keysListItem.decryptdata) {
        throw new Error("Key removed");
      }
      return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);
    }).catch((error) => {
      if (!keysListItem.decryptdata) {
        throw error;
      }
      xhr.open("POST", url, true);
      return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);
    }).then((licenseXhrSetupResult) => {
      if (!xhr.readyState) {
        xhr.open("POST", url, true);
      }
      const finalLicenseChallenge = licenseXhrSetupResult ? licenseXhrSetupResult : licenseChallenge;
      return {
        xhr,
        licenseChallenge: finalLicenseChallenge
      };
    });
  }
  requestLicense(keySessionContext, licenseChallenge) {
    const keyLoadPolicy = this.config.keyLoadPolicy.default;
    return new Promise((resolve, reject) => {
      const url = this.getLicenseServerUrl(keySessionContext.keySystem);
      this.log(`Sending license request to URL: ${url}`);
      const xhr = new XMLHttpRequest();
      xhr.responseType = "arraybuffer";
      xhr.onreadystatechange = () => {
        if (!this.hls || !keySessionContext.mediaKeysSession) {
          return reject(new Error("invalid state"));
        }
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            this._requestLicenseFailureCount = 0;
            let data = xhr.response;
            this.log(`License received ${data instanceof ArrayBuffer ? data.byteLength : data}`);
            const licenseResponseCallback = this.config.licenseResponseCallback;
            if (licenseResponseCallback) {
              try {
                data = licenseResponseCallback.call(this.hls, xhr, url, keySessionContext);
              } catch (error) {
                this.error(error);
              }
            }
            resolve(data);
          } else {
            const retryConfig = keyLoadPolicy.errorRetry;
            const maxNumRetry = retryConfig ? retryConfig.maxNumRetry : 0;
            this._requestLicenseFailureCount++;
            if (this._requestLicenseFailureCount > maxNumRetry || xhr.status >= 400 && xhr.status < 500) {
              reject(new EMEKeyError({
                type: ErrorTypes.KEY_SYSTEM_ERROR,
                details: ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                fatal: true,
                networkDetails: xhr,
                response: {
                  url,
                  data: void 0,
                  code: xhr.status,
                  text: xhr.statusText
                }
              }, `License Request XHR failed (${url}). Status: ${xhr.status} (${xhr.statusText})`));
            } else {
              const attemptsLeft = maxNumRetry - this._requestLicenseFailureCount + 1;
              this.warn(`Retrying license request, ${attemptsLeft} attempts left`);
              this.requestLicense(keySessionContext, licenseChallenge).then(resolve, reject);
            }
          }
        }
      };
      if (keySessionContext.licenseXhr && keySessionContext.licenseXhr.readyState !== XMLHttpRequest.DONE) {
        keySessionContext.licenseXhr.abort();
      }
      keySessionContext.licenseXhr = xhr;
      this.setupLicenseXHR(xhr, url, keySessionContext, licenseChallenge).then(({
        xhr: xhr2,
        licenseChallenge: licenseChallenge2
      }) => {
        xhr2.send(licenseChallenge2);
      });
    });
  }
  onMediaAttached(event, data) {
    if (!this.config.emeEnabled) {
      return;
    }
    const media = data.media;
    this.media = media;
    media.addEventListener("encrypted", this.onMediaEncrypted);
    media.addEventListener("waitingforkey", this.onWaitingForKey);
  }
  onMediaDetached() {
    const media = this.media;
    const mediaKeysList = this.mediaKeySessions;
    if (media) {
      media.removeEventListener("encrypted", this.onMediaEncrypted);
      media.removeEventListener("waitingforkey", this.onWaitingForKey);
      this.media = null;
    }
    this._requestLicenseFailureCount = 0;
    this.setMediaKeysQueue = [];
    this.mediaKeySessions = [];
    this.keyIdToKeySessionPromise = {};
    LevelKey.clearKeyUriToKeyIdMap();
    const keySessionCount = mediaKeysList.length;
    _EMEController.CDMCleanupPromise = Promise.all(mediaKeysList.map((mediaKeySessionContext) => this.removeSession(mediaKeySessionContext)).concat(media == null ? void 0 : media.setMediaKeys(null).catch((error) => {
      this.log(`Could not clear media keys: ${error}. media.src: ${media == null ? void 0 : media.src}`);
    }))).then(() => {
      if (keySessionCount) {
        this.log("finished closing key sessions and clearing media keys");
        mediaKeysList.length = 0;
      }
    }).catch((error) => {
      this.log(`Could not close sessions and clear media keys: ${error}. media.src: ${media == null ? void 0 : media.src}`);
    });
  }
  onManifestLoading() {
    this.keyFormatPromise = null;
  }
  onManifestLoaded(event, {
    sessionKeys
  }) {
    if (!sessionKeys || !this.config.emeEnabled) {
      return;
    }
    if (!this.keyFormatPromise) {
      const keyFormats = sessionKeys.reduce((formats, sessionKey) => {
        if (formats.indexOf(sessionKey.keyFormat) === -1) {
          formats.push(sessionKey.keyFormat);
        }
        return formats;
      }, []);
      this.log(`Selecting key-system from session-keys ${keyFormats.join(", ")}`);
      this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);
    }
  }
  removeSession(mediaKeySessionContext) {
    const {
      mediaKeysSession,
      licenseXhr
    } = mediaKeySessionContext;
    if (mediaKeysSession) {
      this.log(`Remove licenses and keys and close session ${mediaKeysSession.sessionId}`);
      mediaKeysSession.onmessage = null;
      mediaKeysSession.onkeystatuseschange = null;
      if (licenseXhr && licenseXhr.readyState !== XMLHttpRequest.DONE) {
        licenseXhr.abort();
      }
      mediaKeySessionContext.mediaKeysSession = mediaKeySessionContext.decryptdata = mediaKeySessionContext.licenseXhr = void 0;
      const index = this.mediaKeySessions.indexOf(mediaKeySessionContext);
      if (index > -1) {
        this.mediaKeySessions.splice(index, 1);
      }
      return mediaKeysSession.remove().catch((error) => {
        this.log(`Could not remove session: ${error}`);
      }).then(() => {
        return mediaKeysSession.close();
      }).catch((error) => {
        this.log(`Could not close session: ${error}`);
      });
    }
  }
};
EMEController.CDMCleanupPromise = void 0;
var EMEKeyError = class extends Error {
  constructor(data, message) {
    super(message);
    this.data = void 0;
    data.error || (data.error = new Error(message));
    this.data = data;
    data.err = data.error;
  }
};
var CMCDVersion = 1;
var CMCDObjectType = {
  MANIFEST: "m",
  AUDIO: "a",
  VIDEO: "v",
  MUXED: "av",
  INIT: "i",
  CAPTION: "c",
  TIMED_TEXT: "tt",
  KEY: "k",
  OTHER: "o"
};
var CMCDStreamingFormatHLS = "h";
var CMCDController = class _CMCDController {
  // eslint-disable-line no-restricted-globals
  // eslint-disable-line no-restricted-globals
  constructor(hls) {
    this.hls = void 0;
    this.config = void 0;
    this.media = void 0;
    this.sid = void 0;
    this.cid = void 0;
    this.useHeaders = false;
    this.initialized = false;
    this.starved = false;
    this.buffering = true;
    this.audioBuffer = void 0;
    this.videoBuffer = void 0;
    this.onWaiting = () => {
      if (this.initialized) {
        this.starved = true;
      }
      this.buffering = true;
    };
    this.onPlaying = () => {
      if (!this.initialized) {
        this.initialized = true;
      }
      this.buffering = false;
    };
    this.applyPlaylistData = (context) => {
      try {
        this.apply(context, {
          ot: CMCDObjectType.MANIFEST,
          su: !this.initialized
        });
      } catch (error) {
        logger.warn("Could not generate manifest CMCD data.", error);
      }
    };
    this.applyFragmentData = (context) => {
      try {
        const fragment = context.frag;
        const level = this.hls.levels[fragment.level];
        const ot = this.getObjectType(fragment);
        const data = {
          d: fragment.duration * 1e3,
          ot
        };
        if (ot === CMCDObjectType.VIDEO || ot === CMCDObjectType.AUDIO || ot == CMCDObjectType.MUXED) {
          data.br = level.bitrate / 1e3;
          data.tb = this.getTopBandwidth(ot) / 1e3;
          data.bl = this.getBufferLength(ot);
        }
        this.apply(context, data);
      } catch (error) {
        logger.warn("Could not generate segment CMCD data.", error);
      }
    };
    this.hls = hls;
    const config = this.config = hls.config;
    const {
      cmcd
    } = config;
    if (cmcd != null) {
      config.pLoader = this.createPlaylistLoader();
      config.fLoader = this.createFragmentLoader();
      this.sid = cmcd.sessionId || _CMCDController.uuid();
      this.cid = cmcd.contentId;
      this.useHeaders = cmcd.useHeaders === true;
      this.registerListeners();
    }
  }
  registerListeners() {
    const hls = this.hls;
    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);
    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
  }
  unregisterListeners() {
    const hls = this.hls;
    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);
    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
  }
  destroy() {
    this.unregisterListeners();
    this.onMediaDetached();
    this.hls = this.config = this.audioBuffer = this.videoBuffer = null;
  }
  onMediaAttached(event, data) {
    this.media = data.media;
    this.media.addEventListener("waiting", this.onWaiting);
    this.media.addEventListener("playing", this.onPlaying);
  }
  onMediaDetached() {
    if (!this.media) {
      return;
    }
    this.media.removeEventListener("waiting", this.onWaiting);
    this.media.removeEventListener("playing", this.onPlaying);
    this.media = null;
  }
  onBufferCreated(event, data) {
    var _data$tracks$audio, _data$tracks$video;
    this.audioBuffer = (_data$tracks$audio = data.tracks.audio) == null ? void 0 : _data$tracks$audio.buffer;
    this.videoBuffer = (_data$tracks$video = data.tracks.video) == null ? void 0 : _data$tracks$video.buffer;
  }
  /**
   * Create baseline CMCD data
   */
  createData() {
    var _this$media;
    return {
      v: CMCDVersion,
      sf: CMCDStreamingFormatHLS,
      sid: this.sid,
      cid: this.cid,
      pr: (_this$media = this.media) == null ? void 0 : _this$media.playbackRate,
      mtp: this.hls.bandwidthEstimate / 1e3
    };
  }
  /**
   * Apply CMCD data to a request.
   */
  apply(context, data = {}) {
    _extends(data, this.createData());
    const isVideo = data.ot === CMCDObjectType.INIT || data.ot === CMCDObjectType.VIDEO || data.ot === CMCDObjectType.MUXED;
    if (this.starved && isVideo) {
      data.bs = true;
      data.su = true;
      this.starved = false;
    }
    if (data.su == null) {
      data.su = this.buffering;
    }
    if (this.useHeaders) {
      const headers = _CMCDController.toHeaders(data);
      if (!Object.keys(headers).length) {
        return;
      }
      if (!context.headers) {
        context.headers = {};
      }
      _extends(context.headers, headers);
    } else {
      const query = _CMCDController.toQuery(data);
      if (!query) {
        return;
      }
      context.url = _CMCDController.appendQueryToUri(context.url, query);
    }
  }
  /**
   * The CMCD object type.
   */
  getObjectType(fragment) {
    const {
      type: type2
    } = fragment;
    if (type2 === "subtitle") {
      return CMCDObjectType.TIMED_TEXT;
    }
    if (fragment.sn === "initSegment") {
      return CMCDObjectType.INIT;
    }
    if (type2 === "audio") {
      return CMCDObjectType.AUDIO;
    }
    if (type2 === "main") {
      if (!this.hls.audioTracks.length) {
        return CMCDObjectType.MUXED;
      }
      return CMCDObjectType.VIDEO;
    }
    return void 0;
  }
  /**
   * Get the highest bitrate.
   */
  getTopBandwidth(type2) {
    let bitrate = 0;
    let levels;
    const hls = this.hls;
    if (type2 === CMCDObjectType.AUDIO) {
      levels = hls.audioTracks;
    } else {
      const max = hls.maxAutoLevel;
      const len = max > -1 ? max + 1 : hls.levels.length;
      levels = hls.levels.slice(0, len);
    }
    for (const level of levels) {
      if (level.bitrate > bitrate) {
        bitrate = level.bitrate;
      }
    }
    return bitrate > 0 ? bitrate : NaN;
  }
  /**
   * Get the buffer length for a media type in milliseconds
   */
  getBufferLength(type2) {
    const media = this.hls.media;
    const buffer = type2 === CMCDObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;
    if (!buffer || !media) {
      return NaN;
    }
    const info = BufferHelper.bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);
    return info.len * 1e3;
  }
  /**
   * Create a playlist loader
   */
  createPlaylistLoader() {
    const {
      pLoader
    } = this.config;
    const apply = this.applyPlaylistData;
    const Ctor = pLoader || this.config.loader;
    return class CmcdPlaylistLoader {
      constructor(config) {
        this.loader = void 0;
        this.loader = new Ctor(config);
      }
      get stats() {
        return this.loader.stats;
      }
      get context() {
        return this.loader.context;
      }
      destroy() {
        this.loader.destroy();
      }
      abort() {
        this.loader.abort();
      }
      load(context, config, callbacks) {
        apply(context);
        this.loader.load(context, config, callbacks);
      }
    };
  }
  /**
   * Create a playlist loader
   */
  createFragmentLoader() {
    const {
      fLoader
    } = this.config;
    const apply = this.applyFragmentData;
    const Ctor = fLoader || this.config.loader;
    return class CmcdFragmentLoader {
      constructor(config) {
        this.loader = void 0;
        this.loader = new Ctor(config);
      }
      get stats() {
        return this.loader.stats;
      }
      get context() {
        return this.loader.context;
      }
      destroy() {
        this.loader.destroy();
      }
      abort() {
        this.loader.abort();
      }
      load(context, config, callbacks) {
        apply(context);
        this.loader.load(context, config, callbacks);
      }
    };
  }
  /**
   * Generate a random v4 UUI
   *
   * @returns {string}
   */
  static uuid() {
    const url = URL.createObjectURL(new Blob());
    const uuid = url.toString();
    URL.revokeObjectURL(url);
    return uuid.slice(uuid.lastIndexOf("/") + 1);
  }
  /**
   * Serialize a CMCD data object according to the rules defined in the
   * section 3.2 of
   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).
   */
  static serialize(data) {
    const results = [];
    const isValid = (value) => !Number.isNaN(value) && value != null && value !== "" && value !== false;
    const toRounded = (value) => Math.round(value);
    const toHundred = (value) => toRounded(value / 100) * 100;
    const toUrlSafe = (value) => encodeURIComponent(value);
    const formatters = {
      br: toRounded,
      d: toRounded,
      bl: toHundred,
      dl: toHundred,
      mtp: toHundred,
      nor: toUrlSafe,
      rtp: toHundred,
      tb: toRounded
    };
    const keys3 = Object.keys(data || {}).sort();
    for (const key of keys3) {
      let value = data[key];
      if (!isValid(value)) {
        continue;
      }
      if (key === "v" && value === 1) {
        continue;
      }
      if (key == "pr" && value === 1) {
        continue;
      }
      const formatter = formatters[key];
      if (formatter) {
        value = formatter(value);
      }
      const type2 = typeof value;
      let result;
      if (key === "ot" || key === "sf" || key === "st") {
        result = `${key}=${value}`;
      } else if (type2 === "boolean") {
        result = key;
      } else if (type2 === "number") {
        result = `${key}=${value}`;
      } else {
        result = `${key}=${JSON.stringify(value)}`;
      }
      results.push(result);
    }
    return results.join(",");
  }
  /**
   * Convert a CMCD data object to request headers according to the rules
   * defined in the section 2.1 and 3.2 of
   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).
   */
  static toHeaders(data) {
    const keys3 = Object.keys(data);
    const headers = {};
    const headerNames = ["Object", "Request", "Session", "Status"];
    const headerGroups = [{}, {}, {}, {}];
    const headerMap = {
      br: 0,
      d: 0,
      ot: 0,
      tb: 0,
      bl: 1,
      dl: 1,
      mtp: 1,
      nor: 1,
      nrr: 1,
      su: 1,
      cid: 2,
      pr: 2,
      sf: 2,
      sid: 2,
      st: 2,
      v: 2,
      bs: 3,
      rtp: 3
    };
    for (const key of keys3) {
      const index = headerMap[key] != null ? headerMap[key] : 1;
      headerGroups[index][key] = data[key];
    }
    for (let i = 0; i < headerGroups.length; i++) {
      const value = _CMCDController.serialize(headerGroups[i]);
      if (value) {
        headers[`CMCD-${headerNames[i]}`] = value;
      }
    }
    return headers;
  }
  /**
   * Convert a CMCD data object to query args according to the rules
   * defined in the section 2.2 and 3.2 of
   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).
   */
  static toQuery(data) {
    return `CMCD=${encodeURIComponent(_CMCDController.serialize(data))}`;
  }
  /**
   * Append query args to a uri.
   */
  static appendQueryToUri(uri, query) {
    if (!query) {
      return uri;
    }
    const separator = uri.includes("?") ? "&" : "?";
    return `${uri}${separator}${query}`;
  }
};
var PATHWAY_PENALTY_DURATION_MS = 3e5;
var ContentSteeringController = class {
  constructor(hls) {
    this.hls = void 0;
    this.log = void 0;
    this.loader = null;
    this.uri = null;
    this.pathwayId = ".";
    this.pathwayPriority = null;
    this.timeToLoad = 300;
    this.reloadTimer = -1;
    this.updated = 0;
    this.started = false;
    this.enabled = true;
    this.levels = null;
    this.audioTracks = null;
    this.subtitleTracks = null;
    this.penalizedPathways = {};
    this.hls = hls;
    this.log = logger.log.bind(logger, `[content-steering]:`);
    this.registerListeners();
  }
  registerListeners() {
    const hls = this.hls;
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.on(Events.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const hls = this.hls;
    if (!hls) {
      return;
    }
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.off(Events.ERROR, this.onError, this);
  }
  startLoad() {
    this.started = true;
    self.clearTimeout(this.reloadTimer);
    if (this.enabled && this.uri) {
      if (this.updated) {
        const ttl = Math.max(this.timeToLoad * 1e3 - (performance.now() - this.updated), 0);
        this.scheduleRefresh(this.uri, ttl);
      } else {
        this.loadSteeringManifest(this.uri);
      }
    }
  }
  stopLoad() {
    this.started = false;
    if (this.loader) {
      this.loader.destroy();
      this.loader = null;
    }
    self.clearTimeout(this.reloadTimer);
  }
  destroy() {
    this.unregisterListeners();
    this.stopLoad();
    this.hls = null;
    this.levels = this.audioTracks = this.subtitleTracks = null;
  }
  removeLevel(levelToRemove) {
    const levels = this.levels;
    if (levels) {
      this.levels = levels.filter((level) => level !== levelToRemove);
    }
  }
  onManifestLoading() {
    this.stopLoad();
    this.enabled = true;
    this.timeToLoad = 300;
    this.updated = 0;
    this.uri = null;
    this.pathwayId = ".";
    this.levels = this.audioTracks = this.subtitleTracks = null;
  }
  onManifestLoaded(event, data) {
    const {
      contentSteering
    } = data;
    if (contentSteering === null) {
      return;
    }
    this.pathwayId = contentSteering.pathwayId;
    this.uri = contentSteering.uri;
    if (this.started) {
      this.startLoad();
    }
  }
  onManifestParsed(event, data) {
    this.audioTracks = data.audioTracks;
    this.subtitleTracks = data.subtitleTracks;
  }
  onError(event, data) {
    const {
      errorAction
    } = data;
    if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox && errorAction.flags === ErrorActionFlags.MoveAllAlternatesMatchingHost) {
      let pathwayPriority = this.pathwayPriority;
      const pathwayId = this.pathwayId;
      if (!this.penalizedPathways[pathwayId]) {
        this.penalizedPathways[pathwayId] = performance.now();
      }
      if (!pathwayPriority && this.levels) {
        pathwayPriority = this.levels.reduce((pathways, level) => {
          if (pathways.indexOf(level.pathwayId) === -1) {
            pathways.push(level.pathwayId);
          }
          return pathways;
        }, []);
      }
      if (pathwayPriority && pathwayPriority.length > 1) {
        this.updatePathwayPriority(pathwayPriority);
        errorAction.resolved = this.pathwayId !== pathwayId;
      }
    }
  }
  filterParsedLevels(levels) {
    this.levels = levels;
    let pathwayLevels = this.getLevelsForPathway(this.pathwayId);
    if (pathwayLevels.length === 0) {
      const pathwayId = levels[0].pathwayId;
      this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${pathwayId}"`);
      pathwayLevels = this.getLevelsForPathway(pathwayId);
      this.pathwayId = pathwayId;
    }
    if (pathwayLevels.length !== levels.length) {
      this.log(`Found ${pathwayLevels.length}/${levels.length} levels in Pathway "${this.pathwayId}"`);
      return pathwayLevels;
    }
    return levels;
  }
  getLevelsForPathway(pathwayId) {
    if (this.levels === null) {
      return [];
    }
    return this.levels.filter((level) => pathwayId === level.pathwayId);
  }
  updatePathwayPriority(pathwayPriority) {
    this.pathwayPriority = pathwayPriority;
    let levels;
    const penalizedPathways = this.penalizedPathways;
    const now2 = performance.now();
    Object.keys(penalizedPathways).forEach((pathwayId) => {
      if (now2 - penalizedPathways[pathwayId] > PATHWAY_PENALTY_DURATION_MS) {
        delete penalizedPathways[pathwayId];
      }
    });
    for (let i = 0; i < pathwayPriority.length; i++) {
      const pathwayId = pathwayPriority[i];
      if (penalizedPathways[pathwayId]) {
        continue;
      }
      if (pathwayId === this.pathwayId) {
        return;
      }
      const selectedIndex = this.hls.nextLoadLevel;
      const selectedLevel = this.hls.levels[selectedIndex];
      levels = this.getLevelsForPathway(pathwayId);
      if (levels.length > 0) {
        this.log(`Setting Pathway to "${pathwayId}"`);
        this.pathwayId = pathwayId;
        this.hls.trigger(Events.LEVELS_UPDATED, {
          levels
        });
        const levelAfterChange = this.hls.levels[selectedIndex];
        if (selectedLevel && levelAfterChange && this.levels) {
          if (levelAfterChange.attrs["STABLE-VARIANT-ID"] !== selectedLevel.attrs["STABLE-VARIANT-ID"] && levelAfterChange.bitrate !== selectedLevel.bitrate) {
            this.log(`Unstable Pathways change from bitrate ${selectedLevel.bitrate} to ${levelAfterChange.bitrate}`);
          }
          this.hls.nextLoadLevel = selectedIndex;
        }
        break;
      }
    }
  }
  clonePathways(pathwayClones) {
    const levels = this.levels;
    if (!levels) {
      return;
    }
    const audioGroupCloneMap = {};
    const subtitleGroupCloneMap = {};
    pathwayClones.forEach((pathwayClone) => {
      const {
        ID: cloneId,
        "BASE-ID": baseId,
        "URI-REPLACEMENT": uriReplacement
      } = pathwayClone;
      if (levels.some((level) => level.pathwayId === cloneId)) {
        return;
      }
      const clonedVariants = this.getLevelsForPathway(baseId).map((baseLevel) => {
        const levelParsed = _extends({}, baseLevel);
        levelParsed.details = void 0;
        levelParsed.url = performUriReplacement(baseLevel.uri, baseLevel.attrs["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", uriReplacement);
        const attributes = new AttrList(baseLevel.attrs);
        attributes["PATHWAY-ID"] = cloneId;
        const clonedAudioGroupId = attributes.AUDIO && `${attributes.AUDIO}_clone_${cloneId}`;
        const clonedSubtitleGroupId = attributes.SUBTITLES && `${attributes.SUBTITLES}_clone_${cloneId}`;
        if (clonedAudioGroupId) {
          audioGroupCloneMap[attributes.AUDIO] = clonedAudioGroupId;
          attributes.AUDIO = clonedAudioGroupId;
        }
        if (clonedSubtitleGroupId) {
          subtitleGroupCloneMap[attributes.SUBTITLES] = clonedSubtitleGroupId;
          attributes.SUBTITLES = clonedSubtitleGroupId;
        }
        levelParsed.attrs = attributes;
        const clonedLevel = new Level(levelParsed);
        addGroupId(clonedLevel, "audio", clonedAudioGroupId);
        addGroupId(clonedLevel, "text", clonedSubtitleGroupId);
        return clonedLevel;
      });
      levels.push(...clonedVariants);
      cloneRenditionGroups(this.audioTracks, audioGroupCloneMap, uriReplacement, cloneId);
      cloneRenditionGroups(this.subtitleTracks, subtitleGroupCloneMap, uriReplacement, cloneId);
    });
  }
  loadSteeringManifest(uri) {
    const config = this.hls.config;
    const Loader = config.loader;
    if (this.loader) {
      this.loader.destroy();
    }
    this.loader = new Loader(config);
    let url;
    try {
      url = new self.URL(uri);
    } catch (error) {
      this.enabled = false;
      this.log(`Failed to parse Steering Manifest URI: ${uri}`);
      return;
    }
    if (url.protocol !== "data:") {
      const throughput = (this.hls.bandwidthEstimate || config.abrEwmaDefaultEstimate) | 0;
      url.searchParams.set("_HLS_pathway", this.pathwayId);
      url.searchParams.set("_HLS_throughput", "" + throughput);
    }
    const context = {
      responseType: "json",
      url: url.href
    };
    const loadPolicy = config.steeringManifestLoadPolicy.default;
    const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};
    const loaderConfig = {
      loadPolicy,
      timeout: loadPolicy.maxLoadTimeMs,
      maxRetry: legacyRetryCompatibility.maxNumRetry || 0,
      retryDelay: legacyRetryCompatibility.retryDelayMs || 0,
      maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0
    };
    const callbacks = {
      onSuccess: (response, stats, context2, networkDetails) => {
        this.log(`Loaded steering manifest: "${url}"`);
        const steeringData = response.data;
        if (steeringData.VERSION !== 1) {
          this.log(`Steering VERSION ${steeringData.VERSION} not supported!`);
          return;
        }
        this.updated = performance.now();
        this.timeToLoad = steeringData.TTL;
        const {
          "RELOAD-URI": reloadUri,
          "PATHWAY-CLONES": pathwayClones,
          "PATHWAY-PRIORITY": pathwayPriority
        } = steeringData;
        if (reloadUri) {
          try {
            this.uri = new self.URL(reloadUri, url).href;
          } catch (error) {
            this.enabled = false;
            this.log(`Failed to parse Steering Manifest RELOAD-URI: ${reloadUri}`);
            return;
          }
        }
        this.scheduleRefresh(this.uri || context2.url);
        if (pathwayClones) {
          this.clonePathways(pathwayClones);
        }
        if (pathwayPriority) {
          this.updatePathwayPriority(pathwayPriority);
        }
      },
      onError: (error, context2, networkDetails, stats) => {
        this.log(`Error loading steering manifest: ${error.code} ${error.text} (${context2.url})`);
        this.stopLoad();
        if (error.code === 410) {
          this.enabled = false;
          this.log(`Steering manifest ${context2.url} no longer available`);
          return;
        }
        let ttl = this.timeToLoad * 1e3;
        if (error.code === 429) {
          const loader = this.loader;
          if (typeof (loader == null ? void 0 : loader.getResponseHeader) === "function") {
            const retryAfter = loader.getResponseHeader("Retry-After");
            if (retryAfter) {
              ttl = parseFloat(retryAfter) * 1e3;
            }
          }
          this.log(`Steering manifest ${context2.url} rate limited`);
          return;
        }
        this.scheduleRefresh(this.uri || context2.url, ttl);
      },
      onTimeout: (stats, context2, networkDetails) => {
        this.log(`Timeout loading steering manifest (${context2.url})`);
        this.scheduleRefresh(this.uri || context2.url);
      }
    };
    this.log(`Requesting steering manifest: ${url}`);
    this.loader.load(context, loaderConfig, callbacks);
  }
  scheduleRefresh(uri, ttlMs = this.timeToLoad * 1e3) {
    self.clearTimeout(this.reloadTimer);
    this.reloadTimer = self.setTimeout(() => {
      this.loadSteeringManifest(uri);
    }, ttlMs);
  }
};
function cloneRenditionGroups(tracks, groupCloneMap, uriReplacement, cloneId) {
  if (!tracks) {
    return;
  }
  Object.keys(groupCloneMap).forEach((audioGroupId) => {
    const clonedTracks = tracks.filter((track) => track.groupId === audioGroupId).map((track) => {
      const clonedTrack = _extends({}, track);
      clonedTrack.details = void 0;
      clonedTrack.attrs = new AttrList(clonedTrack.attrs);
      clonedTrack.url = clonedTrack.attrs.URI = performUriReplacement(track.url, track.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", uriReplacement);
      clonedTrack.groupId = clonedTrack.attrs["GROUP-ID"] = groupCloneMap[audioGroupId];
      clonedTrack.attrs["PATHWAY-ID"] = cloneId;
      return clonedTrack;
    });
    tracks.push(...clonedTracks);
  });
}
function performUriReplacement(uri, stableId, perOptionKey, uriReplacement) {
  const {
    HOST: host,
    PARAMS: params,
    [perOptionKey]: perOptionUris
  } = uriReplacement;
  let perVariantUri;
  if (stableId) {
    perVariantUri = perOptionUris == null ? void 0 : perOptionUris[stableId];
    if (perVariantUri) {
      uri = perVariantUri;
    }
  }
  const url = new self.URL(uri);
  if (host && !perVariantUri) {
    url.host = host;
  }
  if (params) {
    Object.keys(params).sort().forEach((key) => {
      if (key) {
        url.searchParams.set(key, params[key]);
      }
    });
  }
  return url.href;
}
var AGE_HEADER_LINE_REGEX = /^age:\s*[\d.]+\s*$/im;
var XhrLoader = class {
  constructor(config) {
    this.xhrSetup = void 0;
    this.requestTimeout = void 0;
    this.retryTimeout = void 0;
    this.retryDelay = void 0;
    this.config = null;
    this.callbacks = null;
    this.context = void 0;
    this.loader = null;
    this.stats = void 0;
    this.xhrSetup = config ? config.xhrSetup || null : null;
    this.stats = new LoadStats();
    this.retryDelay = 0;
  }
  destroy() {
    this.callbacks = null;
    this.abortInternal();
    this.loader = null;
    this.config = null;
  }
  abortInternal() {
    const loader = this.loader;
    self.clearTimeout(this.requestTimeout);
    self.clearTimeout(this.retryTimeout);
    if (loader) {
      loader.onreadystatechange = null;
      loader.onprogress = null;
      if (loader.readyState !== 4) {
        this.stats.aborted = true;
        loader.abort();
      }
    }
  }
  abort() {
    var _this$callbacks;
    this.abortInternal();
    if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {
      this.callbacks.onAbort(this.stats, this.context, this.loader);
    }
  }
  load(context, config, callbacks) {
    if (this.stats.loading.start) {
      throw new Error("Loader can only be used once.");
    }
    this.stats.loading.start = self.performance.now();
    this.context = context;
    this.config = config;
    this.callbacks = callbacks;
    this.loadInternal();
  }
  loadInternal() {
    const {
      config,
      context
    } = this;
    if (!config) {
      return;
    }
    const xhr = this.loader = new self.XMLHttpRequest();
    const stats = this.stats;
    stats.loading.first = 0;
    stats.loaded = 0;
    stats.aborted = false;
    const xhrSetup = this.xhrSetup;
    if (xhrSetup) {
      Promise.resolve().then(() => {
        if (this.stats.aborted) return;
        return xhrSetup(xhr, context.url);
      }).catch((error) => {
        xhr.open("GET", context.url, true);
        return xhrSetup(xhr, context.url);
      }).then(() => {
        if (this.stats.aborted) return;
        this.openAndSendXhr(xhr, context, config);
      }).catch((error) => {
        this.callbacks.onError({
          code: xhr.status,
          text: error.message
        }, context, xhr, stats);
        return;
      });
    } else {
      this.openAndSendXhr(xhr, context, config);
    }
  }
  openAndSendXhr(xhr, context, config) {
    if (!xhr.readyState) {
      xhr.open("GET", context.url, true);
    }
    const headers = this.context.headers;
    const {
      maxTimeToFirstByteMs,
      maxLoadTimeMs
    } = config.loadPolicy;
    if (headers) {
      for (const header in headers) {
        xhr.setRequestHeader(header, headers[header]);
      }
    }
    if (context.rangeEnd) {
      xhr.setRequestHeader("Range", "bytes=" + context.rangeStart + "-" + (context.rangeEnd - 1));
    }
    xhr.onreadystatechange = this.readystatechange.bind(this);
    xhr.onprogress = this.loadprogress.bind(this);
    xhr.responseType = context.responseType;
    self.clearTimeout(this.requestTimeout);
    config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;
    this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);
    xhr.send();
  }
  readystatechange() {
    const {
      context,
      loader: xhr,
      stats
    } = this;
    if (!context || !xhr) {
      return;
    }
    const readyState = xhr.readyState;
    const config = this.config;
    if (stats.aborted) {
      return;
    }
    if (readyState >= 2) {
      if (stats.loading.first === 0) {
        stats.loading.first = Math.max(self.performance.now(), stats.loading.start);
        if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {
          self.clearTimeout(this.requestTimeout);
          config.timeout = config.loadPolicy.maxLoadTimeMs;
          this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));
        }
      }
      if (readyState === 4) {
        self.clearTimeout(this.requestTimeout);
        xhr.onreadystatechange = null;
        xhr.onprogress = null;
        const status2 = xhr.status;
        const useResponse = xhr.responseType !== "text";
        if (status2 >= 200 && status2 < 300 && (useResponse && xhr.response || xhr.responseText !== null)) {
          stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
          const data = useResponse ? xhr.response : xhr.responseText;
          const len = xhr.responseType === "arraybuffer" ? data.byteLength : data.length;
          stats.loaded = stats.total = len;
          stats.bwEstimate = stats.total * 8e3 / (stats.loading.end - stats.loading.first);
          if (!this.callbacks) {
            return;
          }
          const onProgress = this.callbacks.onProgress;
          if (onProgress) {
            onProgress(stats, context, data, xhr);
          }
          if (!this.callbacks) {
            return;
          }
          const response = {
            url: xhr.responseURL,
            data,
            code: status2
          };
          this.callbacks.onSuccess(response, stats, context, xhr);
        } else {
          const retryConfig = config.loadPolicy.errorRetry;
          const retryCount = stats.retry;
          if (shouldRetry(retryConfig, retryCount, false, status2)) {
            this.retry(retryConfig);
          } else {
            logger.error(`${status2} while loading ${context.url}`);
            this.callbacks.onError({
              code: status2,
              text: xhr.statusText
            }, context, xhr, stats);
          }
        }
      }
    }
  }
  loadtimeout() {
    var _this$config;
    const retryConfig = (_this$config = this.config) == null ? void 0 : _this$config.loadPolicy.timeoutRetry;
    const retryCount = this.stats.retry;
    if (shouldRetry(retryConfig, retryCount, true)) {
      this.retry(retryConfig);
    } else {
      logger.warn(`timeout while loading ${this.context.url}`);
      const callbacks = this.callbacks;
      if (callbacks) {
        this.abortInternal();
        callbacks.onTimeout(this.stats, this.context, this.loader);
      }
    }
  }
  retry(retryConfig) {
    const {
      context,
      stats
    } = this;
    this.retryDelay = getRetryDelay(retryConfig, stats.retry);
    stats.retry++;
    logger.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${context.url}, retrying ${stats.retry}/${retryConfig.maxNumRetry} in ${this.retryDelay}ms`);
    this.abortInternal();
    this.loader = null;
    self.clearTimeout(this.retryTimeout);
    this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);
  }
  loadprogress(event) {
    const stats = this.stats;
    stats.loaded = event.loaded;
    if (event.lengthComputable) {
      stats.total = event.total;
    }
  }
  getCacheAge() {
    let result = null;
    if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {
      const ageHeader = this.loader.getResponseHeader("age");
      result = ageHeader ? parseFloat(ageHeader) : null;
    }
    return result;
  }
  getResponseHeader(name) {
    if (this.loader && new RegExp(`^${name}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders())) {
      return this.loader.getResponseHeader(name);
    }
    return null;
  }
};
function fetchSupported() {
  if (
    // @ts-ignore
    self.fetch && self.AbortController && self.ReadableStream && self.Request
  ) {
    try {
      new self.ReadableStream({});
      return true;
    } catch (e) {
    }
  }
  return false;
}
var BYTERANGE = /(\d+)-(\d+)\/(\d+)/;
var FetchLoader = class {
  constructor(config) {
    this.fetchSetup = void 0;
    this.requestTimeout = void 0;
    this.request = void 0;
    this.response = void 0;
    this.controller = void 0;
    this.context = void 0;
    this.config = null;
    this.callbacks = null;
    this.stats = void 0;
    this.loader = null;
    this.fetchSetup = config.fetchSetup || getRequest;
    this.controller = new self.AbortController();
    this.stats = new LoadStats();
  }
  destroy() {
    this.loader = this.callbacks = null;
    this.abortInternal();
  }
  abortInternal() {
    const response = this.response;
    if (!(response != null && response.ok)) {
      this.stats.aborted = true;
      this.controller.abort();
    }
  }
  abort() {
    var _this$callbacks;
    this.abortInternal();
    if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {
      this.callbacks.onAbort(this.stats, this.context, this.response);
    }
  }
  load(context, config, callbacks) {
    const stats = this.stats;
    if (stats.loading.start) {
      throw new Error("Loader can only be used once.");
    }
    stats.loading.start = self.performance.now();
    const initParams = getRequestParameters(context, this.controller.signal);
    const onProgress = callbacks.onProgress;
    const isArrayBuffer = context.responseType === "arraybuffer";
    const LENGTH = isArrayBuffer ? "byteLength" : "length";
    const {
      maxTimeToFirstByteMs,
      maxLoadTimeMs
    } = config.loadPolicy;
    this.context = context;
    this.config = config;
    this.callbacks = callbacks;
    this.request = this.fetchSetup(context, initParams);
    self.clearTimeout(this.requestTimeout);
    config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;
    this.requestTimeout = self.setTimeout(() => {
      this.abortInternal();
      callbacks.onTimeout(stats, context, this.response);
    }, config.timeout);
    self.fetch(this.request).then((response) => {
      this.response = this.loader = response;
      const first = Math.max(self.performance.now(), stats.loading.start);
      self.clearTimeout(this.requestTimeout);
      config.timeout = maxLoadTimeMs;
      this.requestTimeout = self.setTimeout(() => {
        this.abortInternal();
        callbacks.onTimeout(stats, context, this.response);
      }, maxLoadTimeMs - (first - stats.loading.start));
      if (!response.ok) {
        const {
          status: status2,
          statusText
        } = response;
        throw new FetchError(statusText || "fetch, bad network response", status2, response);
      }
      stats.loading.first = first;
      stats.total = getContentLength(response.headers) || stats.total;
      if (onProgress && isFiniteNumber(config.highWaterMark)) {
        return this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);
      }
      if (isArrayBuffer) {
        return response.arrayBuffer();
      }
      if (context.responseType === "json") {
        return response.json();
      }
      return response.text();
    }).then((responseData) => {
      const {
        response
      } = this;
      self.clearTimeout(this.requestTimeout);
      stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
      const total = responseData[LENGTH];
      if (total) {
        stats.loaded = stats.total = total;
      }
      const loaderResponse = {
        url: response.url,
        data: responseData,
        code: response.status
      };
      if (onProgress && !isFiniteNumber(config.highWaterMark)) {
        onProgress(stats, context, responseData, response);
      }
      callbacks.onSuccess(loaderResponse, stats, context, response);
    }).catch((error) => {
      self.clearTimeout(this.requestTimeout);
      if (stats.aborted) {
        return;
      }
      const code = !error ? 0 : error.code || 0;
      const text = !error ? null : error.message;
      callbacks.onError({
        code,
        text
      }, context, error ? error.details : null, stats);
    });
  }
  getCacheAge() {
    let result = null;
    if (this.response) {
      const ageHeader = this.response.headers.get("age");
      result = ageHeader ? parseFloat(ageHeader) : null;
    }
    return result;
  }
  getResponseHeader(name) {
    return this.response ? this.response.headers.get(name) : null;
  }
  loadProgressively(response, stats, context, highWaterMark = 0, onProgress) {
    const chunkCache = new ChunkCache();
    const reader = response.body.getReader();
    const pump = () => {
      return reader.read().then((data) => {
        if (data.done) {
          if (chunkCache.dataLength) {
            onProgress(stats, context, chunkCache.flush(), response);
          }
          return Promise.resolve(new ArrayBuffer(0));
        }
        const chunk = data.value;
        const len = chunk.length;
        stats.loaded += len;
        if (len < highWaterMark || chunkCache.dataLength) {
          chunkCache.push(chunk);
          if (chunkCache.dataLength >= highWaterMark) {
            onProgress(stats, context, chunkCache.flush(), response);
          }
        } else {
          onProgress(stats, context, chunk, response);
        }
        return pump();
      }).catch(() => {
        return Promise.reject();
      });
    };
    return pump();
  }
};
function getRequestParameters(context, signal) {
  const initParams = {
    method: "GET",
    mode: "cors",
    credentials: "same-origin",
    signal,
    headers: new self.Headers(_extends({}, context.headers))
  };
  if (context.rangeEnd) {
    initParams.headers.set("Range", "bytes=" + context.rangeStart + "-" + String(context.rangeEnd - 1));
  }
  return initParams;
}
function getByteRangeLength(byteRangeHeader) {
  const result = BYTERANGE.exec(byteRangeHeader);
  if (result) {
    return parseInt(result[2]) - parseInt(result[1]) + 1;
  }
}
function getContentLength(headers) {
  const contentRange = headers.get("Content-Range");
  if (contentRange) {
    const byteRangeLength = getByteRangeLength(contentRange);
    if (isFiniteNumber(byteRangeLength)) {
      return byteRangeLength;
    }
  }
  const contentLength = headers.get("Content-Length");
  if (contentLength) {
    return parseInt(contentLength);
  }
}
function getRequest(context, initParams) {
  return new self.Request(context.url, initParams);
}
var FetchError = class extends Error {
  constructor(message, code, details) {
    super(message);
    this.code = void 0;
    this.details = void 0;
    this.code = code;
    this.details = details;
  }
};
var WHITESPACE_CHAR = /\s/;
var Cues = {
  newCue(track, startTime, endTime, captionScreen) {
    const result = [];
    let row;
    let cue;
    let indenting;
    let indent;
    let text;
    const Cue = self.VTTCue || self.TextTrackCue;
    for (let r2 = 0; r2 < captionScreen.rows.length; r2++) {
      row = captionScreen.rows[r2];
      indenting = true;
      indent = 0;
      text = "";
      if (!row.isEmpty()) {
        var _track$cues;
        for (let c = 0; c < row.chars.length; c++) {
          if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {
            indent++;
          } else {
            text += row.chars[c].uchar;
            indenting = false;
          }
        }
        row.cueStartTime = startTime;
        if (startTime === endTime) {
          endTime += 1e-4;
        }
        if (indent >= 16) {
          indent--;
        } else {
          indent++;
        }
        const cueText = fixLineBreaks(text.trim());
        const id = generateCueId(startTime, endTime, cueText);
        if (!(track != null && (_track$cues = track.cues) != null && _track$cues.getCueById(id))) {
          cue = new Cue(startTime, endTime, cueText);
          cue.id = id;
          cue.line = r2 + 1;
          cue.align = "left";
          cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);
          result.push(cue);
        }
      }
    }
    if (track && result.length) {
      result.sort((cueA, cueB) => {
        if (cueA.line === "auto" || cueB.line === "auto") {
          return 0;
        }
        if (cueA.line > 8 && cueB.line > 8) {
          return cueB.line - cueA.line;
        }
        return cueA.line - cueB.line;
      });
      result.forEach((cue2) => addCueToTrack(track, cue2));
    }
    return result;
  }
};
var defaultLoadPolicy = {
  maxTimeToFirstByteMs: 8e3,
  maxLoadTimeMs: 2e4,
  timeoutRetry: null,
  errorRetry: null
};
var hlsDefaultConfig = _objectSpread2(_objectSpread2({
  autoStartLoad: true,
  // used by stream-controller
  startPosition: -1,
  // used by stream-controller
  defaultAudioCodec: void 0,
  // used by stream-controller
  debug: false,
  // used by logger
  capLevelOnFPSDrop: false,
  // used by fps-controller
  capLevelToPlayerSize: false,
  // used by cap-level-controller
  ignoreDevicePixelRatio: false,
  // used by cap-level-controller
  initialLiveManifestSize: 1,
  // used by stream-controller
  maxBufferLength: 30,
  // used by stream-controller
  backBufferLength: Infinity,
  // used by buffer-controller
  maxBufferSize: 60 * 1e3 * 1e3,
  // used by stream-controller
  maxBufferHole: 0.1,
  // used by stream-controller
  highBufferWatchdogPeriod: 2,
  // used by stream-controller
  nudgeOffset: 0.1,
  // used by stream-controller
  nudgeMaxRetry: 3,
  // used by stream-controller
  maxFragLookUpTolerance: 0.25,
  // used by stream-controller
  liveSyncDurationCount: 3,
  // used by latency-controller
  liveMaxLatencyDurationCount: Infinity,
  // used by latency-controller
  liveSyncDuration: void 0,
  // used by latency-controller
  liveMaxLatencyDuration: void 0,
  // used by latency-controller
  maxLiveSyncPlaybackRate: 1,
  // used by latency-controller
  liveDurationInfinity: false,
  // used by buffer-controller
  /**
   * @deprecated use backBufferLength
   */
  liveBackBufferLength: null,
  // used by buffer-controller
  maxMaxBufferLength: 600,
  // used by stream-controller
  enableWorker: true,
  // used by transmuxer
  workerPath: null,
  // used by transmuxer
  enableSoftwareAES: true,
  // used by decrypter
  startLevel: void 0,
  // used by level-controller
  startFragPrefetch: false,
  // used by stream-controller
  fpsDroppedMonitoringPeriod: 5e3,
  // used by fps-controller
  fpsDroppedMonitoringThreshold: 0.2,
  // used by fps-controller
  appendErrorMaxRetry: 3,
  // used by buffer-controller
  loader: XhrLoader,
  // loader: FetchLoader,
  fLoader: void 0,
  // used by fragment-loader
  pLoader: void 0,
  // used by playlist-loader
  xhrSetup: void 0,
  // used by xhr-loader
  licenseXhrSetup: void 0,
  // used by eme-controller
  licenseResponseCallback: void 0,
  // used by eme-controller
  abrController: AbrController,
  bufferController: BufferController,
  capLevelController: CapLevelController,
  errorController: ErrorController,
  fpsController: FPSController,
  stretchShortVideoTrack: false,
  // used by mp4-remuxer
  maxAudioFramesDrift: 1,
  // used by mp4-remuxer
  forceKeyFrameOnDiscontinuity: true,
  // used by ts-demuxer
  abrEwmaFastLive: 3,
  // used by abr-controller
  abrEwmaSlowLive: 9,
  // used by abr-controller
  abrEwmaFastVoD: 3,
  // used by abr-controller
  abrEwmaSlowVoD: 9,
  // used by abr-controller
  abrEwmaDefaultEstimate: 5e5,
  // 500 kbps  // used by abr-controller
  abrBandWidthFactor: 0.95,
  // used by abr-controller
  abrBandWidthUpFactor: 0.7,
  // used by abr-controller
  abrMaxWithRealBitrate: false,
  // used by abr-controller
  maxStarvationDelay: 4,
  // used by abr-controller
  maxLoadingDelay: 4,
  // used by abr-controller
  minAutoBitrate: 0,
  // used by hls
  emeEnabled: false,
  // used by eme-controller
  widevineLicenseUrl: void 0,
  // used by eme-controller
  drmSystems: {},
  // used by eme-controller
  drmSystemOptions: {},
  // used by eme-controller
  requestMediaKeySystemAccessFunc: requestMediaKeySystemAccess,
  // used by eme-controller
  testBandwidth: true,
  progressive: false,
  lowLatencyMode: true,
  cmcd: void 0,
  enableDateRangeMetadataCues: true,
  enableEmsgMetadataCues: true,
  enableID3MetadataCues: true,
  certLoadPolicy: {
    default: defaultLoadPolicy
  },
  keyLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 8e3,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 2e4,
        backoff: "linear"
      },
      errorRetry: {
        maxNumRetry: 8,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 2e4,
        backoff: "linear"
      }
    }
  },
  manifestLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: Infinity,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  playlistLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 2,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  fragLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 12e4,
      timeoutRetry: {
        maxNumRetry: 4,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 6,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  steeringManifestLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  // These default settings are deprecated in favor of the above policies
  // and are maintained for backwards compatibility
  manifestLoadingTimeOut: 1e4,
  manifestLoadingMaxRetry: 1,
  manifestLoadingRetryDelay: 1e3,
  manifestLoadingMaxRetryTimeout: 64e3,
  levelLoadingTimeOut: 1e4,
  levelLoadingMaxRetry: 4,
  levelLoadingRetryDelay: 1e3,
  levelLoadingMaxRetryTimeout: 64e3,
  fragLoadingTimeOut: 2e4,
  fragLoadingMaxRetry: 6,
  fragLoadingRetryDelay: 1e3,
  fragLoadingMaxRetryTimeout: 64e3
}, timelineConfig()), {}, {
  subtitleStreamController: SubtitleStreamController,
  subtitleTrackController: SubtitleTrackController,
  timelineController: TimelineController,
  audioStreamController: AudioStreamController,
  audioTrackController: AudioTrackController,
  emeController: EMEController,
  cmcdController: CMCDController,
  contentSteeringController: ContentSteeringController
});
function timelineConfig() {
  return {
    cueHandler: Cues,
    // used by timeline-controller
    enableWebVTT: true,
    // used by timeline-controller
    enableIMSC1: true,
    // used by timeline-controller
    enableCEA708Captions: true,
    // used by timeline-controller
    captionsTextTrack1Label: "English",
    // used by timeline-controller
    captionsTextTrack1LanguageCode: "en",
    // used by timeline-controller
    captionsTextTrack2Label: "Spanish",
    // used by timeline-controller
    captionsTextTrack2LanguageCode: "es",
    // used by timeline-controller
    captionsTextTrack3Label: "Unknown CC",
    // used by timeline-controller
    captionsTextTrack3LanguageCode: "",
    // used by timeline-controller
    captionsTextTrack4Label: "Unknown CC",
    // used by timeline-controller
    captionsTextTrack4LanguageCode: "",
    // used by timeline-controller
    renderTextTracksNatively: true
  };
}
function mergeConfig(defaultConfig, userConfig) {
  if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {
    throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
  }
  if (userConfig.liveMaxLatencyDurationCount !== void 0 && (userConfig.liveSyncDurationCount === void 0 || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {
    throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
  }
  if (userConfig.liveMaxLatencyDuration !== void 0 && (userConfig.liveSyncDuration === void 0 || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {
    throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
  }
  const defaultsCopy = deepCpy(defaultConfig);
  const deprecatedSettingTypes = ["manifest", "level", "frag"];
  const deprecatedSettings = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
  deprecatedSettingTypes.forEach((type2) => {
    const policyName = `${type2 === "level" ? "playlist" : type2}LoadPolicy`;
    const policyNotSet = userConfig[policyName] === void 0;
    const report = [];
    deprecatedSettings.forEach((setting) => {
      const deprecatedSetting = `${type2}Loading${setting}`;
      const value = userConfig[deprecatedSetting];
      if (value !== void 0 && policyNotSet) {
        report.push(deprecatedSetting);
        const settings = defaultsCopy[policyName].default;
        userConfig[policyName] = {
          default: settings
        };
        switch (setting) {
          case "TimeOut":
            settings.maxLoadTimeMs = value;
            settings.maxTimeToFirstByteMs = value;
            break;
          case "MaxRetry":
            settings.errorRetry.maxNumRetry = value;
            settings.timeoutRetry.maxNumRetry = value;
            break;
          case "RetryDelay":
            settings.errorRetry.retryDelayMs = value;
            settings.timeoutRetry.retryDelayMs = value;
            break;
          case "MaxRetryTimeout":
            settings.errorRetry.maxRetryDelayMs = value;
            settings.timeoutRetry.maxRetryDelayMs = value;
            break;
        }
      }
    });
    if (report.length) {
      logger.warn(`hls.js config: "${report.join('", "')}" setting(s) are deprecated, use "${policyName}": ${JSON.stringify(userConfig[policyName])}`);
    }
  });
  return _objectSpread2(_objectSpread2({}, defaultsCopy), userConfig);
}
function deepCpy(obj) {
  if (obj && typeof obj === "object") {
    if (Array.isArray(obj)) {
      return obj.map(deepCpy);
    }
    return Object.keys(obj).reduce((result, key) => {
      result[key] = deepCpy(obj[key]);
      return result;
    }, {});
  }
  return obj;
}
function enableStreamingMode(config) {
  const currentLoader = config.loader;
  if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {
    logger.log("[config]: Custom loader detected, cannot enable progressive streaming");
    config.progressive = false;
  } else {
    const canStreamProgressively = fetchSupported();
    if (canStreamProgressively) {
      config.loader = FetchLoader;
      config.progressive = true;
      config.enableSoftwareAES = true;
      logger.log("[config]: Progressive streaming enabled, using FetchLoader");
    }
  }
}
var Hls = class _Hls {
  /**
   * The runtime configuration used by the player. At instantiation this is combination of `hls.userConfig` merged over `Hls.DefaultConfig`.
   */
  /**
   * The configuration object provided on player instantiation.
   */
  /**
   * Get the video-dev/hls.js package version.
   */
  static get version() {
    return "1.4.12";
  }
  /**
   * Check if the required MediaSource Extensions are available.
   */
  static isSupported() {
    return isSupported();
  }
  static get Events() {
    return Events;
  }
  static get ErrorTypes() {
    return ErrorTypes;
  }
  static get ErrorDetails() {
    return ErrorDetails;
  }
  /**
   * Get the default configuration applied to new instances.
   */
  static get DefaultConfig() {
    if (!_Hls.defaultConfig) {
      return hlsDefaultConfig;
    }
    return _Hls.defaultConfig;
  }
  /**
   * Replace the default configuration applied to new instances.
   */
  static set DefaultConfig(defaultConfig) {
    _Hls.defaultConfig = defaultConfig;
  }
  /**
   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.
   * @param userConfig - Configuration options applied over `Hls.DefaultConfig`
   */
  constructor(userConfig = {}) {
    this.config = void 0;
    this.userConfig = void 0;
    this.coreComponents = void 0;
    this.networkControllers = void 0;
    this._emitter = new EventEmitter();
    this._autoLevelCapping = void 0;
    this._maxHdcpLevel = null;
    this.abrController = void 0;
    this.bufferController = void 0;
    this.capLevelController = void 0;
    this.latencyController = void 0;
    this.levelController = void 0;
    this.streamController = void 0;
    this.audioTrackController = void 0;
    this.subtitleTrackController = void 0;
    this.emeController = void 0;
    this.cmcdController = void 0;
    this._media = null;
    this.url = null;
    enableLogs(userConfig.debug || false, "Hls instance");
    const config = this.config = mergeConfig(_Hls.DefaultConfig, userConfig);
    this.userConfig = userConfig;
    this._autoLevelCapping = -1;
    if (config.progressive) {
      enableStreamingMode(config);
    }
    const {
      abrController: ConfigAbrController,
      bufferController: ConfigBufferController,
      capLevelController: ConfigCapLevelController,
      errorController: ConfigErrorController,
      fpsController: ConfigFpsController
    } = config;
    const errorController = new ConfigErrorController(this);
    const abrController = this.abrController = new ConfigAbrController(this);
    const bufferController = this.bufferController = new ConfigBufferController(this);
    const capLevelController = this.capLevelController = new ConfigCapLevelController(this);
    const fpsController = new ConfigFpsController(this);
    const playListLoader = new PlaylistLoader(this);
    const id3TrackController = new ID3TrackController(this);
    const ConfigContentSteeringController = config.contentSteeringController;
    const contentSteering = ConfigContentSteeringController ? new ConfigContentSteeringController(this) : null;
    const levelController = this.levelController = new LevelController(this, contentSteering);
    const fragmentTracker = new FragmentTracker(this);
    const keyLoader = new KeyLoader(this.config);
    const streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);
    capLevelController.setStreamController(streamController);
    fpsController.setStreamController(streamController);
    const networkControllers = [playListLoader, levelController, streamController];
    if (contentSteering) {
      networkControllers.splice(1, 0, contentSteering);
    }
    this.networkControllers = networkControllers;
    const coreComponents = [abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];
    this.audioTrackController = this.createController(config.audioTrackController, networkControllers);
    const AudioStreamControllerClass = config.audioStreamController;
    if (AudioStreamControllerClass) {
      networkControllers.push(new AudioStreamControllerClass(this, fragmentTracker, keyLoader));
    }
    this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);
    const SubtitleStreamControllerClass = config.subtitleStreamController;
    if (SubtitleStreamControllerClass) {
      networkControllers.push(new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));
    }
    this.createController(config.timelineController, coreComponents);
    keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);
    this.cmcdController = this.createController(config.cmcdController, coreComponents);
    this.latencyController = this.createController(LatencyController, coreComponents);
    this.coreComponents = coreComponents;
    networkControllers.push(errorController);
    const onErrorOut = errorController.onErrorOut;
    if (typeof onErrorOut === "function") {
      this.on(Events.ERROR, onErrorOut, errorController);
    }
  }
  createController(ControllerClass, components) {
    if (ControllerClass) {
      const controllerInstance = new ControllerClass(this);
      if (components) {
        components.push(controllerInstance);
      }
      return controllerInstance;
    }
    return null;
  }
  // Delegate the EventEmitter through the public API of Hls.js
  on(event, listener, context = this) {
    this._emitter.on(event, listener, context);
  }
  once(event, listener, context = this) {
    this._emitter.once(event, listener, context);
  }
  removeAllListeners(event) {
    this._emitter.removeAllListeners(event);
  }
  off(event, listener, context = this, once) {
    this._emitter.off(event, listener, context, once);
  }
  listeners(event) {
    return this._emitter.listeners(event);
  }
  emit(event, name, eventObject) {
    return this._emitter.emit(event, name, eventObject);
  }
  trigger(event, eventObject) {
    if (this.config.debug) {
      return this.emit(event, event, eventObject);
    } else {
      try {
        return this.emit(event, event, eventObject);
      } catch (e) {
        logger.error("An internal error happened while handling event " + event + '. Error message: "' + e.message + '". Here is a stacktrace:', e);
        this.trigger(Events.ERROR, {
          type: ErrorTypes.OTHER_ERROR,
          details: ErrorDetails.INTERNAL_EXCEPTION,
          fatal: false,
          event,
          error: e
        });
      }
    }
    return false;
  }
  listenerCount(event) {
    return this._emitter.listenerCount(event);
  }
  /**
   * Dispose of the instance
   */
  destroy() {
    logger.log("destroy");
    this.trigger(Events.DESTROYING, void 0);
    this.detachMedia();
    this.removeAllListeners();
    this._autoLevelCapping = -1;
    this.url = null;
    this.networkControllers.forEach((component) => component.destroy());
    this.networkControllers.length = 0;
    this.coreComponents.forEach((component) => component.destroy());
    this.coreComponents.length = 0;
    const config = this.config;
    config.xhrSetup = config.fetchSetup = void 0;
    this.userConfig = null;
  }
  /**
   * Attaches Hls.js to a media element
   */
  attachMedia(media) {
    logger.log("attachMedia");
    this._media = media;
    this.trigger(Events.MEDIA_ATTACHING, {
      media
    });
  }
  /**
   * Detach Hls.js from the media
   */
  detachMedia() {
    logger.log("detachMedia");
    this.trigger(Events.MEDIA_DETACHING, void 0);
    this._media = null;
  }
  /**
   * Set the source URL. Can be relative or absolute.
   */
  loadSource(url) {
    this.stopLoad();
    const media = this.media;
    const loadedSource = this.url;
    const loadingSource = this.url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {
      alwaysNormalize: true
    });
    logger.log(`loadSource:${loadingSource}`);
    if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {
      this.detachMedia();
      this.attachMedia(media);
    }
    this.trigger(Events.MANIFEST_LOADING, {
      url
    });
  }
  /**
   * Start loading data from the stream source.
   * Depending on default config, client starts loading automatically when a source is set.
   *
   * @param startPosition - Set the start position to stream from.
   * Defaults to -1 (None: starts from earliest point)
   */
  startLoad(startPosition = -1) {
    logger.log(`startLoad(${startPosition})`);
    this.networkControllers.forEach((controller) => {
      controller.startLoad(startPosition);
    });
  }
  /**
   * Stop loading of any stream data.
   */
  stopLoad() {
    logger.log("stopLoad");
    this.networkControllers.forEach((controller) => {
      controller.stopLoad();
    });
  }
  /**
   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)
   */
  swapAudioCodec() {
    logger.log("swapAudioCodec");
    this.streamController.swapAudioCodec();
  }
  /**
   * When the media-element fails, this allows to detach and then re-attach it
   * as one call (convenience method).
   *
   * Automatic recovery of media-errors by this process is configurable.
   */
  recoverMediaError() {
    logger.log("recoverMediaError");
    const media = this._media;
    this.detachMedia();
    if (media) {
      this.attachMedia(media);
    }
  }
  removeLevel(levelIndex, urlId = 0) {
    this.levelController.removeLevel(levelIndex, urlId);
  }
  /**
   * @returns an array of levels (variants) sorted by HDCP-LEVEL, BANDWIDTH, SCORE, and RESOLUTION (height)
   */
  get levels() {
    const levels = this.levelController.levels;
    return levels ? levels : [];
  }
  /**
   * Index of quality level (variant) currently played
   */
  get currentLevel() {
    return this.streamController.currentLevel;
  }
  /**
   * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.
   */
  set currentLevel(newLevel) {
    logger.log(`set currentLevel:${newLevel}`);
    this.loadLevel = newLevel;
    this.abrController.clearTimer();
    this.streamController.immediateLevelSwitch();
  }
  /**
   * Index of next quality level loaded as scheduled by stream controller.
   */
  get nextLevel() {
    return this.streamController.nextLevel;
  }
  /**
   * Set quality level index for next loaded data.
   * This will switch the video quality asap, without interrupting playback.
   * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).
   * @param newLevel - Pass -1 for automatic level selection
   */
  set nextLevel(newLevel) {
    logger.log(`set nextLevel:${newLevel}`);
    this.levelController.manualLevel = newLevel;
    this.streamController.nextLevelSwitch();
  }
  /**
   * Return the quality level of the currently or last (of none is loaded currently) segment
   */
  get loadLevel() {
    return this.levelController.level;
  }
  /**
   * Set quality level index for next loaded data in a conservative way.
   * This will switch the quality without flushing, but interrupt current loading.
   * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.
   * @param newLevel - Pass -1 for automatic level selection
   */
  set loadLevel(newLevel) {
    logger.log(`set loadLevel:${newLevel}`);
    this.levelController.manualLevel = newLevel;
  }
  /**
   * get next quality level loaded
   */
  get nextLoadLevel() {
    return this.levelController.nextLoadLevel;
  }
  /**
   * Set quality level of next loaded segment in a fully "non-destructive" way.
   * Same as `loadLevel` but will wait for next switch (until current loading is done).
   */
  set nextLoadLevel(level) {
    this.levelController.nextLoadLevel = level;
  }
  /**
   * Return "first level": like a default level, if not set,
   * falls back to index of first level referenced in manifest
   */
  get firstLevel() {
    return Math.max(this.levelController.firstLevel, this.minAutoLevel);
  }
  /**
   * Sets "first-level", see getter.
   */
  set firstLevel(newLevel) {
    logger.log(`set firstLevel:${newLevel}`);
    this.levelController.firstLevel = newLevel;
  }
  /**
   * Return start level (level of first fragment that will be played back)
   * if not overrided by user, first level appearing in manifest will be used as start level
   * if -1 : automatic start level selection, playback will start from level matching download bandwidth
   * (determined from download of first segment)
   */
  get startLevel() {
    return this.levelController.startLevel;
  }
  /**
   * set  start level (level of first fragment that will be played back)
   * if not overrided by user, first level appearing in manifest will be used as start level
   * if -1 : automatic start level selection, playback will start from level matching download bandwidth
   * (determined from download of first segment)
   */
  set startLevel(newLevel) {
    logger.log(`set startLevel:${newLevel}`);
    if (newLevel !== -1) {
      newLevel = Math.max(newLevel, this.minAutoLevel);
    }
    this.levelController.startLevel = newLevel;
  }
  /**
   * Whether level capping is enabled.
   * Default value is set via `config.capLevelToPlayerSize`.
   */
  get capLevelToPlayerSize() {
    return this.config.capLevelToPlayerSize;
  }
  /**
   * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.
   */
  set capLevelToPlayerSize(shouldStartCapping) {
    const newCapLevelToPlayerSize = !!shouldStartCapping;
    if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {
      if (newCapLevelToPlayerSize) {
        this.capLevelController.startCapping();
      } else {
        this.capLevelController.stopCapping();
        this.autoLevelCapping = -1;
        this.streamController.nextLevelSwitch();
      }
      this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;
    }
  }
  /**
   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
   */
  get autoLevelCapping() {
    return this._autoLevelCapping;
  }
  /**
   * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.
   */
  get bandwidthEstimate() {
    const {
      bwEstimator
    } = this.abrController;
    if (!bwEstimator) {
      return NaN;
    }
    return bwEstimator.getEstimate();
  }
  /**
   * get time to first byte estimate
   * @type {number}
   */
  get ttfbEstimate() {
    const {
      bwEstimator
    } = this.abrController;
    if (!bwEstimator) {
      return NaN;
    }
    return bwEstimator.getEstimateTTFB();
  }
  /**
   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
   */
  set autoLevelCapping(newLevel) {
    if (this._autoLevelCapping !== newLevel) {
      logger.log(`set autoLevelCapping:${newLevel}`);
      this._autoLevelCapping = newLevel;
    }
  }
  get maxHdcpLevel() {
    return this._maxHdcpLevel;
  }
  set maxHdcpLevel(value) {
    if (HdcpLevels.indexOf(value) > -1) {
      this._maxHdcpLevel = value;
    }
  }
  /**
   * True when automatic level selection enabled
   */
  get autoLevelEnabled() {
    return this.levelController.manualLevel === -1;
  }
  /**
   * Level set manually (if any)
   */
  get manualLevel() {
    return this.levelController.manualLevel;
  }
  /**
   * min level selectable in auto mode according to config.minAutoBitrate
   */
  get minAutoLevel() {
    const {
      levels,
      config: {
        minAutoBitrate
      }
    } = this;
    if (!levels) return 0;
    const len = levels.length;
    for (let i = 0; i < len; i++) {
      if (levels[i].maxBitrate >= minAutoBitrate) {
        return i;
      }
    }
    return 0;
  }
  /**
   * max level selectable in auto mode according to autoLevelCapping
   */
  get maxAutoLevel() {
    const {
      levels,
      autoLevelCapping,
      maxHdcpLevel
    } = this;
    let maxAutoLevel;
    if (autoLevelCapping === -1 && levels && levels.length) {
      maxAutoLevel = levels.length - 1;
    } else {
      maxAutoLevel = autoLevelCapping;
    }
    if (maxHdcpLevel) {
      for (let i = maxAutoLevel; i--; ) {
        const hdcpLevel = levels[i].attrs["HDCP-LEVEL"];
        if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {
          return i;
        }
      }
    }
    return maxAutoLevel;
  }
  /**
   * next automatically selected quality level
   */
  get nextAutoLevel() {
    return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel);
  }
  /**
   * this setter is used to force next auto level.
   * this is useful to force a switch down in auto mode:
   * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
   * forced value is valid for one fragment. upon successful frag loading at forced level,
   * this value will be resetted to -1 by ABR controller.
   */
  set nextAutoLevel(nextLevel) {
    this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, nextLevel);
  }
  /**
   * get the datetime value relative to media.currentTime for the active level Program Date Time if present
   */
  get playingDate() {
    return this.streamController.currentProgramDateTime;
  }
  get mainForwardBufferInfo() {
    return this.streamController.getMainFwdBufferInfo();
  }
  /**
   * Get the list of selectable audio tracks
   */
  get audioTracks() {
    const audioTrackController = this.audioTrackController;
    return audioTrackController ? audioTrackController.audioTracks : [];
  }
  /**
   * index of the selected audio track (index in audio track lists)
   */
  get audioTrack() {
    const audioTrackController = this.audioTrackController;
    return audioTrackController ? audioTrackController.audioTrack : -1;
  }
  /**
   * selects an audio track, based on its index in audio track lists
   */
  set audioTrack(audioTrackId) {
    const audioTrackController = this.audioTrackController;
    if (audioTrackController) {
      audioTrackController.audioTrack = audioTrackId;
    }
  }
  /**
   * get alternate subtitle tracks list from playlist
   */
  get subtitleTracks() {
    const subtitleTrackController = this.subtitleTrackController;
    return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
  }
  /**
   * index of the selected subtitle track (index in subtitle track lists)
   */
  get subtitleTrack() {
    const subtitleTrackController = this.subtitleTrackController;
    return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
  }
  get media() {
    return this._media;
  }
  /**
   * select an subtitle track, based on its index in subtitle track lists
   */
  set subtitleTrack(subtitleTrackId) {
    const subtitleTrackController = this.subtitleTrackController;
    if (subtitleTrackController) {
      subtitleTrackController.subtitleTrack = subtitleTrackId;
    }
  }
  /**
   * Whether subtitle display is enabled or not
   */
  get subtitleDisplay() {
    const subtitleTrackController = this.subtitleTrackController;
    return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
  }
  /**
   * Enable/disable subtitle display rendering
   */
  set subtitleDisplay(value) {
    const subtitleTrackController = this.subtitleTrackController;
    if (subtitleTrackController) {
      subtitleTrackController.subtitleDisplay = value;
    }
  }
  /**
   * get mode for Low-Latency HLS loading
   */
  get lowLatencyMode() {
    return this.config.lowLatencyMode;
  }
  /**
   * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.
   */
  set lowLatencyMode(mode) {
    this.config.lowLatencyMode = mode;
  }
  /**
   * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)
   * @returns null prior to loading live Playlist
   */
  get liveSyncPosition() {
    return this.latencyController.liveSyncPosition;
  }
  /**
   * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)
   * @returns 0 before first playlist is loaded
   */
  get latency() {
    return this.latencyController.latency;
  }
  /**
   * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```
   * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```
   * @returns 0 before first playlist is loaded
   */
  get maxLatency() {
    return this.latencyController.maxLatency;
  }
  /**
   * target distance from the edge as calculated by the latency controller
   */
  get targetLatency() {
    return this.latencyController.targetLatency;
  }
  /**
   * the rate at which the edge of the current live playlist is advancing or 1 if there is none
   */
  get drift() {
    return this.latencyController.drift;
  }
  /**
   * set to true when startLoad is called before MANIFEST_PARSED event
   */
  get forceStartLoad() {
    return this.streamController.forceStartLoad;
  }
};
Hls.defaultConfig = void 0;

// src/app/player/components/html-video-player/html-video-player.component.ts
var _c0 = ["videoPlayer"];
var HtmlVideoPlayerComponent = class _HtmlVideoPlayerComponent {
  constructor(dataService) {
    this.dataService = dataService;
  }
  /**
   * Listen for component input changes
   * @param changes component changes
   */
  ngOnChanges(changes) {
    if (changes.channel && changes.channel.currentValue) {
      this.playChannel(changes.channel.currentValue);
    }
  }
  /**
   * Starts to play the given channel
   * @param channel given channel object
   */
  playChannel(channel) {
    if (this.hls)
      this.hls.destroy();
    if (channel.url) {
      const url = channel.url + (channel.epgParams ?? "");
      const extension = getExtensionFromUrl(channel.url);
      this.dataService.sendIpcEvent(CHANNEL_SET_USER_AGENT, {
        userAgent: channel.http?.["user-agent"] ?? "",
        referer: channel.http?.referrer ?? ""
      });
      if (extension !== "mp4" && extension !== "mpv" && Hls && Hls.isSupported()) {
        console.log("... switching channel to ", channel.name, url);
        this.hls = new Hls();
        this.hls.attachMedia(this.videoPlayer.nativeElement);
        this.hls.loadSource(url);
        this.handlePlayOperation();
      } else {
        console.error("something wrong with hls.js init...");
        this.addSourceToVideo(this.videoPlayer.nativeElement, url, "video/mp4");
        this.videoPlayer.nativeElement.play();
      }
    }
  }
  addSourceToVideo(element, url, type2) {
    const source = document.createElement("source");
    source.src = url;
    source.type = type2;
    element.appendChild(source);
  }
  /**
   * Disables text based captions based on the global settings
   */
  disableCaptions() {
    for (let i = 0; i < this.videoPlayer.nativeElement.textTracks.length; i++) {
      this.videoPlayer.nativeElement.textTracks[i].mode = "hidden";
    }
  }
  /**
   * Handles promise based play operation
   */
  handlePlayOperation() {
    const playPromise = this.videoPlayer.nativeElement.play();
    if (playPromise !== void 0) {
      playPromise.then(() => {
        if (!this.showCaptions) {
          this.disableCaptions();
        }
      }).catch(() => {
      });
    }
  }
  /**
   * Destroy hls instance on component destroy
   */
  ngOnDestroy() {
    if (this.hls) {
      this.hls.destroy();
    }
  }
  static {
    this.\u0275fac = function HtmlVideoPlayerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _HtmlVideoPlayerComponent)(\u0275\u0275directiveInject(DataService));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _HtmlVideoPlayerComponent, selectors: [["app-html-video-player"]], viewQuery: function HtmlVideoPlayerComponent_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c0, 7);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.videoPlayer = _t.first);
      }
    }, inputs: { channel: "channel", showCaptions: "showCaptions" }, standalone: true, features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature], decls: 3, vars: 0, consts: [["videoPlayer", ""], ["id", "video-player", "autoplay", "true", "controls", "true", "muted", "muted"]], template: function HtmlVideoPlayerComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275element(0, "video", 1, 0);
        \u0275\u0275text(2, "\n");
      }
    }, styles: ["\n\n#video-player[_ngcontent-%COMP%] {\n  width: 100%;\n  height: calc(100vh - 60px);\n}\n@media only screen and (max-width: 599px) {\n  #video-player[_ngcontent-%COMP%] {\n    width: 100%;\n    height: calc(50vh - 60px) !important;\n  }\n}"] });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(HtmlVideoPlayerComponent, { className: "HtmlVideoPlayerComponent" });
})();

// node_modules/.pnpm/video.js@7.20.3/node_modules/video.js/dist/video.es.js
var import_window6 = __toESM(require_window());
var import_document = __toESM(require_document2());

// node_modules/.pnpm/@babel+runtime@7.27.0/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends2() {
  return _extends2 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t2 = arguments[e];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n[r2] = t2[r2]);
    }
    return n;
  }, _extends2.apply(null, arguments);
}

// node_modules/.pnpm/video.js@7.20.3/node_modules/video.js/dist/video.es.js
var import_keycode = __toESM(require_keycode());

// node_modules/.pnpm/@babel+runtime@7.27.0/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

// node_modules/.pnpm/@babel+runtime@7.27.0/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t2, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e2) {
    return t3.__proto__ = e2, t3;
  }, _setPrototypeOf(t2, e);
}

// node_modules/.pnpm/@babel+runtime@7.27.0/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(t2, o) {
  t2.prototype = Object.create(o.prototype), t2.prototype.constructor = t2, _setPrototypeOf(t2, o);
}

// node_modules/.pnpm/video.js@7.20.3/node_modules/video.js/dist/video.es.js
var import_tuple = __toESM(require_tuple());
var import_xhr = __toESM(require_lib());
var import_videojs_vtt = __toESM(require_browser_index());

// node_modules/.pnpm/@babel+runtime@7.27.0/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}

// node_modules/.pnpm/@babel+runtime@7.27.0/node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(t2, e, r2) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t2.bind.apply(t2, o))();
  return r2 && _setPrototypeOf(p, r2.prototype), p;
}

// node_modules/.pnpm/@babel+runtime@7.27.0/node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(t2, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t2.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t2,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t2, "prototype", {
    writable: false
  }), e && _setPrototypeOf(t2, e);
}

// node_modules/.pnpm/@videojs+vhs-utils@3.0.5/node_modules/@videojs/vhs-utils/es/resolve-url.js
var import_url_toolkit = __toESM(require_url_toolkit());
var import_window = __toESM(require_window());
var DEFAULT_LOCATION = "http://example.com";
var resolveUrl = function resolveUrl2(baseUrl, relativeUrl) {
  if (/^[a-z]+:/i.test(relativeUrl)) {
    return relativeUrl;
  }
  if (/^data:/.test(baseUrl)) {
    baseUrl = import_window.default.location && import_window.default.location.href || "";
  }
  var nativeURL = typeof import_window.default.URL === "function";
  var protocolLess = /^\/\//.test(baseUrl);
  var removeLocation = !import_window.default.location && !/\/\//i.test(baseUrl);
  if (nativeURL) {
    baseUrl = new import_window.default.URL(baseUrl, import_window.default.location || DEFAULT_LOCATION);
  } else if (!/\/\//i.test(baseUrl)) {
    baseUrl = import_url_toolkit.default.buildAbsoluteURL(import_window.default.location && import_window.default.location.href || "", baseUrl);
  }
  if (nativeURL) {
    var newUrl = new URL(relativeUrl, baseUrl);
    if (removeLocation) {
      return newUrl.href.slice(DEFAULT_LOCATION.length);
    } else if (protocolLess) {
      return newUrl.href.slice(newUrl.protocol.length);
    }
    return newUrl.href;
  }
  return import_url_toolkit.default.buildAbsoluteURL(baseUrl, relativeUrl);
};
var resolve_url_default = resolveUrl;

// node_modules/.pnpm/@videojs+vhs-utils@3.0.5/node_modules/@videojs/vhs-utils/es/stream.js
var Stream = /* @__PURE__ */ function() {
  function Stream2() {
    this.listeners = {};
  }
  var _proto = Stream2.prototype;
  _proto.on = function on3(type2, listener) {
    if (!this.listeners[type2]) {
      this.listeners[type2] = [];
    }
    this.listeners[type2].push(listener);
  };
  _proto.off = function off2(type2, listener) {
    if (!this.listeners[type2]) {
      return false;
    }
    var index = this.listeners[type2].indexOf(listener);
    this.listeners[type2] = this.listeners[type2].slice(0);
    this.listeners[type2].splice(index, 1);
    return index > -1;
  };
  _proto.trigger = function trigger2(type2) {
    var callbacks = this.listeners[type2];
    if (!callbacks) {
      return;
    }
    if (arguments.length === 2) {
      var length = callbacks.length;
      for (var i = 0; i < length; ++i) {
        callbacks[i].call(this, arguments[1]);
      }
    } else {
      var args = Array.prototype.slice.call(arguments, 1);
      var _length = callbacks.length;
      for (var _i = 0; _i < _length; ++_i) {
        callbacks[_i].apply(this, args);
      }
    }
  };
  _proto.dispose = function dispose() {
    this.listeners = {};
  };
  _proto.pipe = function pipe(destination) {
    this.on("data", function(data) {
      destination.push(data);
    });
  };
  return Stream2;
}();

// node_modules/.pnpm/@videojs+vhs-utils@3.0.5/node_modules/@videojs/vhs-utils/es/decode-b64-to-uint8-array.js
var import_window2 = __toESM(require_window());
var atob2 = function atob3(s) {
  return import_window2.default.atob ? import_window2.default.atob(s) : Buffer.from(s, "base64").toString("binary");
};
function decodeB64ToUint8Array(b64Text) {
  var decodedString = atob2(b64Text);
  var array = new Uint8Array(decodedString.length);
  for (var i = 0; i < decodedString.length; i++) {
    array[i] = decodedString.charCodeAt(i);
  }
  return array;
}

// node_modules/.pnpm/m3u8-parser@4.7.1/node_modules/m3u8-parser/dist/m3u8-parser.es.js
var LineStream = /* @__PURE__ */ function(_Stream) {
  _inheritsLoose(LineStream2, _Stream);
  function LineStream2() {
    var _this;
    _this = _Stream.call(this) || this;
    _this.buffer = "";
    return _this;
  }
  var _proto = LineStream2.prototype;
  _proto.push = function push2(data) {
    var nextNewline;
    this.buffer += data;
    nextNewline = this.buffer.indexOf("\n");
    for (; nextNewline > -1; nextNewline = this.buffer.indexOf("\n")) {
      this.trigger("data", this.buffer.substring(0, nextNewline));
      this.buffer = this.buffer.substring(nextNewline + 1);
    }
  };
  return LineStream2;
}(Stream);
var TAB = String.fromCharCode(9);
var parseByterange = function parseByterange2(byterangeString) {
  var match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || "");
  var result = {};
  if (match[1]) {
    result.length = parseInt(match[1], 10);
  }
  if (match[2]) {
    result.offset = parseInt(match[2], 10);
  }
  return result;
};
var attributeSeparator = function attributeSeparator2() {
  var key = "[^=]*";
  var value = '"[^"]*"|[^,]*';
  var keyvalue = "(?:" + key + ")=(?:" + value + ")";
  return new RegExp("(?:^|,)(" + keyvalue + ")");
};
var parseAttributes = function parseAttributes2(attributes) {
  var attrs = attributes.split(attributeSeparator());
  var result = {};
  var i = attrs.length;
  var attr;
  while (i--) {
    if (attrs[i] === "") {
      continue;
    }
    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1);
    attr[0] = attr[0].replace(/^\s+|\s+$/g, "");
    attr[1] = attr[1].replace(/^\s+|\s+$/g, "");
    attr[1] = attr[1].replace(/^['"](.*)['"]$/g, "$1");
    result[attr[0]] = attr[1];
  }
  return result;
};
var ParseStream = /* @__PURE__ */ function(_Stream) {
  _inheritsLoose(ParseStream2, _Stream);
  function ParseStream2() {
    var _this;
    _this = _Stream.call(this) || this;
    _this.customParsers = [];
    _this.tagMappers = [];
    return _this;
  }
  var _proto = ParseStream2.prototype;
  _proto.push = function push2(line) {
    var _this2 = this;
    var match;
    var event;
    line = line.trim();
    if (line.length === 0) {
      return;
    }
    if (line[0] !== "#") {
      this.trigger("data", {
        type: "uri",
        uri: line
      });
      return;
    }
    var newLines = this.tagMappers.reduce(function(acc, mapper) {
      var mappedLine = mapper(line);
      if (mappedLine === line) {
        return acc;
      }
      return acc.concat([mappedLine]);
    }, [line]);
    newLines.forEach(function(newLine) {
      for (var i = 0; i < _this2.customParsers.length; i++) {
        if (_this2.customParsers[i].call(_this2, newLine)) {
          return;
        }
      }
      if (newLine.indexOf("#EXT") !== 0) {
        _this2.trigger("data", {
          type: "comment",
          text: newLine.slice(1)
        });
        return;
      }
      newLine = newLine.replace("\r", "");
      match = /^#EXTM3U/.exec(newLine);
      if (match) {
        _this2.trigger("data", {
          type: "tag",
          tagType: "m3u"
        });
        return;
      }
      match = /^#EXTINF:?([0-9\.]*)?,?(.*)?$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "inf"
        };
        if (match[1]) {
          event.duration = parseFloat(match[1]);
        }
        if (match[2]) {
          event.title = match[2];
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "targetduration"
        };
        if (match[1]) {
          event.duration = parseInt(match[1], 10);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "version"
        };
        if (match[1]) {
          event.version = parseInt(match[1], 10);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-MEDIA-SEQUENCE:?(\-?[0-9.]*)?/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "media-sequence"
        };
        if (match[1]) {
          event.number = parseInt(match[1], 10);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\-?[0-9.]*)?/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "discontinuity-sequence"
        };
        if (match[1]) {
          event.number = parseInt(match[1], 10);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "playlist-type"
        };
        if (match[1]) {
          event.playlistType = match[1];
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-BYTERANGE:?(.*)?$/.exec(newLine);
      if (match) {
        event = _extends2(parseByterange(match[1]), {
          type: "tag",
          tagType: "byterange"
        });
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "allow-cache"
        };
        if (match[1]) {
          event.allowed = !/NO/.test(match[1]);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-MAP:?(.*)$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "map"
        };
        if (match[1]) {
          var attributes = parseAttributes(match[1]);
          if (attributes.URI) {
            event.uri = attributes.URI;
          }
          if (attributes.BYTERANGE) {
            event.byterange = parseByterange(attributes.BYTERANGE);
          }
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-STREAM-INF:?(.*)$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "stream-inf"
        };
        if (match[1]) {
          event.attributes = parseAttributes(match[1]);
          if (event.attributes.RESOLUTION) {
            var split = event.attributes.RESOLUTION.split("x");
            var resolution = {};
            if (split[0]) {
              resolution.width = parseInt(split[0], 10);
            }
            if (split[1]) {
              resolution.height = parseInt(split[1], 10);
            }
            event.attributes.RESOLUTION = resolution;
          }
          if (event.attributes.BANDWIDTH) {
            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);
          }
          if (event.attributes["PROGRAM-ID"]) {
            event.attributes["PROGRAM-ID"] = parseInt(event.attributes["PROGRAM-ID"], 10);
          }
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-MEDIA:?(.*)$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "media"
        };
        if (match[1]) {
          event.attributes = parseAttributes(match[1]);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-ENDLIST/.exec(newLine);
      if (match) {
        _this2.trigger("data", {
          type: "tag",
          tagType: "endlist"
        });
        return;
      }
      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);
      if (match) {
        _this2.trigger("data", {
          type: "tag",
          tagType: "discontinuity"
        });
        return;
      }
      match = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "program-date-time"
        };
        if (match[1]) {
          event.dateTimeString = match[1];
          event.dateTimeObject = new Date(match[1]);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-KEY:?(.*)$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "key"
        };
        if (match[1]) {
          event.attributes = parseAttributes(match[1]);
          if (event.attributes.IV) {
            if (event.attributes.IV.substring(0, 2).toLowerCase() === "0x") {
              event.attributes.IV = event.attributes.IV.substring(2);
            }
            event.attributes.IV = event.attributes.IV.match(/.{8}/g);
            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);
            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);
            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);
            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);
            event.attributes.IV = new Uint32Array(event.attributes.IV);
          }
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-START:?(.*)$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "start"
        };
        if (match[1]) {
          event.attributes = parseAttributes(match[1]);
          event.attributes["TIME-OFFSET"] = parseFloat(event.attributes["TIME-OFFSET"]);
          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "cue-out-cont"
        };
        if (match[1]) {
          event.data = match[1];
        } else {
          event.data = "";
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "cue-out"
        };
        if (match[1]) {
          event.data = match[1];
        } else {
          event.data = "";
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);
      if (match) {
        event = {
          type: "tag",
          tagType: "cue-in"
        };
        if (match[1]) {
          event.data = match[1];
        } else {
          event.data = "";
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event = {
          type: "tag",
          tagType: "skip"
        };
        event.attributes = parseAttributes(match[1]);
        if (event.attributes.hasOwnProperty("SKIPPED-SEGMENTS")) {
          event.attributes["SKIPPED-SEGMENTS"] = parseInt(event.attributes["SKIPPED-SEGMENTS"], 10);
        }
        if (event.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES")) {
          event.attributes["RECENTLY-REMOVED-DATERANGES"] = event.attributes["RECENTLY-REMOVED-DATERANGES"].split(TAB);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-PART:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event = {
          type: "tag",
          tagType: "part"
        };
        event.attributes = parseAttributes(match[1]);
        ["DURATION"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseFloat(event.attributes[key]);
          }
        });
        ["INDEPENDENT", "GAP"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = /YES/.test(event.attributes[key]);
          }
        });
        if (event.attributes.hasOwnProperty("BYTERANGE")) {
          event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);
        }
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event = {
          type: "tag",
          tagType: "server-control"
        };
        event.attributes = parseAttributes(match[1]);
        ["CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseFloat(event.attributes[key]);
          }
        });
        ["CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = /YES/.test(event.attributes[key]);
          }
        });
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event = {
          type: "tag",
          tagType: "part-inf"
        };
        event.attributes = parseAttributes(match[1]);
        ["PART-TARGET"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseFloat(event.attributes[key]);
          }
        });
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event = {
          type: "tag",
          tagType: "preload-hint"
        };
        event.attributes = parseAttributes(match[1]);
        ["BYTERANGE-START", "BYTERANGE-LENGTH"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseInt(event.attributes[key], 10);
            var subkey = key === "BYTERANGE-LENGTH" ? "length" : "offset";
            event.attributes.byterange = event.attributes.byterange || {};
            event.attributes.byterange[subkey] = event.attributes[key];
            delete event.attributes[key];
          }
        });
        _this2.trigger("data", event);
        return;
      }
      match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event = {
          type: "tag",
          tagType: "rendition-report"
        };
        event.attributes = parseAttributes(match[1]);
        ["LAST-MSN", "LAST-PART"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseInt(event.attributes[key], 10);
          }
        });
        _this2.trigger("data", event);
        return;
      }
      _this2.trigger("data", {
        type: "tag",
        data: newLine.slice(4)
      });
    });
  };
  _proto.addParser = function addParser(_ref) {
    var _this3 = this;
    var expression = _ref.expression, customType = _ref.customType, dataParser = _ref.dataParser, segment = _ref.segment;
    if (typeof dataParser !== "function") {
      dataParser = function dataParser2(line) {
        return line;
      };
    }
    this.customParsers.push(function(line) {
      var match = expression.exec(line);
      if (match) {
        _this3.trigger("data", {
          type: "custom",
          data: dataParser(line),
          customType,
          segment
        });
        return true;
      }
    });
  };
  _proto.addTagMapper = function addTagMapper(_ref2) {
    var expression = _ref2.expression, map = _ref2.map;
    var mapFn = function mapFn2(line) {
      if (expression.test(line)) {
        return map(line);
      }
      return line;
    };
    this.tagMappers.push(mapFn);
  };
  return ParseStream2;
}(Stream);
var camelCase = function camelCase2(str) {
  return str.toLowerCase().replace(/-(\w)/g, function(a) {
    return a[1].toUpperCase();
  });
};
var camelCaseKeys = function camelCaseKeys2(attributes) {
  var result = {};
  Object.keys(attributes).forEach(function(key) {
    result[camelCase(key)] = attributes[key];
  });
  return result;
};
var setHoldBack = function setHoldBack2(manifest) {
  var serverControl = manifest.serverControl, targetDuration = manifest.targetDuration, partTargetDuration = manifest.partTargetDuration;
  if (!serverControl) {
    return;
  }
  var tag = "#EXT-X-SERVER-CONTROL";
  var hb = "holdBack";
  var phb = "partHoldBack";
  var minTargetDuration = targetDuration && targetDuration * 3;
  var minPartDuration = partTargetDuration && partTargetDuration * 2;
  if (targetDuration && !serverControl.hasOwnProperty(hb)) {
    serverControl[hb] = minTargetDuration;
    this.trigger("info", {
      message: tag + " defaulting HOLD-BACK to targetDuration * 3 (" + minTargetDuration + ")."
    });
  }
  if (minTargetDuration && serverControl[hb] < minTargetDuration) {
    this.trigger("warn", {
      message: tag + " clamping HOLD-BACK (" + serverControl[hb] + ") to targetDuration * 3 (" + minTargetDuration + ")"
    });
    serverControl[hb] = minTargetDuration;
  }
  if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {
    serverControl[phb] = partTargetDuration * 3;
    this.trigger("info", {
      message: tag + " defaulting PART-HOLD-BACK to partTargetDuration * 3 (" + serverControl[phb] + ")."
    });
  }
  if (partTargetDuration && serverControl[phb] < minPartDuration) {
    this.trigger("warn", {
      message: tag + " clamping PART-HOLD-BACK (" + serverControl[phb] + ") to partTargetDuration * 2 (" + minPartDuration + ")."
    });
    serverControl[phb] = minPartDuration;
  }
};
var Parser = /* @__PURE__ */ function(_Stream) {
  _inheritsLoose(Parser2, _Stream);
  function Parser2() {
    var _this;
    _this = _Stream.call(this) || this;
    _this.lineStream = new LineStream();
    _this.parseStream = new ParseStream();
    _this.lineStream.pipe(_this.parseStream);
    var self2 = _assertThisInitialized(_this);
    var uris = [];
    var currentUri = {};
    var currentMap;
    var _key;
    var hasParts = false;
    var noop4 = function noop5() {
    };
    var defaultMediaGroups = {
      "AUDIO": {},
      "VIDEO": {},
      "CLOSED-CAPTIONS": {},
      "SUBTITLES": {}
    };
    var widevineUuid = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";
    var currentTimeline = 0;
    _this.manifest = {
      allowCache: true,
      discontinuityStarts: [],
      segments: []
    };
    var lastByterangeEnd = 0;
    var lastPartByterangeEnd = 0;
    _this.on("end", function() {
      if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {
        return;
      }
      if (!currentUri.map && currentMap) {
        currentUri.map = currentMap;
      }
      if (!currentUri.key && _key) {
        currentUri.key = _key;
      }
      if (!currentUri.timeline && typeof currentTimeline === "number") {
        currentUri.timeline = currentTimeline;
      }
      _this.manifest.preloadSegment = currentUri;
    });
    _this.parseStream.on("data", function(entry) {
      var mediaGroup;
      var rendition;
      ({
        tag: function tag() {
          ({
            version: function version5() {
              if (entry.version) {
                this.manifest.version = entry.version;
              }
            },
            "allow-cache": function allowCache() {
              this.manifest.allowCache = entry.allowed;
              if (!("allowed" in entry)) {
                this.trigger("info", {
                  message: "defaulting allowCache to YES"
                });
                this.manifest.allowCache = true;
              }
            },
            byterange: function byterange() {
              var byterange2 = {};
              if ("length" in entry) {
                currentUri.byterange = byterange2;
                byterange2.length = entry.length;
                if (!("offset" in entry)) {
                  entry.offset = lastByterangeEnd;
                }
              }
              if ("offset" in entry) {
                currentUri.byterange = byterange2;
                byterange2.offset = entry.offset;
              }
              lastByterangeEnd = byterange2.offset + byterange2.length;
            },
            endlist: function endlist() {
              this.manifest.endList = true;
            },
            inf: function inf() {
              if (!("mediaSequence" in this.manifest)) {
                this.manifest.mediaSequence = 0;
                this.trigger("info", {
                  message: "defaulting media sequence to zero"
                });
              }
              if (!("discontinuitySequence" in this.manifest)) {
                this.manifest.discontinuitySequence = 0;
                this.trigger("info", {
                  message: "defaulting discontinuity sequence to zero"
                });
              }
              if (entry.duration > 0) {
                currentUri.duration = entry.duration;
              }
              if (entry.duration === 0) {
                currentUri.duration = 0.01;
                this.trigger("info", {
                  message: "updating zero segment duration to a small value"
                });
              }
              this.manifest.segments = uris;
            },
            key: function key() {
              if (!entry.attributes) {
                this.trigger("warn", {
                  message: "ignoring key declaration without attribute list"
                });
                return;
              }
              if (entry.attributes.METHOD === "NONE") {
                _key = null;
                return;
              }
              if (!entry.attributes.URI) {
                this.trigger("warn", {
                  message: "ignoring key declaration without URI"
                });
                return;
              }
              if (entry.attributes.KEYFORMAT === "com.apple.streamingkeydelivery") {
                this.manifest.contentProtection = this.manifest.contentProtection || {};
                this.manifest.contentProtection["com.apple.fps.1_0"] = {
                  attributes: entry.attributes
                };
                return;
              }
              if (entry.attributes.KEYFORMAT === "com.microsoft.playready") {
                this.manifest.contentProtection = this.manifest.contentProtection || {};
                this.manifest.contentProtection["com.microsoft.playready"] = {
                  uri: entry.attributes.URI
                };
                return;
              }
              if (entry.attributes.KEYFORMAT === widevineUuid) {
                var VALID_METHODS = ["SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC"];
                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {
                  this.trigger("warn", {
                    message: "invalid key method provided for Widevine"
                  });
                  return;
                }
                if (entry.attributes.METHOD === "SAMPLE-AES-CENC") {
                  this.trigger("warn", {
                    message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"
                  });
                }
                if (entry.attributes.URI.substring(0, 23) !== "data:text/plain;base64,") {
                  this.trigger("warn", {
                    message: "invalid key URI provided for Widevine"
                  });
                  return;
                }
                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === "0x")) {
                  this.trigger("warn", {
                    message: "invalid key ID provided for Widevine"
                  });
                  return;
                }
                this.manifest.contentProtection = this.manifest.contentProtection || {};
                this.manifest.contentProtection["com.widevine.alpha"] = {
                  attributes: {
                    schemeIdUri: entry.attributes.KEYFORMAT,
                    // remove '0x' from the key id string
                    keyId: entry.attributes.KEYID.substring(2)
                  },
                  // decode the base64-encoded PSSH box
                  pssh: decodeB64ToUint8Array(entry.attributes.URI.split(",")[1])
                };
                return;
              }
              if (!entry.attributes.METHOD) {
                this.trigger("warn", {
                  message: "defaulting key method to AES-128"
                });
              }
              _key = {
                method: entry.attributes.METHOD || "AES-128",
                uri: entry.attributes.URI
              };
              if (typeof entry.attributes.IV !== "undefined") {
                _key.iv = entry.attributes.IV;
              }
            },
            "media-sequence": function mediaSequence() {
              if (!isFinite(entry.number)) {
                this.trigger("warn", {
                  message: "ignoring invalid media sequence: " + entry.number
                });
                return;
              }
              this.manifest.mediaSequence = entry.number;
            },
            "discontinuity-sequence": function discontinuitySequence() {
              if (!isFinite(entry.number)) {
                this.trigger("warn", {
                  message: "ignoring invalid discontinuity sequence: " + entry.number
                });
                return;
              }
              this.manifest.discontinuitySequence = entry.number;
              currentTimeline = entry.number;
            },
            "playlist-type": function playlistType() {
              if (!/VOD|EVENT/.test(entry.playlistType)) {
                this.trigger("warn", {
                  message: "ignoring unknown playlist type: " + entry.playlist
                });
                return;
              }
              this.manifest.playlistType = entry.playlistType;
            },
            map: function map() {
              currentMap = {};
              if (entry.uri) {
                currentMap.uri = entry.uri;
              }
              if (entry.byterange) {
                currentMap.byterange = entry.byterange;
              }
              if (_key) {
                currentMap.key = _key;
              }
            },
            "stream-inf": function streamInf() {
              this.manifest.playlists = uris;
              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
              if (!entry.attributes) {
                this.trigger("warn", {
                  message: "ignoring empty stream-inf attributes"
                });
                return;
              }
              if (!currentUri.attributes) {
                currentUri.attributes = {};
              }
              _extends2(currentUri.attributes, entry.attributes);
            },
            media: function media() {
              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes["GROUP-ID"] && entry.attributes.NAME)) {
                this.trigger("warn", {
                  message: "ignoring incomplete or missing media group"
                });
                return;
              }
              var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];
              mediaGroupType[entry.attributes["GROUP-ID"]] = mediaGroupType[entry.attributes["GROUP-ID"]] || {};
              mediaGroup = mediaGroupType[entry.attributes["GROUP-ID"]];
              rendition = {
                default: /yes/i.test(entry.attributes.DEFAULT)
              };
              if (rendition.default) {
                rendition.autoselect = true;
              } else {
                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);
              }
              if (entry.attributes.LANGUAGE) {
                rendition.language = entry.attributes.LANGUAGE;
              }
              if (entry.attributes.URI) {
                rendition.uri = entry.attributes.URI;
              }
              if (entry.attributes["INSTREAM-ID"]) {
                rendition.instreamId = entry.attributes["INSTREAM-ID"];
              }
              if (entry.attributes.CHARACTERISTICS) {
                rendition.characteristics = entry.attributes.CHARACTERISTICS;
              }
              if (entry.attributes.FORCED) {
                rendition.forced = /yes/i.test(entry.attributes.FORCED);
              }
              mediaGroup[entry.attributes.NAME] = rendition;
            },
            discontinuity: function discontinuity() {
              currentTimeline += 1;
              currentUri.discontinuity = true;
              this.manifest.discontinuityStarts.push(uris.length);
            },
            "program-date-time": function programDateTime() {
              if (typeof this.manifest.dateTimeString === "undefined") {
                this.manifest.dateTimeString = entry.dateTimeString;
                this.manifest.dateTimeObject = entry.dateTimeObject;
              }
              currentUri.dateTimeString = entry.dateTimeString;
              currentUri.dateTimeObject = entry.dateTimeObject;
            },
            targetduration: function targetduration() {
              if (!isFinite(entry.duration) || entry.duration < 0) {
                this.trigger("warn", {
                  message: "ignoring invalid target duration: " + entry.duration
                });
                return;
              }
              this.manifest.targetDuration = entry.duration;
              setHoldBack.call(this, this.manifest);
            },
            start: function start2() {
              if (!entry.attributes || isNaN(entry.attributes["TIME-OFFSET"])) {
                this.trigger("warn", {
                  message: "ignoring start declaration without appropriate attribute list"
                });
                return;
              }
              this.manifest.start = {
                timeOffset: entry.attributes["TIME-OFFSET"],
                precise: entry.attributes.PRECISE
              };
            },
            "cue-out": function cueOut() {
              currentUri.cueOut = entry.data;
            },
            "cue-out-cont": function cueOutCont() {
              currentUri.cueOutCont = entry.data;
            },
            "cue-in": function cueIn() {
              currentUri.cueIn = entry.data;
            },
            "skip": function skip() {
              this.manifest.skip = camelCaseKeys(entry.attributes);
              this.warnOnMissingAttributes_("#EXT-X-SKIP", entry.attributes, ["SKIPPED-SEGMENTS"]);
            },
            "part": function part() {
              var _this2 = this;
              hasParts = true;
              var segmentIndex = this.manifest.segments.length;
              var part2 = camelCaseKeys(entry.attributes);
              currentUri.parts = currentUri.parts || [];
              currentUri.parts.push(part2);
              if (part2.byterange) {
                if (!part2.byterange.hasOwnProperty("offset")) {
                  part2.byterange.offset = lastPartByterangeEnd;
                }
                lastPartByterangeEnd = part2.byterange.offset + part2.byterange.length;
              }
              var partIndex = currentUri.parts.length - 1;
              this.warnOnMissingAttributes_("#EXT-X-PART #" + partIndex + " for segment #" + segmentIndex, entry.attributes, ["URI", "DURATION"]);
              if (this.manifest.renditionReports) {
                this.manifest.renditionReports.forEach(function(r2, i) {
                  if (!r2.hasOwnProperty("lastPart")) {
                    _this2.trigger("warn", {
                      message: "#EXT-X-RENDITION-REPORT #" + i + " lacks required attribute(s): LAST-PART"
                    });
                  }
                });
              }
            },
            "server-control": function serverControl() {
              var attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);
              if (!attrs.hasOwnProperty("canBlockReload")) {
                attrs.canBlockReload = false;
                this.trigger("info", {
                  message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"
                });
              }
              setHoldBack.call(this, this.manifest);
              if (attrs.canSkipDateranges && !attrs.hasOwnProperty("canSkipUntil")) {
                this.trigger("warn", {
                  message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"
                });
              }
            },
            "preload-hint": function preloadHint() {
              var segmentIndex = this.manifest.segments.length;
              var hint = camelCaseKeys(entry.attributes);
              var isPart = hint.type && hint.type === "PART";
              currentUri.preloadHints = currentUri.preloadHints || [];
              currentUri.preloadHints.push(hint);
              if (hint.byterange) {
                if (!hint.byterange.hasOwnProperty("offset")) {
                  hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;
                  if (isPart) {
                    lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;
                  }
                }
              }
              var index = currentUri.preloadHints.length - 1;
              this.warnOnMissingAttributes_("#EXT-X-PRELOAD-HINT #" + index + " for segment #" + segmentIndex, entry.attributes, ["TYPE", "URI"]);
              if (!hint.type) {
                return;
              }
              for (var i = 0; i < currentUri.preloadHints.length - 1; i++) {
                var otherHint = currentUri.preloadHints[i];
                if (!otherHint.type) {
                  continue;
                }
                if (otherHint.type === hint.type) {
                  this.trigger("warn", {
                    message: "#EXT-X-PRELOAD-HINT #" + index + " for segment #" + segmentIndex + " has the same TYPE " + hint.type + " as preload hint #" + i
                  });
                }
              }
            },
            "rendition-report": function renditionReport() {
              var report = camelCaseKeys(entry.attributes);
              this.manifest.renditionReports = this.manifest.renditionReports || [];
              this.manifest.renditionReports.push(report);
              var index = this.manifest.renditionReports.length - 1;
              var required = ["LAST-MSN", "URI"];
              if (hasParts) {
                required.push("LAST-PART");
              }
              this.warnOnMissingAttributes_("#EXT-X-RENDITION-REPORT #" + index, entry.attributes, required);
            },
            "part-inf": function partInf() {
              this.manifest.partInf = camelCaseKeys(entry.attributes);
              this.warnOnMissingAttributes_("#EXT-X-PART-INF", entry.attributes, ["PART-TARGET"]);
              if (this.manifest.partInf.partTarget) {
                this.manifest.partTargetDuration = this.manifest.partInf.partTarget;
              }
              setHoldBack.call(this, this.manifest);
            }
          }[entry.tagType] || noop4).call(self2);
        },
        uri: function uri() {
          currentUri.uri = entry.uri;
          uris.push(currentUri);
          if (this.manifest.targetDuration && !("duration" in currentUri)) {
            this.trigger("warn", {
              message: "defaulting segment duration to the target duration"
            });
            currentUri.duration = this.manifest.targetDuration;
          }
          if (_key) {
            currentUri.key = _key;
          }
          currentUri.timeline = currentTimeline;
          if (currentMap) {
            currentUri.map = currentMap;
          }
          lastPartByterangeEnd = 0;
          currentUri = {};
        },
        comment: function comment() {
        },
        custom: function custom() {
          if (entry.segment) {
            currentUri.custom = currentUri.custom || {};
            currentUri.custom[entry.customType] = entry.data;
          } else {
            this.manifest.custom = this.manifest.custom || {};
            this.manifest.custom[entry.customType] = entry.data;
          }
        }
      })[entry.type].call(self2);
    });
    return _this;
  }
  var _proto = Parser2.prototype;
  _proto.warnOnMissingAttributes_ = function warnOnMissingAttributes_(identifier, attributes, required) {
    var missing = [];
    required.forEach(function(key) {
      if (!attributes.hasOwnProperty(key)) {
        missing.push(key);
      }
    });
    if (missing.length) {
      this.trigger("warn", {
        message: identifier + " lacks required attribute(s): " + missing.join(", ")
      });
    }
  };
  _proto.push = function push2(chunk) {
    this.lineStream.push(chunk);
  };
  _proto.end = function end() {
    this.lineStream.push("\n");
    this.trigger("end");
  };
  _proto.addParser = function addParser(options) {
    this.parseStream.addParser(options);
  };
  _proto.addTagMapper = function addTagMapper(options) {
    this.parseStream.addTagMapper(options);
  };
  return Parser2;
}(Stream);

// node_modules/.pnpm/@videojs+vhs-utils@3.0.5/node_modules/@videojs/vhs-utils/es/codecs.js
var import_window3 = __toESM(require_window());
var regexs = {
  // to determine mime types
  mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,
  webm: /^(vp0?[89]|av0?1|opus|vorbis)/,
  ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,
  // to determine if a codec is audio or video
  video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,
  audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,
  text: /^(stpp.ttml.im1t)/,
  // mux.js support regex
  muxerVideo: /^(avc0?1)/,
  muxerAudio: /^(mp4a)/,
  // match nothing as muxer does not support text right now.
  // there cannot never be a character before the start of a string
  // so this matches nothing.
  muxerText: /a^/
};
var mediaTypes = ["video", "audio", "text"];
var upperMediaTypes = ["Video", "Audio", "Text"];
var translateLegacyCodec = function translateLegacyCodec2(codec) {
  if (!codec) {
    return codec;
  }
  return codec.replace(/avc1\.(\d+)\.(\d+)/i, function(orig, profile, avcLevel) {
    var profileHex = ("00" + Number(profile).toString(16)).slice(-2);
    var avcLevelHex = ("00" + Number(avcLevel).toString(16)).slice(-2);
    return "avc1." + profileHex + "00" + avcLevelHex;
  });
};
var parseCodecs = function parseCodecs2(codecString) {
  if (codecString === void 0) {
    codecString = "";
  }
  var codecs = codecString.split(",");
  var result = [];
  codecs.forEach(function(codec) {
    codec = codec.trim();
    var codecType;
    mediaTypes.forEach(function(name) {
      var match = regexs[name].exec(codec.toLowerCase());
      if (!match || match.length <= 1) {
        return;
      }
      codecType = name;
      var type2 = codec.substring(0, match[1].length);
      var details = codec.replace(type2, "");
      result.push({
        type: type2,
        details,
        mediaType: name
      });
    });
    if (!codecType) {
      result.push({
        type: codec,
        details: "",
        mediaType: "unknown"
      });
    }
  });
  return result;
};
var codecsFromDefault = function codecsFromDefault2(master, audioGroupId) {
  if (!master.mediaGroups.AUDIO || !audioGroupId) {
    return null;
  }
  var audioGroup = master.mediaGroups.AUDIO[audioGroupId];
  if (!audioGroup) {
    return null;
  }
  for (var name in audioGroup) {
    var audioType = audioGroup[name];
    if (audioType.default && audioType.playlists) {
      return parseCodecs(audioType.playlists[0].attributes.CODECS);
    }
  }
  return null;
};
var isAudioCodec = function isAudioCodec2(codec) {
  if (codec === void 0) {
    codec = "";
  }
  return regexs.audio.test(codec.trim().toLowerCase());
};
var isTextCodec = function isTextCodec2(codec) {
  if (codec === void 0) {
    codec = "";
  }
  return regexs.text.test(codec.trim().toLowerCase());
};
var getMimeForCodec = function getMimeForCodec2(codecString) {
  if (!codecString || typeof codecString !== "string") {
    return;
  }
  var codecs = codecString.toLowerCase().split(",").map(function(c) {
    return translateLegacyCodec(c.trim());
  });
  var type2 = "video";
  if (codecs.length === 1 && isAudioCodec(codecs[0])) {
    type2 = "audio";
  } else if (codecs.length === 1 && isTextCodec(codecs[0])) {
    type2 = "application";
  }
  var container = "mp4";
  if (codecs.every(function(c) {
    return regexs.mp4.test(c);
  })) {
    container = "mp4";
  } else if (codecs.every(function(c) {
    return regexs.webm.test(c);
  })) {
    container = "webm";
  } else if (codecs.every(function(c) {
    return regexs.ogg.test(c);
  })) {
    container = "ogg";
  }
  return type2 + "/" + container + ';codecs="' + codecString + '"';
};
var browserSupportsCodec = function browserSupportsCodec2(codecString) {
  if (codecString === void 0) {
    codecString = "";
  }
  return import_window3.default.MediaSource && import_window3.default.MediaSource.isTypeSupported && import_window3.default.MediaSource.isTypeSupported(getMimeForCodec(codecString)) || false;
};
var muxerSupportsCodec = function muxerSupportsCodec2(codecString) {
  if (codecString === void 0) {
    codecString = "";
  }
  return codecString.toLowerCase().split(",").every(function(codec) {
    codec = codec.trim();
    for (var i = 0; i < upperMediaTypes.length; i++) {
      var type2 = upperMediaTypes[i];
      if (regexs["muxer" + type2].test(codec)) {
        return true;
      }
    }
    return false;
  });
};
var DEFAULT_AUDIO_CODEC = "mp4a.40.2";
var DEFAULT_VIDEO_CODEC = "avc1.4d400d";

// node_modules/.pnpm/@videojs+vhs-utils@3.0.5/node_modules/@videojs/vhs-utils/es/media-types.js
var MPEGURL_REGEX = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i;
var DASH_REGEX = /^application\/dash\+xml/i;
var simpleTypeFromSourceType = function simpleTypeFromSourceType2(type2) {
  if (MPEGURL_REGEX.test(type2)) {
    return "hls";
  }
  if (DASH_REGEX.test(type2)) {
    return "dash";
  }
  if (type2 === "application/vnd.videojs.vhs+json") {
    return "vhs-json";
  }
  return null;
};

// node_modules/.pnpm/@videojs+vhs-utils@3.0.5/node_modules/@videojs/vhs-utils/es/byte-helpers.js
var import_window4 = __toESM(require_window());
var countBits = function countBits2(x) {
  return x.toString(2).length;
};
var countBytes = function countBytes2(x) {
  return Math.ceil(countBits(x) / 8);
};
var isArrayBufferView = function isArrayBufferView2(obj) {
  if (ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(obj);
  }
  return obj && obj.buffer instanceof ArrayBuffer;
};
var isTypedArray = function isTypedArray2(obj) {
  return isArrayBufferView(obj);
};
var toUint8 = function toUint82(bytes) {
  if (bytes instanceof Uint8Array) {
    return bytes;
  }
  if (!Array.isArray(bytes) && !isTypedArray(bytes) && !(bytes instanceof ArrayBuffer)) {
    if (typeof bytes !== "number" || typeof bytes === "number" && bytes !== bytes) {
      bytes = 0;
    } else {
      bytes = [bytes];
    }
  }
  return new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);
};
var BigInt = import_window4.default.BigInt || Number;
var BYTE_TABLE = [BigInt("0x1"), BigInt("0x100"), BigInt("0x10000"), BigInt("0x1000000"), BigInt("0x100000000"), BigInt("0x10000000000"), BigInt("0x1000000000000"), BigInt("0x100000000000000"), BigInt("0x10000000000000000")];
var ENDIANNESS = function() {
  var a = new Uint16Array([65484]);
  var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
  if (b[0] === 255) {
    return "big";
  }
  if (b[0] === 204) {
    return "little";
  }
  return "unknown";
}();
var bytesToNumber = function bytesToNumber2(bytes, _temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$signed = _ref.signed, signed = _ref$signed === void 0 ? false : _ref$signed, _ref$le = _ref.le, le = _ref$le === void 0 ? false : _ref$le;
  bytes = toUint8(bytes);
  var fn = le ? "reduce" : "reduceRight";
  var obj = bytes[fn] ? bytes[fn] : Array.prototype[fn];
  var number = obj.call(bytes, function(total, byte, i) {
    var exponent = le ? i : Math.abs(i + 1 - bytes.length);
    return total + BigInt(byte) * BYTE_TABLE[exponent];
  }, BigInt(0));
  if (signed) {
    var max = BYTE_TABLE[bytes.length] / BigInt(2) - BigInt(1);
    number = BigInt(number);
    if (number > max) {
      number -= max;
      number -= max;
      number -= BigInt(2);
    }
  }
  return Number(number);
};
var numberToBytes = function numberToBytes2(number, _temp2) {
  var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$le = _ref2.le, le = _ref2$le === void 0 ? false : _ref2$le;
  if (typeof number !== "bigint" && typeof number !== "number" || typeof number === "number" && number !== number) {
    number = 0;
  }
  number = BigInt(number);
  var byteCount = countBytes(number);
  var bytes = new Uint8Array(new ArrayBuffer(byteCount));
  for (var i = 0; i < byteCount; i++) {
    var byteIndex = le ? i : Math.abs(i + 1 - bytes.length);
    bytes[byteIndex] = Number(number / BYTE_TABLE[i] & BigInt(255));
    if (number < 0) {
      bytes[byteIndex] = Math.abs(~bytes[byteIndex]);
      bytes[byteIndex] -= i === 0 ? 1 : 2;
    }
  }
  return bytes;
};
var bytesToString = function bytesToString2(bytes) {
  if (!bytes) {
    return "";
  }
  bytes = Array.prototype.slice.call(bytes);
  var string = String.fromCharCode.apply(null, toUint8(bytes));
  try {
    return decodeURIComponent(escape(string));
  } catch (e) {
  }
  return string;
};
var stringToBytes = function stringToBytes2(string, stringIsBytes) {
  if (typeof string !== "string" && string && typeof string.toString === "function") {
    string = string.toString();
  }
  if (typeof string !== "string") {
    return new Uint8Array();
  }
  if (!stringIsBytes) {
    string = unescape(encodeURIComponent(string));
  }
  var view = new Uint8Array(string.length);
  for (var i = 0; i < string.length; i++) {
    view[i] = string.charCodeAt(i);
  }
  return view;
};
var concatTypedArrays = function concatTypedArrays2() {
  for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {
    buffers[_key] = arguments[_key];
  }
  buffers = buffers.filter(function(b) {
    return b && (b.byteLength || b.length) && typeof b !== "string";
  });
  if (buffers.length <= 1) {
    return toUint8(buffers[0]);
  }
  var totalLen = buffers.reduce(function(total, buf, i) {
    return total + (buf.byteLength || buf.length);
  }, 0);
  var tempBuffer = new Uint8Array(totalLen);
  var offset = 0;
  buffers.forEach(function(buf) {
    buf = toUint8(buf);
    tempBuffer.set(buf, offset);
    offset += buf.byteLength;
  });
  return tempBuffer;
};
var bytesMatch = function bytesMatch2(a, b, _temp3) {
  var _ref3 = _temp3 === void 0 ? {} : _temp3, _ref3$offset = _ref3.offset, offset = _ref3$offset === void 0 ? 0 : _ref3$offset, _ref3$mask = _ref3.mask, mask = _ref3$mask === void 0 ? [] : _ref3$mask;
  a = toUint8(a);
  b = toUint8(b);
  var fn = b.every ? b.every : Array.prototype.every;
  return b.length && a.length - offset >= b.length && // ie 11 doesn't support every on uin8
  fn.call(b, function(bByte, i) {
    var aByte = mask[i] ? mask[i] & a[offset + i] : a[offset + i];
    return bByte === aByte;
  });
};

// node_modules/.pnpm/mpd-parser@0.21.1/node_modules/mpd-parser/dist/mpd-parser.es.js
var import_window5 = __toESM(require_window());

// node_modules/.pnpm/@videojs+vhs-utils@3.0.5/node_modules/@videojs/vhs-utils/es/media-groups.js
var forEachMediaGroup = function forEachMediaGroup2(master, groups, callback2) {
  groups.forEach(function(mediaType) {
    for (var groupKey in master.mediaGroups[mediaType]) {
      for (var labelKey in master.mediaGroups[mediaType][groupKey]) {
        var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];
        callback2(mediaProperties, mediaType, groupKey, labelKey);
      }
    }
  });
};

// node_modules/.pnpm/mpd-parser@0.21.1/node_modules/mpd-parser/dist/mpd-parser.es.js
var import_xmldom = __toESM(require_lib2());
var isObject = function isObject2(obj) {
  return !!obj && typeof obj === "object";
};
var merge = function merge2() {
  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
    objects[_key] = arguments[_key];
  }
  return objects.reduce(function(result, source) {
    if (typeof source !== "object") {
      return result;
    }
    Object.keys(source).forEach(function(key) {
      if (Array.isArray(result[key]) && Array.isArray(source[key])) {
        result[key] = result[key].concat(source[key]);
      } else if (isObject(result[key]) && isObject(source[key])) {
        result[key] = merge2(result[key], source[key]);
      } else {
        result[key] = source[key];
      }
    });
    return result;
  }, {});
};
var values = function values2(o) {
  return Object.keys(o).map(function(k) {
    return o[k];
  });
};
var range = function range2(start2, end) {
  var result = [];
  for (var i = start2; i < end; i++) {
    result.push(i);
  }
  return result;
};
var flatten = function flatten2(lists) {
  return lists.reduce(function(x, y) {
    return x.concat(y);
  }, []);
};
var from = function from2(list) {
  if (!list.length) {
    return [];
  }
  var result = [];
  for (var i = 0; i < list.length; i++) {
    result.push(list[i]);
  }
  return result;
};
var findIndexes = function findIndexes2(l, key) {
  return l.reduce(function(a, e, i) {
    if (e[key]) {
      a.push(i);
    }
    return a;
  }, []);
};
var findIndex = function findIndex2(list, matchingFunction) {
  for (var i = 0; i < list.length; i++) {
    if (matchingFunction(list[i])) {
      return i;
    }
  }
  return -1;
};
var union = function union2(lists, keyFunction) {
  return values(lists.reduce(function(acc, list) {
    list.forEach(function(el) {
      acc[keyFunction(el)] = el;
    });
    return acc;
  }, {}));
};
var errors = {
  INVALID_NUMBER_OF_PERIOD: "INVALID_NUMBER_OF_PERIOD",
  DASH_EMPTY_MANIFEST: "DASH_EMPTY_MANIFEST",
  DASH_INVALID_XML: "DASH_INVALID_XML",
  NO_BASE_URL: "NO_BASE_URL",
  MISSING_SEGMENT_INFORMATION: "MISSING_SEGMENT_INFORMATION",
  SEGMENT_TIME_UNSPECIFIED: "SEGMENT_TIME_UNSPECIFIED",
  UNSUPPORTED_UTC_TIMING_SCHEME: "UNSUPPORTED_UTC_TIMING_SCHEME"
};
var urlTypeToSegment = function urlTypeToSegment2(_ref) {
  var _ref$baseUrl = _ref.baseUrl, baseUrl = _ref$baseUrl === void 0 ? "" : _ref$baseUrl, _ref$source = _ref.source, source = _ref$source === void 0 ? "" : _ref$source, _ref$range = _ref.range, range3 = _ref$range === void 0 ? "" : _ref$range, _ref$indexRange = _ref.indexRange, indexRange = _ref$indexRange === void 0 ? "" : _ref$indexRange;
  var segment = {
    uri: source,
    resolvedUri: resolve_url_default(baseUrl || "", source)
  };
  if (range3 || indexRange) {
    var rangeStr = range3 ? range3 : indexRange;
    var ranges = rangeStr.split("-");
    var startRange = import_window5.default.BigInt ? import_window5.default.BigInt(ranges[0]) : parseInt(ranges[0], 10);
    var endRange = import_window5.default.BigInt ? import_window5.default.BigInt(ranges[1]) : parseInt(ranges[1], 10);
    if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === "bigint") {
      startRange = Number(startRange);
    }
    if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === "bigint") {
      endRange = Number(endRange);
    }
    var length;
    if (typeof endRange === "bigint" || typeof startRange === "bigint") {
      length = import_window5.default.BigInt(endRange) - import_window5.default.BigInt(startRange) + import_window5.default.BigInt(1);
    } else {
      length = endRange - startRange + 1;
    }
    if (typeof length === "bigint" && length < Number.MAX_SAFE_INTEGER) {
      length = Number(length);
    }
    segment.byterange = {
      length,
      offset: startRange
    };
  }
  return segment;
};
var byteRangeToString = function byteRangeToString2(byterange) {
  var endRange;
  if (typeof byterange.offset === "bigint" || typeof byterange.length === "bigint") {
    endRange = import_window5.default.BigInt(byterange.offset) + import_window5.default.BigInt(byterange.length) - import_window5.default.BigInt(1);
  } else {
    endRange = byterange.offset + byterange.length - 1;
  }
  return byterange.offset + "-" + endRange;
};
var parseEndNumber = function parseEndNumber2(endNumber) {
  if (endNumber && typeof endNumber !== "number") {
    endNumber = parseInt(endNumber, 10);
  }
  if (isNaN(endNumber)) {
    return null;
  }
  return endNumber;
};
var segmentRange = {
  /**
   * Returns the entire range of available segments for a static MPD
   *
   * @param {Object} attributes
   *        Inheritied MPD attributes
   * @return {{ start: number, end: number }}
   *         The start and end numbers for available segments
   */
  static: function _static(attributes) {
    var duration5 = attributes.duration, _attributes$timescale = attributes.timescale, timescale2 = _attributes$timescale === void 0 ? 1 : _attributes$timescale, sourceDuration = attributes.sourceDuration, periodDuration = attributes.periodDuration;
    var endNumber = parseEndNumber(attributes.endNumber);
    var segmentDuration = duration5 / timescale2;
    if (typeof endNumber === "number") {
      return {
        start: 0,
        end: endNumber
      };
    }
    if (typeof periodDuration === "number") {
      return {
        start: 0,
        end: periodDuration / segmentDuration
      };
    }
    return {
      start: 0,
      end: sourceDuration / segmentDuration
    };
  },
  /**
   * Returns the current live window range of available segments for a dynamic MPD
   *
   * @param {Object} attributes
   *        Inheritied MPD attributes
   * @return {{ start: number, end: number }}
   *         The start and end numbers for available segments
   */
  dynamic: function dynamic(attributes) {
    var NOW = attributes.NOW, clientOffset = attributes.clientOffset, availabilityStartTime2 = attributes.availabilityStartTime, _attributes$timescale2 = attributes.timescale, timescale2 = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2, duration5 = attributes.duration, _attributes$periodSta = attributes.periodStart, periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta, _attributes$minimumUp = attributes.minimumUpdatePeriod, minimumUpdatePeriod2 = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp, _attributes$timeShift = attributes.timeShiftBufferDepth, timeShiftBufferDepth2 = _attributes$timeShift === void 0 ? Infinity : _attributes$timeShift;
    var endNumber = parseEndNumber(attributes.endNumber);
    var now2 = (NOW + clientOffset) / 1e3;
    var periodStartWC = availabilityStartTime2 + periodStart;
    var periodEndWC = now2 + minimumUpdatePeriod2;
    var periodDuration = periodEndWC - periodStartWC;
    var segmentCount = Math.ceil(periodDuration * timescale2 / duration5);
    var availableStart = Math.floor((now2 - periodStartWC - timeShiftBufferDepth2) * timescale2 / duration5);
    var availableEnd = Math.floor((now2 - periodStartWC) * timescale2 / duration5);
    return {
      start: Math.max(0, availableStart),
      end: typeof endNumber === "number" ? endNumber : Math.min(segmentCount, availableEnd)
    };
  }
};
var toSegments = function toSegments2(attributes) {
  return function(number) {
    var duration5 = attributes.duration, _attributes$timescale3 = attributes.timescale, timescale2 = _attributes$timescale3 === void 0 ? 1 : _attributes$timescale3, periodStart = attributes.periodStart, _attributes$startNumb = attributes.startNumber, startNumber2 = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb;
    return {
      number: startNumber2 + number,
      duration: duration5 / timescale2,
      timeline: periodStart,
      time: number * duration5
    };
  };
};
var parseByDuration = function parseByDuration2(attributes) {
  var type2 = attributes.type, duration5 = attributes.duration, _attributes$timescale4 = attributes.timescale, timescale2 = _attributes$timescale4 === void 0 ? 1 : _attributes$timescale4, periodDuration = attributes.periodDuration, sourceDuration = attributes.sourceDuration;
  var _segmentRange$type = segmentRange[type2](attributes), start2 = _segmentRange$type.start, end = _segmentRange$type.end;
  var segments = range(start2, end).map(toSegments(attributes));
  if (type2 === "static") {
    var index = segments.length - 1;
    var sectionDuration = typeof periodDuration === "number" ? periodDuration : sourceDuration;
    segments[index].duration = sectionDuration - duration5 / timescale2 * index;
  }
  return segments;
};
var segmentsFromBase = function segmentsFromBase2(attributes) {
  var baseUrl = attributes.baseUrl, _attributes$initializ = attributes.initialization, initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ, sourceDuration = attributes.sourceDuration, _attributes$indexRang = attributes.indexRange, indexRange = _attributes$indexRang === void 0 ? "" : _attributes$indexRang, periodStart = attributes.periodStart, presentationTime = attributes.presentationTime, _attributes$number = attributes.number, number = _attributes$number === void 0 ? 0 : _attributes$number, duration5 = attributes.duration;
  if (!baseUrl) {
    throw new Error(errors.NO_BASE_URL);
  }
  var initSegment = urlTypeToSegment({
    baseUrl,
    source: initialization.sourceURL,
    range: initialization.range
  });
  var segment = urlTypeToSegment({
    baseUrl,
    source: baseUrl,
    indexRange
  });
  segment.map = initSegment;
  if (duration5) {
    var segmentTimeInfo = parseByDuration(attributes);
    if (segmentTimeInfo.length) {
      segment.duration = segmentTimeInfo[0].duration;
      segment.timeline = segmentTimeInfo[0].timeline;
    }
  } else if (sourceDuration) {
    segment.duration = sourceDuration;
    segment.timeline = periodStart;
  }
  segment.presentationTime = presentationTime || periodStart;
  segment.number = number;
  return [segment];
};
var addSidxSegmentsToPlaylist$1 = function addSidxSegmentsToPlaylist(playlist, sidx, baseUrl) {
  var initSegment = playlist.sidx.map ? playlist.sidx.map : null;
  var sourceDuration = playlist.sidx.duration;
  var timeline = playlist.timeline || 0;
  var sidxByteRange = playlist.sidx.byterange;
  var sidxEnd = sidxByteRange.offset + sidxByteRange.length;
  var timescale2 = sidx.timescale;
  var mediaReferences = sidx.references.filter(function(r2) {
    return r2.referenceType !== 1;
  });
  var segments = [];
  var type2 = playlist.endList ? "static" : "dynamic";
  var periodStart = playlist.sidx.timeline;
  var presentationTime = periodStart;
  var number = playlist.mediaSequence || 0;
  var startIndex;
  if (typeof sidx.firstOffset === "bigint") {
    startIndex = import_window5.default.BigInt(sidxEnd) + sidx.firstOffset;
  } else {
    startIndex = sidxEnd + sidx.firstOffset;
  }
  for (var i = 0; i < mediaReferences.length; i++) {
    var reference = sidx.references[i];
    var size = reference.referencedSize;
    var duration5 = reference.subsegmentDuration;
    var endIndex = void 0;
    if (typeof startIndex === "bigint") {
      endIndex = startIndex + import_window5.default.BigInt(size) - import_window5.default.BigInt(1);
    } else {
      endIndex = startIndex + size - 1;
    }
    var indexRange = startIndex + "-" + endIndex;
    var attributes = {
      baseUrl,
      timescale: timescale2,
      timeline,
      periodStart,
      presentationTime,
      number,
      duration: duration5,
      sourceDuration,
      indexRange,
      type: type2
    };
    var segment = segmentsFromBase(attributes)[0];
    if (initSegment) {
      segment.map = initSegment;
    }
    segments.push(segment);
    if (typeof startIndex === "bigint") {
      startIndex += import_window5.default.BigInt(size);
    } else {
      startIndex += size;
    }
    presentationTime += duration5 / timescale2;
    number++;
  }
  playlist.segments = segments;
  return playlist;
};
var SUPPORTED_MEDIA_TYPES = ["AUDIO", "SUBTITLES"];
var TIME_FUDGE = 1 / 60;
var getUniqueTimelineStarts = function getUniqueTimelineStarts2(timelineStarts) {
  return union(timelineStarts, function(_ref) {
    var timeline = _ref.timeline;
    return timeline;
  }).sort(function(a, b) {
    return a.timeline > b.timeline ? 1 : -1;
  });
};
var findPlaylistWithName = function findPlaylistWithName2(playlists, name) {
  for (var i = 0; i < playlists.length; i++) {
    if (playlists[i].attributes.NAME === name) {
      return playlists[i];
    }
  }
  return null;
};
var getMediaGroupPlaylists = function getMediaGroupPlaylists2(manifest) {
  var mediaGroupPlaylists = [];
  forEachMediaGroup(manifest, SUPPORTED_MEDIA_TYPES, function(properties, type2, group, label) {
    mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);
  });
  return mediaGroupPlaylists;
};
var updateMediaSequenceForPlaylist = function updateMediaSequenceForPlaylist2(_ref2) {
  var playlist = _ref2.playlist, mediaSequence = _ref2.mediaSequence;
  playlist.mediaSequence = mediaSequence;
  playlist.segments.forEach(function(segment, index) {
    segment.number = playlist.mediaSequence + index;
  });
};
var updateSequenceNumbers = function updateSequenceNumbers2(_ref3) {
  var oldPlaylists = _ref3.oldPlaylists, newPlaylists = _ref3.newPlaylists, timelineStarts = _ref3.timelineStarts;
  newPlaylists.forEach(function(playlist) {
    playlist.discontinuitySequence = findIndex(timelineStarts, function(_ref4) {
      var timeline = _ref4.timeline;
      return timeline === playlist.timeline;
    });
    var oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);
    if (!oldPlaylist) {
      return;
    }
    if (playlist.sidx) {
      return;
    }
    var firstNewSegment = playlist.segments[0];
    var oldMatchingSegmentIndex = findIndex(oldPlaylist.segments, function(oldSegment) {
      return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;
    });
    if (oldMatchingSegmentIndex === -1) {
      updateMediaSequenceForPlaylist({
        playlist,
        mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length
      });
      playlist.segments[0].discontinuity = true;
      playlist.discontinuityStarts.unshift(0);
      if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {
        playlist.discontinuitySequence--;
      }
      return;
    }
    var oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];
    if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {
      firstNewSegment.discontinuity = true;
      playlist.discontinuityStarts.unshift(0);
      playlist.discontinuitySequence--;
    }
    updateMediaSequenceForPlaylist({
      playlist,
      mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number
    });
  });
};
var positionManifestOnTimeline = function positionManifestOnTimeline2(_ref5) {
  var oldManifest = _ref5.oldManifest, newManifest = _ref5.newManifest;
  var oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));
  var newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest));
  newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);
  updateSequenceNumbers({
    oldPlaylists,
    newPlaylists,
    timelineStarts: newManifest.timelineStarts
  });
  return newManifest;
};
var generateSidxKey = function generateSidxKey2(sidx) {
  return sidx && sidx.uri + "-" + byteRangeToString(sidx.byterange);
};
var mergeDiscontiguousPlaylists = function mergeDiscontiguousPlaylists2(playlists) {
  var mergedPlaylists = values(playlists.reduce(function(acc, playlist) {
    var name = playlist.attributes.id + (playlist.attributes.lang || "");
    if (!acc[name]) {
      acc[name] = playlist;
      acc[name].attributes.timelineStarts = [];
    } else {
      if (playlist.segments) {
        var _acc$name$segments;
        if (playlist.segments[0]) {
          playlist.segments[0].discontinuity = true;
        }
        (_acc$name$segments = acc[name].segments).push.apply(_acc$name$segments, playlist.segments);
      }
      if (playlist.attributes.contentProtection) {
        acc[name].attributes.contentProtection = playlist.attributes.contentProtection;
      }
    }
    acc[name].attributes.timelineStarts.push({
      // Although they represent the same number, it's important to have both to make it
      // compatible with HLS potentially having a similar attribute.
      start: playlist.attributes.periodStart,
      timeline: playlist.attributes.periodStart
    });
    return acc;
  }, {}));
  return mergedPlaylists.map(function(playlist) {
    playlist.discontinuityStarts = findIndexes(playlist.segments || [], "discontinuity");
    return playlist;
  });
};
var addSidxSegmentsToPlaylist2 = function addSidxSegmentsToPlaylist3(playlist, sidxMapping) {
  var sidxKey = generateSidxKey(playlist.sidx);
  var sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;
  if (sidxMatch) {
    addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);
  }
  return playlist;
};
var addSidxSegmentsToPlaylists = function addSidxSegmentsToPlaylists2(playlists, sidxMapping) {
  if (sidxMapping === void 0) {
    sidxMapping = {};
  }
  if (!Object.keys(sidxMapping).length) {
    return playlists;
  }
  for (var i in playlists) {
    playlists[i] = addSidxSegmentsToPlaylist2(playlists[i], sidxMapping);
  }
  return playlists;
};
var formatAudioPlaylist = function formatAudioPlaylist2(_ref, isAudioOnly3) {
  var _attributes;
  var attributes = _ref.attributes, segments = _ref.segments, sidx = _ref.sidx, mediaSequence = _ref.mediaSequence, discontinuitySequence = _ref.discontinuitySequence, discontinuityStarts = _ref.discontinuityStarts;
  var playlist = {
    attributes: (_attributes = {
      NAME: attributes.id,
      BANDWIDTH: attributes.bandwidth,
      CODECS: attributes.codecs
    }, _attributes["PROGRAM-ID"] = 1, _attributes),
    uri: "",
    endList: attributes.type === "static",
    timeline: attributes.periodStart,
    resolvedUri: "",
    targetDuration: attributes.duration,
    discontinuitySequence,
    discontinuityStarts,
    timelineStarts: attributes.timelineStarts,
    mediaSequence,
    segments
  };
  if (attributes.contentProtection) {
    playlist.contentProtection = attributes.contentProtection;
  }
  if (sidx) {
    playlist.sidx = sidx;
  }
  if (isAudioOnly3) {
    playlist.attributes.AUDIO = "audio";
    playlist.attributes.SUBTITLES = "subs";
  }
  return playlist;
};
var formatVttPlaylist = function formatVttPlaylist2(_ref2) {
  var _m3u8Attributes;
  var attributes = _ref2.attributes, segments = _ref2.segments, mediaSequence = _ref2.mediaSequence, discontinuityStarts = _ref2.discontinuityStarts, discontinuitySequence = _ref2.discontinuitySequence;
  if (typeof segments === "undefined") {
    segments = [{
      uri: attributes.baseUrl,
      timeline: attributes.periodStart,
      resolvedUri: attributes.baseUrl || "",
      duration: attributes.sourceDuration,
      number: 0
    }];
    attributes.duration = attributes.sourceDuration;
  }
  var m3u8Attributes = (_m3u8Attributes = {
    NAME: attributes.id,
    BANDWIDTH: attributes.bandwidth
  }, _m3u8Attributes["PROGRAM-ID"] = 1, _m3u8Attributes);
  if (attributes.codecs) {
    m3u8Attributes.CODECS = attributes.codecs;
  }
  return {
    attributes: m3u8Attributes,
    uri: "",
    endList: attributes.type === "static",
    timeline: attributes.periodStart,
    resolvedUri: attributes.baseUrl || "",
    targetDuration: attributes.duration,
    timelineStarts: attributes.timelineStarts,
    discontinuityStarts,
    discontinuitySequence,
    mediaSequence,
    segments
  };
};
var organizeAudioPlaylists = function organizeAudioPlaylists2(playlists, sidxMapping, isAudioOnly3) {
  if (sidxMapping === void 0) {
    sidxMapping = {};
  }
  if (isAudioOnly3 === void 0) {
    isAudioOnly3 = false;
  }
  var mainPlaylist;
  var formattedPlaylists = playlists.reduce(function(a, playlist) {
    var role = playlist.attributes.role && playlist.attributes.role.value || "";
    var language = playlist.attributes.lang || "";
    var label = playlist.attributes.label || "main";
    if (language && !playlist.attributes.label) {
      var roleLabel = role ? " (" + role + ")" : "";
      label = "" + playlist.attributes.lang + roleLabel;
    }
    if (!a[label]) {
      a[label] = {
        language,
        autoselect: true,
        default: role === "main",
        playlists: [],
        uri: ""
      };
    }
    var formatted = addSidxSegmentsToPlaylist2(formatAudioPlaylist(playlist, isAudioOnly3), sidxMapping);
    a[label].playlists.push(formatted);
    if (typeof mainPlaylist === "undefined" && role === "main") {
      mainPlaylist = playlist;
      mainPlaylist.default = true;
    }
    return a;
  }, {});
  if (!mainPlaylist) {
    var firstLabel = Object.keys(formattedPlaylists)[0];
    formattedPlaylists[firstLabel].default = true;
  }
  return formattedPlaylists;
};
var organizeVttPlaylists = function organizeVttPlaylists2(playlists, sidxMapping) {
  if (sidxMapping === void 0) {
    sidxMapping = {};
  }
  return playlists.reduce(function(a, playlist) {
    var label = playlist.attributes.lang || "text";
    if (!a[label]) {
      a[label] = {
        language: label,
        default: false,
        autoselect: false,
        playlists: [],
        uri: ""
      };
    }
    a[label].playlists.push(addSidxSegmentsToPlaylist2(formatVttPlaylist(playlist), sidxMapping));
    return a;
  }, {});
};
var organizeCaptionServices = function organizeCaptionServices2(captionServices) {
  return captionServices.reduce(function(svcObj, svc) {
    if (!svc) {
      return svcObj;
    }
    svc.forEach(function(service) {
      var channel = service.channel, language = service.language;
      svcObj[language] = {
        autoselect: false,
        default: false,
        instreamId: channel,
        language
      };
      if (service.hasOwnProperty("aspectRatio")) {
        svcObj[language].aspectRatio = service.aspectRatio;
      }
      if (service.hasOwnProperty("easyReader")) {
        svcObj[language].easyReader = service.easyReader;
      }
      if (service.hasOwnProperty("3D")) {
        svcObj[language]["3D"] = service["3D"];
      }
    });
    return svcObj;
  }, {});
};
var formatVideoPlaylist = function formatVideoPlaylist2(_ref3) {
  var _attributes2;
  var attributes = _ref3.attributes, segments = _ref3.segments, sidx = _ref3.sidx, discontinuityStarts = _ref3.discontinuityStarts;
  var playlist = {
    attributes: (_attributes2 = {
      NAME: attributes.id,
      AUDIO: "audio",
      SUBTITLES: "subs",
      RESOLUTION: {
        width: attributes.width,
        height: attributes.height
      },
      CODECS: attributes.codecs,
      BANDWIDTH: attributes.bandwidth
    }, _attributes2["PROGRAM-ID"] = 1, _attributes2),
    uri: "",
    endList: attributes.type === "static",
    timeline: attributes.periodStart,
    resolvedUri: "",
    targetDuration: attributes.duration,
    discontinuityStarts,
    timelineStarts: attributes.timelineStarts,
    segments
  };
  if (attributes.contentProtection) {
    playlist.contentProtection = attributes.contentProtection;
  }
  if (sidx) {
    playlist.sidx = sidx;
  }
  return playlist;
};
var videoOnly = function videoOnly2(_ref4) {
  var attributes = _ref4.attributes;
  return attributes.mimeType === "video/mp4" || attributes.mimeType === "video/webm" || attributes.contentType === "video";
};
var audioOnly = function audioOnly2(_ref5) {
  var attributes = _ref5.attributes;
  return attributes.mimeType === "audio/mp4" || attributes.mimeType === "audio/webm" || attributes.contentType === "audio";
};
var vttOnly = function vttOnly2(_ref6) {
  var attributes = _ref6.attributes;
  return attributes.mimeType === "text/vtt" || attributes.contentType === "text";
};
var addMediaSequenceValues = function addMediaSequenceValues2(playlists, timelineStarts) {
  playlists.forEach(function(playlist) {
    playlist.mediaSequence = 0;
    playlist.discontinuitySequence = findIndex(timelineStarts, function(_ref7) {
      var timeline = _ref7.timeline;
      return timeline === playlist.timeline;
    });
    if (!playlist.segments) {
      return;
    }
    playlist.segments.forEach(function(segment, index) {
      segment.number = index;
    });
  });
};
var flattenMediaGroupPlaylists = function flattenMediaGroupPlaylists2(mediaGroupObject) {
  if (!mediaGroupObject) {
    return [];
  }
  return Object.keys(mediaGroupObject).reduce(function(acc, label) {
    var labelContents = mediaGroupObject[label];
    return acc.concat(labelContents.playlists);
  }, []);
};
var toM3u8 = function toM3u82(_ref8) {
  var _mediaGroups;
  var dashPlaylists = _ref8.dashPlaylists, locations = _ref8.locations, _ref8$sidxMapping = _ref8.sidxMapping, sidxMapping = _ref8$sidxMapping === void 0 ? {} : _ref8$sidxMapping, previousManifest = _ref8.previousManifest;
  if (!dashPlaylists.length) {
    return {};
  }
  var _dashPlaylists$0$attr = dashPlaylists[0].attributes, duration5 = _dashPlaylists$0$attr.sourceDuration, type2 = _dashPlaylists$0$attr.type, suggestedPresentationDelay2 = _dashPlaylists$0$attr.suggestedPresentationDelay, minimumUpdatePeriod2 = _dashPlaylists$0$attr.minimumUpdatePeriod;
  var videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);
  var audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));
  var vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));
  var captions = dashPlaylists.map(function(playlist) {
    return playlist.attributes.captionServices;
  }).filter(Boolean);
  var manifest = {
    allowCache: true,
    discontinuityStarts: [],
    segments: [],
    endList: true,
    mediaGroups: (_mediaGroups = {
      AUDIO: {},
      VIDEO: {}
    }, _mediaGroups["CLOSED-CAPTIONS"] = {}, _mediaGroups.SUBTITLES = {}, _mediaGroups),
    uri: "",
    duration: duration5,
    playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)
  };
  if (minimumUpdatePeriod2 >= 0) {
    manifest.minimumUpdatePeriod = minimumUpdatePeriod2 * 1e3;
  }
  if (locations) {
    manifest.locations = locations;
  }
  if (type2 === "dynamic") {
    manifest.suggestedPresentationDelay = suggestedPresentationDelay2;
  }
  var isAudioOnly3 = manifest.playlists.length === 0;
  var organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly3) : null;
  var organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;
  var formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));
  var playlistTimelineStarts = formattedPlaylists.map(function(_ref9) {
    var timelineStarts = _ref9.timelineStarts;
    return timelineStarts;
  });
  manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);
  addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);
  if (organizedAudioGroup) {
    manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;
  }
  if (organizedVttGroup) {
    manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;
  }
  if (captions.length) {
    manifest.mediaGroups["CLOSED-CAPTIONS"].cc = organizeCaptionServices(captions);
  }
  if (previousManifest) {
    return positionManifestOnTimeline({
      oldManifest: previousManifest,
      newManifest: manifest
    });
  }
  return manifest;
};
var getLiveRValue = function getLiveRValue2(attributes, time, duration5) {
  var NOW = attributes.NOW, clientOffset = attributes.clientOffset, availabilityStartTime2 = attributes.availabilityStartTime, _attributes$timescale = attributes.timescale, timescale2 = _attributes$timescale === void 0 ? 1 : _attributes$timescale, _attributes$periodSta = attributes.periodStart, periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta, _attributes$minimumUp = attributes.minimumUpdatePeriod, minimumUpdatePeriod2 = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp;
  var now2 = (NOW + clientOffset) / 1e3;
  var periodStartWC = availabilityStartTime2 + periodStart;
  var periodEndWC = now2 + minimumUpdatePeriod2;
  var periodDuration = periodEndWC - periodStartWC;
  return Math.ceil((periodDuration * timescale2 - time) / duration5);
};
var parseByTimeline = function parseByTimeline2(attributes, segmentTimeline) {
  var type2 = attributes.type, _attributes$minimumUp2 = attributes.minimumUpdatePeriod, minimumUpdatePeriod2 = _attributes$minimumUp2 === void 0 ? 0 : _attributes$minimumUp2, _attributes$media = attributes.media, media = _attributes$media === void 0 ? "" : _attributes$media, sourceDuration = attributes.sourceDuration, _attributes$timescale2 = attributes.timescale, timescale2 = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2, _attributes$startNumb = attributes.startNumber, startNumber2 = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb, timeline = attributes.periodStart;
  var segments = [];
  var time = -1;
  for (var sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {
    var S = segmentTimeline[sIndex];
    var duration5 = S.d;
    var repeat = S.r || 0;
    var segmentTime = S.t || 0;
    if (time < 0) {
      time = segmentTime;
    }
    if (segmentTime && segmentTime > time) {
      time = segmentTime;
    }
    var count = void 0;
    if (repeat < 0) {
      var nextS = sIndex + 1;
      if (nextS === segmentTimeline.length) {
        if (type2 === "dynamic" && minimumUpdatePeriod2 > 0 && media.indexOf("$Number$") > 0) {
          count = getLiveRValue(attributes, time, duration5);
        } else {
          count = (sourceDuration * timescale2 - time) / duration5;
        }
      } else {
        count = (segmentTimeline[nextS].t - time) / duration5;
      }
    } else {
      count = repeat + 1;
    }
    var end = startNumber2 + segments.length + count;
    var number = startNumber2 + segments.length;
    while (number < end) {
      segments.push({
        number,
        duration: duration5 / timescale2,
        time,
        timeline
      });
      time += duration5;
      number++;
    }
  }
  return segments;
};
var identifierPattern = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g;
var identifierReplacement = function identifierReplacement2(values3) {
  return function(match, identifier, format, width2) {
    if (match === "$$") {
      return "$";
    }
    if (typeof values3[identifier] === "undefined") {
      return match;
    }
    var value = "" + values3[identifier];
    if (identifier === "RepresentationID") {
      return value;
    }
    if (!format) {
      width2 = 1;
    } else {
      width2 = parseInt(width2, 10);
    }
    if (value.length >= width2) {
      return value;
    }
    return "" + new Array(width2 - value.length + 1).join("0") + value;
  };
};
var constructTemplateUrl = function constructTemplateUrl2(url, values3) {
  return url.replace(identifierPattern, identifierReplacement(values3));
};
var parseTemplateInfo = function parseTemplateInfo2(attributes, segmentTimeline) {
  if (!attributes.duration && !segmentTimeline) {
    return [{
      number: attributes.startNumber || 1,
      duration: attributes.sourceDuration,
      time: 0,
      timeline: attributes.periodStart
    }];
  }
  if (attributes.duration) {
    return parseByDuration(attributes);
  }
  return parseByTimeline(attributes, segmentTimeline);
};
var segmentsFromTemplate = function segmentsFromTemplate2(attributes, segmentTimeline) {
  var templateValues = {
    RepresentationID: attributes.id,
    Bandwidth: attributes.bandwidth || 0
  };
  var _attributes$initializ = attributes.initialization, initialization = _attributes$initializ === void 0 ? {
    sourceURL: "",
    range: ""
  } : _attributes$initializ;
  var mapSegment = urlTypeToSegment({
    baseUrl: attributes.baseUrl,
    source: constructTemplateUrl(initialization.sourceURL, templateValues),
    range: initialization.range
  });
  var segments = parseTemplateInfo(attributes, segmentTimeline);
  return segments.map(function(segment) {
    templateValues.Number = segment.number;
    templateValues.Time = segment.time;
    var uri = constructTemplateUrl(attributes.media || "", templateValues);
    var timescale2 = attributes.timescale || 1;
    var presentationTimeOffset2 = attributes.presentationTimeOffset || 0;
    var presentationTime = (
      // Even if the @t attribute is not specified for the segment, segment.time is
      // calculated in mpd-parser prior to this, so it's assumed to be available.
      attributes.periodStart + (segment.time - presentationTimeOffset2) / timescale2
    );
    var map = {
      uri,
      timeline: segment.timeline,
      duration: segment.duration,
      resolvedUri: resolve_url_default(attributes.baseUrl || "", uri),
      map: mapSegment,
      number: segment.number,
      presentationTime
    };
    return map;
  });
};
var SegmentURLToSegmentObject = function SegmentURLToSegmentObject2(attributes, segmentUrl) {
  var baseUrl = attributes.baseUrl, _attributes$initializ = attributes.initialization, initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ;
  var initSegment = urlTypeToSegment({
    baseUrl,
    source: initialization.sourceURL,
    range: initialization.range
  });
  var segment = urlTypeToSegment({
    baseUrl,
    source: segmentUrl.media,
    range: segmentUrl.mediaRange
  });
  segment.map = initSegment;
  return segment;
};
var segmentsFromList = function segmentsFromList2(attributes, segmentTimeline) {
  var duration5 = attributes.duration, _attributes$segmentUr = attributes.segmentUrls, segmentUrls = _attributes$segmentUr === void 0 ? [] : _attributes$segmentUr, periodStart = attributes.periodStart;
  if (!duration5 && !segmentTimeline || duration5 && segmentTimeline) {
    throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);
  }
  var segmentUrlMap = segmentUrls.map(function(segmentUrlObject) {
    return SegmentURLToSegmentObject(attributes, segmentUrlObject);
  });
  var segmentTimeInfo;
  if (duration5) {
    segmentTimeInfo = parseByDuration(attributes);
  }
  if (segmentTimeline) {
    segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);
  }
  var segments = segmentTimeInfo.map(function(segmentTime, index) {
    if (segmentUrlMap[index]) {
      var segment = segmentUrlMap[index];
      var timescale2 = attributes.timescale || 1;
      var presentationTimeOffset2 = attributes.presentationTimeOffset || 0;
      segment.timeline = segmentTime.timeline;
      segment.duration = segmentTime.duration;
      segment.number = segmentTime.number;
      segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset2) / timescale2;
      return segment;
    }
  }).filter(function(segment) {
    return segment;
  });
  return segments;
};
var generateSegments = function generateSegments2(_ref) {
  var attributes = _ref.attributes, segmentInfo = _ref.segmentInfo;
  var segmentAttributes;
  var segmentsFn;
  if (segmentInfo.template) {
    segmentsFn = segmentsFromTemplate;
    segmentAttributes = merge(attributes, segmentInfo.template);
  } else if (segmentInfo.base) {
    segmentsFn = segmentsFromBase;
    segmentAttributes = merge(attributes, segmentInfo.base);
  } else if (segmentInfo.list) {
    segmentsFn = segmentsFromList;
    segmentAttributes = merge(attributes, segmentInfo.list);
  }
  var segmentsInfo = {
    attributes
  };
  if (!segmentsFn) {
    return segmentsInfo;
  }
  var segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline);
  if (segmentAttributes.duration) {
    var _segmentAttributes = segmentAttributes, duration5 = _segmentAttributes.duration, _segmentAttributes$ti = _segmentAttributes.timescale, timescale2 = _segmentAttributes$ti === void 0 ? 1 : _segmentAttributes$ti;
    segmentAttributes.duration = duration5 / timescale2;
  } else if (segments.length) {
    segmentAttributes.duration = segments.reduce(function(max, segment) {
      return Math.max(max, Math.ceil(segment.duration));
    }, 0);
  } else {
    segmentAttributes.duration = 0;
  }
  segmentsInfo.attributes = segmentAttributes;
  segmentsInfo.segments = segments;
  if (segmentInfo.base && segmentAttributes.indexRange) {
    segmentsInfo.sidx = segments[0];
    segmentsInfo.segments = [];
  }
  return segmentsInfo;
};
var toPlaylists = function toPlaylists2(representations) {
  return representations.map(generateSegments);
};
var findChildren = function findChildren2(element, name) {
  return from(element.childNodes).filter(function(_ref) {
    var tagName = _ref.tagName;
    return tagName === name;
  });
};
var getContent = function getContent2(element) {
  return element.textContent.trim();
};
var parseDuration = function parseDuration2(str) {
  var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
  var SECONDS_IN_MONTH = 30 * 24 * 60 * 60;
  var SECONDS_IN_DAY = 24 * 60 * 60;
  var SECONDS_IN_HOUR = 60 * 60;
  var SECONDS_IN_MIN = 60;
  var durationRegex = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/;
  var match = durationRegex.exec(str);
  if (!match) {
    return 0;
  }
  var _match$slice = match.slice(1), year = _match$slice[0], month = _match$slice[1], day = _match$slice[2], hour = _match$slice[3], minute = _match$slice[4], second = _match$slice[5];
  return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);
};
var parseDate = function parseDate2(str) {
  var dateRegex = /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/;
  if (dateRegex.test(str)) {
    str += "Z";
  }
  return Date.parse(str);
};
var parsers = {
  /**
   * Specifies the duration of the entire Media Presentation. Format is a duration string
   * as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  mediaPresentationDuration: function mediaPresentationDuration(value) {
    return parseDuration(value);
  },
  /**
   * Specifies the Segment availability start time for all Segments referred to in this
   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability
   * time. Format is a date string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The date as seconds from unix epoch
   */
  availabilityStartTime: function availabilityStartTime(value) {
    return parseDate(value) / 1e3;
  },
  /**
   * Specifies the smallest period between potential changes to the MPD. Format is a
   * duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  minimumUpdatePeriod: function minimumUpdatePeriod(value) {
    return parseDuration(value);
  },
  /**
   * Specifies the suggested presentation delay. Format is a
   * duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  suggestedPresentationDelay: function suggestedPresentationDelay(value) {
    return parseDuration(value);
  },
  /**
   * specifices the type of mpd. Can be either "static" or "dynamic"
   *
   * @param {string} value
   *        value of attribute as a string
   *
   * @return {string}
   *         The type as a string
   */
  type: function type(value) {
    return value;
  },
  /**
   * Specifies the duration of the smallest time shifting buffer for any Representation
   * in the MPD. Format is a duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  timeShiftBufferDepth: function timeShiftBufferDepth(value) {
    return parseDuration(value);
  },
  /**
   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.
   * Format is a duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  start: function start(value) {
    return parseDuration(value);
  },
  /**
   * Specifies the width of the visual presentation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed width
   */
  width: function width(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the height of the visual presentation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed height
   */
  height: function height(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the bitrate of the representation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed bandwidth
   */
  bandwidth: function bandwidth(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the number of the first Media Segment in this Representation in the Period
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed number
   */
  startNumber: function startNumber(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the timescale in units per seconds
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed timescale
   */
  timescale: function timescale(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the presentationTimeOffset.
   *
   * @param {string} value
   *        value of the attribute as a string
   *
   * @return {number}
   *         The parsed presentationTimeOffset
   */
  presentationTimeOffset: function presentationTimeOffset(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the constant approximate Segment duration
   * NOTE: The <Period> element also contains an @duration attribute. This duration
   *       specifies the duration of the Period. This attribute is currently not
   *       supported by the rest of the parser, however we still check for it to prevent
   *       errors.
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed duration
   */
  duration: function duration(value) {
    var parsedValue = parseInt(value, 10);
    if (isNaN(parsedValue)) {
      return parseDuration(value);
    }
    return parsedValue;
  },
  /**
   * Specifies the Segment duration, in units of the value of the @timescale.
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed duration
   */
  d: function d(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the MPD start time, in @timescale units, the first Segment in the series
   * starts relative to the beginning of the Period
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed time
   */
  t: function t(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the repeat count of the number of following contiguous Segments with the
   * same duration expressed by the value of @d
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed number
   */
  r: function r(value) {
    return parseInt(value, 10);
  },
  /**
   * Default parser for all other attributes. Acts as a no-op and just returns the value
   * as a string
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {string}
   *         Unparsed value
   */
  DEFAULT: function DEFAULT(value) {
    return value;
  }
};
var parseAttributes3 = function parseAttributes4(el) {
  if (!(el && el.attributes)) {
    return {};
  }
  return from(el.attributes).reduce(function(a, e) {
    var parseFn = parsers[e.name] || parsers.DEFAULT;
    a[e.name] = parseFn(e.value);
    return a;
  }, {});
};
var keySystemsMap = {
  "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey",
  "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha",
  "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready",
  "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime"
};
var buildBaseUrls = function buildBaseUrls2(referenceUrls, baseUrlElements) {
  if (!baseUrlElements.length) {
    return referenceUrls;
  }
  return flatten(referenceUrls.map(function(reference) {
    return baseUrlElements.map(function(baseUrlElement) {
      return resolve_url_default(reference, getContent(baseUrlElement));
    });
  }));
};
var getSegmentInformation = function getSegmentInformation2(adaptationSet) {
  var segmentTemplate = findChildren(adaptationSet, "SegmentTemplate")[0];
  var segmentList = findChildren(adaptationSet, "SegmentList")[0];
  var segmentUrls = segmentList && findChildren(segmentList, "SegmentURL").map(function(s) {
    return merge({
      tag: "SegmentURL"
    }, parseAttributes3(s));
  });
  var segmentBase = findChildren(adaptationSet, "SegmentBase")[0];
  var segmentTimelineParentNode = segmentList || segmentTemplate;
  var segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, "SegmentTimeline")[0];
  var segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;
  var segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, "Initialization")[0];
  var template = segmentTemplate && parseAttributes3(segmentTemplate);
  if (template && segmentInitialization) {
    template.initialization = segmentInitialization && parseAttributes3(segmentInitialization);
  } else if (template && template.initialization) {
    template.initialization = {
      sourceURL: template.initialization
    };
  }
  var segmentInfo = {
    template,
    segmentTimeline: segmentTimeline && findChildren(segmentTimeline, "S").map(function(s) {
      return parseAttributes3(s);
    }),
    list: segmentList && merge(parseAttributes3(segmentList), {
      segmentUrls,
      initialization: parseAttributes3(segmentInitialization)
    }),
    base: segmentBase && merge(parseAttributes3(segmentBase), {
      initialization: parseAttributes3(segmentInitialization)
    })
  };
  Object.keys(segmentInfo).forEach(function(key) {
    if (!segmentInfo[key]) {
      delete segmentInfo[key];
    }
  });
  return segmentInfo;
};
var inheritBaseUrls = function inheritBaseUrls2(adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) {
  return function(representation) {
    var repBaseUrlElements = findChildren(representation, "BaseURL");
    var repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);
    var attributes = merge(adaptationSetAttributes, parseAttributes3(representation));
    var representationSegmentInfo = getSegmentInformation(representation);
    return repBaseUrls.map(function(baseUrl) {
      return {
        segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),
        attributes: merge(attributes, {
          baseUrl
        })
      };
    });
  };
};
var generateKeySystemInformation = function generateKeySystemInformation2(contentProtectionNodes) {
  return contentProtectionNodes.reduce(function(acc, node) {
    var attributes = parseAttributes3(node);
    if (attributes.schemeIdUri) {
      attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();
    }
    var keySystem = keySystemsMap[attributes.schemeIdUri];
    if (keySystem) {
      acc[keySystem] = {
        attributes
      };
      var psshNode = findChildren(node, "cenc:pssh")[0];
      if (psshNode) {
        var pssh = getContent(psshNode);
        acc[keySystem].pssh = pssh && decodeB64ToUint8Array(pssh);
      }
    }
    return acc;
  }, {});
};
var parseCaptionServiceMetadata = function parseCaptionServiceMetadata2(service) {
  if (service.schemeIdUri === "urn:scte:dash:cc:cea-608:2015") {
    var values3 = typeof service.value !== "string" ? [] : service.value.split(";");
    return values3.map(function(value) {
      var channel;
      var language;
      language = value;
      if (/^CC\d=/.test(value)) {
        var _value$split = value.split("=");
        channel = _value$split[0];
        language = _value$split[1];
      } else if (/^CC\d$/.test(value)) {
        channel = value;
      }
      return {
        channel,
        language
      };
    });
  } else if (service.schemeIdUri === "urn:scte:dash:cc:cea-708:2015") {
    var _values = typeof service.value !== "string" ? [] : service.value.split(";");
    return _values.map(function(value) {
      var flags = {
        // service or channel number 1-63
        "channel": void 0,
        // language is a 3ALPHA per ISO 639.2/B
        // field is required
        "language": void 0,
        // BIT 1/0 or ?
        // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown
        "aspectRatio": 1,
        // BIT 1/0
        // easy reader flag indicated the text is tailed to the needs of beginning readers
        // default 0, or off
        "easyReader": 0,
        // BIT 1/0
        // If 3d metadata is present (CEA-708.1) then 1
        // default 0
        "3D": 0
      };
      if (/=/.test(value)) {
        var _value$split2 = value.split("="), channel = _value$split2[0], _value$split2$ = _value$split2[1], opts = _value$split2$ === void 0 ? "" : _value$split2$;
        flags.channel = channel;
        flags.language = value;
        opts.split(",").forEach(function(opt) {
          var _opt$split = opt.split(":"), name = _opt$split[0], val = _opt$split[1];
          if (name === "lang") {
            flags.language = val;
          } else if (name === "er") {
            flags.easyReader = Number(val);
          } else if (name === "war") {
            flags.aspectRatio = Number(val);
          } else if (name === "3D") {
            flags["3D"] = Number(val);
          }
        });
      } else {
        flags.language = value;
      }
      if (flags.channel) {
        flags.channel = "SERVICE" + flags.channel;
      }
      return flags;
    });
  }
};
var toRepresentations = function toRepresentations2(periodAttributes, periodBaseUrls, periodSegmentInfo) {
  return function(adaptationSet) {
    var adaptationSetAttributes = parseAttributes3(adaptationSet);
    var adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, "BaseURL"));
    var role = findChildren(adaptationSet, "Role")[0];
    var roleAttributes = {
      role: parseAttributes3(role)
    };
    var attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);
    var accessibility = findChildren(adaptationSet, "Accessibility")[0];
    var captionServices = parseCaptionServiceMetadata(parseAttributes3(accessibility));
    if (captionServices) {
      attrs = merge(attrs, {
        captionServices
      });
    }
    var label = findChildren(adaptationSet, "Label")[0];
    if (label && label.childNodes.length) {
      var labelVal = label.childNodes[0].nodeValue.trim();
      attrs = merge(attrs, {
        label: labelVal
      });
    }
    var contentProtection = generateKeySystemInformation(findChildren(adaptationSet, "ContentProtection"));
    if (Object.keys(contentProtection).length) {
      attrs = merge(attrs, {
        contentProtection
      });
    }
    var segmentInfo = getSegmentInformation(adaptationSet);
    var representations = findChildren(adaptationSet, "Representation");
    var adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);
    return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));
  };
};
var toAdaptationSets = function toAdaptationSets2(mpdAttributes, mpdBaseUrls) {
  return function(period, index) {
    var periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, "BaseURL"));
    var periodAttributes = merge(mpdAttributes, {
      periodStart: period.attributes.start
    });
    if (typeof period.attributes.duration === "number") {
      periodAttributes.periodDuration = period.attributes.duration;
    }
    var adaptationSets = findChildren(period.node, "AdaptationSet");
    var periodSegmentInfo = getSegmentInformation(period.node);
    return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));
  };
};
var getPeriodStart = function getPeriodStart2(_ref) {
  var attributes = _ref.attributes, priorPeriodAttributes = _ref.priorPeriodAttributes, mpdType = _ref.mpdType;
  if (typeof attributes.start === "number") {
    return attributes.start;
  }
  if (priorPeriodAttributes && typeof priorPeriodAttributes.start === "number" && typeof priorPeriodAttributes.duration === "number") {
    return priorPeriodAttributes.start + priorPeriodAttributes.duration;
  }
  if (!priorPeriodAttributes && mpdType === "static") {
    return 0;
  }
  return null;
};
var inheritAttributes = function inheritAttributes2(mpd, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$manifestUri = _options.manifestUri, manifestUri = _options$manifestUri === void 0 ? "" : _options$manifestUri, _options$NOW = _options.NOW, NOW = _options$NOW === void 0 ? Date.now() : _options$NOW, _options$clientOffset = _options.clientOffset, clientOffset = _options$clientOffset === void 0 ? 0 : _options$clientOffset;
  var periodNodes = findChildren(mpd, "Period");
  if (!periodNodes.length) {
    throw new Error(errors.INVALID_NUMBER_OF_PERIOD);
  }
  var locations = findChildren(mpd, "Location");
  var mpdAttributes = parseAttributes3(mpd);
  var mpdBaseUrls = buildBaseUrls([manifestUri], findChildren(mpd, "BaseURL"));
  mpdAttributes.type = mpdAttributes.type || "static";
  mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;
  mpdAttributes.NOW = NOW;
  mpdAttributes.clientOffset = clientOffset;
  if (locations.length) {
    mpdAttributes.locations = locations.map(getContent);
  }
  var periods = [];
  periodNodes.forEach(function(node, index) {
    var attributes = parseAttributes3(node);
    var priorPeriod = periods[index - 1];
    attributes.start = getPeriodStart({
      attributes,
      priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,
      mpdType: mpdAttributes.type
    });
    periods.push({
      node,
      attributes
    });
  });
  return {
    locations: mpdAttributes.locations,
    representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls)))
  };
};
var stringToMpdXml = function stringToMpdXml2(manifestString) {
  if (manifestString === "") {
    throw new Error(errors.DASH_EMPTY_MANIFEST);
  }
  var parser6 = new import_xmldom.DOMParser();
  var xml;
  var mpd;
  try {
    xml = parser6.parseFromString(manifestString, "application/xml");
    mpd = xml && xml.documentElement.tagName === "MPD" ? xml.documentElement : null;
  } catch (e) {
  }
  if (!mpd || mpd && mpd.getElementsByTagName("parsererror").length > 0) {
    throw new Error(errors.DASH_INVALID_XML);
  }
  return mpd;
};
var parseUTCTimingScheme = function parseUTCTimingScheme2(mpd) {
  var UTCTimingNode = findChildren(mpd, "UTCTiming")[0];
  if (!UTCTimingNode) {
    return null;
  }
  var attributes = parseAttributes3(UTCTimingNode);
  switch (attributes.schemeIdUri) {
    case "urn:mpeg:dash:utc:http-head:2014":
    case "urn:mpeg:dash:utc:http-head:2012":
      attributes.method = "HEAD";
      break;
    case "urn:mpeg:dash:utc:http-xsdate:2014":
    case "urn:mpeg:dash:utc:http-iso:2014":
    case "urn:mpeg:dash:utc:http-xsdate:2012":
    case "urn:mpeg:dash:utc:http-iso:2012":
      attributes.method = "GET";
      break;
    case "urn:mpeg:dash:utc:direct:2014":
    case "urn:mpeg:dash:utc:direct:2012":
      attributes.method = "DIRECT";
      attributes.value = Date.parse(attributes.value);
      break;
    case "urn:mpeg:dash:utc:http-ntp:2014":
    case "urn:mpeg:dash:utc:ntp:2014":
    case "urn:mpeg:dash:utc:sntp:2014":
    default:
      throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);
  }
  return attributes;
};
var parse = function parse2(manifestString, options) {
  if (options === void 0) {
    options = {};
  }
  var parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);
  var playlists = toPlaylists(parsedManifestInfo.representationInfo);
  return toM3u8({
    dashPlaylists: playlists,
    locations: parsedManifestInfo.locations,
    sidxMapping: options.sidxMapping,
    previousManifest: options.previousManifest
  });
};
var parseUTCTiming = function parseUTCTiming2(manifestString) {
  return parseUTCTimingScheme(stringToMpdXml(manifestString));
};

// node_modules/.pnpm/video.js@7.20.3/node_modules/video.js/dist/video.es.js
var import_parse_sidx = __toESM(require_parse_sidx());

// node_modules/.pnpm/@videojs+vhs-utils@3.0.5/node_modules/@videojs/vhs-utils/es/id3-helpers.js
var ID3 = toUint8([73, 68, 51]);
var getId3Size = function getId3Size2(bytes, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  bytes = toUint8(bytes);
  var flags = bytes[offset + 5];
  var returnSize = bytes[offset + 6] << 21 | bytes[offset + 7] << 14 | bytes[offset + 8] << 7 | bytes[offset + 9];
  var footerPresent = (flags & 16) >> 4;
  if (footerPresent) {
    return returnSize + 20;
  }
  return returnSize + 10;
};
var getId3Offset = function getId3Offset2(bytes, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  bytes = toUint8(bytes);
  if (bytes.length - offset < 10 || !bytesMatch(bytes, ID3, {
    offset
  })) {
    return offset;
  }
  offset += getId3Size(bytes, offset);
  return getId3Offset2(bytes, offset);
};

// node_modules/.pnpm/@videojs+vhs-utils@3.0.5/node_modules/@videojs/vhs-utils/es/opus-helpers.js
var OPUS_HEAD = new Uint8Array([
  // O, p, u, s
  79,
  112,
  117,
  115,
  // H, e, a, d
  72,
  101,
  97,
  100
]);

// node_modules/.pnpm/@videojs+vhs-utils@3.0.5/node_modules/@videojs/vhs-utils/es/mp4-helpers.js
var normalizePath = function normalizePath2(path) {
  if (typeof path === "string") {
    return stringToBytes(path);
  }
  if (typeof path === "number") {
    return path;
  }
  return path;
};
var normalizePaths = function normalizePaths2(paths) {
  if (!Array.isArray(paths)) {
    return [normalizePath(paths)];
  }
  return paths.map(function(p) {
    return normalizePath(p);
  });
};
var DESCRIPTORS;
var parseDescriptors = function parseDescriptors2(bytes) {
  bytes = toUint8(bytes);
  var results = [];
  var i = 0;
  while (bytes.length > i) {
    var tag = bytes[i];
    var size = 0;
    var headerSize = 0;
    headerSize++;
    var byte = bytes[headerSize];
    headerSize++;
    while (byte & 128) {
      size = (byte & 127) << 7;
      byte = bytes[headerSize];
      headerSize++;
    }
    size += byte & 127;
    for (var z = 0; z < DESCRIPTORS.length; z++) {
      var _DESCRIPTORS$z = DESCRIPTORS[z], id = _DESCRIPTORS$z.id, parser6 = _DESCRIPTORS$z.parser;
      if (tag === id) {
        results.push(parser6(bytes.subarray(headerSize, headerSize + size)));
        break;
      }
    }
    i += size + headerSize;
  }
  return results;
};
DESCRIPTORS = [{
  id: 3,
  parser: function parser(bytes) {
    var desc = {
      tag: 3,
      id: bytes[0] << 8 | bytes[1],
      flags: bytes[2],
      size: 3,
      dependsOnEsId: 0,
      ocrEsId: 0,
      descriptors: [],
      url: ""
    };
    if (desc.flags & 128) {
      desc.dependsOnEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];
      desc.size += 2;
    }
    if (desc.flags & 64) {
      var len = bytes[desc.size];
      desc.url = bytesToString(bytes.subarray(desc.size + 1, desc.size + 1 + len));
      desc.size += len;
    }
    if (desc.flags & 32) {
      desc.ocrEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];
      desc.size += 2;
    }
    desc.descriptors = parseDescriptors(bytes.subarray(desc.size)) || [];
    return desc;
  }
}, {
  id: 4,
  parser: function parser2(bytes) {
    var desc = {
      tag: 4,
      oti: bytes[0],
      streamType: bytes[1],
      bufferSize: bytes[2] << 16 | bytes[3] << 8 | bytes[4],
      maxBitrate: bytes[5] << 24 | bytes[6] << 16 | bytes[7] << 8 | bytes[8],
      avgBitrate: bytes[9] << 24 | bytes[10] << 16 | bytes[11] << 8 | bytes[12],
      descriptors: parseDescriptors(bytes.subarray(13))
    };
    return desc;
  }
}, {
  id: 5,
  parser: function parser3(bytes) {
    return {
      tag: 5,
      bytes
    };
  }
}, {
  id: 6,
  parser: function parser4(bytes) {
    return {
      tag: 6,
      bytes
    };
  }
}];
var findBox2 = function findBox3(bytes, paths, complete) {
  if (complete === void 0) {
    complete = false;
  }
  paths = normalizePaths(paths);
  bytes = toUint8(bytes);
  var results = [];
  if (!paths.length) {
    return results;
  }
  var i = 0;
  while (i < bytes.length) {
    var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;
    var type2 = bytes.subarray(i + 4, i + 8);
    if (size === 0) {
      break;
    }
    var end = i + size;
    if (end > bytes.length) {
      if (complete) {
        break;
      }
      end = bytes.length;
    }
    var data = bytes.subarray(i + 8, end);
    if (bytesMatch(type2, paths[0])) {
      if (paths.length === 1) {
        results.push(data);
      } else {
        results.push.apply(results, findBox3(data, paths.slice(1), complete));
      }
    }
    i = end;
  }
  return results;
};

// node_modules/.pnpm/@videojs+vhs-utils@3.0.5/node_modules/@videojs/vhs-utils/es/ebml-helpers.js
var EBML_TAGS = {
  EBML: toUint8([26, 69, 223, 163]),
  DocType: toUint8([66, 130]),
  Segment: toUint8([24, 83, 128, 103]),
  SegmentInfo: toUint8([21, 73, 169, 102]),
  Tracks: toUint8([22, 84, 174, 107]),
  Track: toUint8([174]),
  TrackNumber: toUint8([215]),
  DefaultDuration: toUint8([35, 227, 131]),
  TrackEntry: toUint8([174]),
  TrackType: toUint8([131]),
  FlagDefault: toUint8([136]),
  CodecID: toUint8([134]),
  CodecPrivate: toUint8([99, 162]),
  VideoTrack: toUint8([224]),
  AudioTrack: toUint8([225]),
  // Not used yet, but will be used for live webm/mkv
  // see https://www.matroska.org/technical/basics.html#block-structure
  // see https://www.matroska.org/technical/basics.html#simpleblock-structure
  Cluster: toUint8([31, 67, 182, 117]),
  Timestamp: toUint8([231]),
  TimestampScale: toUint8([42, 215, 177]),
  BlockGroup: toUint8([160]),
  BlockDuration: toUint8([155]),
  Block: toUint8([161]),
  SimpleBlock: toUint8([163])
};
var LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];
var getLength = function getLength2(byte) {
  var len = 1;
  for (var i = 0; i < LENGTH_TABLE.length; i++) {
    if (byte & LENGTH_TABLE[i]) {
      break;
    }
    len++;
  }
  return len;
};
var getvint = function getvint2(bytes, offset, removeLength, signed) {
  if (removeLength === void 0) {
    removeLength = true;
  }
  if (signed === void 0) {
    signed = false;
  }
  var length = getLength(bytes[offset]);
  var valueBytes = bytes.subarray(offset, offset + length);
  if (removeLength) {
    valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);
    valueBytes[0] ^= LENGTH_TABLE[length - 1];
  }
  return {
    length,
    value: bytesToNumber(valueBytes, {
      signed
    }),
    bytes: valueBytes
  };
};
var normalizePath3 = function normalizePath4(path) {
  if (typeof path === "string") {
    return path.match(/.{1,2}/g).map(function(p) {
      return normalizePath4(p);
    });
  }
  if (typeof path === "number") {
    return numberToBytes(path);
  }
  return path;
};
var normalizePaths3 = function normalizePaths4(paths) {
  if (!Array.isArray(paths)) {
    return [normalizePath3(paths)];
  }
  return paths.map(function(p) {
    return normalizePath3(p);
  });
};
var getInfinityDataSize = function getInfinityDataSize2(id, bytes, offset) {
  if (offset >= bytes.length) {
    return bytes.length;
  }
  var innerid = getvint(bytes, offset, false);
  if (bytesMatch(id.bytes, innerid.bytes)) {
    return offset;
  }
  var dataHeader = getvint(bytes, offset + innerid.length);
  return getInfinityDataSize2(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);
};
var findEbml = function findEbml2(bytes, paths) {
  paths = normalizePaths3(paths);
  bytes = toUint8(bytes);
  var results = [];
  if (!paths.length) {
    return results;
  }
  var i = 0;
  while (i < bytes.length) {
    var id = getvint(bytes, i, false);
    var dataHeader = getvint(bytes, i + id.length);
    var dataStart = i + id.length + dataHeader.length;
    if (dataHeader.value === 127) {
      dataHeader.value = getInfinityDataSize(id, bytes, dataStart);
      if (dataHeader.value !== bytes.length) {
        dataHeader.value -= dataStart;
      }
    }
    var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;
    var data = bytes.subarray(dataStart, dataEnd);
    if (bytesMatch(paths[0], id.bytes)) {
      if (paths.length === 1) {
        results.push(data);
      } else {
        results = results.concat(findEbml2(data, paths.slice(1)));
      }
    }
    var totalLength = id.length + dataHeader.length + data.length;
    i += totalLength;
  }
  return results;
};

// node_modules/.pnpm/@videojs+vhs-utils@3.0.5/node_modules/@videojs/vhs-utils/es/nal-helpers.js
var NAL_TYPE_ONE = toUint8([0, 0, 0, 1]);
var NAL_TYPE_TWO = toUint8([0, 0, 1]);
var EMULATION_PREVENTION = toUint8([0, 0, 3]);
var discardEmulationPreventionBytes = function discardEmulationPreventionBytes2(bytes) {
  var positions = [];
  var i = 1;
  while (i < bytes.length - 2) {
    if (bytesMatch(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {
      positions.push(i + 2);
      i++;
    }
    i++;
  }
  if (positions.length === 0) {
    return bytes;
  }
  var newLength = bytes.length - positions.length;
  var newData = new Uint8Array(newLength);
  var sourceIndex = 0;
  for (i = 0; i < newLength; sourceIndex++, i++) {
    if (sourceIndex === positions[0]) {
      sourceIndex++;
      positions.shift();
    }
    newData[i] = bytes[sourceIndex];
  }
  return newData;
};
var findNal = function findNal2(bytes, dataType, types, nalLimit) {
  if (nalLimit === void 0) {
    nalLimit = Infinity;
  }
  bytes = toUint8(bytes);
  types = [].concat(types);
  var i = 0;
  var nalStart;
  var nalsFound = 0;
  while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {
    var nalOffset = void 0;
    if (bytesMatch(bytes.subarray(i), NAL_TYPE_ONE)) {
      nalOffset = 4;
    } else if (bytesMatch(bytes.subarray(i), NAL_TYPE_TWO)) {
      nalOffset = 3;
    }
    if (!nalOffset) {
      i++;
      continue;
    }
    nalsFound++;
    if (nalStart) {
      return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));
    }
    var nalType = void 0;
    if (dataType === "h264") {
      nalType = bytes[i + nalOffset] & 31;
    } else if (dataType === "h265") {
      nalType = bytes[i + nalOffset] >> 1 & 63;
    }
    if (types.indexOf(nalType) !== -1) {
      nalStart = i + nalOffset;
    }
    i += nalOffset + (dataType === "h264" ? 1 : 2);
  }
  return bytes.subarray(0, 0);
};
var findH264Nal = function findH264Nal2(bytes, type2, nalLimit) {
  return findNal(bytes, "h264", type2, nalLimit);
};
var findH265Nal = function findH265Nal2(bytes, type2, nalLimit) {
  return findNal(bytes, "h265", type2, nalLimit);
};

// node_modules/.pnpm/@videojs+vhs-utils@3.0.5/node_modules/@videojs/vhs-utils/es/containers.js
var CONSTANTS = {
  // "webm" string literal in hex
  "webm": toUint8([119, 101, 98, 109]),
  // "matroska" string literal in hex
  "matroska": toUint8([109, 97, 116, 114, 111, 115, 107, 97]),
  // "fLaC" string literal in hex
  "flac": toUint8([102, 76, 97, 67]),
  // "OggS" string literal in hex
  "ogg": toUint8([79, 103, 103, 83]),
  // ac-3 sync byte, also works for ec-3 as that is simply a codec
  // of ac-3
  "ac3": toUint8([11, 119]),
  // "RIFF" string literal in hex used for wav and avi
  "riff": toUint8([82, 73, 70, 70]),
  // "AVI" string literal in hex
  "avi": toUint8([65, 86, 73]),
  // "WAVE" string literal in hex
  "wav": toUint8([87, 65, 86, 69]),
  // "ftyp3g" string literal in hex
  "3gp": toUint8([102, 116, 121, 112, 51, 103]),
  // "ftyp" string literal in hex
  "mp4": toUint8([102, 116, 121, 112]),
  // "styp" string literal in hex
  "fmp4": toUint8([115, 116, 121, 112]),
  // "ftypqt" string literal in hex
  "mov": toUint8([102, 116, 121, 112, 113, 116]),
  // moov string literal in hex
  "moov": toUint8([109, 111, 111, 118]),
  // moof string literal in hex
  "moof": toUint8([109, 111, 111, 102])
};
var _isLikely = {
  aac: function aac(bytes) {
    var offset = getId3Offset(bytes);
    return bytesMatch(bytes, [255, 16], {
      offset,
      mask: [255, 22]
    });
  },
  mp3: function mp3(bytes) {
    var offset = getId3Offset(bytes);
    return bytesMatch(bytes, [255, 2], {
      offset,
      mask: [255, 6]
    });
  },
  webm: function webm(bytes) {
    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0];
    return bytesMatch(docType, CONSTANTS.webm);
  },
  mkv: function mkv(bytes) {
    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0];
    return bytesMatch(docType, CONSTANTS.matroska);
  },
  mp4: function mp4(bytes) {
    if (_isLikely["3gp"](bytes) || _isLikely.mov(bytes)) {
      return false;
    }
    if (bytesMatch(bytes, CONSTANTS.mp4, {
      offset: 4
    }) || bytesMatch(bytes, CONSTANTS.fmp4, {
      offset: 4
    })) {
      return true;
    }
    if (bytesMatch(bytes, CONSTANTS.moof, {
      offset: 4
    }) || bytesMatch(bytes, CONSTANTS.moov, {
      offset: 4
    })) {
      return true;
    }
  },
  mov: function mov(bytes) {
    return bytesMatch(bytes, CONSTANTS.mov, {
      offset: 4
    });
  },
  "3gp": function gp(bytes) {
    return bytesMatch(bytes, CONSTANTS["3gp"], {
      offset: 4
    });
  },
  ac3: function ac3(bytes) {
    var offset = getId3Offset(bytes);
    return bytesMatch(bytes, CONSTANTS.ac3, {
      offset
    });
  },
  ts: function ts(bytes) {
    if (bytes.length < 189 && bytes.length >= 1) {
      return bytes[0] === 71;
    }
    var i = 0;
    while (i + 188 < bytes.length && i < 188) {
      if (bytes[i] === 71 && bytes[i + 188] === 71) {
        return true;
      }
      i += 1;
    }
    return false;
  },
  flac: function flac(bytes) {
    var offset = getId3Offset(bytes);
    return bytesMatch(bytes, CONSTANTS.flac, {
      offset
    });
  },
  ogg: function ogg(bytes) {
    return bytesMatch(bytes, CONSTANTS.ogg);
  },
  avi: function avi(bytes) {
    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.avi, {
      offset: 8
    });
  },
  wav: function wav(bytes) {
    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.wav, {
      offset: 8
    });
  },
  "h264": function h264(bytes) {
    return findH264Nal(bytes, 7, 3).length;
  },
  "h265": function h265(bytes) {
    return findH265Nal(bytes, [32, 33], 3).length;
  }
};
var isLikelyTypes = Object.keys(_isLikely).filter(function(t2) {
  return t2 !== "ts" && t2 !== "h264" && t2 !== "h265";
}).concat(["ts", "h264", "h265"]);
isLikelyTypes.forEach(function(type2) {
  var isLikelyFn = _isLikely[type2];
  _isLikely[type2] = function(bytes) {
    return isLikelyFn(toUint8(bytes));
  };
});
var isLikely = _isLikely;
var detectContainerForBytes = function detectContainerForBytes2(bytes) {
  bytes = toUint8(bytes);
  for (var i = 0; i < isLikelyTypes.length; i++) {
    var type2 = isLikelyTypes[i];
    if (isLikely[type2](bytes)) {
      return type2;
    }
  }
  return "";
};
var isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment2(bytes) {
  return findBox2(bytes, ["moof"]).length > 0;
};

// node_modules/.pnpm/video.js@7.20.3/node_modules/video.js/dist/video.es.js
var import_clock = __toESM(require_clock());
var version$5 = "7.20.3";
var hooks_ = {};
var hooks = function hooks2(type2, fn) {
  hooks_[type2] = hooks_[type2] || [];
  if (fn) {
    hooks_[type2] = hooks_[type2].concat(fn);
  }
  return hooks_[type2];
};
var hook = function hook2(type2, fn) {
  hooks(type2, fn);
};
var removeHook = function removeHook2(type2, fn) {
  var index = hooks(type2).indexOf(fn);
  if (index <= -1) {
    return false;
  }
  hooks_[type2] = hooks_[type2].slice();
  hooks_[type2].splice(index, 1);
  return true;
};
var hookOnce = function hookOnce2(type2, fn) {
  hooks(type2, [].concat(fn).map(function(original) {
    var wrapper = function wrapper2() {
      removeHook(type2, wrapper2);
      return original.apply(void 0, arguments);
    };
    return wrapper;
  }));
};
var FullscreenApi = {
  prefixed: true
};
var apiMap = [
  ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror", "fullscreen"],
  // WebKit
  ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror", "-webkit-full-screen"],
  // Mozilla
  ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror", "-moz-full-screen"],
  // Microsoft
  ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError", "-ms-fullscreen"]
];
var specApi = apiMap[0];
var browserApi;
for (i = 0; i < apiMap.length; i++) {
  if (apiMap[i][1] in import_document.default) {
    browserApi = apiMap[i];
    break;
  }
}
var i;
if (browserApi) {
  for (_i = 0; _i < browserApi.length; _i++) {
    FullscreenApi[specApi[_i]] = browserApi[_i];
  }
  FullscreenApi.prefixed = browserApi[0] !== specApi[0];
}
var _i;
var history = [];
var LogByTypeFactory = function LogByTypeFactory2(name, log2) {
  return function(type2, level, args) {
    var lvl = log2.levels[level];
    var lvlRegExp = new RegExp("^(" + lvl + ")$");
    if (type2 !== "log") {
      args.unshift(type2.toUpperCase() + ":");
    }
    args.unshift(name + ":");
    if (history) {
      history.push([].concat(args));
      var splice = history.length - 1e3;
      history.splice(0, splice > 0 ? splice : 0);
    }
    if (!import_window6.default.console) {
      return;
    }
    var fn = import_window6.default.console[type2];
    if (!fn && type2 === "debug") {
      fn = import_window6.default.console.info || import_window6.default.console.log;
    }
    if (!fn || !lvl || !lvlRegExp.test(type2)) {
      return;
    }
    fn[Array.isArray(args) ? "apply" : "call"](import_window6.default.console, args);
  };
};
function createLogger$1(name) {
  var level = "info";
  var logByType;
  var log2 = function log3() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    logByType("log", level, args);
  };
  logByType = LogByTypeFactory(name, log2);
  log2.createLogger = function(subname) {
    return createLogger$1(name + ": " + subname);
  };
  log2.levels = {
    all: "debug|log|warn|error",
    off: "",
    debug: "debug|log|warn|error",
    info: "log|warn|error",
    warn: "warn|error",
    error: "error",
    DEFAULT: level
  };
  log2.level = function(lvl) {
    if (typeof lvl === "string") {
      if (!log2.levels.hasOwnProperty(lvl)) {
        throw new Error('"' + lvl + '" in not a valid log level');
      }
      level = lvl;
    }
    return level;
  };
  log2.history = function() {
    return history ? [].concat(history) : [];
  };
  log2.history.filter = function(fname) {
    return (history || []).filter(function(historyItem) {
      return new RegExp(".*" + fname + ".*").test(historyItem[0]);
    });
  };
  log2.history.clear = function() {
    if (history) {
      history.length = 0;
    }
  };
  log2.history.disable = function() {
    if (history !== null) {
      history.length = 0;
      history = null;
    }
  };
  log2.history.enable = function() {
    if (history === null) {
      history = [];
    }
  };
  log2.error = function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return logByType("error", level, args);
  };
  log2.warn = function() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return logByType("warn", level, args);
  };
  log2.debug = function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return logByType("debug", level, args);
  };
  return log2;
}
var log$1 = createLogger$1("VIDEOJS");
var createLogger = log$1.createLogger;
var toString = Object.prototype.toString;
var keys = function keys2(object) {
  return isObject3(object) ? Object.keys(object) : [];
};
function each(object, fn) {
  keys(object).forEach(function(key) {
    return fn(object[key], key);
  });
}
function reduce(object, fn, initial) {
  if (initial === void 0) {
    initial = 0;
  }
  return keys(object).reduce(function(accum, key) {
    return fn(accum, object[key], key);
  }, initial);
}
function assign(target) {
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }
  if (Object.assign) {
    return _extends2.apply(void 0, [target].concat(sources));
  }
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    each(source, function(value, key) {
      target[key] = value;
    });
  });
  return target;
}
function isObject3(value) {
  return !!value && typeof value === "object";
}
function isPlain(value) {
  return isObject3(value) && toString.call(value) === "[object Object]" && value.constructor === Object;
}
function computedStyle(el, prop) {
  if (!el || !prop) {
    return "";
  }
  if (typeof import_window6.default.getComputedStyle === "function") {
    var computedStyleValue;
    try {
      computedStyleValue = import_window6.default.getComputedStyle(el);
    } catch (e) {
      return "";
    }
    return computedStyleValue ? computedStyleValue.getPropertyValue(prop) || computedStyleValue[prop] : "";
  }
  return "";
}
var USER_AGENT = import_window6.default.navigator && import_window6.default.navigator.userAgent || "";
var webkitVersionMap = /AppleWebKit\/([\d.]+)/i.exec(USER_AGENT);
var appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;
var IS_IPOD = /iPod/i.test(USER_AGENT);
var IOS_VERSION = function() {
  var match = USER_AGENT.match(/OS (\d+)_/i);
  if (match && match[1]) {
    return match[1];
  }
  return null;
}();
var IS_ANDROID = /Android/i.test(USER_AGENT);
var ANDROID_VERSION = function() {
  var match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
  if (!match) {
    return null;
  }
  var major = match[1] && parseFloat(match[1]);
  var minor = match[2] && parseFloat(match[2]);
  if (major && minor) {
    return parseFloat(match[1] + "." + match[2]);
  } else if (major) {
    return major;
  }
  return null;
}();
var IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;
var IS_FIREFOX = /Firefox/i.test(USER_AGENT);
var IS_EDGE = /Edg/i.test(USER_AGENT);
var IS_CHROME = !IS_EDGE && (/Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT));
var CHROME_VERSION = function() {
  var match = USER_AGENT.match(/(Chrome|CriOS)\/(\d+)/);
  if (match && match[2]) {
    return parseFloat(match[2]);
  }
  return null;
}();
var IE_VERSION = function() {
  var result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
  var version5 = result && parseFloat(result[1]);
  if (!version5 && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
    version5 = 11;
  }
  return version5;
}();
var IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;
var IS_WINDOWS = /Windows/i.test(USER_AGENT);
var TOUCH_ENABLED = Boolean(isReal() && ("ontouchstart" in import_window6.default || import_window6.default.navigator.maxTouchPoints || import_window6.default.DocumentTouch && import_window6.default.document instanceof import_window6.default.DocumentTouch));
var IS_IPAD = /iPad/i.test(USER_AGENT) || IS_SAFARI && TOUCH_ENABLED && !/iPhone/i.test(USER_AGENT);
var IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
var IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;
var IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME;
var browser = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  IS_IPOD,
  IOS_VERSION,
  IS_ANDROID,
  ANDROID_VERSION,
  IS_NATIVE_ANDROID,
  IS_FIREFOX,
  IS_EDGE,
  IS_CHROME,
  CHROME_VERSION,
  IE_VERSION,
  IS_SAFARI,
  IS_WINDOWS,
  TOUCH_ENABLED,
  IS_IPAD,
  IS_IPHONE,
  IS_IOS,
  IS_ANY_SAFARI
});
function isNonBlankString(str) {
  return typeof str === "string" && Boolean(str.trim());
}
function throwIfWhitespace(str) {
  if (str.indexOf(" ") >= 0) {
    throw new Error("class has illegal whitespace characters");
  }
}
function classRegExp(className) {
  return new RegExp("(^|\\s)" + className + "($|\\s)");
}
function isReal() {
  return import_document.default === import_window6.default.document;
}
function isEl(value) {
  return isObject3(value) && value.nodeType === 1;
}
function isInFrame() {
  try {
    return import_window6.default.parent !== import_window6.default.self;
  } catch (x) {
    return true;
  }
}
function createQuerier(method) {
  return function(selector, context) {
    if (!isNonBlankString(selector)) {
      return import_document.default[method](null);
    }
    if (isNonBlankString(context)) {
      context = import_document.default.querySelector(context);
    }
    var ctx = isEl(context) ? context : import_document.default;
    return ctx[method] && ctx[method](selector);
  };
}
function createEl(tagName, properties, attributes, content) {
  if (tagName === void 0) {
    tagName = "div";
  }
  if (properties === void 0) {
    properties = {};
  }
  if (attributes === void 0) {
    attributes = {};
  }
  var el = import_document.default.createElement(tagName);
  Object.getOwnPropertyNames(properties).forEach(function(propName) {
    var val = properties[propName];
    if (propName.indexOf("aria-") !== -1 || propName === "role" || propName === "type") {
      log$1.warn("Setting attributes in the second argument of createEl()\nhas been deprecated. Use the third argument instead.\n" + ("createEl(type, properties, attributes). Attempting to set " + propName + " to " + val + "."));
      el.setAttribute(propName, val);
    } else if (propName === "textContent") {
      textContent(el, val);
    } else if (el[propName] !== val || propName === "tabIndex") {
      el[propName] = val;
    }
  });
  Object.getOwnPropertyNames(attributes).forEach(function(attrName) {
    el.setAttribute(attrName, attributes[attrName]);
  });
  if (content) {
    appendContent(el, content);
  }
  return el;
}
function textContent(el, text) {
  if (typeof el.textContent === "undefined") {
    el.innerText = text;
  } else {
    el.textContent = text;
  }
  return el;
}
function prependTo(child, parent) {
  if (parent.firstChild) {
    parent.insertBefore(child, parent.firstChild);
  } else {
    parent.appendChild(child);
  }
}
function hasClass(element, classToCheck) {
  throwIfWhitespace(classToCheck);
  if (element.classList) {
    return element.classList.contains(classToCheck);
  }
  return classRegExp(classToCheck).test(element.className);
}
function addClass(element, classToAdd) {
  if (element.classList) {
    element.classList.add(classToAdd);
  } else if (!hasClass(element, classToAdd)) {
    element.className = (element.className + " " + classToAdd).trim();
  }
  return element;
}
function removeClass(element, classToRemove) {
  if (!element) {
    log$1.warn("removeClass was called with an element that doesn't exist");
    return null;
  }
  if (element.classList) {
    element.classList.remove(classToRemove);
  } else {
    throwIfWhitespace(classToRemove);
    element.className = element.className.split(/\s+/).filter(function(c) {
      return c !== classToRemove;
    }).join(" ");
  }
  return element;
}
function toggleClass(element, classToToggle, predicate) {
  var has = hasClass(element, classToToggle);
  if (typeof predicate === "function") {
    predicate = predicate(element, classToToggle);
  }
  if (typeof predicate !== "boolean") {
    predicate = !has;
  }
  if (predicate === has) {
    return;
  }
  if (predicate) {
    addClass(element, classToToggle);
  } else {
    removeClass(element, classToToggle);
  }
  return element;
}
function setAttributes(el, attributes) {
  Object.getOwnPropertyNames(attributes).forEach(function(attrName) {
    var attrValue = attributes[attrName];
    if (attrValue === null || typeof attrValue === "undefined" || attrValue === false) {
      el.removeAttribute(attrName);
    } else {
      el.setAttribute(attrName, attrValue === true ? "" : attrValue);
    }
  });
}
function getAttributes(tag) {
  var obj = {};
  var knownBooleans = ",autoplay,controls,playsinline,loop,muted,default,defaultMuted,";
  if (tag && tag.attributes && tag.attributes.length > 0) {
    var attrs = tag.attributes;
    for (var i = attrs.length - 1; i >= 0; i--) {
      var attrName = attrs[i].name;
      var attrVal = attrs[i].value;
      if (typeof tag[attrName] === "boolean" || knownBooleans.indexOf("," + attrName + ",") !== -1) {
        attrVal = attrVal !== null ? true : false;
      }
      obj[attrName] = attrVal;
    }
  }
  return obj;
}
function getAttribute(el, attribute) {
  return el.getAttribute(attribute);
}
function setAttribute(el, attribute, value) {
  el.setAttribute(attribute, value);
}
function removeAttribute(el, attribute) {
  el.removeAttribute(attribute);
}
function blockTextSelection() {
  import_document.default.body.focus();
  import_document.default.onselectstart = function() {
    return false;
  };
}
function unblockTextSelection() {
  import_document.default.onselectstart = function() {
    return true;
  };
}
function getBoundingClientRect(el) {
  if (el && el.getBoundingClientRect && el.parentNode) {
    var rect = el.getBoundingClientRect();
    var result = {};
    ["bottom", "height", "left", "right", "top", "width"].forEach(function(k) {
      if (rect[k] !== void 0) {
        result[k] = rect[k];
      }
    });
    if (!result.height) {
      result.height = parseFloat(computedStyle(el, "height"));
    }
    if (!result.width) {
      result.width = parseFloat(computedStyle(el, "width"));
    }
    return result;
  }
}
function findPosition(el) {
  if (!el || el && !el.offsetParent) {
    return {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
  }
  var width2 = el.offsetWidth;
  var height2 = el.offsetHeight;
  var left = 0;
  var top = 0;
  while (el.offsetParent && el !== import_document.default[FullscreenApi.fullscreenElement]) {
    left += el.offsetLeft;
    top += el.offsetTop;
    el = el.offsetParent;
  }
  return {
    left,
    top,
    width: width2,
    height: height2
  };
}
function getPointerPosition(el, event) {
  var translated = {
    x: 0,
    y: 0
  };
  if (IS_IOS) {
    var item = el;
    while (item && item.nodeName.toLowerCase() !== "html") {
      var transform3 = computedStyle(item, "transform");
      if (/^matrix/.test(transform3)) {
        var values3 = transform3.slice(7, -1).split(/,\s/).map(Number);
        translated.x += values3[4];
        translated.y += values3[5];
      } else if (/^matrix3d/.test(transform3)) {
        var _values = transform3.slice(9, -1).split(/,\s/).map(Number);
        translated.x += _values[12];
        translated.y += _values[13];
      }
      item = item.parentNode;
    }
  }
  var position = {};
  var boxTarget = findPosition(event.target);
  var box = findPosition(el);
  var boxW = box.width;
  var boxH = box.height;
  var offsetY = event.offsetY - (box.top - boxTarget.top);
  var offsetX = event.offsetX - (box.left - boxTarget.left);
  if (event.changedTouches) {
    offsetX = event.changedTouches[0].pageX - box.left;
    offsetY = event.changedTouches[0].pageY + box.top;
    if (IS_IOS) {
      offsetX -= translated.x;
      offsetY -= translated.y;
    }
  }
  position.y = 1 - Math.max(0, Math.min(1, offsetY / boxH));
  position.x = Math.max(0, Math.min(1, offsetX / boxW));
  return position;
}
function isTextNode(value) {
  return isObject3(value) && value.nodeType === 3;
}
function emptyEl(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
  return el;
}
function normalizeContent(content) {
  if (typeof content === "function") {
    content = content();
  }
  return (Array.isArray(content) ? content : [content]).map(function(value) {
    if (typeof value === "function") {
      value = value();
    }
    if (isEl(value) || isTextNode(value)) {
      return value;
    }
    if (typeof value === "string" && /\S/.test(value)) {
      return import_document.default.createTextNode(value);
    }
  }).filter(function(value) {
    return value;
  });
}
function appendContent(el, content) {
  normalizeContent(content).forEach(function(node) {
    return el.appendChild(node);
  });
  return el;
}
function insertContent(el, content) {
  return appendContent(emptyEl(el), content);
}
function isSingleLeftClick(event) {
  if (event.button === void 0 && event.buttons === void 0) {
    return true;
  }
  if (event.button === 0 && event.buttons === void 0) {
    return true;
  }
  if (event.type === "mouseup" && event.button === 0 && event.buttons === 0) {
    return true;
  }
  if (event.button !== 0 || event.buttons !== 1) {
    return false;
  }
  return true;
}
var $ = createQuerier("querySelector");
var $$ = createQuerier("querySelectorAll");
var Dom = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isReal,
  isEl,
  isInFrame,
  createEl,
  textContent,
  prependTo,
  hasClass,
  addClass,
  removeClass,
  toggleClass,
  setAttributes,
  getAttributes,
  getAttribute,
  setAttribute,
  removeAttribute,
  blockTextSelection,
  unblockTextSelection,
  getBoundingClientRect,
  findPosition,
  getPointerPosition,
  isTextNode,
  emptyEl,
  normalizeContent,
  appendContent,
  insertContent,
  isSingleLeftClick,
  $,
  $$
});
var _windowLoaded = false;
var videojs$1;
var autoSetup = function autoSetup2() {
  if (videojs$1.options.autoSetup === false) {
    return;
  }
  var vids = Array.prototype.slice.call(import_document.default.getElementsByTagName("video"));
  var audios = Array.prototype.slice.call(import_document.default.getElementsByTagName("audio"));
  var divs = Array.prototype.slice.call(import_document.default.getElementsByTagName("video-js"));
  var mediaEls = vids.concat(audios, divs);
  if (mediaEls && mediaEls.length > 0) {
    for (var i = 0, e = mediaEls.length; i < e; i++) {
      var mediaEl = mediaEls[i];
      if (mediaEl && mediaEl.getAttribute) {
        if (mediaEl.player === void 0) {
          var options = mediaEl.getAttribute("data-setup");
          if (options !== null) {
            videojs$1(mediaEl);
          }
        }
      } else {
        autoSetupTimeout(1);
        break;
      }
    }
  } else if (!_windowLoaded) {
    autoSetupTimeout(1);
  }
};
function autoSetupTimeout(wait, vjs) {
  if (!isReal()) {
    return;
  }
  if (vjs) {
    videojs$1 = vjs;
  }
  import_window6.default.setTimeout(autoSetup, wait);
}
function setWindowLoaded() {
  _windowLoaded = true;
  import_window6.default.removeEventListener("load", setWindowLoaded);
}
if (isReal()) {
  if (import_document.default.readyState === "complete") {
    setWindowLoaded();
  } else {
    import_window6.default.addEventListener("load", setWindowLoaded);
  }
}
var createStyleElement = function createStyleElement2(className) {
  var style = import_document.default.createElement("style");
  style.className = className;
  return style;
};
var setTextContent = function setTextContent2(el, content) {
  if (el.styleSheet) {
    el.styleSheet.cssText = content;
  } else {
    el.textContent = content;
  }
};
var _initialGuid = 3;
var _guid = _initialGuid;
function newGUID() {
  return _guid++;
}
var FakeWeakMap;
if (!import_window6.default.WeakMap) {
  FakeWeakMap = /* @__PURE__ */ function() {
    function FakeWeakMap2() {
      this.vdata = "vdata" + Math.floor(import_window6.default.performance && import_window6.default.performance.now() || Date.now());
      this.data = {};
    }
    var _proto = FakeWeakMap2.prototype;
    _proto.set = function set4(key, value) {
      var access = key[this.vdata] || newGUID();
      if (!key[this.vdata]) {
        key[this.vdata] = access;
      }
      this.data[access] = value;
      return this;
    };
    _proto.get = function get7(key) {
      var access = key[this.vdata];
      if (access) {
        return this.data[access];
      }
      log$1("We have no data for this element", key);
      return void 0;
    };
    _proto.has = function has(key) {
      var access = key[this.vdata];
      return access in this.data;
    };
    _proto["delete"] = function _delete(key) {
      var access = key[this.vdata];
      if (access) {
        delete this.data[access];
        delete key[this.vdata];
      }
    };
    return FakeWeakMap2;
  }();
}
var DomData = import_window6.default.WeakMap ? /* @__PURE__ */ new WeakMap() : new FakeWeakMap();
function _cleanUpEvents(elem, type2) {
  if (!DomData.has(elem)) {
    return;
  }
  var data = DomData.get(elem);
  if (data.handlers[type2].length === 0) {
    delete data.handlers[type2];
    if (elem.removeEventListener) {
      elem.removeEventListener(type2, data.dispatcher, false);
    } else if (elem.detachEvent) {
      elem.detachEvent("on" + type2, data.dispatcher);
    }
  }
  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
    delete data.handlers;
    delete data.dispatcher;
    delete data.disabled;
  }
  if (Object.getOwnPropertyNames(data).length === 0) {
    DomData["delete"](elem);
  }
}
function _handleMultipleEvents(fn, elem, types, callback2) {
  types.forEach(function(type2) {
    fn(elem, type2, callback2);
  });
}
function fixEvent(event) {
  if (event.fixed_) {
    return event;
  }
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  if (!event || !event.isPropagationStopped || !event.isImmediatePropagationStopped) {
    var old = event || import_window6.default.event;
    event = {};
    for (var key in old) {
      if (key !== "layerX" && key !== "layerY" && key !== "keyLocation" && key !== "webkitMovementX" && key !== "webkitMovementY" && key !== "path") {
        if (!(key === "returnValue" && old.preventDefault)) {
          event[key] = old[key];
        }
      }
    }
    if (!event.target) {
      event.target = event.srcElement || import_document.default;
    }
    if (!event.relatedTarget) {
      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
    }
    event.preventDefault = function() {
      if (old.preventDefault) {
        old.preventDefault();
      }
      event.returnValue = false;
      old.returnValue = false;
      event.defaultPrevented = true;
    };
    event.defaultPrevented = false;
    event.stopPropagation = function() {
      if (old.stopPropagation) {
        old.stopPropagation();
      }
      event.cancelBubble = true;
      old.cancelBubble = true;
      event.isPropagationStopped = returnTrue;
    };
    event.isPropagationStopped = returnFalse;
    event.stopImmediatePropagation = function() {
      if (old.stopImmediatePropagation) {
        old.stopImmediatePropagation();
      }
      event.isImmediatePropagationStopped = returnTrue;
      event.stopPropagation();
    };
    event.isImmediatePropagationStopped = returnFalse;
    if (event.clientX !== null && event.clientX !== void 0) {
      var doc = import_document.default.documentElement;
      var body = import_document.default.body;
      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }
    event.which = event.charCode || event.keyCode;
    if (event.button !== null && event.button !== void 0) {
      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;
    }
  }
  event.fixed_ = true;
  return event;
}
var _supportsPassive;
var supportsPassive = function supportsPassive2() {
  if (typeof _supportsPassive !== "boolean") {
    _supportsPassive = false;
    try {
      var opts = Object.defineProperty({}, "passive", {
        get: function get7() {
          _supportsPassive = true;
        }
      });
      import_window6.default.addEventListener("test", null, opts);
      import_window6.default.removeEventListener("test", null, opts);
    } catch (e) {
    }
  }
  return _supportsPassive;
};
var passiveEvents = ["touchstart", "touchmove"];
function on(elem, type2, fn) {
  if (Array.isArray(type2)) {
    return _handleMultipleEvents(on, elem, type2, fn);
  }
  if (!DomData.has(elem)) {
    DomData.set(elem, {});
  }
  var data = DomData.get(elem);
  if (!data.handlers) {
    data.handlers = {};
  }
  if (!data.handlers[type2]) {
    data.handlers[type2] = [];
  }
  if (!fn.guid) {
    fn.guid = newGUID();
  }
  data.handlers[type2].push(fn);
  if (!data.dispatcher) {
    data.disabled = false;
    data.dispatcher = function(event, hash3) {
      if (data.disabled) {
        return;
      }
      event = fixEvent(event);
      var handlers = data.handlers[event.type];
      if (handlers) {
        var handlersCopy = handlers.slice(0);
        for (var m = 0, n = handlersCopy.length; m < n; m++) {
          if (event.isImmediatePropagationStopped()) {
            break;
          } else {
            try {
              handlersCopy[m].call(elem, event, hash3);
            } catch (e) {
              log$1.error(e);
            }
          }
        }
      }
    };
  }
  if (data.handlers[type2].length === 1) {
    if (elem.addEventListener) {
      var options = false;
      if (supportsPassive() && passiveEvents.indexOf(type2) > -1) {
        options = {
          passive: true
        };
      }
      elem.addEventListener(type2, data.dispatcher, options);
    } else if (elem.attachEvent) {
      elem.attachEvent("on" + type2, data.dispatcher);
    }
  }
}
function off(elem, type2, fn) {
  if (!DomData.has(elem)) {
    return;
  }
  var data = DomData.get(elem);
  if (!data.handlers) {
    return;
  }
  if (Array.isArray(type2)) {
    return _handleMultipleEvents(off, elem, type2, fn);
  }
  var removeType = function removeType2(el, t3) {
    data.handlers[t3] = [];
    _cleanUpEvents(el, t3);
  };
  if (type2 === void 0) {
    for (var t2 in data.handlers) {
      if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t2)) {
        removeType(elem, t2);
      }
    }
    return;
  }
  var handlers = data.handlers[type2];
  if (!handlers) {
    return;
  }
  if (!fn) {
    removeType(elem, type2);
    return;
  }
  if (fn.guid) {
    for (var n = 0; n < handlers.length; n++) {
      if (handlers[n].guid === fn.guid) {
        handlers.splice(n--, 1);
      }
    }
  }
  _cleanUpEvents(elem, type2);
}
function trigger(elem, event, hash3) {
  var elemData = DomData.has(elem) ? DomData.get(elem) : {};
  var parent = elem.parentNode || elem.ownerDocument;
  if (typeof event === "string") {
    event = {
      type: event,
      target: elem
    };
  } else if (!event.target) {
    event.target = elem;
  }
  event = fixEvent(event);
  if (elemData.dispatcher) {
    elemData.dispatcher.call(elem, event, hash3);
  }
  if (parent && !event.isPropagationStopped() && event.bubbles === true) {
    trigger.call(null, parent, event, hash3);
  } else if (!parent && !event.defaultPrevented && event.target && event.target[event.type]) {
    if (!DomData.has(event.target)) {
      DomData.set(event.target, {});
    }
    var targetData = DomData.get(event.target);
    if (event.target[event.type]) {
      targetData.disabled = true;
      if (typeof event.target[event.type] === "function") {
        event.target[event.type]();
      }
      targetData.disabled = false;
    }
  }
  return !event.defaultPrevented;
}
function one(elem, type2, fn) {
  if (Array.isArray(type2)) {
    return _handleMultipleEvents(one, elem, type2, fn);
  }
  var func = function func2() {
    off(elem, type2, func2);
    fn.apply(this, arguments);
  };
  func.guid = fn.guid = fn.guid || newGUID();
  on(elem, type2, func);
}
function any(elem, type2, fn) {
  var func = function func2() {
    off(elem, type2, func2);
    fn.apply(this, arguments);
  };
  func.guid = fn.guid = fn.guid || newGUID();
  on(elem, type2, func);
}
var Events2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fixEvent,
  on,
  off,
  trigger,
  one,
  any
});
var UPDATE_REFRESH_INTERVAL = 30;
var bind = function bind2(context, fn, uid) {
  if (!fn.guid) {
    fn.guid = newGUID();
  }
  var bound = fn.bind(context);
  bound.guid = uid ? uid + "_" + fn.guid : fn.guid;
  return bound;
};
var throttle = function throttle2(fn, wait) {
  var last = import_window6.default.performance.now();
  var throttled = function throttled2() {
    var now2 = import_window6.default.performance.now();
    if (now2 - last >= wait) {
      fn.apply(void 0, arguments);
      last = now2;
    }
  };
  return throttled;
};
var debounce = function debounce2(func, wait, immediate, context) {
  if (context === void 0) {
    context = import_window6.default;
  }
  var timeout;
  var cancel = function cancel2() {
    context.clearTimeout(timeout);
    timeout = null;
  };
  var debounced = function debounced2() {
    var self2 = this;
    var args = arguments;
    var _later = function later() {
      timeout = null;
      _later = null;
      if (!immediate) {
        func.apply(self2, args);
      }
    };
    if (!timeout && immediate) {
      func.apply(self2, args);
    }
    context.clearTimeout(timeout);
    timeout = context.setTimeout(_later, wait);
  };
  debounced.cancel = cancel;
  return debounced;
};
var EventTarget$2 = function EventTarget() {
};
EventTarget$2.prototype.allowedEvents_ = {};
EventTarget$2.prototype.on = function(type2, fn) {
  var ael = this.addEventListener;
  this.addEventListener = function() {
  };
  on(this, type2, fn);
  this.addEventListener = ael;
};
EventTarget$2.prototype.addEventListener = EventTarget$2.prototype.on;
EventTarget$2.prototype.off = function(type2, fn) {
  off(this, type2, fn);
};
EventTarget$2.prototype.removeEventListener = EventTarget$2.prototype.off;
EventTarget$2.prototype.one = function(type2, fn) {
  var ael = this.addEventListener;
  this.addEventListener = function() {
  };
  one(this, type2, fn);
  this.addEventListener = ael;
};
EventTarget$2.prototype.any = function(type2, fn) {
  var ael = this.addEventListener;
  this.addEventListener = function() {
  };
  any(this, type2, fn);
  this.addEventListener = ael;
};
EventTarget$2.prototype.trigger = function(event) {
  var type2 = event.type || event;
  if (typeof event === "string") {
    event = {
      type: type2
    };
  }
  event = fixEvent(event);
  if (this.allowedEvents_[type2] && this["on" + type2]) {
    this["on" + type2](event);
  }
  trigger(this, event);
};
EventTarget$2.prototype.dispatchEvent = EventTarget$2.prototype.trigger;
var EVENT_MAP;
EventTarget$2.prototype.queueTrigger = function(event) {
  var _this = this;
  if (!EVENT_MAP) {
    EVENT_MAP = /* @__PURE__ */ new Map();
  }
  var type2 = event.type || event;
  var map = EVENT_MAP.get(this);
  if (!map) {
    map = /* @__PURE__ */ new Map();
    EVENT_MAP.set(this, map);
  }
  var oldTimeout = map.get(type2);
  map["delete"](type2);
  import_window6.default.clearTimeout(oldTimeout);
  var timeout = import_window6.default.setTimeout(function() {
    if (map.size === 0) {
      map = null;
      EVENT_MAP["delete"](_this);
    }
    _this.trigger(event);
  }, 0);
  map.set(type2, timeout);
};
var objName = function objName2(obj) {
  if (typeof obj.name === "function") {
    return obj.name();
  }
  if (typeof obj.name === "string") {
    return obj.name;
  }
  if (obj.name_) {
    return obj.name_;
  }
  if (obj.constructor && obj.constructor.name) {
    return obj.constructor.name;
  }
  return typeof obj;
};
var isEvented = function isEvented2(object) {
  return object instanceof EventTarget$2 || !!object.eventBusEl_ && ["on", "one", "off", "trigger"].every(function(k) {
    return typeof object[k] === "function";
  });
};
var addEventedCallback = function addEventedCallback2(target, callback2) {
  if (isEvented(target)) {
    callback2();
  } else {
    if (!target.eventedCallbacks) {
      target.eventedCallbacks = [];
    }
    target.eventedCallbacks.push(callback2);
  }
};
var isValidEventType = function isValidEventType2(type2) {
  return (
    // The regex here verifies that the `type` contains at least one non-
    // whitespace character.
    typeof type2 === "string" && /\S/.test(type2) || Array.isArray(type2) && !!type2.length
  );
};
var validateTarget = function validateTarget2(target, obj, fnName) {
  if (!target || !target.nodeName && !isEvented(target)) {
    throw new Error("Invalid target for " + objName(obj) + "#" + fnName + "; must be a DOM node or evented object.");
  }
};
var validateEventType = function validateEventType2(type2, obj, fnName) {
  if (!isValidEventType(type2)) {
    throw new Error("Invalid event type for " + objName(obj) + "#" + fnName + "; must be a non-empty string or array.");
  }
};
var validateListener = function validateListener2(listener, obj, fnName) {
  if (typeof listener !== "function") {
    throw new Error("Invalid listener for " + objName(obj) + "#" + fnName + "; must be a function.");
  }
};
var normalizeListenArgs = function normalizeListenArgs2(self2, args, fnName) {
  var isTargetingSelf = args.length < 3 || args[0] === self2 || args[0] === self2.eventBusEl_;
  var target;
  var type2;
  var listener;
  if (isTargetingSelf) {
    target = self2.eventBusEl_;
    if (args.length >= 3) {
      args.shift();
    }
    type2 = args[0];
    listener = args[1];
  } else {
    target = args[0];
    type2 = args[1];
    listener = args[2];
  }
  validateTarget(target, self2, fnName);
  validateEventType(type2, self2, fnName);
  validateListener(listener, self2, fnName);
  listener = bind(self2, listener);
  return {
    isTargetingSelf,
    target,
    type: type2,
    listener
  };
};
var listen = function listen2(target, method, type2, listener) {
  validateTarget(target, target, method);
  if (target.nodeName) {
    Events2[method](target, type2, listener);
  } else {
    target[method](type2, listener);
  }
};
var EventedMixin = {
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  on: function on2() {
    var _this = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var _normalizeListenArgs = normalizeListenArgs(this, args, "on"), isTargetingSelf = _normalizeListenArgs.isTargetingSelf, target = _normalizeListenArgs.target, type2 = _normalizeListenArgs.type, listener = _normalizeListenArgs.listener;
    listen(target, "on", type2, listener);
    if (!isTargetingSelf) {
      var removeListenerOnDispose = function removeListenerOnDispose2() {
        return _this.off(target, type2, listener);
      };
      removeListenerOnDispose.guid = listener.guid;
      var removeRemoverOnTargetDispose = function removeRemoverOnTargetDispose2() {
        return _this.off("dispose", removeListenerOnDispose);
      };
      removeRemoverOnTargetDispose.guid = listener.guid;
      listen(this, "on", "dispose", removeListenerOnDispose);
      listen(target, "on", "dispose", removeRemoverOnTargetDispose);
    }
  },
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will be called once per event and then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  one: function one2() {
    var _this2 = this;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    var _normalizeListenArgs2 = normalizeListenArgs(this, args, "one"), isTargetingSelf = _normalizeListenArgs2.isTargetingSelf, target = _normalizeListenArgs2.target, type2 = _normalizeListenArgs2.type, listener = _normalizeListenArgs2.listener;
    if (isTargetingSelf) {
      listen(target, "one", type2, listener);
    } else {
      var wrapper = function wrapper2() {
        _this2.off(target, type2, wrapper2);
        for (var _len3 = arguments.length, largs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          largs[_key3] = arguments[_key3];
        }
        listener.apply(null, largs);
      };
      wrapper.guid = listener.guid;
      listen(target, "one", type2, wrapper);
    }
  },
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will only be called once for the first event that is triggered
   * then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  any: function any2() {
    var _this3 = this;
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    var _normalizeListenArgs3 = normalizeListenArgs(this, args, "any"), isTargetingSelf = _normalizeListenArgs3.isTargetingSelf, target = _normalizeListenArgs3.target, type2 = _normalizeListenArgs3.type, listener = _normalizeListenArgs3.listener;
    if (isTargetingSelf) {
      listen(target, "any", type2, listener);
    } else {
      var wrapper = function wrapper2() {
        _this3.off(target, type2, wrapper2);
        for (var _len5 = arguments.length, largs = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          largs[_key5] = arguments[_key5];
        }
        listener.apply(null, largs);
      };
      wrapper.guid = listener.guid;
      listen(target, "any", type2, wrapper);
    }
  },
  /**
   * Removes listener(s) from event(s) on an evented object.
   *
   * @param  {string|Array|Element|Object} [targetOrType]
   *         If this is a string or array, it represents the event type(s).
   *
   *         Another evented object can be passed here instead, in which case
   *         ALL 3 arguments are _required_.
   *
   * @param  {string|Array|Function} [typeOrListener]
   *         If the first argument was a string or array, this may be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function; otherwise, _all_ listeners bound to the
   *         event type(s) will be removed.
   */
  off: function off$1(targetOrType, typeOrListener, listener) {
    if (!targetOrType || isValidEventType(targetOrType)) {
      off(this.eventBusEl_, targetOrType, typeOrListener);
    } else {
      var target = targetOrType;
      var type2 = typeOrListener;
      validateTarget(target, this, "off");
      validateEventType(type2, this, "off");
      validateListener(listener, this, "off");
      listener = bind(this, listener);
      this.off("dispose", listener);
      if (target.nodeName) {
        off(target, type2, listener);
        off(target, "dispose", listener);
      } else if (isEvented(target)) {
        target.off(type2, listener);
        target.off("dispose", listener);
      }
    }
  },
  /**
   * Fire an event on this evented object, causing its listeners to be called.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash]
   *          An additional object to pass along to listeners.
   *
   * @return {boolean}
   *          Whether or not the default behavior was prevented.
   */
  trigger: function trigger$1(event, hash3) {
    validateTarget(this.eventBusEl_, this, "trigger");
    var type2 = event && typeof event !== "string" ? event.type : event;
    if (!isValidEventType(type2)) {
      var error = "Invalid event type for " + objName(this) + "#trigger; must be a non-empty string or object with a type key that has a non-empty value.";
      if (event) {
        (this.log || log$1).error(error);
      } else {
        throw new Error(error);
      }
    }
    return trigger(this.eventBusEl_, event, hash3);
  }
};
function evented(target, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, eventBusKey = _options.eventBusKey;
  if (eventBusKey) {
    if (!target[eventBusKey].nodeName) {
      throw new Error('The eventBusKey "' + eventBusKey + '" does not refer to an element.');
    }
    target.eventBusEl_ = target[eventBusKey];
  } else {
    target.eventBusEl_ = createEl("span", {
      className: "vjs-event-bus"
    });
  }
  assign(target, EventedMixin);
  if (target.eventedCallbacks) {
    target.eventedCallbacks.forEach(function(callback2) {
      callback2();
    });
  }
  target.on("dispose", function() {
    target.off();
    [target, target.el_, target.eventBusEl_].forEach(function(val) {
      if (val && DomData.has(val)) {
        DomData["delete"](val);
      }
    });
    import_window6.default.setTimeout(function() {
      target.eventBusEl_ = null;
    }, 0);
  });
  return target;
}
var StatefulMixin = {
  /**
   * A hash containing arbitrary keys and values representing the state of
   * the object.
   *
   * @type {Object}
   */
  state: {},
  /**
   * Set the state of an object by mutating its
   * {@link module:stateful~StatefulMixin.state|state} object in place.
   *
   * @fires   module:stateful~StatefulMixin#statechanged
   * @param   {Object|Function} stateUpdates
   *          A new set of properties to shallow-merge into the plugin state.
   *          Can be a plain object or a function returning a plain object.
   *
   * @return {Object|undefined}
   *          An object containing changes that occurred. If no changes
   *          occurred, returns `undefined`.
   */
  setState: function setState(stateUpdates) {
    var _this = this;
    if (typeof stateUpdates === "function") {
      stateUpdates = stateUpdates();
    }
    var changes;
    each(stateUpdates, function(value, key) {
      if (_this.state[key] !== value) {
        changes = changes || {};
        changes[key] = {
          from: _this.state[key],
          to: value
        };
      }
      _this.state[key] = value;
    });
    if (changes && isEvented(this)) {
      this.trigger({
        changes,
        type: "statechanged"
      });
    }
    return changes;
  }
};
function stateful(target, defaultState) {
  assign(target, StatefulMixin);
  target.state = assign({}, target.state, defaultState);
  if (typeof target.handleStateChanged === "function" && isEvented(target)) {
    target.on("statechanged", target.handleStateChanged);
  }
  return target;
}
var toLowerCase = function toLowerCase2(string) {
  if (typeof string !== "string") {
    return string;
  }
  return string.replace(/./, function(w) {
    return w.toLowerCase();
  });
};
var toTitleCase$1 = function toTitleCase(string) {
  if (typeof string !== "string") {
    return string;
  }
  return string.replace(/./, function(w) {
    return w.toUpperCase();
  });
};
var titleCaseEquals = function titleCaseEquals2(str1, str2) {
  return toTitleCase$1(str1) === toTitleCase$1(str2);
};
function mergeOptions$3() {
  var result = {};
  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    each(source, function(value, key) {
      if (!isPlain(value)) {
        result[key] = value;
        return;
      }
      if (!isPlain(result[key])) {
        result[key] = {};
      }
      result[key] = mergeOptions$3(result[key], value);
    });
  });
  return result;
}
var MapSham = /* @__PURE__ */ function() {
  function MapSham2() {
    this.map_ = {};
  }
  var _proto = MapSham2.prototype;
  _proto.has = function has(key) {
    return key in this.map_;
  };
  _proto["delete"] = function _delete(key) {
    var has = this.has(key);
    delete this.map_[key];
    return has;
  };
  _proto.set = function set4(key, value) {
    this.map_[key] = value;
    return this;
  };
  _proto.forEach = function forEach(callback2, thisArg) {
    for (var key in this.map_) {
      callback2.call(thisArg, this.map_[key], key, this);
    }
  };
  return MapSham2;
}();
var Map$1 = import_window6.default.Map ? import_window6.default.Map : MapSham;
var SetSham = /* @__PURE__ */ function() {
  function SetSham2() {
    this.set_ = {};
  }
  var _proto = SetSham2.prototype;
  _proto.has = function has(key) {
    return key in this.set_;
  };
  _proto["delete"] = function _delete(key) {
    var has = this.has(key);
    delete this.set_[key];
    return has;
  };
  _proto.add = function add(key) {
    this.set_[key] = 1;
    return this;
  };
  _proto.forEach = function forEach(callback2, thisArg) {
    for (var key in this.set_) {
      callback2.call(thisArg, key, key, this);
    }
  };
  return SetSham2;
}();
var Set$1 = import_window6.default.Set ? import_window6.default.Set : SetSham;
var Component$1 = /* @__PURE__ */ function() {
  function Component3(player, options, ready) {
    var _this = this;
    if (!player && this.play) {
      this.player_ = player = this;
    } else {
      this.player_ = player;
    }
    this.isDisposed_ = false;
    this.parentComponent_ = null;
    this.options_ = mergeOptions$3({}, this.options_);
    options = this.options_ = mergeOptions$3(this.options_, options);
    this.id_ = options.id || options.el && options.el.id;
    if (!this.id_) {
      var id = player && player.id && player.id() || "no_player";
      this.id_ = id + "_component_" + newGUID();
    }
    this.name_ = options.name || null;
    if (options.el) {
      this.el_ = options.el;
    } else if (options.createEl !== false) {
      this.el_ = this.createEl();
    }
    if (options.className && this.el_) {
      options.className.split(" ").forEach(function(c) {
        return _this.addClass(c);
      });
    }
    if (options.evented !== false) {
      evented(this, {
        eventBusKey: this.el_ ? "el_" : null
      });
      this.handleLanguagechange = this.handleLanguagechange.bind(this);
      this.on(this.player_, "languagechange", this.handleLanguagechange);
    }
    stateful(this, this.constructor.defaultState);
    this.children_ = [];
    this.childIndex_ = {};
    this.childNameIndex_ = {};
    this.setTimeoutIds_ = new Set$1();
    this.setIntervalIds_ = new Set$1();
    this.rafIds_ = new Set$1();
    this.namedRafs_ = new Map$1();
    this.clearingTimersOnDispose_ = false;
    if (options.initChildren !== false) {
      this.initChildren();
    }
    this.ready(ready);
    if (options.reportTouchActivity !== false) {
      this.enableTouchActivity();
    }
  }
  var _proto = Component3.prototype;
  _proto.dispose = function dispose(options) {
    if (options === void 0) {
      options = {};
    }
    if (this.isDisposed_) {
      return;
    }
    if (this.readyQueue_) {
      this.readyQueue_.length = 0;
    }
    this.trigger({
      type: "dispose",
      bubbles: false
    });
    this.isDisposed_ = true;
    if (this.children_) {
      for (var i = this.children_.length - 1; i >= 0; i--) {
        if (this.children_[i].dispose) {
          this.children_[i].dispose();
        }
      }
    }
    this.children_ = null;
    this.childIndex_ = null;
    this.childNameIndex_ = null;
    this.parentComponent_ = null;
    if (this.el_) {
      if (this.el_.parentNode) {
        if (options.restoreEl) {
          this.el_.parentNode.replaceChild(options.restoreEl, this.el_);
        } else {
          this.el_.parentNode.removeChild(this.el_);
        }
      }
      this.el_ = null;
    }
    this.player_ = null;
  };
  _proto.isDisposed = function isDisposed() {
    return Boolean(this.isDisposed_);
  };
  _proto.player = function player() {
    return this.player_;
  };
  _proto.options = function options(obj) {
    if (!obj) {
      return this.options_;
    }
    this.options_ = mergeOptions$3(this.options_, obj);
    return this.options_;
  };
  _proto.el = function el() {
    return this.el_;
  };
  _proto.createEl = function createEl$1(tagName, properties, attributes) {
    return createEl(tagName, properties, attributes);
  };
  _proto.localize = function localize(string, tokens, defaultValue) {
    if (defaultValue === void 0) {
      defaultValue = string;
    }
    var code = this.player_.language && this.player_.language();
    var languages = this.player_.languages && this.player_.languages();
    var language = languages && languages[code];
    var primaryCode = code && code.split("-")[0];
    var primaryLang = languages && languages[primaryCode];
    var localizedString = defaultValue;
    if (language && language[string]) {
      localizedString = language[string];
    } else if (primaryLang && primaryLang[string]) {
      localizedString = primaryLang[string];
    }
    if (tokens) {
      localizedString = localizedString.replace(/\{(\d+)\}/g, function(match, index) {
        var value = tokens[index - 1];
        var ret = value;
        if (typeof value === "undefined") {
          ret = match;
        }
        return ret;
      });
    }
    return localizedString;
  };
  _proto.handleLanguagechange = function handleLanguagechange() {
  };
  _proto.contentEl = function contentEl() {
    return this.contentEl_ || this.el_;
  };
  _proto.id = function id() {
    return this.id_;
  };
  _proto.name = function name() {
    return this.name_;
  };
  _proto.children = function children() {
    return this.children_;
  };
  _proto.getChildById = function getChildById(id) {
    return this.childIndex_[id];
  };
  _proto.getChild = function getChild(name) {
    if (!name) {
      return;
    }
    return this.childNameIndex_[name];
  };
  _proto.getDescendant = function getDescendant() {
    for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {
      names[_key] = arguments[_key];
    }
    names = names.reduce(function(acc, n) {
      return acc.concat(n);
    }, []);
    var currentChild = this;
    for (var i = 0; i < names.length; i++) {
      currentChild = currentChild.getChild(names[i]);
      if (!currentChild || !currentChild.getChild) {
        return;
      }
    }
    return currentChild;
  };
  _proto.addChild = function addChild(child, options, index) {
    if (options === void 0) {
      options = {};
    }
    if (index === void 0) {
      index = this.children_.length;
    }
    var component;
    var componentName;
    if (typeof child === "string") {
      componentName = toTitleCase$1(child);
      var componentClassName = options.componentClass || componentName;
      options.name = componentName;
      var ComponentClass = Component3.getComponent(componentClassName);
      if (!ComponentClass) {
        throw new Error("Component " + componentClassName + " does not exist");
      }
      if (typeof ComponentClass !== "function") {
        return null;
      }
      component = new ComponentClass(this.player_ || this, options);
    } else {
      component = child;
    }
    if (component.parentComponent_) {
      component.parentComponent_.removeChild(component);
    }
    this.children_.splice(index, 0, component);
    component.parentComponent_ = this;
    if (typeof component.id === "function") {
      this.childIndex_[component.id()] = component;
    }
    componentName = componentName || component.name && toTitleCase$1(component.name());
    if (componentName) {
      this.childNameIndex_[componentName] = component;
      this.childNameIndex_[toLowerCase(componentName)] = component;
    }
    if (typeof component.el === "function" && component.el()) {
      var refNode = null;
      if (this.children_[index + 1]) {
        if (this.children_[index + 1].el_) {
          refNode = this.children_[index + 1].el_;
        } else if (isEl(this.children_[index + 1])) {
          refNode = this.children_[index + 1];
        }
      }
      this.contentEl().insertBefore(component.el(), refNode);
    }
    return component;
  };
  _proto.removeChild = function removeChild(component) {
    if (typeof component === "string") {
      component = this.getChild(component);
    }
    if (!component || !this.children_) {
      return;
    }
    var childFound = false;
    for (var i = this.children_.length - 1; i >= 0; i--) {
      if (this.children_[i] === component) {
        childFound = true;
        this.children_.splice(i, 1);
        break;
      }
    }
    if (!childFound) {
      return;
    }
    component.parentComponent_ = null;
    this.childIndex_[component.id()] = null;
    this.childNameIndex_[toTitleCase$1(component.name())] = null;
    this.childNameIndex_[toLowerCase(component.name())] = null;
    var compEl = component.el();
    if (compEl && compEl.parentNode === this.contentEl()) {
      this.contentEl().removeChild(component.el());
    }
  };
  _proto.initChildren = function initChildren() {
    var _this2 = this;
    var children = this.options_.children;
    if (children) {
      var parentOptions = this.options_;
      var handleAdd = function handleAdd2(child) {
        var name = child.name;
        var opts = child.opts;
        if (parentOptions[name] !== void 0) {
          opts = parentOptions[name];
        }
        if (opts === false) {
          return;
        }
        if (opts === true) {
          opts = {};
        }
        opts.playerOptions = _this2.options_.playerOptions;
        var newChild = _this2.addChild(name, opts);
        if (newChild) {
          _this2[name] = newChild;
        }
      };
      var workingChildren;
      var Tech2 = Component3.getComponent("Tech");
      if (Array.isArray(children)) {
        workingChildren = children;
      } else {
        workingChildren = Object.keys(children);
      }
      workingChildren.concat(Object.keys(this.options_).filter(function(child) {
        return !workingChildren.some(function(wchild) {
          if (typeof wchild === "string") {
            return child === wchild;
          }
          return child === wchild.name;
        });
      })).map(function(child) {
        var name;
        var opts;
        if (typeof child === "string") {
          name = child;
          opts = children[name] || _this2.options_[name] || {};
        } else {
          name = child.name;
          opts = child;
        }
        return {
          name,
          opts
        };
      }).filter(function(child) {
        var c = Component3.getComponent(child.opts.componentClass || toTitleCase$1(child.name));
        return c && !Tech2.isTech(c);
      }).forEach(handleAdd);
    }
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return "";
  };
  _proto.ready = function ready(fn, sync) {
    if (sync === void 0) {
      sync = false;
    }
    if (!fn) {
      return;
    }
    if (!this.isReady_) {
      this.readyQueue_ = this.readyQueue_ || [];
      this.readyQueue_.push(fn);
      return;
    }
    if (sync) {
      fn.call(this);
    } else {
      this.setTimeout(fn, 1);
    }
  };
  _proto.triggerReady = function triggerReady() {
    this.isReady_ = true;
    this.setTimeout(function() {
      var readyQueue = this.readyQueue_;
      this.readyQueue_ = [];
      if (readyQueue && readyQueue.length > 0) {
        readyQueue.forEach(function(fn) {
          fn.call(this);
        }, this);
      }
      this.trigger("ready");
    }, 1);
  };
  _proto.$ = function $$1(selector, context) {
    return $(selector, context || this.contentEl());
  };
  _proto.$$ = function $$$1(selector, context) {
    return $$(selector, context || this.contentEl());
  };
  _proto.hasClass = function hasClass$1(classToCheck) {
    return hasClass(this.el_, classToCheck);
  };
  _proto.addClass = function addClass$1(classToAdd) {
    addClass(this.el_, classToAdd);
  };
  _proto.removeClass = function removeClass$1(classToRemove) {
    removeClass(this.el_, classToRemove);
  };
  _proto.toggleClass = function toggleClass$1(classToToggle, predicate) {
    toggleClass(this.el_, classToToggle, predicate);
  };
  _proto.show = function show() {
    this.removeClass("vjs-hidden");
  };
  _proto.hide = function hide() {
    this.addClass("vjs-hidden");
  };
  _proto.lockShowing = function lockShowing() {
    this.addClass("vjs-lock-showing");
  };
  _proto.unlockShowing = function unlockShowing() {
    this.removeClass("vjs-lock-showing");
  };
  _proto.getAttribute = function getAttribute$1(attribute) {
    return getAttribute(this.el_, attribute);
  };
  _proto.setAttribute = function setAttribute$1(attribute, value) {
    setAttribute(this.el_, attribute, value);
  };
  _proto.removeAttribute = function removeAttribute$1(attribute) {
    removeAttribute(this.el_, attribute);
  };
  _proto.width = function width2(num, skipListeners) {
    return this.dimension("width", num, skipListeners);
  };
  _proto.height = function height2(num, skipListeners) {
    return this.dimension("height", num, skipListeners);
  };
  _proto.dimensions = function dimensions(width2, height2) {
    this.width(width2, true);
    this.height(height2);
  };
  _proto.dimension = function dimension(widthOrHeight, num, skipListeners) {
    if (num !== void 0) {
      if (num === null || num !== num) {
        num = 0;
      }
      if (("" + num).indexOf("%") !== -1 || ("" + num).indexOf("px") !== -1) {
        this.el_.style[widthOrHeight] = num;
      } else if (num === "auto") {
        this.el_.style[widthOrHeight] = "";
      } else {
        this.el_.style[widthOrHeight] = num + "px";
      }
      if (!skipListeners) {
        this.trigger("componentresize");
      }
      return;
    }
    if (!this.el_) {
      return 0;
    }
    var val = this.el_.style[widthOrHeight];
    var pxIndex = val.indexOf("px");
    if (pxIndex !== -1) {
      return parseInt(val.slice(0, pxIndex), 10);
    }
    return parseInt(this.el_["offset" + toTitleCase$1(widthOrHeight)], 10);
  };
  _proto.currentDimension = function currentDimension(widthOrHeight) {
    var computedWidthOrHeight = 0;
    if (widthOrHeight !== "width" && widthOrHeight !== "height") {
      throw new Error("currentDimension only accepts width or height value");
    }
    computedWidthOrHeight = computedStyle(this.el_, widthOrHeight);
    computedWidthOrHeight = parseFloat(computedWidthOrHeight);
    if (computedWidthOrHeight === 0 || isNaN(computedWidthOrHeight)) {
      var rule = "offset" + toTitleCase$1(widthOrHeight);
      computedWidthOrHeight = this.el_[rule];
    }
    return computedWidthOrHeight;
  };
  _proto.currentDimensions = function currentDimensions() {
    return {
      width: this.currentDimension("width"),
      height: this.currentDimension("height")
    };
  };
  _proto.currentWidth = function currentWidth() {
    return this.currentDimension("width");
  };
  _proto.currentHeight = function currentHeight() {
    return this.currentDimension("height");
  };
  _proto.focus = function focus() {
    this.el_.focus();
  };
  _proto.blur = function blur() {
    this.el_.blur();
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    if (this.player_) {
      if (!import_keycode.default.isEventKey(event, "Tab")) {
        event.stopPropagation();
      }
      this.player_.handleKeyDown(event);
    }
  };
  _proto.handleKeyPress = function handleKeyPress(event) {
    this.handleKeyDown(event);
  };
  _proto.emitTapEvents = function emitTapEvents() {
    var touchStart = 0;
    var firstTouch = null;
    var tapMovementThreshold = 10;
    var touchTimeThreshold = 200;
    var couldBeTap;
    this.on("touchstart", function(event) {
      if (event.touches.length === 1) {
        firstTouch = {
          pageX: event.touches[0].pageX,
          pageY: event.touches[0].pageY
        };
        touchStart = import_window6.default.performance.now();
        couldBeTap = true;
      }
    });
    this.on("touchmove", function(event) {
      if (event.touches.length > 1) {
        couldBeTap = false;
      } else if (firstTouch) {
        var xdiff = event.touches[0].pageX - firstTouch.pageX;
        var ydiff = event.touches[0].pageY - firstTouch.pageY;
        var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
        if (touchDistance > tapMovementThreshold) {
          couldBeTap = false;
        }
      }
    });
    var noTap = function noTap2() {
      couldBeTap = false;
    };
    this.on("touchleave", noTap);
    this.on("touchcancel", noTap);
    this.on("touchend", function(event) {
      firstTouch = null;
      if (couldBeTap === true) {
        var touchTime = import_window6.default.performance.now() - touchStart;
        if (touchTime < touchTimeThreshold) {
          event.preventDefault();
          this.trigger("tap");
        }
      }
    });
  };
  _proto.enableTouchActivity = function enableTouchActivity() {
    if (!this.player() || !this.player().reportUserActivity) {
      return;
    }
    var report = bind(this.player(), this.player().reportUserActivity);
    var touchHolding;
    this.on("touchstart", function() {
      report();
      this.clearInterval(touchHolding);
      touchHolding = this.setInterval(report, 250);
    });
    var touchEnd = function touchEnd2(event) {
      report();
      this.clearInterval(touchHolding);
    };
    this.on("touchmove", report);
    this.on("touchend", touchEnd);
    this.on("touchcancel", touchEnd);
  };
  _proto.setTimeout = function setTimeout2(fn, timeout) {
    var _this3 = this;
    var timeoutId;
    fn = bind(this, fn);
    this.clearTimersOnDispose_();
    timeoutId = import_window6.default.setTimeout(function() {
      if (_this3.setTimeoutIds_.has(timeoutId)) {
        _this3.setTimeoutIds_["delete"](timeoutId);
      }
      fn();
    }, timeout);
    this.setTimeoutIds_.add(timeoutId);
    return timeoutId;
  };
  _proto.clearTimeout = function clearTimeout2(timeoutId) {
    if (this.setTimeoutIds_.has(timeoutId)) {
      this.setTimeoutIds_["delete"](timeoutId);
      import_window6.default.clearTimeout(timeoutId);
    }
    return timeoutId;
  };
  _proto.setInterval = function setInterval(fn, interval) {
    fn = bind(this, fn);
    this.clearTimersOnDispose_();
    var intervalId = import_window6.default.setInterval(fn, interval);
    this.setIntervalIds_.add(intervalId);
    return intervalId;
  };
  _proto.clearInterval = function clearInterval2(intervalId) {
    if (this.setIntervalIds_.has(intervalId)) {
      this.setIntervalIds_["delete"](intervalId);
      import_window6.default.clearInterval(intervalId);
    }
    return intervalId;
  };
  _proto.requestAnimationFrame = function requestAnimationFrame(fn) {
    var _this4 = this;
    if (!this.supportsRaf_) {
      return this.setTimeout(fn, 1e3 / 60);
    }
    this.clearTimersOnDispose_();
    var id;
    fn = bind(this, fn);
    id = import_window6.default.requestAnimationFrame(function() {
      if (_this4.rafIds_.has(id)) {
        _this4.rafIds_["delete"](id);
      }
      fn();
    });
    this.rafIds_.add(id);
    return id;
  };
  _proto.requestNamedAnimationFrame = function requestNamedAnimationFrame(name, fn) {
    var _this5 = this;
    if (this.namedRafs_.has(name)) {
      return;
    }
    this.clearTimersOnDispose_();
    fn = bind(this, fn);
    var id = this.requestAnimationFrame(function() {
      fn();
      if (_this5.namedRafs_.has(name)) {
        _this5.namedRafs_["delete"](name);
      }
    });
    this.namedRafs_.set(name, id);
    return name;
  };
  _proto.cancelNamedAnimationFrame = function cancelNamedAnimationFrame(name) {
    if (!this.namedRafs_.has(name)) {
      return;
    }
    this.cancelAnimationFrame(this.namedRafs_.get(name));
    this.namedRafs_["delete"](name);
  };
  _proto.cancelAnimationFrame = function cancelAnimationFrame(id) {
    if (!this.supportsRaf_) {
      return this.clearTimeout(id);
    }
    if (this.rafIds_.has(id)) {
      this.rafIds_["delete"](id);
      import_window6.default.cancelAnimationFrame(id);
    }
    return id;
  };
  _proto.clearTimersOnDispose_ = function clearTimersOnDispose_() {
    var _this6 = this;
    if (this.clearingTimersOnDispose_) {
      return;
    }
    this.clearingTimersOnDispose_ = true;
    this.one("dispose", function() {
      [["namedRafs_", "cancelNamedAnimationFrame"], ["rafIds_", "cancelAnimationFrame"], ["setTimeoutIds_", "clearTimeout"], ["setIntervalIds_", "clearInterval"]].forEach(function(_ref) {
        var idName = _ref[0], cancelName = _ref[1];
        _this6[idName].forEach(function(val, key) {
          return _this6[cancelName](key);
        });
      });
      _this6.clearingTimersOnDispose_ = false;
    });
  };
  Component3.registerComponent = function registerComponent(name, ComponentToRegister) {
    if (typeof name !== "string" || !name) {
      throw new Error('Illegal component name, "' + name + '"; must be a non-empty string.');
    }
    var Tech2 = Component3.getComponent("Tech");
    var isTech = Tech2 && Tech2.isTech(ComponentToRegister);
    var isComp = Component3 === ComponentToRegister || Component3.prototype.isPrototypeOf(ComponentToRegister.prototype);
    if (isTech || !isComp) {
      var reason;
      if (isTech) {
        reason = "techs must be registered using Tech.registerTech()";
      } else {
        reason = "must be a Component subclass";
      }
      throw new Error('Illegal component, "' + name + '"; ' + reason + ".");
    }
    name = toTitleCase$1(name);
    if (!Component3.components_) {
      Component3.components_ = {};
    }
    var Player2 = Component3.getComponent("Player");
    if (name === "Player" && Player2 && Player2.players) {
      var players = Player2.players;
      var playerNames = Object.keys(players);
      if (players && playerNames.length > 0 && playerNames.map(function(pname) {
        return players[pname];
      }).every(Boolean)) {
        throw new Error("Can not register Player component after player has been created.");
      }
    }
    Component3.components_[name] = ComponentToRegister;
    Component3.components_[toLowerCase(name)] = ComponentToRegister;
    return ComponentToRegister;
  };
  Component3.getComponent = function getComponent(name) {
    if (!name || !Component3.components_) {
      return;
    }
    return Component3.components_[name];
  };
  return Component3;
}();
Component$1.prototype.supportsRaf_ = typeof import_window6.default.requestAnimationFrame === "function" && typeof import_window6.default.cancelAnimationFrame === "function";
Component$1.registerComponent("Component", Component$1);
function rangeCheck(fnName, index, maxIndex) {
  if (typeof index !== "number" || index < 0 || index > maxIndex) {
    throw new Error("Failed to execute '" + fnName + "' on 'TimeRanges': The index provided (" + index + ") is non-numeric or out of bounds (0-" + maxIndex + ").");
  }
}
function getRange(fnName, valueIndex, ranges, rangeIndex) {
  rangeCheck(fnName, rangeIndex, ranges.length - 1);
  return ranges[rangeIndex][valueIndex];
}
function createTimeRangesObj(ranges) {
  var timeRangesObj;
  if (ranges === void 0 || ranges.length === 0) {
    timeRangesObj = {
      length: 0,
      start: function start2() {
        throw new Error("This TimeRanges object is empty");
      },
      end: function end() {
        throw new Error("This TimeRanges object is empty");
      }
    };
  } else {
    timeRangesObj = {
      length: ranges.length,
      start: getRange.bind(null, "start", 0, ranges),
      end: getRange.bind(null, "end", 1, ranges)
    };
  }
  if (import_window6.default.Symbol && import_window6.default.Symbol.iterator) {
    timeRangesObj[import_window6.default.Symbol.iterator] = function() {
      return (ranges || []).values();
    };
  }
  return timeRangesObj;
}
function createTimeRanges(start2, end) {
  if (Array.isArray(start2)) {
    return createTimeRangesObj(start2);
  } else if (start2 === void 0 || end === void 0) {
    return createTimeRangesObj();
  }
  return createTimeRangesObj([[start2, end]]);
}
function bufferedPercent(buffered, duration5) {
  var bufferedDuration = 0;
  var start2;
  var end;
  if (!duration5) {
    return 0;
  }
  if (!buffered || !buffered.length) {
    buffered = createTimeRanges(0, 0);
  }
  for (var i = 0; i < buffered.length; i++) {
    start2 = buffered.start(i);
    end = buffered.end(i);
    if (end > duration5) {
      end = duration5;
    }
    bufferedDuration += end - start2;
  }
  return bufferedDuration / duration5;
}
function MediaError(value) {
  if (value instanceof MediaError) {
    return value;
  }
  if (typeof value === "number") {
    this.code = value;
  } else if (typeof value === "string") {
    this.message = value;
  } else if (isObject3(value)) {
    if (typeof value.code === "number") {
      this.code = value.code;
    }
    assign(this, value);
  }
  if (!this.message) {
    this.message = MediaError.defaultMessages[this.code] || "";
  }
}
MediaError.prototype.code = 0;
MediaError.prototype.message = "";
MediaError.prototype.status = null;
MediaError.errorTypes = ["MEDIA_ERR_CUSTOM", "MEDIA_ERR_ABORTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_DECODE", "MEDIA_ERR_SRC_NOT_SUPPORTED", "MEDIA_ERR_ENCRYPTED"];
MediaError.defaultMessages = {
  1: "You aborted the media playback",
  2: "A network error caused the media download to fail part-way.",
  3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
  4: "The media could not be loaded, either because the server or network failed or because the format is not supported.",
  5: "The media is encrypted and we do not have the keys to decrypt it."
};
for (errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {
  MediaError[MediaError.errorTypes[errNum]] = errNum;
  MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
}
var errNum;
function isPromise2(value) {
  return value !== void 0 && value !== null && typeof value.then === "function";
}
function silencePromise(value) {
  if (isPromise2(value)) {
    value.then(null, function(e) {
    });
  }
}
var trackToJson_ = function trackToJson_2(track) {
  var ret = ["kind", "label", "language", "id", "inBandMetadataTrackDispatchType", "mode", "src"].reduce(function(acc, prop, i) {
    if (track[prop]) {
      acc[prop] = track[prop];
    }
    return acc;
  }, {
    cues: track.cues && Array.prototype.map.call(track.cues, function(cue) {
      return {
        startTime: cue.startTime,
        endTime: cue.endTime,
        text: cue.text,
        id: cue.id
      };
    })
  });
  return ret;
};
var textTracksToJson = function textTracksToJson2(tech) {
  var trackEls = tech.$$("track");
  var trackObjs = Array.prototype.map.call(trackEls, function(t2) {
    return t2.track;
  });
  var tracks = Array.prototype.map.call(trackEls, function(trackEl) {
    var json = trackToJson_(trackEl.track);
    if (trackEl.src) {
      json.src = trackEl.src;
    }
    return json;
  });
  return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function(track) {
    return trackObjs.indexOf(track) === -1;
  }).map(trackToJson_));
};
var jsonToTextTracks = function jsonToTextTracks2(json, tech) {
  json.forEach(function(track) {
    var addedTrack = tech.addRemoteTextTrack(track).track;
    if (!track.src && track.cues) {
      track.cues.forEach(function(cue) {
        return addedTrack.addCue(cue);
      });
    }
  });
  return tech.textTracks();
};
var textTrackConverter = {
  textTracksToJson,
  jsonToTextTracks,
  trackToJson_
};
var MODAL_CLASS_NAME = "vjs-modal-dialog";
var ModalDialog = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(ModalDialog2, _Component);
  function ModalDialog2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.handleKeyDown_ = function(e) {
      return _this.handleKeyDown(e);
    };
    _this.close_ = function(e) {
      return _this.close(e);
    };
    _this.opened_ = _this.hasBeenOpened_ = _this.hasBeenFilled_ = false;
    _this.closeable(!_this.options_.uncloseable);
    _this.content(_this.options_.content);
    _this.contentEl_ = createEl("div", {
      className: MODAL_CLASS_NAME + "-content"
    }, {
      role: "document"
    });
    _this.descEl_ = createEl("p", {
      className: MODAL_CLASS_NAME + "-description vjs-control-text",
      id: _this.el().getAttribute("aria-describedby")
    });
    textContent(_this.descEl_, _this.description());
    _this.el_.appendChild(_this.descEl_);
    _this.el_.appendChild(_this.contentEl_);
    return _this;
  }
  var _proto = ModalDialog2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: this.buildCSSClass(),
      tabIndex: -1
    }, {
      "aria-describedby": this.id() + "_description",
      "aria-hidden": "true",
      "aria-label": this.label(),
      "role": "dialog"
    });
  };
  _proto.dispose = function dispose() {
    this.contentEl_ = null;
    this.descEl_ = null;
    this.previouslyActiveEl_ = null;
    _Component.prototype.dispose.call(this);
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return MODAL_CLASS_NAME + " vjs-hidden " + _Component.prototype.buildCSSClass.call(this);
  };
  _proto.label = function label() {
    return this.localize(this.options_.label || "Modal Window");
  };
  _proto.description = function description() {
    var desc = this.options_.description || this.localize("This is a modal window.");
    if (this.closeable()) {
      desc += " " + this.localize("This modal can be closed by pressing the Escape key or activating the close button.");
    }
    return desc;
  };
  _proto.open = function open() {
    if (!this.opened_) {
      var player = this.player();
      this.trigger("beforemodalopen");
      this.opened_ = true;
      if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {
        this.fill();
      }
      this.wasPlaying_ = !player.paused();
      if (this.options_.pauseOnOpen && this.wasPlaying_) {
        player.pause();
      }
      this.on("keydown", this.handleKeyDown_);
      this.hadControls_ = player.controls();
      player.controls(false);
      this.show();
      this.conditionalFocus_();
      this.el().setAttribute("aria-hidden", "false");
      this.trigger("modalopen");
      this.hasBeenOpened_ = true;
    }
  };
  _proto.opened = function opened(value) {
    if (typeof value === "boolean") {
      this[value ? "open" : "close"]();
    }
    return this.opened_;
  };
  _proto.close = function close() {
    if (!this.opened_) {
      return;
    }
    var player = this.player();
    this.trigger("beforemodalclose");
    this.opened_ = false;
    if (this.wasPlaying_ && this.options_.pauseOnOpen) {
      player.play();
    }
    this.off("keydown", this.handleKeyDown_);
    if (this.hadControls_) {
      player.controls(true);
    }
    this.hide();
    this.el().setAttribute("aria-hidden", "true");
    this.trigger("modalclose");
    this.conditionalBlur_();
    if (this.options_.temporary) {
      this.dispose();
    }
  };
  _proto.closeable = function closeable(value) {
    if (typeof value === "boolean") {
      var closeable2 = this.closeable_ = !!value;
      var close = this.getChild("closeButton");
      if (closeable2 && !close) {
        var temp = this.contentEl_;
        this.contentEl_ = this.el_;
        close = this.addChild("closeButton", {
          controlText: "Close Modal Dialog"
        });
        this.contentEl_ = temp;
        this.on(close, "close", this.close_);
      }
      if (!closeable2 && close) {
        this.off(close, "close", this.close_);
        this.removeChild(close);
        close.dispose();
      }
    }
    return this.closeable_;
  };
  _proto.fill = function fill() {
    this.fillWith(this.content());
  };
  _proto.fillWith = function fillWith(content) {
    var contentEl = this.contentEl();
    var parentEl = contentEl.parentNode;
    var nextSiblingEl = contentEl.nextSibling;
    this.trigger("beforemodalfill");
    this.hasBeenFilled_ = true;
    parentEl.removeChild(contentEl);
    this.empty();
    insertContent(contentEl, content);
    this.trigger("modalfill");
    if (nextSiblingEl) {
      parentEl.insertBefore(contentEl, nextSiblingEl);
    } else {
      parentEl.appendChild(contentEl);
    }
    var closeButton = this.getChild("closeButton");
    if (closeButton) {
      parentEl.appendChild(closeButton.el_);
    }
  };
  _proto.empty = function empty() {
    this.trigger("beforemodalempty");
    emptyEl(this.contentEl());
    this.trigger("modalempty");
  };
  _proto.content = function content(value) {
    if (typeof value !== "undefined") {
      this.content_ = value;
    }
    return this.content_;
  };
  _proto.conditionalFocus_ = function conditionalFocus_() {
    var activeEl = import_document.default.activeElement;
    var playerEl = this.player_.el_;
    this.previouslyActiveEl_ = null;
    if (playerEl.contains(activeEl) || playerEl === activeEl) {
      this.previouslyActiveEl_ = activeEl;
      this.focus();
    }
  };
  _proto.conditionalBlur_ = function conditionalBlur_() {
    if (this.previouslyActiveEl_) {
      this.previouslyActiveEl_.focus();
      this.previouslyActiveEl_ = null;
    }
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    event.stopPropagation();
    if (import_keycode.default.isEventKey(event, "Escape") && this.closeable()) {
      event.preventDefault();
      this.close();
      return;
    }
    if (!import_keycode.default.isEventKey(event, "Tab")) {
      return;
    }
    var focusableEls = this.focusableEls_();
    var activeEl = this.el_.querySelector(":focus");
    var focusIndex;
    for (var i = 0; i < focusableEls.length; i++) {
      if (activeEl === focusableEls[i]) {
        focusIndex = i;
        break;
      }
    }
    if (import_document.default.activeElement === this.el_) {
      focusIndex = 0;
    }
    if (event.shiftKey && focusIndex === 0) {
      focusableEls[focusableEls.length - 1].focus();
      event.preventDefault();
    } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {
      focusableEls[0].focus();
      event.preventDefault();
    }
  };
  _proto.focusableEls_ = function focusableEls_() {
    var allChildren = this.el_.querySelectorAll("*");
    return Array.prototype.filter.call(allChildren, function(child) {
      return (child instanceof import_window6.default.HTMLAnchorElement || child instanceof import_window6.default.HTMLAreaElement) && child.hasAttribute("href") || (child instanceof import_window6.default.HTMLInputElement || child instanceof import_window6.default.HTMLSelectElement || child instanceof import_window6.default.HTMLTextAreaElement || child instanceof import_window6.default.HTMLButtonElement) && !child.hasAttribute("disabled") || child instanceof import_window6.default.HTMLIFrameElement || child instanceof import_window6.default.HTMLObjectElement || child instanceof import_window6.default.HTMLEmbedElement || child.hasAttribute("tabindex") && child.getAttribute("tabindex") !== -1 || child.hasAttribute("contenteditable");
    });
  };
  return ModalDialog2;
}(Component$1);
ModalDialog.prototype.options_ = {
  pauseOnOpen: true,
  temporary: true
};
Component$1.registerComponent("ModalDialog", ModalDialog);
var TrackList = /* @__PURE__ */ function(_EventTarget) {
  _inheritsLoose(TrackList2, _EventTarget);
  function TrackList2(tracks) {
    var _this;
    if (tracks === void 0) {
      tracks = [];
    }
    _this = _EventTarget.call(this) || this;
    _this.tracks_ = [];
    Object.defineProperty(_assertThisInitialized(_this), "length", {
      get: function get7() {
        return this.tracks_.length;
      }
    });
    for (var i = 0; i < tracks.length; i++) {
      _this.addTrack(tracks[i]);
    }
    return _this;
  }
  var _proto = TrackList2.prototype;
  _proto.addTrack = function addTrack(track) {
    var _this2 = this;
    var index = this.tracks_.length;
    if (!("" + index in this)) {
      Object.defineProperty(this, index, {
        get: function get7() {
          return this.tracks_[index];
        }
      });
    }
    if (this.tracks_.indexOf(track) === -1) {
      this.tracks_.push(track);
      this.trigger({
        track,
        type: "addtrack",
        target: this
      });
    }
    track.labelchange_ = function() {
      _this2.trigger({
        track,
        type: "labelchange",
        target: _this2
      });
    };
    if (isEvented(track)) {
      track.addEventListener("labelchange", track.labelchange_);
    }
  };
  _proto.removeTrack = function removeTrack(rtrack) {
    var track;
    for (var i = 0, l = this.length; i < l; i++) {
      if (this[i] === rtrack) {
        track = this[i];
        if (track.off) {
          track.off();
        }
        this.tracks_.splice(i, 1);
        break;
      }
    }
    if (!track) {
      return;
    }
    this.trigger({
      track,
      type: "removetrack",
      target: this
    });
  };
  _proto.getTrackById = function getTrackById(id) {
    var result = null;
    for (var i = 0, l = this.length; i < l; i++) {
      var track = this[i];
      if (track.id === id) {
        result = track;
        break;
      }
    }
    return result;
  };
  return TrackList2;
}(EventTarget$2);
TrackList.prototype.allowedEvents_ = {
  change: "change",
  addtrack: "addtrack",
  removetrack: "removetrack",
  labelchange: "labelchange"
};
for (event in TrackList.prototype.allowedEvents_) {
  TrackList.prototype["on" + event] = null;
}
var event;
var disableOthers$1 = function disableOthers(list, track) {
  for (var i = 0; i < list.length; i++) {
    if (!Object.keys(list[i]).length || track.id === list[i].id) {
      continue;
    }
    list[i].enabled = false;
  }
};
var AudioTrackList = /* @__PURE__ */ function(_TrackList) {
  _inheritsLoose(AudioTrackList2, _TrackList);
  function AudioTrackList2(tracks) {
    var _this;
    if (tracks === void 0) {
      tracks = [];
    }
    for (var i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].enabled) {
        disableOthers$1(tracks, tracks[i]);
        break;
      }
    }
    _this = _TrackList.call(this, tracks) || this;
    _this.changing_ = false;
    return _this;
  }
  var _proto = AudioTrackList2.prototype;
  _proto.addTrack = function addTrack(track) {
    var _this2 = this;
    if (track.enabled) {
      disableOthers$1(this, track);
    }
    _TrackList.prototype.addTrack.call(this, track);
    if (!track.addEventListener) {
      return;
    }
    track.enabledChange_ = function() {
      if (_this2.changing_) {
        return;
      }
      _this2.changing_ = true;
      disableOthers$1(_this2, track);
      _this2.changing_ = false;
      _this2.trigger("change");
    };
    track.addEventListener("enabledchange", track.enabledChange_);
  };
  _proto.removeTrack = function removeTrack(rtrack) {
    _TrackList.prototype.removeTrack.call(this, rtrack);
    if (rtrack.removeEventListener && rtrack.enabledChange_) {
      rtrack.removeEventListener("enabledchange", rtrack.enabledChange_);
      rtrack.enabledChange_ = null;
    }
  };
  return AudioTrackList2;
}(TrackList);
var disableOthers2 = function disableOthers3(list, track) {
  for (var i = 0; i < list.length; i++) {
    if (!Object.keys(list[i]).length || track.id === list[i].id) {
      continue;
    }
    list[i].selected = false;
  }
};
var VideoTrackList = /* @__PURE__ */ function(_TrackList) {
  _inheritsLoose(VideoTrackList2, _TrackList);
  function VideoTrackList2(tracks) {
    var _this;
    if (tracks === void 0) {
      tracks = [];
    }
    for (var i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].selected) {
        disableOthers2(tracks, tracks[i]);
        break;
      }
    }
    _this = _TrackList.call(this, tracks) || this;
    _this.changing_ = false;
    Object.defineProperty(_assertThisInitialized(_this), "selectedIndex", {
      get: function get7() {
        for (var _i = 0; _i < this.length; _i++) {
          if (this[_i].selected) {
            return _i;
          }
        }
        return -1;
      },
      set: function set4() {
      }
    });
    return _this;
  }
  var _proto = VideoTrackList2.prototype;
  _proto.addTrack = function addTrack(track) {
    var _this2 = this;
    if (track.selected) {
      disableOthers2(this, track);
    }
    _TrackList.prototype.addTrack.call(this, track);
    if (!track.addEventListener) {
      return;
    }
    track.selectedChange_ = function() {
      if (_this2.changing_) {
        return;
      }
      _this2.changing_ = true;
      disableOthers2(_this2, track);
      _this2.changing_ = false;
      _this2.trigger("change");
    };
    track.addEventListener("selectedchange", track.selectedChange_);
  };
  _proto.removeTrack = function removeTrack(rtrack) {
    _TrackList.prototype.removeTrack.call(this, rtrack);
    if (rtrack.removeEventListener && rtrack.selectedChange_) {
      rtrack.removeEventListener("selectedchange", rtrack.selectedChange_);
      rtrack.selectedChange_ = null;
    }
  };
  return VideoTrackList2;
}(TrackList);
var TextTrackList = /* @__PURE__ */ function(_TrackList) {
  _inheritsLoose(TextTrackList2, _TrackList);
  function TextTrackList2() {
    return _TrackList.apply(this, arguments) || this;
  }
  var _proto = TextTrackList2.prototype;
  _proto.addTrack = function addTrack(track) {
    var _this = this;
    _TrackList.prototype.addTrack.call(this, track);
    if (!this.queueChange_) {
      this.queueChange_ = function() {
        return _this.queueTrigger("change");
      };
    }
    if (!this.triggerSelectedlanguagechange) {
      this.triggerSelectedlanguagechange_ = function() {
        return _this.trigger("selectedlanguagechange");
      };
    }
    track.addEventListener("modechange", this.queueChange_);
    var nonLanguageTextTrackKind = ["metadata", "chapters"];
    if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {
      track.addEventListener("modechange", this.triggerSelectedlanguagechange_);
    }
  };
  _proto.removeTrack = function removeTrack(rtrack) {
    _TrackList.prototype.removeTrack.call(this, rtrack);
    if (rtrack.removeEventListener) {
      if (this.queueChange_) {
        rtrack.removeEventListener("modechange", this.queueChange_);
      }
      if (this.selectedlanguagechange_) {
        rtrack.removeEventListener("modechange", this.triggerSelectedlanguagechange_);
      }
    }
  };
  return TextTrackList2;
}(TrackList);
var HtmlTrackElementList = /* @__PURE__ */ function() {
  function HtmlTrackElementList2(trackElements) {
    if (trackElements === void 0) {
      trackElements = [];
    }
    this.trackElements_ = [];
    Object.defineProperty(this, "length", {
      get: function get7() {
        return this.trackElements_.length;
      }
    });
    for (var i = 0, length = trackElements.length; i < length; i++) {
      this.addTrackElement_(trackElements[i]);
    }
  }
  var _proto = HtmlTrackElementList2.prototype;
  _proto.addTrackElement_ = function addTrackElement_(trackElement) {
    var index = this.trackElements_.length;
    if (!("" + index in this)) {
      Object.defineProperty(this, index, {
        get: function get7() {
          return this.trackElements_[index];
        }
      });
    }
    if (this.trackElements_.indexOf(trackElement) === -1) {
      this.trackElements_.push(trackElement);
    }
  };
  _proto.getTrackElementByTrack_ = function getTrackElementByTrack_(track) {
    var trackElement_;
    for (var i = 0, length = this.trackElements_.length; i < length; i++) {
      if (track === this.trackElements_[i].track) {
        trackElement_ = this.trackElements_[i];
        break;
      }
    }
    return trackElement_;
  };
  _proto.removeTrackElement_ = function removeTrackElement_(trackElement) {
    for (var i = 0, length = this.trackElements_.length; i < length; i++) {
      if (trackElement === this.trackElements_[i]) {
        if (this.trackElements_[i].track && typeof this.trackElements_[i].track.off === "function") {
          this.trackElements_[i].track.off();
        }
        if (typeof this.trackElements_[i].off === "function") {
          this.trackElements_[i].off();
        }
        this.trackElements_.splice(i, 1);
        break;
      }
    }
  };
  return HtmlTrackElementList2;
}();
var TextTrackCueList = /* @__PURE__ */ function() {
  function TextTrackCueList2(cues) {
    TextTrackCueList2.prototype.setCues_.call(this, cues);
    Object.defineProperty(this, "length", {
      get: function get7() {
        return this.length_;
      }
    });
  }
  var _proto = TextTrackCueList2.prototype;
  _proto.setCues_ = function setCues_(cues) {
    var oldLength = this.length || 0;
    var i = 0;
    var l = cues.length;
    this.cues_ = cues;
    this.length_ = cues.length;
    var defineProp = function defineProp2(index) {
      if (!("" + index in this)) {
        Object.defineProperty(this, "" + index, {
          get: function get7() {
            return this.cues_[index];
          }
        });
      }
    };
    if (oldLength < l) {
      i = oldLength;
      for (; i < l; i++) {
        defineProp.call(this, i);
      }
    }
  };
  _proto.getCueById = function getCueById(id) {
    var result = null;
    for (var i = 0, l = this.length; i < l; i++) {
      var cue = this[i];
      if (cue.id === id) {
        result = cue;
        break;
      }
    }
    return result;
  };
  return TextTrackCueList2;
}();
var VideoTrackKind = {
  alternative: "alternative",
  captions: "captions",
  main: "main",
  sign: "sign",
  subtitles: "subtitles",
  commentary: "commentary"
};
var AudioTrackKind = {
  "alternative": "alternative",
  "descriptions": "descriptions",
  "main": "main",
  "main-desc": "main-desc",
  "translation": "translation",
  "commentary": "commentary"
};
var TextTrackKind = {
  subtitles: "subtitles",
  captions: "captions",
  descriptions: "descriptions",
  chapters: "chapters",
  metadata: "metadata"
};
var TextTrackMode = {
  disabled: "disabled",
  hidden: "hidden",
  showing: "showing"
};
var Track = /* @__PURE__ */ function(_EventTarget) {
  _inheritsLoose(Track2, _EventTarget);
  function Track2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _EventTarget.call(this) || this;
    var trackProps = {
      id: options.id || "vjs_track_" + newGUID(),
      kind: options.kind || "",
      language: options.language || ""
    };
    var label = options.label || "";
    var _loop = function _loop2(key2) {
      Object.defineProperty(_assertThisInitialized(_this), key2, {
        get: function get7() {
          return trackProps[key2];
        },
        set: function set4() {
        }
      });
    };
    for (var key in trackProps) {
      _loop(key);
    }
    Object.defineProperty(_assertThisInitialized(_this), "label", {
      get: function get7() {
        return label;
      },
      set: function set4(newLabel) {
        if (newLabel !== label) {
          label = newLabel;
          this.trigger("labelchange");
        }
      }
    });
    return _this;
  }
  return Track2;
}(EventTarget$2);
var parseUrl = function parseUrl2(url) {
  var props = ["protocol", "hostname", "port", "pathname", "search", "hash", "host"];
  var a = import_document.default.createElement("a");
  a.href = url;
  var details = {};
  for (var i = 0; i < props.length; i++) {
    details[props[i]] = a[props[i]];
  }
  if (details.protocol === "http:") {
    details.host = details.host.replace(/:80$/, "");
  }
  if (details.protocol === "https:") {
    details.host = details.host.replace(/:443$/, "");
  }
  if (!details.protocol) {
    details.protocol = import_window6.default.location.protocol;
  }
  if (!details.host) {
    details.host = import_window6.default.location.host;
  }
  return details;
};
var getAbsoluteURL = function getAbsoluteURL2(url) {
  if (!url.match(/^https?:\/\//)) {
    var a = import_document.default.createElement("a");
    a.href = url;
    url = a.href;
  }
  return url;
};
var getFileExtension = function getFileExtension2(path) {
  if (typeof path === "string") {
    var splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/;
    var pathParts = splitPathRe.exec(path);
    if (pathParts) {
      return pathParts.pop().toLowerCase();
    }
  }
  return "";
};
var isCrossOrigin = function isCrossOrigin2(url, winLoc) {
  if (winLoc === void 0) {
    winLoc = import_window6.default.location;
  }
  var urlInfo = parseUrl(url);
  var srcProtocol = urlInfo.protocol === ":" ? winLoc.protocol : urlInfo.protocol;
  var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;
  return crossOrigin;
};
var Url = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  parseUrl,
  getAbsoluteURL,
  getFileExtension,
  isCrossOrigin
});
var parseCues = function parseCues2(srcContent, track) {
  var parser6 = new import_window6.default.WebVTT.Parser(import_window6.default, import_window6.default.vttjs, import_window6.default.WebVTT.StringDecoder());
  var errors2 = [];
  parser6.oncue = function(cue) {
    track.addCue(cue);
  };
  parser6.onparsingerror = function(error) {
    errors2.push(error);
  };
  parser6.onflush = function() {
    track.trigger({
      type: "loadeddata",
      target: track
    });
  };
  parser6.parse(srcContent);
  if (errors2.length > 0) {
    if (import_window6.default.console && import_window6.default.console.groupCollapsed) {
      import_window6.default.console.groupCollapsed("Text Track parsing errors for " + track.src);
    }
    errors2.forEach(function(error) {
      return log$1.error(error);
    });
    if (import_window6.default.console && import_window6.default.console.groupEnd) {
      import_window6.default.console.groupEnd();
    }
  }
  parser6.flush();
};
var loadTrack = function loadTrack2(src, track) {
  var opts = {
    uri: src
  };
  var crossOrigin = isCrossOrigin(src);
  if (crossOrigin) {
    opts.cors = crossOrigin;
  }
  var withCredentials = track.tech_.crossOrigin() === "use-credentials";
  if (withCredentials) {
    opts.withCredentials = withCredentials;
  }
  (0, import_xhr.default)(opts, bind(this, function(err, response, responseBody) {
    if (err) {
      return log$1.error(err, response);
    }
    track.loaded_ = true;
    if (typeof import_window6.default.WebVTT !== "function") {
      if (track.tech_) {
        track.tech_.any(["vttjsloaded", "vttjserror"], function(event) {
          if (event.type === "vttjserror") {
            log$1.error("vttjs failed to load, stopping trying to process " + track.src);
            return;
          }
          return parseCues(responseBody, track);
        });
      }
    } else {
      parseCues(responseBody, track);
    }
  }));
};
var TextTrack = /* @__PURE__ */ function(_Track) {
  _inheritsLoose(TextTrack2, _Track);
  function TextTrack2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    if (!options.tech) {
      throw new Error("A tech was not provided.");
    }
    var settings = mergeOptions$3(options, {
      kind: TextTrackKind[options.kind] || "subtitles",
      language: options.language || options.srclang || ""
    });
    var mode = TextTrackMode[settings.mode] || "disabled";
    var default_ = settings["default"];
    if (settings.kind === "metadata" || settings.kind === "chapters") {
      mode = "hidden";
    }
    _this = _Track.call(this, settings) || this;
    _this.tech_ = settings.tech;
    _this.cues_ = [];
    _this.activeCues_ = [];
    _this.preload_ = _this.tech_.preloadTextTracks !== false;
    var cues = new TextTrackCueList(_this.cues_);
    var activeCues = new TextTrackCueList(_this.activeCues_);
    var changed = false;
    _this.timeupdateHandler = bind(_assertThisInitialized(_this), function(event) {
      if (event === void 0) {
        event = {};
      }
      if (this.tech_.isDisposed()) {
        return;
      }
      if (!this.tech_.isReady_) {
        if (event.type !== "timeupdate") {
          this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
        }
        return;
      }
      this.activeCues = this.activeCues;
      if (changed) {
        this.trigger("cuechange");
        changed = false;
      }
      if (event.type !== "timeupdate") {
        this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
      }
    });
    var disposeHandler = function disposeHandler2() {
      _this.stopTracking();
    };
    _this.tech_.one("dispose", disposeHandler);
    if (mode !== "disabled") {
      _this.startTracking();
    }
    Object.defineProperties(_assertThisInitialized(_this), {
      /**
       * @memberof TextTrack
       * @member {boolean} default
       *         If this track was set to be on or off by default. Cannot be changed after
       *         creation.
       * @instance
       *
       * @readonly
       */
      "default": {
        get: function get7() {
          return default_;
        },
        set: function set4() {
        }
      },
      /**
       * @memberof TextTrack
       * @member {string} mode
       *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will
       *         not be set if setting to an invalid mode.
       * @instance
       *
       * @fires TextTrack#modechange
       */
      mode: {
        get: function get7() {
          return mode;
        },
        set: function set4(newMode) {
          if (!TextTrackMode[newMode]) {
            return;
          }
          if (mode === newMode) {
            return;
          }
          mode = newMode;
          if (!this.preload_ && mode !== "disabled" && this.cues.length === 0) {
            loadTrack(this.src, this);
          }
          this.stopTracking();
          if (mode !== "disabled") {
            this.startTracking();
          }
          this.trigger("modechange");
        }
      },
      /**
       * @memberof TextTrack
       * @member {TextTrackCueList} cues
       *         The text track cue list for this TextTrack.
       * @instance
       */
      cues: {
        get: function get7() {
          if (!this.loaded_) {
            return null;
          }
          return cues;
        },
        set: function set4() {
        }
      },
      /**
       * @memberof TextTrack
       * @member {TextTrackCueList} activeCues
       *         The list text track cues that are currently active for this TextTrack.
       * @instance
       */
      activeCues: {
        get: function get7() {
          if (!this.loaded_) {
            return null;
          }
          if (this.cues.length === 0) {
            return activeCues;
          }
          var ct = this.tech_.currentTime();
          var active = [];
          for (var i = 0, l = this.cues.length; i < l; i++) {
            var cue = this.cues[i];
            if (cue.startTime <= ct && cue.endTime >= ct) {
              active.push(cue);
            } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {
              active.push(cue);
            }
          }
          changed = false;
          if (active.length !== this.activeCues_.length) {
            changed = true;
          } else {
            for (var _i = 0; _i < active.length; _i++) {
              if (this.activeCues_.indexOf(active[_i]) === -1) {
                changed = true;
              }
            }
          }
          this.activeCues_ = active;
          activeCues.setCues_(this.activeCues_);
          return activeCues;
        },
        // /!\ Keep this setter empty (see the timeupdate handler above)
        set: function set4() {
        }
      }
    });
    if (settings.src) {
      _this.src = settings.src;
      if (!_this.preload_) {
        _this.loaded_ = true;
      }
      if (_this.preload_ || settings.kind !== "subtitles" && settings.kind !== "captions") {
        loadTrack(_this.src, _assertThisInitialized(_this));
      }
    } else {
      _this.loaded_ = true;
    }
    return _this;
  }
  var _proto = TextTrack2.prototype;
  _proto.startTracking = function startTracking() {
    this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
    this.tech_.on("timeupdate", this.timeupdateHandler);
  };
  _proto.stopTracking = function stopTracking() {
    if (this.rvf_) {
      this.tech_.cancelVideoFrameCallback(this.rvf_);
      this.rvf_ = void 0;
    }
    this.tech_.off("timeupdate", this.timeupdateHandler);
  };
  _proto.addCue = function addCue(originalCue) {
    var cue = originalCue;
    if (import_window6.default.vttjs && !(originalCue instanceof import_window6.default.vttjs.VTTCue)) {
      cue = new import_window6.default.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);
      for (var prop in originalCue) {
        if (!(prop in cue)) {
          cue[prop] = originalCue[prop];
        }
      }
      cue.id = originalCue.id;
      cue.originalCue_ = originalCue;
    }
    var tracks = this.tech_.textTracks();
    for (var i = 0; i < tracks.length; i++) {
      if (tracks[i] !== this) {
        tracks[i].removeCue(cue);
      }
    }
    this.cues_.push(cue);
    this.cues.setCues_(this.cues_);
  };
  _proto.removeCue = function removeCue(_removeCue) {
    var i = this.cues_.length;
    while (i--) {
      var cue = this.cues_[i];
      if (cue === _removeCue || cue.originalCue_ && cue.originalCue_ === _removeCue) {
        this.cues_.splice(i, 1);
        this.cues.setCues_(this.cues_);
        break;
      }
    }
  };
  return TextTrack2;
}(Track);
TextTrack.prototype.allowedEvents_ = {
  cuechange: "cuechange"
};
var AudioTrack = /* @__PURE__ */ function(_Track) {
  _inheritsLoose(AudioTrack2, _Track);
  function AudioTrack2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    var settings = mergeOptions$3(options, {
      kind: AudioTrackKind[options.kind] || ""
    });
    _this = _Track.call(this, settings) || this;
    var enabled = false;
    Object.defineProperty(_assertThisInitialized(_this), "enabled", {
      get: function get7() {
        return enabled;
      },
      set: function set4(newEnabled) {
        if (typeof newEnabled !== "boolean" || newEnabled === enabled) {
          return;
        }
        enabled = newEnabled;
        this.trigger("enabledchange");
      }
    });
    if (settings.enabled) {
      _this.enabled = settings.enabled;
    }
    _this.loaded_ = true;
    return _this;
  }
  return AudioTrack2;
}(Track);
var VideoTrack = /* @__PURE__ */ function(_Track) {
  _inheritsLoose(VideoTrack2, _Track);
  function VideoTrack2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    var settings = mergeOptions$3(options, {
      kind: VideoTrackKind[options.kind] || ""
    });
    _this = _Track.call(this, settings) || this;
    var selected = false;
    Object.defineProperty(_assertThisInitialized(_this), "selected", {
      get: function get7() {
        return selected;
      },
      set: function set4(newSelected) {
        if (typeof newSelected !== "boolean" || newSelected === selected) {
          return;
        }
        selected = newSelected;
        this.trigger("selectedchange");
      }
    });
    if (settings.selected) {
      _this.selected = settings.selected;
    }
    return _this;
  }
  return VideoTrack2;
}(Track);
var NONE = 0;
var LOADING = 1;
var LOADED = 2;
var ERROR = 3;
var HTMLTrackElement = /* @__PURE__ */ function(_EventTarget) {
  _inheritsLoose(HTMLTrackElement2, _EventTarget);
  function HTMLTrackElement2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _EventTarget.call(this) || this;
    var readyState;
    var track = new TextTrack(options);
    _this.kind = track.kind;
    _this.src = track.src;
    _this.srclang = track.language;
    _this.label = track.label;
    _this["default"] = track["default"];
    Object.defineProperties(_assertThisInitialized(_this), {
      /**
       * @memberof HTMLTrackElement
       * @member {HTMLTrackElement~ReadyState} readyState
       *         The current ready state of the track element.
       * @instance
       */
      readyState: {
        get: function get7() {
          return readyState;
        }
      },
      /**
       * @memberof HTMLTrackElement
       * @member {TextTrack} track
       *         The underlying TextTrack object.
       * @instance
       *
       */
      track: {
        get: function get7() {
          return track;
        }
      }
    });
    readyState = NONE;
    track.addEventListener("loadeddata", function() {
      readyState = LOADED;
      _this.trigger({
        type: "load",
        target: _assertThisInitialized(_this)
      });
    });
    return _this;
  }
  return HTMLTrackElement2;
}(EventTarget$2);
HTMLTrackElement.prototype.allowedEvents_ = {
  load: "load"
};
HTMLTrackElement.NONE = NONE;
HTMLTrackElement.LOADING = LOADING;
HTMLTrackElement.LOADED = LOADED;
HTMLTrackElement.ERROR = ERROR;
var NORMAL = {
  audio: {
    ListClass: AudioTrackList,
    TrackClass: AudioTrack,
    capitalName: "Audio"
  },
  video: {
    ListClass: VideoTrackList,
    TrackClass: VideoTrack,
    capitalName: "Video"
  },
  text: {
    ListClass: TextTrackList,
    TrackClass: TextTrack,
    capitalName: "Text"
  }
};
Object.keys(NORMAL).forEach(function(type2) {
  NORMAL[type2].getterName = type2 + "Tracks";
  NORMAL[type2].privateName = type2 + "Tracks_";
});
var REMOTE = {
  remoteText: {
    ListClass: TextTrackList,
    TrackClass: TextTrack,
    capitalName: "RemoteText",
    getterName: "remoteTextTracks",
    privateName: "remoteTextTracks_"
  },
  remoteTextEl: {
    ListClass: HtmlTrackElementList,
    TrackClass: HTMLTrackElement,
    capitalName: "RemoteTextTrackEls",
    getterName: "remoteTextTrackEls",
    privateName: "remoteTextTrackEls_"
  }
};
var ALL = _extends2({}, NORMAL, REMOTE);
REMOTE.names = Object.keys(REMOTE);
NORMAL.names = Object.keys(NORMAL);
ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);
function createTrackHelper(self2, kind, label, language, options) {
  if (options === void 0) {
    options = {};
  }
  var tracks = self2.textTracks();
  options.kind = kind;
  if (label) {
    options.label = label;
  }
  if (language) {
    options.language = language;
  }
  options.tech = self2;
  var track = new ALL.text.TrackClass(options);
  tracks.addTrack(track);
  return track;
}
var Tech = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(Tech2, _Component);
  function Tech2(options, ready) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    if (ready === void 0) {
      ready = function ready2() {
      };
    }
    options.reportTouchActivity = false;
    _this = _Component.call(this, null, options, ready) || this;
    _this.onDurationChange_ = function(e) {
      return _this.onDurationChange(e);
    };
    _this.trackProgress_ = function(e) {
      return _this.trackProgress(e);
    };
    _this.trackCurrentTime_ = function(e) {
      return _this.trackCurrentTime(e);
    };
    _this.stopTrackingCurrentTime_ = function(e) {
      return _this.stopTrackingCurrentTime(e);
    };
    _this.disposeSourceHandler_ = function(e) {
      return _this.disposeSourceHandler(e);
    };
    _this.queuedHanders_ = /* @__PURE__ */ new Set();
    _this.hasStarted_ = false;
    _this.on("playing", function() {
      this.hasStarted_ = true;
    });
    _this.on("loadstart", function() {
      this.hasStarted_ = false;
    });
    ALL.names.forEach(function(name) {
      var props = ALL[name];
      if (options && options[props.getterName]) {
        _this[props.privateName] = options[props.getterName];
      }
    });
    if (!_this.featuresProgressEvents) {
      _this.manualProgressOn();
    }
    if (!_this.featuresTimeupdateEvents) {
      _this.manualTimeUpdatesOn();
    }
    ["Text", "Audio", "Video"].forEach(function(track) {
      if (options["native" + track + "Tracks"] === false) {
        _this["featuresNative" + track + "Tracks"] = false;
      }
    });
    if (options.nativeCaptions === false || options.nativeTextTracks === false) {
      _this.featuresNativeTextTracks = false;
    } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {
      _this.featuresNativeTextTracks = true;
    }
    if (!_this.featuresNativeTextTracks) {
      _this.emulateTextTracks();
    }
    _this.preloadTextTracks = options.preloadTextTracks !== false;
    _this.autoRemoteTextTracks_ = new ALL.text.ListClass();
    _this.initTrackListeners();
    if (!options.nativeControlsForTouch) {
      _this.emitTapEvents();
    }
    if (_this.constructor) {
      _this.name_ = _this.constructor.name || "Unknown Tech";
    }
    return _this;
  }
  var _proto = Tech2.prototype;
  _proto.triggerSourceset = function triggerSourceset(src) {
    var _this2 = this;
    if (!this.isReady_) {
      this.one("ready", function() {
        return _this2.setTimeout(function() {
          return _this2.triggerSourceset(src);
        }, 1);
      });
    }
    this.trigger({
      src,
      type: "sourceset"
    });
  };
  _proto.manualProgressOn = function manualProgressOn() {
    this.on("durationchange", this.onDurationChange_);
    this.manualProgress = true;
    this.one("ready", this.trackProgress_);
  };
  _proto.manualProgressOff = function manualProgressOff() {
    this.manualProgress = false;
    this.stopTrackingProgress();
    this.off("durationchange", this.onDurationChange_);
  };
  _proto.trackProgress = function trackProgress(event) {
    this.stopTrackingProgress();
    this.progressInterval = this.setInterval(bind(this, function() {
      var numBufferedPercent = this.bufferedPercent();
      if (this.bufferedPercent_ !== numBufferedPercent) {
        this.trigger("progress");
      }
      this.bufferedPercent_ = numBufferedPercent;
      if (numBufferedPercent === 1) {
        this.stopTrackingProgress();
      }
    }), 500);
  };
  _proto.onDurationChange = function onDurationChange(event) {
    this.duration_ = this.duration();
  };
  _proto.buffered = function buffered() {
    return createTimeRanges(0, 0);
  };
  _proto.bufferedPercent = function bufferedPercent$1() {
    return bufferedPercent(this.buffered(), this.duration_);
  };
  _proto.stopTrackingProgress = function stopTrackingProgress() {
    this.clearInterval(this.progressInterval);
  };
  _proto.manualTimeUpdatesOn = function manualTimeUpdatesOn() {
    this.manualTimeUpdates = true;
    this.on("play", this.trackCurrentTime_);
    this.on("pause", this.stopTrackingCurrentTime_);
  };
  _proto.manualTimeUpdatesOff = function manualTimeUpdatesOff() {
    this.manualTimeUpdates = false;
    this.stopTrackingCurrentTime();
    this.off("play", this.trackCurrentTime_);
    this.off("pause", this.stopTrackingCurrentTime_);
  };
  _proto.trackCurrentTime = function trackCurrentTime() {
    if (this.currentTimeInterval) {
      this.stopTrackingCurrentTime();
    }
    this.currentTimeInterval = this.setInterval(function() {
      this.trigger({
        type: "timeupdate",
        target: this,
        manuallyTriggered: true
      });
    }, 250);
  };
  _proto.stopTrackingCurrentTime = function stopTrackingCurrentTime() {
    this.clearInterval(this.currentTimeInterval);
    this.trigger({
      type: "timeupdate",
      target: this,
      manuallyTriggered: true
    });
  };
  _proto.dispose = function dispose() {
    this.clearTracks(NORMAL.names);
    if (this.manualProgress) {
      this.manualProgressOff();
    }
    if (this.manualTimeUpdates) {
      this.manualTimeUpdatesOff();
    }
    _Component.prototype.dispose.call(this);
  };
  _proto.clearTracks = function clearTracks(types) {
    var _this3 = this;
    types = [].concat(types);
    types.forEach(function(type2) {
      var list = _this3[type2 + "Tracks"]() || [];
      var i = list.length;
      while (i--) {
        var track = list[i];
        if (type2 === "text") {
          _this3.removeRemoteTextTrack(track);
        }
        list.removeTrack(track);
      }
    });
  };
  _proto.cleanupAutoTextTracks = function cleanupAutoTextTracks() {
    var list = this.autoRemoteTextTracks_ || [];
    var i = list.length;
    while (i--) {
      var track = list[i];
      this.removeRemoteTextTrack(track);
    }
  };
  _proto.reset = function reset3() {
  };
  _proto.crossOrigin = function crossOrigin() {
  };
  _proto.setCrossOrigin = function setCrossOrigin() {
  };
  _proto.error = function error(err) {
    if (err !== void 0) {
      this.error_ = new MediaError(err);
      this.trigger("error");
    }
    return this.error_;
  };
  _proto.played = function played() {
    if (this.hasStarted_) {
      return createTimeRanges(0, 0);
    }
    return createTimeRanges();
  };
  _proto.play = function play() {
  };
  _proto.setScrubbing = function setScrubbing() {
  };
  _proto.scrubbing = function scrubbing() {
  };
  _proto.setCurrentTime = function setCurrentTime() {
    if (this.manualTimeUpdates) {
      this.trigger({
        type: "timeupdate",
        target: this,
        manuallyTriggered: true
      });
    }
  };
  _proto.initTrackListeners = function initTrackListeners() {
    var _this4 = this;
    NORMAL.names.forEach(function(name) {
      var props = NORMAL[name];
      var trackListChanges = function trackListChanges2() {
        _this4.trigger(name + "trackchange");
      };
      var tracks = _this4[props.getterName]();
      tracks.addEventListener("removetrack", trackListChanges);
      tracks.addEventListener("addtrack", trackListChanges);
      _this4.on("dispose", function() {
        tracks.removeEventListener("removetrack", trackListChanges);
        tracks.removeEventListener("addtrack", trackListChanges);
      });
    });
  };
  _proto.addWebVttScript_ = function addWebVttScript_() {
    var _this5 = this;
    if (import_window6.default.WebVTT) {
      return;
    }
    if (import_document.default.body.contains(this.el())) {
      if (!this.options_["vtt.js"] && isPlain(import_videojs_vtt.default) && Object.keys(import_videojs_vtt.default).length > 0) {
        this.trigger("vttjsloaded");
        return;
      }
      var script = import_document.default.createElement("script");
      script.onload = function() {
        _this5.trigger("vttjsloaded");
      };
      script.onerror = function() {
        _this5.trigger("vttjserror");
      };
      this.on("dispose", function() {
        script.onload = null;
        script.onerror = null;
      });
      import_window6.default.WebVTT = true;
    }
  };
  _proto.emulateTextTracks = function emulateTextTracks() {
    var _this6 = this;
    var tracks = this.textTracks();
    var remoteTracks = this.remoteTextTracks();
    var handleAddTrack = function handleAddTrack2(e) {
      return tracks.addTrack(e.track);
    };
    var handleRemoveTrack = function handleRemoveTrack2(e) {
      return tracks.removeTrack(e.track);
    };
    remoteTracks.on("addtrack", handleAddTrack);
    remoteTracks.on("removetrack", handleRemoveTrack);
    this.addWebVttScript_();
    var updateDisplay = function updateDisplay2() {
      return _this6.trigger("texttrackchange");
    };
    var textTracksChanges = function textTracksChanges2() {
      updateDisplay();
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        track.removeEventListener("cuechange", updateDisplay);
        if (track.mode === "showing") {
          track.addEventListener("cuechange", updateDisplay);
        }
      }
    };
    textTracksChanges();
    tracks.addEventListener("change", textTracksChanges);
    tracks.addEventListener("addtrack", textTracksChanges);
    tracks.addEventListener("removetrack", textTracksChanges);
    this.on("dispose", function() {
      remoteTracks.off("addtrack", handleAddTrack);
      remoteTracks.off("removetrack", handleRemoveTrack);
      tracks.removeEventListener("change", textTracksChanges);
      tracks.removeEventListener("addtrack", textTracksChanges);
      tracks.removeEventListener("removetrack", textTracksChanges);
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        track.removeEventListener("cuechange", updateDisplay);
      }
    });
  };
  _proto.addTextTrack = function addTextTrack(kind, label, language) {
    if (!kind) {
      throw new Error("TextTrack kind is required but was not provided");
    }
    return createTrackHelper(this, kind, label, language);
  };
  _proto.createRemoteTextTrack = function createRemoteTextTrack(options) {
    var track = mergeOptions$3(options, {
      tech: this
    });
    return new REMOTE.remoteTextEl.TrackClass(track);
  };
  _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    var _this7 = this;
    if (options === void 0) {
      options = {};
    }
    var htmlTrackElement = this.createRemoteTextTrack(options);
    if (manualCleanup !== true && manualCleanup !== false) {
      log$1.warn('Calling addRemoteTextTrack without explicitly setting the "manualCleanup" parameter to `true` is deprecated and default to `false` in future version of video.js');
      manualCleanup = true;
    }
    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
    this.remoteTextTracks().addTrack(htmlTrackElement.track);
    if (manualCleanup !== true) {
      this.ready(function() {
        return _this7.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);
      });
    }
    return htmlTrackElement;
  };
  _proto.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);
    this.remoteTextTrackEls().removeTrackElement_(trackElement);
    this.remoteTextTracks().removeTrack(track);
    this.autoRemoteTextTracks_.removeTrack(track);
  };
  _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    return {};
  };
  _proto.requestPictureInPicture = function requestPictureInPicture() {
    var PromiseClass = this.options_.Promise || import_window6.default.Promise;
    if (PromiseClass) {
      return PromiseClass.reject();
    }
  };
  _proto.disablePictureInPicture = function disablePictureInPicture() {
    return true;
  };
  _proto.setDisablePictureInPicture = function setDisablePictureInPicture() {
  };
  _proto.requestVideoFrameCallback = function requestVideoFrameCallback(cb) {
    var _this8 = this;
    var id = newGUID();
    if (!this.isReady_ || this.paused()) {
      this.queuedHanders_.add(id);
      this.one("playing", function() {
        if (_this8.queuedHanders_.has(id)) {
          _this8.queuedHanders_["delete"](id);
          cb();
        }
      });
    } else {
      this.requestNamedAnimationFrame(id, cb);
    }
    return id;
  };
  _proto.cancelVideoFrameCallback = function cancelVideoFrameCallback(id) {
    if (this.queuedHanders_.has(id)) {
      this.queuedHanders_["delete"](id);
    } else {
      this.cancelNamedAnimationFrame(id);
    }
  };
  _proto.setPoster = function setPoster() {
  };
  _proto.playsinline = function playsinline() {
  };
  _proto.setPlaysinline = function setPlaysinline() {
  };
  _proto.overrideNativeAudioTracks = function overrideNativeAudioTracks() {
  };
  _proto.overrideNativeVideoTracks = function overrideNativeVideoTracks() {
  };
  _proto.canPlayType = function canPlayType3() {
    return "";
  };
  Tech2.canPlayType = function canPlayType3() {
    return "";
  };
  Tech2.canPlaySource = function canPlaySource(srcObj, options) {
    return Tech2.canPlayType(srcObj.type);
  };
  Tech2.isTech = function isTech(component) {
    return component.prototype instanceof Tech2 || component instanceof Tech2 || component === Tech2;
  };
  Tech2.registerTech = function registerTech(name, tech) {
    if (!Tech2.techs_) {
      Tech2.techs_ = {};
    }
    if (!Tech2.isTech(tech)) {
      throw new Error("Tech " + name + " must be a Tech");
    }
    if (!Tech2.canPlayType) {
      throw new Error("Techs must have a static canPlayType method on them");
    }
    if (!Tech2.canPlaySource) {
      throw new Error("Techs must have a static canPlaySource method on them");
    }
    name = toTitleCase$1(name);
    Tech2.techs_[name] = tech;
    Tech2.techs_[toLowerCase(name)] = tech;
    if (name !== "Tech") {
      Tech2.defaultTechOrder_.push(name);
    }
    return tech;
  };
  Tech2.getTech = function getTech(name) {
    if (!name) {
      return;
    }
    if (Tech2.techs_ && Tech2.techs_[name]) {
      return Tech2.techs_[name];
    }
    name = toTitleCase$1(name);
    if (import_window6.default && import_window6.default.videojs && import_window6.default.videojs[name]) {
      log$1.warn("The " + name + " tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)");
      return import_window6.default.videojs[name];
    }
  };
  return Tech2;
}(Component$1);
ALL.names.forEach(function(name) {
  var props = ALL[name];
  Tech.prototype[props.getterName] = function() {
    this[props.privateName] = this[props.privateName] || new props.ListClass();
    return this[props.privateName];
  };
});
Tech.prototype.featuresVolumeControl = true;
Tech.prototype.featuresMuteControl = true;
Tech.prototype.featuresFullscreenResize = false;
Tech.prototype.featuresPlaybackRate = false;
Tech.prototype.featuresProgressEvents = false;
Tech.prototype.featuresSourceset = false;
Tech.prototype.featuresTimeupdateEvents = false;
Tech.prototype.featuresNativeTextTracks = false;
Tech.prototype.featuresVideoFrameCallback = false;
Tech.withSourceHandlers = function(_Tech) {
  _Tech.registerSourceHandler = function(handler, index) {
    var handlers = _Tech.sourceHandlers;
    if (!handlers) {
      handlers = _Tech.sourceHandlers = [];
    }
    if (index === void 0) {
      index = handlers.length;
    }
    handlers.splice(index, 0, handler);
  };
  _Tech.canPlayType = function(type2) {
    var handlers = _Tech.sourceHandlers || [];
    var can;
    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canPlayType(type2);
      if (can) {
        return can;
      }
    }
    return "";
  };
  _Tech.selectSourceHandler = function(source, options) {
    var handlers = _Tech.sourceHandlers || [];
    var can;
    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canHandleSource(source, options);
      if (can) {
        return handlers[i];
      }
    }
    return null;
  };
  _Tech.canPlaySource = function(srcObj, options) {
    var sh = _Tech.selectSourceHandler(srcObj, options);
    if (sh) {
      return sh.canHandleSource(srcObj, options);
    }
    return "";
  };
  var deferrable = ["seekable", "seeking", "duration"];
  deferrable.forEach(function(fnName) {
    var originalFn = this[fnName];
    if (typeof originalFn !== "function") {
      return;
    }
    this[fnName] = function() {
      if (this.sourceHandler_ && this.sourceHandler_[fnName]) {
        return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);
      }
      return originalFn.apply(this, arguments);
    };
  }, _Tech.prototype);
  _Tech.prototype.setSource = function(source) {
    var sh = _Tech.selectSourceHandler(source, this.options_);
    if (!sh) {
      if (_Tech.nativeSourceHandler) {
        sh = _Tech.nativeSourceHandler;
      } else {
        log$1.error("No source handler found for the current source.");
      }
    }
    this.disposeSourceHandler();
    this.off("dispose", this.disposeSourceHandler_);
    if (sh !== _Tech.nativeSourceHandler) {
      this.currentSource_ = source;
    }
    this.sourceHandler_ = sh.handleSource(source, this, this.options_);
    this.one("dispose", this.disposeSourceHandler_);
  };
  _Tech.prototype.disposeSourceHandler = function() {
    if (this.currentSource_) {
      this.clearTracks(["audio", "video"]);
      this.currentSource_ = null;
    }
    this.cleanupAutoTextTracks();
    if (this.sourceHandler_) {
      if (this.sourceHandler_.dispose) {
        this.sourceHandler_.dispose();
      }
      this.sourceHandler_ = null;
    }
  };
};
Component$1.registerComponent("Tech", Tech);
Tech.registerTech("Tech", Tech);
Tech.defaultTechOrder_ = [];
var middlewares = {};
var middlewareInstances = {};
var TERMINATOR = {};
function use(type2, middleware) {
  middlewares[type2] = middlewares[type2] || [];
  middlewares[type2].push(middleware);
}
function setSource(player, src, next) {
  player.setTimeout(function() {
    return setSourceHelper(src, middlewares[src.type], next, player);
  }, 1);
}
function setTech(middleware, tech) {
  middleware.forEach(function(mw) {
    return mw.setTech && mw.setTech(tech);
  });
}
function get(middleware, tech, method) {
  return middleware.reduceRight(middlewareIterator(method), tech[method]());
}
function set(middleware, tech, method, arg) {
  return tech[method](middleware.reduce(middlewareIterator(method), arg));
}
function mediate(middleware, tech, method, arg) {
  if (arg === void 0) {
    arg = null;
  }
  var callMethod = "call" + toTitleCase$1(method);
  var middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg);
  var terminated = middlewareValue === TERMINATOR;
  var returnValue = terminated ? null : tech[method](middlewareValue);
  executeRight(middleware, method, returnValue, terminated);
  return returnValue;
}
var allowedGetters = {
  buffered: 1,
  currentTime: 1,
  duration: 1,
  muted: 1,
  played: 1,
  paused: 1,
  seekable: 1,
  volume: 1,
  ended: 1
};
var allowedSetters = {
  setCurrentTime: 1,
  setMuted: 1,
  setVolume: 1
};
var allowedMediators = {
  play: 1,
  pause: 1
};
function middlewareIterator(method) {
  return function(value, mw) {
    if (value === TERMINATOR) {
      return TERMINATOR;
    }
    if (mw[method]) {
      return mw[method](value);
    }
    return value;
  };
}
function executeRight(mws, method, value, terminated) {
  for (var i = mws.length - 1; i >= 0; i--) {
    var mw = mws[i];
    if (mw[method]) {
      mw[method](terminated, value);
    }
  }
}
function clearCacheForPlayer(player) {
  middlewareInstances[player.id()] = null;
}
function getOrCreateFactory(player, mwFactory) {
  var mws = middlewareInstances[player.id()];
  var mw = null;
  if (mws === void 0 || mws === null) {
    mw = mwFactory(player);
    middlewareInstances[player.id()] = [[mwFactory, mw]];
    return mw;
  }
  for (var i = 0; i < mws.length; i++) {
    var _mws$i = mws[i], mwf = _mws$i[0], mwi = _mws$i[1];
    if (mwf !== mwFactory) {
      continue;
    }
    mw = mwi;
  }
  if (mw === null) {
    mw = mwFactory(player);
    mws.push([mwFactory, mw]);
  }
  return mw;
}
function setSourceHelper(src, middleware, next, player, acc, lastRun) {
  if (src === void 0) {
    src = {};
  }
  if (middleware === void 0) {
    middleware = [];
  }
  if (acc === void 0) {
    acc = [];
  }
  if (lastRun === void 0) {
    lastRun = false;
  }
  var _middleware = middleware, mwFactory = _middleware[0], mwrest = _middleware.slice(1);
  if (typeof mwFactory === "string") {
    setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);
  } else if (mwFactory) {
    var mw = getOrCreateFactory(player, mwFactory);
    if (!mw.setSource) {
      acc.push(mw);
      return setSourceHelper(src, mwrest, next, player, acc, lastRun);
    }
    mw.setSource(assign({}, src), function(err, _src) {
      if (err) {
        return setSourceHelper(src, mwrest, next, player, acc, lastRun);
      }
      acc.push(mw);
      setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);
    });
  } else if (mwrest.length) {
    setSourceHelper(src, mwrest, next, player, acc, lastRun);
  } else if (lastRun) {
    next(src, acc);
  } else {
    setSourceHelper(src, middlewares["*"], next, player, acc, true);
  }
}
var MimetypesKind = {
  opus: "video/ogg",
  ogv: "video/ogg",
  mp4: "video/mp4",
  mov: "video/mp4",
  m4v: "video/mp4",
  mkv: "video/x-matroska",
  m4a: "audio/mp4",
  mp3: "audio/mpeg",
  aac: "audio/aac",
  caf: "audio/x-caf",
  flac: "audio/flac",
  oga: "audio/ogg",
  wav: "audio/wav",
  m3u8: "application/x-mpegURL",
  mpd: "application/dash+xml",
  jpg: "image/jpeg",
  jpeg: "image/jpeg",
  gif: "image/gif",
  png: "image/png",
  svg: "image/svg+xml",
  webp: "image/webp"
};
var getMimetype = function getMimetype2(src) {
  if (src === void 0) {
    src = "";
  }
  var ext = getFileExtension(src);
  var mimetype = MimetypesKind[ext.toLowerCase()];
  return mimetype || "";
};
var findMimetype = function findMimetype2(player, src) {
  if (!src) {
    return "";
  }
  if (player.cache_.source.src === src && player.cache_.source.type) {
    return player.cache_.source.type;
  }
  var matchingSources = player.cache_.sources.filter(function(s2) {
    return s2.src === src;
  });
  if (matchingSources.length) {
    return matchingSources[0].type;
  }
  var sources = player.$$("source");
  for (var i = 0; i < sources.length; i++) {
    var s = sources[i];
    if (s.type && s.src && s.src === src) {
      return s.type;
    }
  }
  return getMimetype(src);
};
var filterSource = function filterSource2(src) {
  if (Array.isArray(src)) {
    var newsrc = [];
    src.forEach(function(srcobj) {
      srcobj = filterSource2(srcobj);
      if (Array.isArray(srcobj)) {
        newsrc = newsrc.concat(srcobj);
      } else if (isObject3(srcobj)) {
        newsrc.push(srcobj);
      }
    });
    src = newsrc;
  } else if (typeof src === "string" && src.trim()) {
    src = [fixSource({
      src
    })];
  } else if (isObject3(src) && typeof src.src === "string" && src.src && src.src.trim()) {
    src = [fixSource(src)];
  } else {
    src = [];
  }
  return src;
};
function fixSource(src) {
  if (!src.type) {
    var mimetype = getMimetype(src.src);
    if (mimetype) {
      src.type = mimetype;
    }
  }
  return src;
}
var MediaLoader = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(MediaLoader2, _Component);
  function MediaLoader2(player, options, ready) {
    var _this;
    var options_ = mergeOptions$3({
      createEl: false
    }, options);
    _this = _Component.call(this, player, options_, ready) || this;
    if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {
      for (var i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {
        var techName = toTitleCase$1(j[i]);
        var tech = Tech.getTech(techName);
        if (!techName) {
          tech = Component$1.getComponent(techName);
        }
        if (tech && tech.isSupported()) {
          player.loadTech_(techName);
          break;
        }
      }
    } else {
      player.src(options.playerOptions.sources);
    }
    return _this;
  }
  return MediaLoader2;
}(Component$1);
Component$1.registerComponent("MediaLoader", MediaLoader);
var ClickableComponent = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(ClickableComponent2, _Component);
  function ClickableComponent2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    if (_this.options_.controlText) {
      _this.controlText(_this.options_.controlText);
    }
    _this.handleMouseOver_ = function(e) {
      return _this.handleMouseOver(e);
    };
    _this.handleMouseOut_ = function(e) {
      return _this.handleMouseOut(e);
    };
    _this.handleClick_ = function(e) {
      return _this.handleClick(e);
    };
    _this.handleKeyDown_ = function(e) {
      return _this.handleKeyDown(e);
    };
    _this.emitTapEvents();
    _this.enable();
    return _this;
  }
  var _proto = ClickableComponent2.prototype;
  _proto.createEl = function createEl$1(tag, props, attributes) {
    if (tag === void 0) {
      tag = "div";
    }
    if (props === void 0) {
      props = {};
    }
    if (attributes === void 0) {
      attributes = {};
    }
    props = assign({
      className: this.buildCSSClass(),
      tabIndex: 0
    }, props);
    if (tag === "button") {
      log$1.error("Creating a ClickableComponent with an HTML element of " + tag + " is not supported; use a Button instead.");
    }
    attributes = assign({
      role: "button"
    }, attributes);
    this.tabIndex_ = props.tabIndex;
    var el = createEl(tag, props, attributes);
    el.appendChild(createEl("span", {
      className: "vjs-icon-placeholder"
    }, {
      "aria-hidden": true
    }));
    this.createControlTextEl(el);
    return el;
  };
  _proto.dispose = function dispose() {
    this.controlTextEl_ = null;
    _Component.prototype.dispose.call(this);
  };
  _proto.createControlTextEl = function createControlTextEl(el) {
    this.controlTextEl_ = createEl("span", {
      className: "vjs-control-text"
    }, {
      // let the screen reader user know that the text of the element may change
      "aria-live": "polite"
    });
    if (el) {
      el.appendChild(this.controlTextEl_);
    }
    this.controlText(this.controlText_, el);
    return this.controlTextEl_;
  };
  _proto.controlText = function controlText(text, el) {
    if (el === void 0) {
      el = this.el();
    }
    if (text === void 0) {
      return this.controlText_ || "Need Text";
    }
    var localizedText = this.localize(text);
    this.controlText_ = text;
    textContent(this.controlTextEl_, localizedText);
    if (!this.nonIconControl && !this.player_.options_.noUITitleAttributes) {
      el.setAttribute("title", localizedText);
    }
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-control vjs-button " + _Component.prototype.buildCSSClass.call(this);
  };
  _proto.enable = function enable() {
    if (!this.enabled_) {
      this.enabled_ = true;
      this.removeClass("vjs-disabled");
      this.el_.setAttribute("aria-disabled", "false");
      if (typeof this.tabIndex_ !== "undefined") {
        this.el_.setAttribute("tabIndex", this.tabIndex_);
      }
      this.on(["tap", "click"], this.handleClick_);
      this.on("keydown", this.handleKeyDown_);
    }
  };
  _proto.disable = function disable() {
    this.enabled_ = false;
    this.addClass("vjs-disabled");
    this.el_.setAttribute("aria-disabled", "true");
    if (typeof this.tabIndex_ !== "undefined") {
      this.el_.removeAttribute("tabIndex");
    }
    this.off("mouseover", this.handleMouseOver_);
    this.off("mouseout", this.handleMouseOut_);
    this.off(["tap", "click"], this.handleClick_);
    this.off("keydown", this.handleKeyDown_);
  };
  _proto.handleLanguagechange = function handleLanguagechange() {
    this.controlText(this.controlText_);
  };
  _proto.handleClick = function handleClick(event) {
    if (this.options_.clickHandler) {
      this.options_.clickHandler.call(this, arguments);
    }
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    if (import_keycode.default.isEventKey(event, "Space") || import_keycode.default.isEventKey(event, "Enter")) {
      event.preventDefault();
      event.stopPropagation();
      this.trigger("click");
    } else {
      _Component.prototype.handleKeyDown.call(this, event);
    }
  };
  return ClickableComponent2;
}(Component$1);
Component$1.registerComponent("ClickableComponent", ClickableComponent);
var PosterImage = /* @__PURE__ */ function(_ClickableComponent) {
  _inheritsLoose(PosterImage2, _ClickableComponent);
  function PosterImage2(player, options) {
    var _this;
    _this = _ClickableComponent.call(this, player, options) || this;
    _this.update();
    _this.update_ = function(e) {
      return _this.update(e);
    };
    player.on("posterchange", _this.update_);
    return _this;
  }
  var _proto = PosterImage2.prototype;
  _proto.dispose = function dispose() {
    this.player().off("posterchange", this.update_);
    _ClickableComponent.prototype.dispose.call(this);
  };
  _proto.createEl = function createEl$1() {
    var el = createEl("div", {
      className: "vjs-poster",
      // Don't want poster to be tabbable.
      tabIndex: -1
    });
    return el;
  };
  _proto.update = function update(event) {
    var url = this.player().poster();
    this.setSrc(url);
    if (url) {
      this.show();
    } else {
      this.hide();
    }
  };
  _proto.setSrc = function setSrc(url) {
    var backgroundImage = "";
    if (url) {
      backgroundImage = 'url("' + url + '")';
    }
    this.el_.style.backgroundImage = backgroundImage;
  };
  _proto.handleClick = function handleClick(event) {
    if (!this.player_.controls()) {
      return;
    }
    var sourceIsEncrypted = this.player_.usingPlugin("eme") && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;
    if (this.player_.tech(true) && // We've observed a bug in IE and Edge when playing back DRM content where
    // calling .focus() on the video element causes the video to go black,
    // so we avoid it in that specific case
    !((IE_VERSION || IS_EDGE) && sourceIsEncrypted)) {
      this.player_.tech(true).focus();
    }
    if (this.player_.paused()) {
      silencePromise(this.player_.play());
    } else {
      this.player_.pause();
    }
  };
  return PosterImage2;
}(ClickableComponent);
Component$1.registerComponent("PosterImage", PosterImage);
var darkGray = "#222";
var lightGray = "#ccc";
var fontMap = {
  monospace: "monospace",
  sansSerif: "sans-serif",
  serif: "serif",
  monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
  monospaceSerif: '"Courier New", monospace',
  proportionalSansSerif: "sans-serif",
  proportionalSerif: "serif",
  casual: '"Comic Sans MS", Impact, fantasy',
  script: '"Monotype Corsiva", cursive',
  smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
};
function constructColor(color, opacity) {
  var hex;
  if (color.length === 4) {
    hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
  } else if (color.length === 7) {
    hex = color.slice(1);
  } else {
    throw new Error("Invalid color code provided, " + color + "; must be formatted as e.g. #f0e or #f604e2.");
  }
  return "rgba(" + parseInt(hex.slice(0, 2), 16) + "," + parseInt(hex.slice(2, 4), 16) + "," + parseInt(hex.slice(4, 6), 16) + "," + opacity + ")";
}
function tryUpdateStyle(el, style, rule) {
  try {
    el.style[style] = rule;
  } catch (e) {
    return;
  }
}
var TextTrackDisplay = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(TextTrackDisplay2, _Component);
  function TextTrackDisplay2(player, options, ready) {
    var _this;
    _this = _Component.call(this, player, options, ready) || this;
    var updateDisplayHandler = function updateDisplayHandler2(e) {
      return _this.updateDisplay(e);
    };
    player.on("loadstart", function(e) {
      return _this.toggleDisplay(e);
    });
    player.on("texttrackchange", updateDisplayHandler);
    player.on("loadedmetadata", function(e) {
      return _this.preselectTrack(e);
    });
    player.ready(bind(_assertThisInitialized(_this), function() {
      if (player.tech_ && player.tech_.featuresNativeTextTracks) {
        this.hide();
        return;
      }
      player.on("fullscreenchange", updateDisplayHandler);
      player.on("playerresize", updateDisplayHandler);
      import_window6.default.addEventListener("orientationchange", updateDisplayHandler);
      player.on("dispose", function() {
        return import_window6.default.removeEventListener("orientationchange", updateDisplayHandler);
      });
      var tracks = this.options_.playerOptions.tracks || [];
      for (var i = 0; i < tracks.length; i++) {
        this.player_.addRemoteTextTrack(tracks[i], true);
      }
      this.preselectTrack();
    }));
    return _this;
  }
  var _proto = TextTrackDisplay2.prototype;
  _proto.preselectTrack = function preselectTrack() {
    var modes = {
      captions: 1,
      subtitles: 1
    };
    var trackList = this.player_.textTracks();
    var userPref = this.player_.cache_.selectedLanguage;
    var firstDesc;
    var firstCaptions;
    var preferredTrack;
    for (var i = 0; i < trackList.length; i++) {
      var track = trackList[i];
      if (userPref && userPref.enabled && userPref.language && userPref.language === track.language && track.kind in modes) {
        if (track.kind === userPref.kind) {
          preferredTrack = track;
        } else if (!preferredTrack) {
          preferredTrack = track;
        }
      } else if (userPref && !userPref.enabled) {
        preferredTrack = null;
        firstDesc = null;
        firstCaptions = null;
      } else if (track["default"]) {
        if (track.kind === "descriptions" && !firstDesc) {
          firstDesc = track;
        } else if (track.kind in modes && !firstCaptions) {
          firstCaptions = track;
        }
      }
    }
    if (preferredTrack) {
      preferredTrack.mode = "showing";
    } else if (firstCaptions) {
      firstCaptions.mode = "showing";
    } else if (firstDesc) {
      firstDesc.mode = "showing";
    }
  };
  _proto.toggleDisplay = function toggleDisplay() {
    if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {
      this.hide();
    } else {
      this.show();
    }
  };
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-text-track-display"
    }, {
      "translate": "yes",
      "aria-live": "off",
      "aria-atomic": "true"
    });
  };
  _proto.clearDisplay = function clearDisplay() {
    if (typeof import_window6.default.WebVTT === "function") {
      import_window6.default.WebVTT.processCues(import_window6.default, [], this.el_);
    }
  };
  _proto.updateDisplay = function updateDisplay() {
    var tracks = this.player_.textTracks();
    var allowMultipleShowingTracks = this.options_.allowMultipleShowingTracks;
    this.clearDisplay();
    if (allowMultipleShowingTracks) {
      var showingTracks = [];
      for (var _i = 0; _i < tracks.length; ++_i) {
        var track = tracks[_i];
        if (track.mode !== "showing") {
          continue;
        }
        showingTracks.push(track);
      }
      this.updateForTrack(showingTracks);
      return;
    }
    var descriptionsTrack = null;
    var captionsSubtitlesTrack = null;
    var i = tracks.length;
    while (i--) {
      var _track = tracks[i];
      if (_track.mode === "showing") {
        if (_track.kind === "descriptions") {
          descriptionsTrack = _track;
        } else {
          captionsSubtitlesTrack = _track;
        }
      }
    }
    if (captionsSubtitlesTrack) {
      if (this.getAttribute("aria-live") !== "off") {
        this.setAttribute("aria-live", "off");
      }
      this.updateForTrack(captionsSubtitlesTrack);
    } else if (descriptionsTrack) {
      if (this.getAttribute("aria-live") !== "assertive") {
        this.setAttribute("aria-live", "assertive");
      }
      this.updateForTrack(descriptionsTrack);
    }
  };
  _proto.updateDisplayState = function updateDisplayState(track) {
    var overrides = this.player_.textTrackSettings.getValues();
    var cues = track.activeCues;
    var i = cues.length;
    while (i--) {
      var cue = cues[i];
      if (!cue) {
        continue;
      }
      var cueDiv = cue.displayState;
      if (overrides.color) {
        cueDiv.firstChild.style.color = overrides.color;
      }
      if (overrides.textOpacity) {
        tryUpdateStyle(cueDiv.firstChild, "color", constructColor(overrides.color || "#fff", overrides.textOpacity));
      }
      if (overrides.backgroundColor) {
        cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
      }
      if (overrides.backgroundOpacity) {
        tryUpdateStyle(cueDiv.firstChild, "backgroundColor", constructColor(overrides.backgroundColor || "#000", overrides.backgroundOpacity));
      }
      if (overrides.windowColor) {
        if (overrides.windowOpacity) {
          tryUpdateStyle(cueDiv, "backgroundColor", constructColor(overrides.windowColor, overrides.windowOpacity));
        } else {
          cueDiv.style.backgroundColor = overrides.windowColor;
        }
      }
      if (overrides.edgeStyle) {
        if (overrides.edgeStyle === "dropshadow") {
          cueDiv.firstChild.style.textShadow = "2px 2px 3px " + darkGray + ", 2px 2px 4px " + darkGray + ", 2px 2px 5px " + darkGray;
        } else if (overrides.edgeStyle === "raised") {
          cueDiv.firstChild.style.textShadow = "1px 1px " + darkGray + ", 2px 2px " + darkGray + ", 3px 3px " + darkGray;
        } else if (overrides.edgeStyle === "depressed") {
          cueDiv.firstChild.style.textShadow = "1px 1px " + lightGray + ", 0 1px " + lightGray + ", -1px -1px " + darkGray + ", 0 -1px " + darkGray;
        } else if (overrides.edgeStyle === "uniform") {
          cueDiv.firstChild.style.textShadow = "0 0 4px " + darkGray + ", 0 0 4px " + darkGray + ", 0 0 4px " + darkGray + ", 0 0 4px " + darkGray;
        }
      }
      if (overrides.fontPercent && overrides.fontPercent !== 1) {
        var fontSize = import_window6.default.parseFloat(cueDiv.style.fontSize);
        cueDiv.style.fontSize = fontSize * overrides.fontPercent + "px";
        cueDiv.style.height = "auto";
        cueDiv.style.top = "auto";
      }
      if (overrides.fontFamily && overrides.fontFamily !== "default") {
        if (overrides.fontFamily === "small-caps") {
          cueDiv.firstChild.style.fontVariant = "small-caps";
        } else {
          cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
        }
      }
    }
  };
  _proto.updateForTrack = function updateForTrack(tracks) {
    if (!Array.isArray(tracks)) {
      tracks = [tracks];
    }
    if (typeof import_window6.default.WebVTT !== "function" || tracks.every(function(track2) {
      return !track2.activeCues;
    })) {
      return;
    }
    var cues = [];
    for (var i = 0; i < tracks.length; ++i) {
      var track = tracks[i];
      for (var j = 0; j < track.activeCues.length; ++j) {
        cues.push(track.activeCues[j]);
      }
    }
    import_window6.default.WebVTT.processCues(import_window6.default, cues, this.el_);
    for (var _i2 = 0; _i2 < tracks.length; ++_i2) {
      var _track2 = tracks[_i2];
      for (var _j = 0; _j < _track2.activeCues.length; ++_j) {
        var cueEl = _track2.activeCues[_j].displayState;
        addClass(cueEl, "vjs-text-track-cue");
        addClass(cueEl, "vjs-text-track-cue-" + (_track2.language ? _track2.language : _i2));
        if (_track2.language) {
          setAttribute(cueEl, "lang", _track2.language);
        }
      }
      if (this.player_.textTrackSettings) {
        this.updateDisplayState(_track2);
      }
    }
  };
  return TextTrackDisplay2;
}(Component$1);
Component$1.registerComponent("TextTrackDisplay", TextTrackDisplay);
var LoadingSpinner = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(LoadingSpinner2, _Component);
  function LoadingSpinner2() {
    return _Component.apply(this, arguments) || this;
  }
  var _proto = LoadingSpinner2.prototype;
  _proto.createEl = function createEl$1() {
    var isAudio = this.player_.isAudio();
    var playerType = this.localize(isAudio ? "Audio Player" : "Video Player");
    var controlText = createEl("span", {
      className: "vjs-control-text",
      textContent: this.localize("{1} is loading.", [playerType])
    });
    var el = _Component.prototype.createEl.call(this, "div", {
      className: "vjs-loading-spinner",
      dir: "ltr"
    });
    el.appendChild(controlText);
    return el;
  };
  return LoadingSpinner2;
}(Component$1);
Component$1.registerComponent("LoadingSpinner", LoadingSpinner);
var Button = /* @__PURE__ */ function(_ClickableComponent) {
  _inheritsLoose(Button2, _ClickableComponent);
  function Button2() {
    return _ClickableComponent.apply(this, arguments) || this;
  }
  var _proto = Button2.prototype;
  _proto.createEl = function createEl$1(tag, props, attributes) {
    if (props === void 0) {
      props = {};
    }
    if (attributes === void 0) {
      attributes = {};
    }
    tag = "button";
    props = assign({
      className: this.buildCSSClass()
    }, props);
    attributes = assign({
      // Necessary since the default button type is "submit"
      type: "button"
    }, attributes);
    var el = createEl(tag, props, attributes);
    el.appendChild(createEl("span", {
      className: "vjs-icon-placeholder"
    }, {
      "aria-hidden": true
    }));
    this.createControlTextEl(el);
    return el;
  };
  _proto.addChild = function addChild(child, options) {
    if (options === void 0) {
      options = {};
    }
    var className = this.constructor.name;
    log$1.warn("Adding an actionable (user controllable) child to a Button (" + className + ") is not supported; use a ClickableComponent instead.");
    return Component$1.prototype.addChild.call(this, child, options);
  };
  _proto.enable = function enable() {
    _ClickableComponent.prototype.enable.call(this);
    this.el_.removeAttribute("disabled");
  };
  _proto.disable = function disable() {
    _ClickableComponent.prototype.disable.call(this);
    this.el_.setAttribute("disabled", "disabled");
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    if (import_keycode.default.isEventKey(event, "Space") || import_keycode.default.isEventKey(event, "Enter")) {
      event.stopPropagation();
      return;
    }
    _ClickableComponent.prototype.handleKeyDown.call(this, event);
  };
  return Button2;
}(ClickableComponent);
Component$1.registerComponent("Button", Button);
var BigPlayButton = /* @__PURE__ */ function(_Button) {
  _inheritsLoose(BigPlayButton2, _Button);
  function BigPlayButton2(player, options) {
    var _this;
    _this = _Button.call(this, player, options) || this;
    _this.mouseused_ = false;
    _this.on("mousedown", function(e) {
      return _this.handleMouseDown(e);
    });
    return _this;
  }
  var _proto = BigPlayButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-big-play-button";
  };
  _proto.handleClick = function handleClick(event) {
    var playPromise = this.player_.play();
    if (this.mouseused_ && event.clientX && event.clientY) {
      var sourceIsEncrypted = this.player_.usingPlugin("eme") && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;
      silencePromise(playPromise);
      if (this.player_.tech(true) && // We've observed a bug in IE and Edge when playing back DRM content where
      // calling .focus() on the video element causes the video to go black,
      // so we avoid it in that specific case
      !((IE_VERSION || IS_EDGE) && sourceIsEncrypted)) {
        this.player_.tech(true).focus();
      }
      return;
    }
    var cb = this.player_.getChild("controlBar");
    var playToggle = cb && cb.getChild("playToggle");
    if (!playToggle) {
      this.player_.tech(true).focus();
      return;
    }
    var playFocus = function playFocus2() {
      return playToggle.focus();
    };
    if (isPromise2(playPromise)) {
      playPromise.then(playFocus, function() {
      });
    } else {
      this.setTimeout(playFocus, 1);
    }
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    this.mouseused_ = false;
    _Button.prototype.handleKeyDown.call(this, event);
  };
  _proto.handleMouseDown = function handleMouseDown(event) {
    this.mouseused_ = true;
  };
  return BigPlayButton2;
}(Button);
BigPlayButton.prototype.controlText_ = "Play Video";
Component$1.registerComponent("BigPlayButton", BigPlayButton);
var CloseButton = /* @__PURE__ */ function(_Button) {
  _inheritsLoose(CloseButton2, _Button);
  function CloseButton2(player, options) {
    var _this;
    _this = _Button.call(this, player, options) || this;
    _this.controlText(options && options.controlText || _this.localize("Close"));
    return _this;
  }
  var _proto = CloseButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-close-button " + _Button.prototype.buildCSSClass.call(this);
  };
  _proto.handleClick = function handleClick(event) {
    this.trigger({
      type: "close",
      bubbles: false
    });
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    if (import_keycode.default.isEventKey(event, "Esc")) {
      event.preventDefault();
      event.stopPropagation();
      this.trigger("click");
    } else {
      _Button.prototype.handleKeyDown.call(this, event);
    }
  };
  return CloseButton2;
}(Button);
Component$1.registerComponent("CloseButton", CloseButton);
var PlayToggle = /* @__PURE__ */ function(_Button) {
  _inheritsLoose(PlayToggle2, _Button);
  function PlayToggle2(player, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _Button.call(this, player, options) || this;
    options.replay = options.replay === void 0 || options.replay;
    _this.on(player, "play", function(e) {
      return _this.handlePlay(e);
    });
    _this.on(player, "pause", function(e) {
      return _this.handlePause(e);
    });
    if (options.replay) {
      _this.on(player, "ended", function(e) {
        return _this.handleEnded(e);
      });
    }
    return _this;
  }
  var _proto = PlayToggle2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-play-control " + _Button.prototype.buildCSSClass.call(this);
  };
  _proto.handleClick = function handleClick(event) {
    if (this.player_.paused()) {
      silencePromise(this.player_.play());
    } else {
      this.player_.pause();
    }
  };
  _proto.handleSeeked = function handleSeeked(event) {
    this.removeClass("vjs-ended");
    if (this.player_.paused()) {
      this.handlePause(event);
    } else {
      this.handlePlay(event);
    }
  };
  _proto.handlePlay = function handlePlay(event) {
    this.removeClass("vjs-ended");
    this.removeClass("vjs-paused");
    this.addClass("vjs-playing");
    this.controlText("Pause");
  };
  _proto.handlePause = function handlePause(event) {
    this.removeClass("vjs-playing");
    this.addClass("vjs-paused");
    this.controlText("Play");
  };
  _proto.handleEnded = function handleEnded(event) {
    var _this2 = this;
    this.removeClass("vjs-playing");
    this.addClass("vjs-ended");
    this.controlText("Replay");
    this.one(this.player_, "seeked", function(e) {
      return _this2.handleSeeked(e);
    });
  };
  return PlayToggle2;
}(Button);
PlayToggle.prototype.controlText_ = "Play";
Component$1.registerComponent("PlayToggle", PlayToggle);
var defaultImplementation = function defaultImplementation2(seconds, guide) {
  seconds = seconds < 0 ? 0 : seconds;
  var s = Math.floor(seconds % 60);
  var m = Math.floor(seconds / 60 % 60);
  var h = Math.floor(seconds / 3600);
  var gm = Math.floor(guide / 60 % 60);
  var gh = Math.floor(guide / 3600);
  if (isNaN(seconds) || seconds === Infinity) {
    h = m = s = "-";
  }
  h = h > 0 || gh > 0 ? h + ":" : "";
  m = ((h || gm >= 10) && m < 10 ? "0" + m : m) + ":";
  s = s < 10 ? "0" + s : s;
  return h + m + s;
};
var implementation = defaultImplementation;
function setFormatTime(customImplementation) {
  implementation = customImplementation;
}
function resetFormatTime() {
  implementation = defaultImplementation;
}
function formatTime(seconds, guide) {
  if (guide === void 0) {
    guide = seconds;
  }
  return implementation(seconds, guide);
}
var TimeDisplay = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(TimeDisplay2, _Component);
  function TimeDisplay2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.on(player, ["timeupdate", "ended"], function(e) {
      return _this.updateContent(e);
    });
    _this.updateTextNode_();
    return _this;
  }
  var _proto = TimeDisplay2.prototype;
  _proto.createEl = function createEl$1() {
    var className = this.buildCSSClass();
    var el = _Component.prototype.createEl.call(this, "div", {
      className: className + " vjs-time-control vjs-control"
    });
    var span = createEl("span", {
      className: "vjs-control-text",
      textContent: this.localize(this.labelText_) + "\xA0"
    }, {
      role: "presentation"
    });
    el.appendChild(span);
    this.contentEl_ = createEl("span", {
      className: className + "-display"
    }, {
      // tell screen readers not to automatically read the time as it changes
      "aria-live": "off",
      // span elements have no implicit role, but some screen readers (notably VoiceOver)
      // treat them as a break between items in the DOM when using arrow keys
      // (or left-to-right swipes on iOS) to read contents of a page. Using
      // role='presentation' causes VoiceOver to NOT treat this span as a break.
      "role": "presentation"
    });
    el.appendChild(this.contentEl_);
    return el;
  };
  _proto.dispose = function dispose() {
    this.contentEl_ = null;
    this.textNode_ = null;
    _Component.prototype.dispose.call(this);
  };
  _proto.updateTextNode_ = function updateTextNode_(time) {
    var _this2 = this;
    if (time === void 0) {
      time = 0;
    }
    time = formatTime(time);
    if (this.formattedTime_ === time) {
      return;
    }
    this.formattedTime_ = time;
    this.requestNamedAnimationFrame("TimeDisplay#updateTextNode_", function() {
      if (!_this2.contentEl_) {
        return;
      }
      var oldNode = _this2.textNode_;
      if (oldNode && _this2.contentEl_.firstChild !== oldNode) {
        oldNode = null;
        log$1.warn("TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.");
      }
      _this2.textNode_ = import_document.default.createTextNode(_this2.formattedTime_);
      if (!_this2.textNode_) {
        return;
      }
      if (oldNode) {
        _this2.contentEl_.replaceChild(_this2.textNode_, oldNode);
      } else {
        _this2.contentEl_.appendChild(_this2.textNode_);
      }
    });
  };
  _proto.updateContent = function updateContent(event) {
  };
  return TimeDisplay2;
}(Component$1);
TimeDisplay.prototype.labelText_ = "Time";
TimeDisplay.prototype.controlText_ = "Time";
Component$1.registerComponent("TimeDisplay", TimeDisplay);
var CurrentTimeDisplay = /* @__PURE__ */ function(_TimeDisplay) {
  _inheritsLoose(CurrentTimeDisplay2, _TimeDisplay);
  function CurrentTimeDisplay2() {
    return _TimeDisplay.apply(this, arguments) || this;
  }
  var _proto = CurrentTimeDisplay2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-current-time";
  };
  _proto.updateContent = function updateContent(event) {
    var time;
    if (this.player_.ended()) {
      time = this.player_.duration();
    } else {
      time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    }
    this.updateTextNode_(time);
  };
  return CurrentTimeDisplay2;
}(TimeDisplay);
CurrentTimeDisplay.prototype.labelText_ = "Current Time";
CurrentTimeDisplay.prototype.controlText_ = "Current Time";
Component$1.registerComponent("CurrentTimeDisplay", CurrentTimeDisplay);
var DurationDisplay = /* @__PURE__ */ function(_TimeDisplay) {
  _inheritsLoose(DurationDisplay2, _TimeDisplay);
  function DurationDisplay2(player, options) {
    var _this;
    _this = _TimeDisplay.call(this, player, options) || this;
    var updateContent = function updateContent2(e) {
      return _this.updateContent(e);
    };
    _this.on(player, "durationchange", updateContent);
    _this.on(player, "loadstart", updateContent);
    _this.on(player, "loadedmetadata", updateContent);
    return _this;
  }
  var _proto = DurationDisplay2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-duration";
  };
  _proto.updateContent = function updateContent(event) {
    var duration5 = this.player_.duration();
    this.updateTextNode_(duration5);
  };
  return DurationDisplay2;
}(TimeDisplay);
DurationDisplay.prototype.labelText_ = "Duration";
DurationDisplay.prototype.controlText_ = "Duration";
Component$1.registerComponent("DurationDisplay", DurationDisplay);
var TimeDivider = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(TimeDivider2, _Component);
  function TimeDivider2() {
    return _Component.apply(this, arguments) || this;
  }
  var _proto = TimeDivider2.prototype;
  _proto.createEl = function createEl2() {
    var el = _Component.prototype.createEl.call(this, "div", {
      className: "vjs-time-control vjs-time-divider"
    }, {
      // this element and its contents can be hidden from assistive techs since
      // it is made extraneous by the announcement of the control text
      // for the current time and duration displays
      "aria-hidden": true
    });
    var div = _Component.prototype.createEl.call(this, "div");
    var span = _Component.prototype.createEl.call(this, "span", {
      textContent: "/"
    });
    div.appendChild(span);
    el.appendChild(div);
    return el;
  };
  return TimeDivider2;
}(Component$1);
Component$1.registerComponent("TimeDivider", TimeDivider);
var RemainingTimeDisplay = /* @__PURE__ */ function(_TimeDisplay) {
  _inheritsLoose(RemainingTimeDisplay2, _TimeDisplay);
  function RemainingTimeDisplay2(player, options) {
    var _this;
    _this = _TimeDisplay.call(this, player, options) || this;
    _this.on(player, "durationchange", function(e) {
      return _this.updateContent(e);
    });
    return _this;
  }
  var _proto = RemainingTimeDisplay2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-remaining-time";
  };
  _proto.createEl = function createEl$1() {
    var el = _TimeDisplay.prototype.createEl.call(this);
    if (this.options_.displayNegative !== false) {
      el.insertBefore(createEl("span", {}, {
        "aria-hidden": true
      }, "-"), this.contentEl_);
    }
    return el;
  };
  _proto.updateContent = function updateContent(event) {
    if (typeof this.player_.duration() !== "number") {
      return;
    }
    var time;
    if (this.player_.ended()) {
      time = 0;
    } else if (this.player_.remainingTimeDisplay) {
      time = this.player_.remainingTimeDisplay();
    } else {
      time = this.player_.remainingTime();
    }
    this.updateTextNode_(time);
  };
  return RemainingTimeDisplay2;
}(TimeDisplay);
RemainingTimeDisplay.prototype.labelText_ = "Remaining Time";
RemainingTimeDisplay.prototype.controlText_ = "Remaining Time";
Component$1.registerComponent("RemainingTimeDisplay", RemainingTimeDisplay);
var LiveDisplay = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(LiveDisplay2, _Component);
  function LiveDisplay2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.updateShowing();
    _this.on(_this.player(), "durationchange", function(e) {
      return _this.updateShowing(e);
    });
    return _this;
  }
  var _proto = LiveDisplay2.prototype;
  _proto.createEl = function createEl$1() {
    var el = _Component.prototype.createEl.call(this, "div", {
      className: "vjs-live-control vjs-control"
    });
    this.contentEl_ = createEl("div", {
      className: "vjs-live-display"
    }, {
      "aria-live": "off"
    });
    this.contentEl_.appendChild(createEl("span", {
      className: "vjs-control-text",
      textContent: this.localize("Stream Type") + "\xA0"
    }));
    this.contentEl_.appendChild(import_document.default.createTextNode(this.localize("LIVE")));
    el.appendChild(this.contentEl_);
    return el;
  };
  _proto.dispose = function dispose() {
    this.contentEl_ = null;
    _Component.prototype.dispose.call(this);
  };
  _proto.updateShowing = function updateShowing(event) {
    if (this.player().duration() === Infinity) {
      this.show();
    } else {
      this.hide();
    }
  };
  return LiveDisplay2;
}(Component$1);
Component$1.registerComponent("LiveDisplay", LiveDisplay);
var SeekToLive = /* @__PURE__ */ function(_Button) {
  _inheritsLoose(SeekToLive2, _Button);
  function SeekToLive2(player, options) {
    var _this;
    _this = _Button.call(this, player, options) || this;
    _this.updateLiveEdgeStatus();
    if (_this.player_.liveTracker) {
      _this.updateLiveEdgeStatusHandler_ = function(e) {
        return _this.updateLiveEdgeStatus(e);
      };
      _this.on(_this.player_.liveTracker, "liveedgechange", _this.updateLiveEdgeStatusHandler_);
    }
    return _this;
  }
  var _proto = SeekToLive2.prototype;
  _proto.createEl = function createEl$1() {
    var el = _Button.prototype.createEl.call(this, "button", {
      className: "vjs-seek-to-live-control vjs-control"
    });
    this.textEl_ = createEl("span", {
      className: "vjs-seek-to-live-text",
      textContent: this.localize("LIVE")
    }, {
      "aria-hidden": "true"
    });
    el.appendChild(this.textEl_);
    return el;
  };
  _proto.updateLiveEdgeStatus = function updateLiveEdgeStatus() {
    if (!this.player_.liveTracker || this.player_.liveTracker.atLiveEdge()) {
      this.setAttribute("aria-disabled", true);
      this.addClass("vjs-at-live-edge");
      this.controlText("Seek to live, currently playing live");
    } else {
      this.setAttribute("aria-disabled", false);
      this.removeClass("vjs-at-live-edge");
      this.controlText("Seek to live, currently behind live");
    }
  };
  _proto.handleClick = function handleClick() {
    this.player_.liveTracker.seekToLiveEdge();
  };
  _proto.dispose = function dispose() {
    if (this.player_.liveTracker) {
      this.off(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_);
    }
    this.textEl_ = null;
    _Button.prototype.dispose.call(this);
  };
  return SeekToLive2;
}(Button);
SeekToLive.prototype.controlText_ = "Seek to live, currently playing live";
Component$1.registerComponent("SeekToLive", SeekToLive);
var clamp = function clamp2(number, min, max) {
  number = Number(number);
  return Math.min(max, Math.max(min, isNaN(number) ? min : number));
};
var Slider = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(Slider2, _Component);
  function Slider2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.handleMouseDown_ = function(e) {
      return _this.handleMouseDown(e);
    };
    _this.handleMouseUp_ = function(e) {
      return _this.handleMouseUp(e);
    };
    _this.handleKeyDown_ = function(e) {
      return _this.handleKeyDown(e);
    };
    _this.handleClick_ = function(e) {
      return _this.handleClick(e);
    };
    _this.handleMouseMove_ = function(e) {
      return _this.handleMouseMove(e);
    };
    _this.update_ = function(e) {
      return _this.update(e);
    };
    _this.bar = _this.getChild(_this.options_.barName);
    _this.vertical(!!_this.options_.vertical);
    _this.enable();
    return _this;
  }
  var _proto = Slider2.prototype;
  _proto.enabled = function enabled() {
    return this.enabled_;
  };
  _proto.enable = function enable() {
    if (this.enabled()) {
      return;
    }
    this.on("mousedown", this.handleMouseDown_);
    this.on("touchstart", this.handleMouseDown_);
    this.on("keydown", this.handleKeyDown_);
    this.on("click", this.handleClick_);
    this.on(this.player_, "controlsvisible", this.update);
    if (this.playerEvent) {
      this.on(this.player_, this.playerEvent, this.update);
    }
    this.removeClass("disabled");
    this.setAttribute("tabindex", 0);
    this.enabled_ = true;
  };
  _proto.disable = function disable() {
    if (!this.enabled()) {
      return;
    }
    var doc = this.bar.el_.ownerDocument;
    this.off("mousedown", this.handleMouseDown_);
    this.off("touchstart", this.handleMouseDown_);
    this.off("keydown", this.handleKeyDown_);
    this.off("click", this.handleClick_);
    this.off(this.player_, "controlsvisible", this.update_);
    this.off(doc, "mousemove", this.handleMouseMove_);
    this.off(doc, "mouseup", this.handleMouseUp_);
    this.off(doc, "touchmove", this.handleMouseMove_);
    this.off(doc, "touchend", this.handleMouseUp_);
    this.removeAttribute("tabindex");
    this.addClass("disabled");
    if (this.playerEvent) {
      this.off(this.player_, this.playerEvent, this.update);
    }
    this.enabled_ = false;
  };
  _proto.createEl = function createEl2(type2, props, attributes) {
    if (props === void 0) {
      props = {};
    }
    if (attributes === void 0) {
      attributes = {};
    }
    props.className = props.className + " vjs-slider";
    props = assign({
      tabIndex: 0
    }, props);
    attributes = assign({
      "role": "slider",
      "aria-valuenow": 0,
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      "tabIndex": 0
    }, attributes);
    return _Component.prototype.createEl.call(this, type2, props, attributes);
  };
  _proto.handleMouseDown = function handleMouseDown(event) {
    var doc = this.bar.el_.ownerDocument;
    if (event.type === "mousedown") {
      event.preventDefault();
    }
    if (event.type === "touchstart" && !IS_CHROME) {
      event.preventDefault();
    }
    blockTextSelection();
    this.addClass("vjs-sliding");
    this.trigger("slideractive");
    this.on(doc, "mousemove", this.handleMouseMove_);
    this.on(doc, "mouseup", this.handleMouseUp_);
    this.on(doc, "touchmove", this.handleMouseMove_);
    this.on(doc, "touchend", this.handleMouseUp_);
    this.handleMouseMove(event, true);
  };
  _proto.handleMouseMove = function handleMouseMove(event) {
  };
  _proto.handleMouseUp = function handleMouseUp() {
    var doc = this.bar.el_.ownerDocument;
    unblockTextSelection();
    this.removeClass("vjs-sliding");
    this.trigger("sliderinactive");
    this.off(doc, "mousemove", this.handleMouseMove_);
    this.off(doc, "mouseup", this.handleMouseUp_);
    this.off(doc, "touchmove", this.handleMouseMove_);
    this.off(doc, "touchend", this.handleMouseUp_);
    this.update();
  };
  _proto.update = function update() {
    var _this2 = this;
    if (!this.el_ || !this.bar) {
      return;
    }
    var progress = this.getProgress();
    if (progress === this.progress_) {
      return progress;
    }
    this.progress_ = progress;
    this.requestNamedAnimationFrame("Slider#update", function() {
      var sizeKey = _this2.vertical() ? "height" : "width";
      _this2.bar.el().style[sizeKey] = (progress * 100).toFixed(2) + "%";
    });
    return progress;
  };
  _proto.getProgress = function getProgress() {
    return Number(clamp(this.getPercent(), 0, 1).toFixed(4));
  };
  _proto.calculateDistance = function calculateDistance(event) {
    var position = getPointerPosition(this.el_, event);
    if (this.vertical()) {
      return position.y;
    }
    return position.x;
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    if (import_keycode.default.isEventKey(event, "Left") || import_keycode.default.isEventKey(event, "Down")) {
      event.preventDefault();
      event.stopPropagation();
      this.stepBack();
    } else if (import_keycode.default.isEventKey(event, "Right") || import_keycode.default.isEventKey(event, "Up")) {
      event.preventDefault();
      event.stopPropagation();
      this.stepForward();
    } else {
      _Component.prototype.handleKeyDown.call(this, event);
    }
  };
  _proto.handleClick = function handleClick(event) {
    event.stopPropagation();
    event.preventDefault();
  };
  _proto.vertical = function vertical(bool) {
    if (bool === void 0) {
      return this.vertical_ || false;
    }
    this.vertical_ = !!bool;
    if (this.vertical_) {
      this.addClass("vjs-slider-vertical");
    } else {
      this.addClass("vjs-slider-horizontal");
    }
  };
  return Slider2;
}(Component$1);
Component$1.registerComponent("Slider", Slider);
var percentify = function percentify2(time, end) {
  return clamp(time / end * 100, 0, 100).toFixed(2) + "%";
};
var LoadProgressBar = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(LoadProgressBar2, _Component);
  function LoadProgressBar2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.partEls_ = [];
    _this.on(player, "progress", function(e) {
      return _this.update(e);
    });
    return _this;
  }
  var _proto = LoadProgressBar2.prototype;
  _proto.createEl = function createEl$1() {
    var el = _Component.prototype.createEl.call(this, "div", {
      className: "vjs-load-progress"
    });
    var wrapper = createEl("span", {
      className: "vjs-control-text"
    });
    var loadedText = createEl("span", {
      textContent: this.localize("Loaded")
    });
    var separator = import_document.default.createTextNode(": ");
    this.percentageEl_ = createEl("span", {
      className: "vjs-control-text-loaded-percentage",
      textContent: "0%"
    });
    el.appendChild(wrapper);
    wrapper.appendChild(loadedText);
    wrapper.appendChild(separator);
    wrapper.appendChild(this.percentageEl_);
    return el;
  };
  _proto.dispose = function dispose() {
    this.partEls_ = null;
    this.percentageEl_ = null;
    _Component.prototype.dispose.call(this);
  };
  _proto.update = function update(event) {
    var _this2 = this;
    this.requestNamedAnimationFrame("LoadProgressBar#update", function() {
      var liveTracker = _this2.player_.liveTracker;
      var buffered = _this2.player_.buffered();
      var duration5 = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : _this2.player_.duration();
      var bufferedEnd = _this2.player_.bufferedEnd();
      var children = _this2.partEls_;
      var percent = percentify(bufferedEnd, duration5);
      if (_this2.percent_ !== percent) {
        _this2.el_.style.width = percent;
        textContent(_this2.percentageEl_, percent);
        _this2.percent_ = percent;
      }
      for (var i = 0; i < buffered.length; i++) {
        var start2 = buffered.start(i);
        var end = buffered.end(i);
        var part = children[i];
        if (!part) {
          part = _this2.el_.appendChild(createEl());
          children[i] = part;
        }
        if (part.dataset.start === start2 && part.dataset.end === end) {
          continue;
        }
        part.dataset.start = start2;
        part.dataset.end = end;
        part.style.left = percentify(start2, bufferedEnd);
        part.style.width = percentify(end - start2, bufferedEnd);
      }
      for (var _i = children.length; _i > buffered.length; _i--) {
        _this2.el_.removeChild(children[_i - 1]);
      }
      children.length = buffered.length;
    });
  };
  return LoadProgressBar2;
}(Component$1);
Component$1.registerComponent("LoadProgressBar", LoadProgressBar);
var TimeTooltip = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(TimeTooltip2, _Component);
  function TimeTooltip2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.update = throttle(bind(_assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
    return _this;
  }
  var _proto = TimeTooltip2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-time-tooltip"
    }, {
      "aria-hidden": "true"
    });
  };
  _proto.update = function update(seekBarRect, seekBarPoint, content) {
    var tooltipRect = findPosition(this.el_);
    var playerRect = getBoundingClientRect(this.player_.el());
    var seekBarPointPx = seekBarRect.width * seekBarPoint;
    if (!playerRect || !tooltipRect) {
      return;
    }
    var spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;
    var spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);
    var pullTooltipBy = tooltipRect.width / 2;
    if (spaceLeftOfPoint < pullTooltipBy) {
      pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
    } else if (spaceRightOfPoint < pullTooltipBy) {
      pullTooltipBy = spaceRightOfPoint;
    }
    if (pullTooltipBy < 0) {
      pullTooltipBy = 0;
    } else if (pullTooltipBy > tooltipRect.width) {
      pullTooltipBy = tooltipRect.width;
    }
    pullTooltipBy = Math.round(pullTooltipBy);
    this.el_.style.right = "-" + pullTooltipBy + "px";
    this.write(content);
  };
  _proto.write = function write(content) {
    textContent(this.el_, content);
  };
  _proto.updateTime = function updateTime(seekBarRect, seekBarPoint, time, cb) {
    var _this2 = this;
    this.requestNamedAnimationFrame("TimeTooltip#updateTime", function() {
      var content;
      var duration5 = _this2.player_.duration();
      if (_this2.player_.liveTracker && _this2.player_.liveTracker.isLive()) {
        var liveWindow = _this2.player_.liveTracker.liveWindow();
        var secondsBehind = liveWindow - seekBarPoint * liveWindow;
        content = (secondsBehind < 1 ? "" : "-") + formatTime(secondsBehind, liveWindow);
      } else {
        content = formatTime(time, duration5);
      }
      _this2.update(seekBarRect, seekBarPoint, content);
      if (cb) {
        cb();
      }
    });
  };
  return TimeTooltip2;
}(Component$1);
Component$1.registerComponent("TimeTooltip", TimeTooltip);
var PlayProgressBar = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(PlayProgressBar2, _Component);
  function PlayProgressBar2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.update = throttle(bind(_assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
    return _this;
  }
  var _proto = PlayProgressBar2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-play-progress vjs-slider-bar"
    }, {
      "aria-hidden": "true"
    });
  };
  _proto.update = function update(seekBarRect, seekBarPoint) {
    var timeTooltip = this.getChild("timeTooltip");
    if (!timeTooltip) {
      return;
    }
    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    timeTooltip.updateTime(seekBarRect, seekBarPoint, time);
  };
  return PlayProgressBar2;
}(Component$1);
PlayProgressBar.prototype.options_ = {
  children: []
};
if (!IS_IOS && !IS_ANDROID) {
  PlayProgressBar.prototype.options_.children.push("timeTooltip");
}
Component$1.registerComponent("PlayProgressBar", PlayProgressBar);
var MouseTimeDisplay = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(MouseTimeDisplay2, _Component);
  function MouseTimeDisplay2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.update = throttle(bind(_assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
    return _this;
  }
  var _proto = MouseTimeDisplay2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-mouse-display"
    });
  };
  _proto.update = function update(seekBarRect, seekBarPoint) {
    var _this2 = this;
    var time = seekBarPoint * this.player_.duration();
    this.getChild("timeTooltip").updateTime(seekBarRect, seekBarPoint, time, function() {
      _this2.el_.style.left = seekBarRect.width * seekBarPoint + "px";
    });
  };
  return MouseTimeDisplay2;
}(Component$1);
MouseTimeDisplay.prototype.options_ = {
  children: ["timeTooltip"]
};
Component$1.registerComponent("MouseTimeDisplay", MouseTimeDisplay);
var STEP_SECONDS = 5;
var PAGE_KEY_MULTIPLIER = 12;
var SeekBar = /* @__PURE__ */ function(_Slider) {
  _inheritsLoose(SeekBar2, _Slider);
  function SeekBar2(player, options) {
    var _this;
    _this = _Slider.call(this, player, options) || this;
    _this.setEventHandlers_();
    return _this;
  }
  var _proto = SeekBar2.prototype;
  _proto.setEventHandlers_ = function setEventHandlers_() {
    var _this2 = this;
    this.update_ = bind(this, this.update);
    this.update = throttle(this.update_, UPDATE_REFRESH_INTERVAL);
    this.on(this.player_, ["ended", "durationchange", "timeupdate"], this.update);
    if (this.player_.liveTracker) {
      this.on(this.player_.liveTracker, "liveedgechange", this.update);
    }
    this.updateInterval = null;
    this.enableIntervalHandler_ = function(e) {
      return _this2.enableInterval_(e);
    };
    this.disableIntervalHandler_ = function(e) {
      return _this2.disableInterval_(e);
    };
    this.on(this.player_, ["playing"], this.enableIntervalHandler_);
    this.on(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_);
    if ("hidden" in import_document.default && "visibilityState" in import_document.default) {
      this.on(import_document.default, "visibilitychange", this.toggleVisibility_);
    }
  };
  _proto.toggleVisibility_ = function toggleVisibility_(e) {
    if (import_document.default.visibilityState === "hidden") {
      this.cancelNamedAnimationFrame("SeekBar#update");
      this.cancelNamedAnimationFrame("Slider#update");
      this.disableInterval_(e);
    } else {
      if (!this.player_.ended() && !this.player_.paused()) {
        this.enableInterval_();
      }
      this.update();
    }
  };
  _proto.enableInterval_ = function enableInterval_() {
    if (this.updateInterval) {
      return;
    }
    this.updateInterval = this.setInterval(this.update, UPDATE_REFRESH_INTERVAL);
  };
  _proto.disableInterval_ = function disableInterval_(e) {
    if (this.player_.liveTracker && this.player_.liveTracker.isLive() && e && e.type !== "ended") {
      return;
    }
    if (!this.updateInterval) {
      return;
    }
    this.clearInterval(this.updateInterval);
    this.updateInterval = null;
  };
  _proto.createEl = function createEl2() {
    return _Slider.prototype.createEl.call(this, "div", {
      className: "vjs-progress-holder"
    }, {
      "aria-label": this.localize("Progress Bar")
    });
  };
  _proto.update = function update(event) {
    var _this3 = this;
    if (import_document.default.visibilityState === "hidden") {
      return;
    }
    var percent = _Slider.prototype.update.call(this);
    this.requestNamedAnimationFrame("SeekBar#update", function() {
      var currentTime = _this3.player_.ended() ? _this3.player_.duration() : _this3.getCurrentTime_();
      var liveTracker = _this3.player_.liveTracker;
      var duration5 = _this3.player_.duration();
      if (liveTracker && liveTracker.isLive()) {
        duration5 = _this3.player_.liveTracker.liveCurrentTime();
      }
      if (_this3.percent_ !== percent) {
        _this3.el_.setAttribute("aria-valuenow", (percent * 100).toFixed(2));
        _this3.percent_ = percent;
      }
      if (_this3.currentTime_ !== currentTime || _this3.duration_ !== duration5) {
        _this3.el_.setAttribute("aria-valuetext", _this3.localize("progress bar timing: currentTime={1} duration={2}", [formatTime(currentTime, duration5), formatTime(duration5, duration5)], "{1} of {2}"));
        _this3.currentTime_ = currentTime;
        _this3.duration_ = duration5;
      }
      if (_this3.bar) {
        _this3.bar.update(getBoundingClientRect(_this3.el()), _this3.getProgress());
      }
    });
    return percent;
  };
  _proto.userSeek_ = function userSeek_(ct) {
    if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
      this.player_.liveTracker.nextSeekedFromUser();
    }
    this.player_.currentTime(ct);
  };
  _proto.getCurrentTime_ = function getCurrentTime_() {
    return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
  };
  _proto.getPercent = function getPercent() {
    var currentTime = this.getCurrentTime_();
    var percent;
    var liveTracker = this.player_.liveTracker;
    if (liveTracker && liveTracker.isLive()) {
      percent = (currentTime - liveTracker.seekableStart()) / liveTracker.liveWindow();
      if (liveTracker.atLiveEdge()) {
        percent = 1;
      }
    } else {
      percent = currentTime / this.player_.duration();
    }
    return percent;
  };
  _proto.handleMouseDown = function handleMouseDown(event) {
    if (!isSingleLeftClick(event)) {
      return;
    }
    event.stopPropagation();
    this.videoWasPlaying = !this.player_.paused();
    this.player_.pause();
    _Slider.prototype.handleMouseDown.call(this, event);
  };
  _proto.handleMouseMove = function handleMouseMove(event, mouseDown) {
    if (mouseDown === void 0) {
      mouseDown = false;
    }
    if (!isSingleLeftClick(event)) {
      return;
    }
    if (!mouseDown && !this.player_.scrubbing()) {
      this.player_.scrubbing(true);
    }
    var newTime;
    var distance = this.calculateDistance(event);
    var liveTracker = this.player_.liveTracker;
    if (!liveTracker || !liveTracker.isLive()) {
      newTime = distance * this.player_.duration();
      if (newTime === this.player_.duration()) {
        newTime = newTime - 0.1;
      }
    } else {
      if (distance >= 0.99) {
        liveTracker.seekToLiveEdge();
        return;
      }
      var seekableStart = liveTracker.seekableStart();
      var seekableEnd = liveTracker.liveCurrentTime();
      newTime = seekableStart + distance * liveTracker.liveWindow();
      if (newTime >= seekableEnd) {
        newTime = seekableEnd;
      }
      if (newTime <= seekableStart) {
        newTime = seekableStart + 0.1;
      }
      if (newTime === Infinity) {
        return;
      }
    }
    this.userSeek_(newTime);
  };
  _proto.enable = function enable() {
    _Slider.prototype.enable.call(this);
    var mouseTimeDisplay = this.getChild("mouseTimeDisplay");
    if (!mouseTimeDisplay) {
      return;
    }
    mouseTimeDisplay.show();
  };
  _proto.disable = function disable() {
    _Slider.prototype.disable.call(this);
    var mouseTimeDisplay = this.getChild("mouseTimeDisplay");
    if (!mouseTimeDisplay) {
      return;
    }
    mouseTimeDisplay.hide();
  };
  _proto.handleMouseUp = function handleMouseUp(event) {
    _Slider.prototype.handleMouseUp.call(this, event);
    if (event) {
      event.stopPropagation();
    }
    this.player_.scrubbing(false);
    this.player_.trigger({
      type: "timeupdate",
      target: this,
      manuallyTriggered: true
    });
    if (this.videoWasPlaying) {
      silencePromise(this.player_.play());
    } else {
      this.update_();
    }
  };
  _proto.stepForward = function stepForward() {
    this.userSeek_(this.player_.currentTime() + STEP_SECONDS);
  };
  _proto.stepBack = function stepBack() {
    this.userSeek_(this.player_.currentTime() - STEP_SECONDS);
  };
  _proto.handleAction = function handleAction(event) {
    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    var liveTracker = this.player_.liveTracker;
    if (import_keycode.default.isEventKey(event, "Space") || import_keycode.default.isEventKey(event, "Enter")) {
      event.preventDefault();
      event.stopPropagation();
      this.handleAction(event);
    } else if (import_keycode.default.isEventKey(event, "Home")) {
      event.preventDefault();
      event.stopPropagation();
      this.userSeek_(0);
    } else if (import_keycode.default.isEventKey(event, "End")) {
      event.preventDefault();
      event.stopPropagation();
      if (liveTracker && liveTracker.isLive()) {
        this.userSeek_(liveTracker.liveCurrentTime());
      } else {
        this.userSeek_(this.player_.duration());
      }
    } else if (/^[0-9]$/.test((0, import_keycode.default)(event))) {
      event.preventDefault();
      event.stopPropagation();
      var gotoFraction = (import_keycode.default.codes[(0, import_keycode.default)(event)] - import_keycode.default.codes["0"]) * 10 / 100;
      if (liveTracker && liveTracker.isLive()) {
        this.userSeek_(liveTracker.seekableStart() + liveTracker.liveWindow() * gotoFraction);
      } else {
        this.userSeek_(this.player_.duration() * gotoFraction);
      }
    } else if (import_keycode.default.isEventKey(event, "PgDn")) {
      event.preventDefault();
      event.stopPropagation();
      this.userSeek_(this.player_.currentTime() - STEP_SECONDS * PAGE_KEY_MULTIPLIER);
    } else if (import_keycode.default.isEventKey(event, "PgUp")) {
      event.preventDefault();
      event.stopPropagation();
      this.userSeek_(this.player_.currentTime() + STEP_SECONDS * PAGE_KEY_MULTIPLIER);
    } else {
      _Slider.prototype.handleKeyDown.call(this, event);
    }
  };
  _proto.dispose = function dispose() {
    this.disableInterval_();
    this.off(this.player_, ["ended", "durationchange", "timeupdate"], this.update);
    if (this.player_.liveTracker) {
      this.off(this.player_.liveTracker, "liveedgechange", this.update);
    }
    this.off(this.player_, ["playing"], this.enableIntervalHandler_);
    this.off(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_);
    if ("hidden" in import_document.default && "visibilityState" in import_document.default) {
      this.off(import_document.default, "visibilitychange", this.toggleVisibility_);
    }
    _Slider.prototype.dispose.call(this);
  };
  return SeekBar2;
}(Slider);
SeekBar.prototype.options_ = {
  children: ["loadProgressBar", "playProgressBar"],
  barName: "playProgressBar"
};
if (!IS_IOS && !IS_ANDROID) {
  SeekBar.prototype.options_.children.splice(1, 0, "mouseTimeDisplay");
}
Component$1.registerComponent("SeekBar", SeekBar);
var ProgressControl = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(ProgressControl2, _Component);
  function ProgressControl2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.handleMouseMove = throttle(bind(_assertThisInitialized(_this), _this.handleMouseMove), UPDATE_REFRESH_INTERVAL);
    _this.throttledHandleMouseSeek = throttle(bind(_assertThisInitialized(_this), _this.handleMouseSeek), UPDATE_REFRESH_INTERVAL);
    _this.handleMouseUpHandler_ = function(e) {
      return _this.handleMouseUp(e);
    };
    _this.handleMouseDownHandler_ = function(e) {
      return _this.handleMouseDown(e);
    };
    _this.enable();
    return _this;
  }
  var _proto = ProgressControl2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-progress-control vjs-control"
    });
  };
  _proto.handleMouseMove = function handleMouseMove(event) {
    var seekBar = this.getChild("seekBar");
    if (!seekBar) {
      return;
    }
    var playProgressBar = seekBar.getChild("playProgressBar");
    var mouseTimeDisplay = seekBar.getChild("mouseTimeDisplay");
    if (!playProgressBar && !mouseTimeDisplay) {
      return;
    }
    var seekBarEl = seekBar.el();
    var seekBarRect = findPosition(seekBarEl);
    var seekBarPoint = getPointerPosition(seekBarEl, event).x;
    seekBarPoint = clamp(seekBarPoint, 0, 1);
    if (mouseTimeDisplay) {
      mouseTimeDisplay.update(seekBarRect, seekBarPoint);
    }
    if (playProgressBar) {
      playProgressBar.update(seekBarRect, seekBar.getProgress());
    }
  };
  _proto.handleMouseSeek = function handleMouseSeek(event) {
    var seekBar = this.getChild("seekBar");
    if (seekBar) {
      seekBar.handleMouseMove(event);
    }
  };
  _proto.enabled = function enabled() {
    return this.enabled_;
  };
  _proto.disable = function disable() {
    this.children().forEach(function(child) {
      return child.disable && child.disable();
    });
    if (!this.enabled()) {
      return;
    }
    this.off(["mousedown", "touchstart"], this.handleMouseDownHandler_);
    this.off(this.el_, "mousemove", this.handleMouseMove);
    this.removeListenersAddedOnMousedownAndTouchstart();
    this.addClass("disabled");
    this.enabled_ = false;
    if (this.player_.scrubbing()) {
      var seekBar = this.getChild("seekBar");
      this.player_.scrubbing(false);
      if (seekBar.videoWasPlaying) {
        silencePromise(this.player_.play());
      }
    }
  };
  _proto.enable = function enable() {
    this.children().forEach(function(child) {
      return child.enable && child.enable();
    });
    if (this.enabled()) {
      return;
    }
    this.on(["mousedown", "touchstart"], this.handleMouseDownHandler_);
    this.on(this.el_, "mousemove", this.handleMouseMove);
    this.removeClass("disabled");
    this.enabled_ = true;
  };
  _proto.removeListenersAddedOnMousedownAndTouchstart = function removeListenersAddedOnMousedownAndTouchstart() {
    var doc = this.el_.ownerDocument;
    this.off(doc, "mousemove", this.throttledHandleMouseSeek);
    this.off(doc, "touchmove", this.throttledHandleMouseSeek);
    this.off(doc, "mouseup", this.handleMouseUpHandler_);
    this.off(doc, "touchend", this.handleMouseUpHandler_);
  };
  _proto.handleMouseDown = function handleMouseDown(event) {
    var doc = this.el_.ownerDocument;
    var seekBar = this.getChild("seekBar");
    if (seekBar) {
      seekBar.handleMouseDown(event);
    }
    this.on(doc, "mousemove", this.throttledHandleMouseSeek);
    this.on(doc, "touchmove", this.throttledHandleMouseSeek);
    this.on(doc, "mouseup", this.handleMouseUpHandler_);
    this.on(doc, "touchend", this.handleMouseUpHandler_);
  };
  _proto.handleMouseUp = function handleMouseUp(event) {
    var seekBar = this.getChild("seekBar");
    if (seekBar) {
      seekBar.handleMouseUp(event);
    }
    this.removeListenersAddedOnMousedownAndTouchstart();
  };
  return ProgressControl2;
}(Component$1);
ProgressControl.prototype.options_ = {
  children: ["seekBar"]
};
Component$1.registerComponent("ProgressControl", ProgressControl);
var PictureInPictureToggle = /* @__PURE__ */ function(_Button) {
  _inheritsLoose(PictureInPictureToggle2, _Button);
  function PictureInPictureToggle2(player, options) {
    var _this;
    _this = _Button.call(this, player, options) || this;
    _this.on(player, ["enterpictureinpicture", "leavepictureinpicture"], function(e) {
      return _this.handlePictureInPictureChange(e);
    });
    _this.on(player, ["disablepictureinpicturechanged", "loadedmetadata"], function(e) {
      return _this.handlePictureInPictureEnabledChange(e);
    });
    _this.on(player, ["loadedmetadata", "audioonlymodechange", "audiopostermodechange"], function() {
      var isSourceAudio = player.currentType().substring(0, 5) === "audio";
      if (isSourceAudio || player.audioPosterMode() || player.audioOnlyMode()) {
        if (player.isInPictureInPicture()) {
          player.exitPictureInPicture();
        }
        _this.hide();
      } else {
        _this.show();
      }
    });
    _this.disable();
    return _this;
  }
  var _proto = PictureInPictureToggle2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-picture-in-picture-control " + _Button.prototype.buildCSSClass.call(this);
  };
  _proto.handlePictureInPictureEnabledChange = function handlePictureInPictureEnabledChange() {
    if (import_document.default.pictureInPictureEnabled && this.player_.disablePictureInPicture() === false) {
      this.enable();
    } else {
      this.disable();
    }
  };
  _proto.handlePictureInPictureChange = function handlePictureInPictureChange(event) {
    if (this.player_.isInPictureInPicture()) {
      this.controlText("Exit Picture-in-Picture");
    } else {
      this.controlText("Picture-in-Picture");
    }
    this.handlePictureInPictureEnabledChange();
  };
  _proto.handleClick = function handleClick(event) {
    if (!this.player_.isInPictureInPicture()) {
      this.player_.requestPictureInPicture();
    } else {
      this.player_.exitPictureInPicture();
    }
  };
  return PictureInPictureToggle2;
}(Button);
PictureInPictureToggle.prototype.controlText_ = "Picture-in-Picture";
Component$1.registerComponent("PictureInPictureToggle", PictureInPictureToggle);
var FullscreenToggle = /* @__PURE__ */ function(_Button) {
  _inheritsLoose(FullscreenToggle2, _Button);
  function FullscreenToggle2(player, options) {
    var _this;
    _this = _Button.call(this, player, options) || this;
    _this.on(player, "fullscreenchange", function(e) {
      return _this.handleFullscreenChange(e);
    });
    if (import_document.default[player.fsApi_.fullscreenEnabled] === false) {
      _this.disable();
    }
    return _this;
  }
  var _proto = FullscreenToggle2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-fullscreen-control " + _Button.prototype.buildCSSClass.call(this);
  };
  _proto.handleFullscreenChange = function handleFullscreenChange(event) {
    if (this.player_.isFullscreen()) {
      this.controlText("Non-Fullscreen");
    } else {
      this.controlText("Fullscreen");
    }
  };
  _proto.handleClick = function handleClick(event) {
    if (!this.player_.isFullscreen()) {
      this.player_.requestFullscreen();
    } else {
      this.player_.exitFullscreen();
    }
  };
  return FullscreenToggle2;
}(Button);
FullscreenToggle.prototype.controlText_ = "Fullscreen";
Component$1.registerComponent("FullscreenToggle", FullscreenToggle);
var checkVolumeSupport = function checkVolumeSupport2(self2, player) {
  if (player.tech_ && !player.tech_.featuresVolumeControl) {
    self2.addClass("vjs-hidden");
  }
  self2.on(player, "loadstart", function() {
    if (!player.tech_.featuresVolumeControl) {
      self2.addClass("vjs-hidden");
    } else {
      self2.removeClass("vjs-hidden");
    }
  });
};
var VolumeLevel = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(VolumeLevel2, _Component);
  function VolumeLevel2() {
    return _Component.apply(this, arguments) || this;
  }
  var _proto = VolumeLevel2.prototype;
  _proto.createEl = function createEl2() {
    var el = _Component.prototype.createEl.call(this, "div", {
      className: "vjs-volume-level"
    });
    el.appendChild(_Component.prototype.createEl.call(this, "span", {
      className: "vjs-control-text"
    }));
    return el;
  };
  return VolumeLevel2;
}(Component$1);
Component$1.registerComponent("VolumeLevel", VolumeLevel);
var VolumeLevelTooltip = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(VolumeLevelTooltip2, _Component);
  function VolumeLevelTooltip2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.update = throttle(bind(_assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
    return _this;
  }
  var _proto = VolumeLevelTooltip2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-volume-tooltip"
    }, {
      "aria-hidden": "true"
    });
  };
  _proto.update = function update(rangeBarRect, rangeBarPoint, vertical, content) {
    if (!vertical) {
      var tooltipRect = getBoundingClientRect(this.el_);
      var playerRect = getBoundingClientRect(this.player_.el());
      var volumeBarPointPx = rangeBarRect.width * rangeBarPoint;
      if (!playerRect || !tooltipRect) {
        return;
      }
      var spaceLeftOfPoint = rangeBarRect.left - playerRect.left + volumeBarPointPx;
      var spaceRightOfPoint = rangeBarRect.width - volumeBarPointPx + (playerRect.right - rangeBarRect.right);
      var pullTooltipBy = tooltipRect.width / 2;
      if (spaceLeftOfPoint < pullTooltipBy) {
        pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
      } else if (spaceRightOfPoint < pullTooltipBy) {
        pullTooltipBy = spaceRightOfPoint;
      }
      if (pullTooltipBy < 0) {
        pullTooltipBy = 0;
      } else if (pullTooltipBy > tooltipRect.width) {
        pullTooltipBy = tooltipRect.width;
      }
      this.el_.style.right = "-" + pullTooltipBy + "px";
    }
    this.write(content + "%");
  };
  _proto.write = function write(content) {
    textContent(this.el_, content);
  };
  _proto.updateVolume = function updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, cb) {
    var _this2 = this;
    this.requestNamedAnimationFrame("VolumeLevelTooltip#updateVolume", function() {
      _this2.update(rangeBarRect, rangeBarPoint, vertical, volume.toFixed(0));
      if (cb) {
        cb();
      }
    });
  };
  return VolumeLevelTooltip2;
}(Component$1);
Component$1.registerComponent("VolumeLevelTooltip", VolumeLevelTooltip);
var MouseVolumeLevelDisplay = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(MouseVolumeLevelDisplay2, _Component);
  function MouseVolumeLevelDisplay2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.update = throttle(bind(_assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
    return _this;
  }
  var _proto = MouseVolumeLevelDisplay2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-mouse-display"
    });
  };
  _proto.update = function update(rangeBarRect, rangeBarPoint, vertical) {
    var _this2 = this;
    var volume = 100 * rangeBarPoint;
    this.getChild("volumeLevelTooltip").updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, function() {
      if (vertical) {
        _this2.el_.style.bottom = rangeBarRect.height * rangeBarPoint + "px";
      } else {
        _this2.el_.style.left = rangeBarRect.width * rangeBarPoint + "px";
      }
    });
  };
  return MouseVolumeLevelDisplay2;
}(Component$1);
MouseVolumeLevelDisplay.prototype.options_ = {
  children: ["volumeLevelTooltip"]
};
Component$1.registerComponent("MouseVolumeLevelDisplay", MouseVolumeLevelDisplay);
var VolumeBar = /* @__PURE__ */ function(_Slider) {
  _inheritsLoose(VolumeBar2, _Slider);
  function VolumeBar2(player, options) {
    var _this;
    _this = _Slider.call(this, player, options) || this;
    _this.on("slideractive", function(e) {
      return _this.updateLastVolume_(e);
    });
    _this.on(player, "volumechange", function(e) {
      return _this.updateARIAAttributes(e);
    });
    player.ready(function() {
      return _this.updateARIAAttributes();
    });
    return _this;
  }
  var _proto = VolumeBar2.prototype;
  _proto.createEl = function createEl2() {
    return _Slider.prototype.createEl.call(this, "div", {
      className: "vjs-volume-bar vjs-slider-bar"
    }, {
      "aria-label": this.localize("Volume Level"),
      "aria-live": "polite"
    });
  };
  _proto.handleMouseDown = function handleMouseDown(event) {
    if (!isSingleLeftClick(event)) {
      return;
    }
    _Slider.prototype.handleMouseDown.call(this, event);
  };
  _proto.handleMouseMove = function handleMouseMove(event) {
    var mouseVolumeLevelDisplay = this.getChild("mouseVolumeLevelDisplay");
    if (mouseVolumeLevelDisplay) {
      var volumeBarEl = this.el();
      var volumeBarRect = getBoundingClientRect(volumeBarEl);
      var vertical = this.vertical();
      var volumeBarPoint = getPointerPosition(volumeBarEl, event);
      volumeBarPoint = vertical ? volumeBarPoint.y : volumeBarPoint.x;
      volumeBarPoint = clamp(volumeBarPoint, 0, 1);
      mouseVolumeLevelDisplay.update(volumeBarRect, volumeBarPoint, vertical);
    }
    if (!isSingleLeftClick(event)) {
      return;
    }
    this.checkMuted();
    this.player_.volume(this.calculateDistance(event));
  };
  _proto.checkMuted = function checkMuted() {
    if (this.player_.muted()) {
      this.player_.muted(false);
    }
  };
  _proto.getPercent = function getPercent() {
    if (this.player_.muted()) {
      return 0;
    }
    return this.player_.volume();
  };
  _proto.stepForward = function stepForward() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() + 0.1);
  };
  _proto.stepBack = function stepBack() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() - 0.1);
  };
  _proto.updateARIAAttributes = function updateARIAAttributes(event) {
    var ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();
    this.el_.setAttribute("aria-valuenow", ariaValue);
    this.el_.setAttribute("aria-valuetext", ariaValue + "%");
  };
  _proto.volumeAsPercentage_ = function volumeAsPercentage_() {
    return Math.round(this.player_.volume() * 100);
  };
  _proto.updateLastVolume_ = function updateLastVolume_() {
    var _this2 = this;
    var volumeBeforeDrag = this.player_.volume();
    this.one("sliderinactive", function() {
      if (_this2.player_.volume() === 0) {
        _this2.player_.lastVolume_(volumeBeforeDrag);
      }
    });
  };
  return VolumeBar2;
}(Slider);
VolumeBar.prototype.options_ = {
  children: ["volumeLevel"],
  barName: "volumeLevel"
};
if (!IS_IOS && !IS_ANDROID) {
  VolumeBar.prototype.options_.children.splice(0, 0, "mouseVolumeLevelDisplay");
}
VolumeBar.prototype.playerEvent = "volumechange";
Component$1.registerComponent("VolumeBar", VolumeBar);
var VolumeControl = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(VolumeControl2, _Component);
  function VolumeControl2(player, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    options.vertical = options.vertical || false;
    if (typeof options.volumeBar === "undefined" || isPlain(options.volumeBar)) {
      options.volumeBar = options.volumeBar || {};
      options.volumeBar.vertical = options.vertical;
    }
    _this = _Component.call(this, player, options) || this;
    checkVolumeSupport(_assertThisInitialized(_this), player);
    _this.throttledHandleMouseMove = throttle(bind(_assertThisInitialized(_this), _this.handleMouseMove), UPDATE_REFRESH_INTERVAL);
    _this.handleMouseUpHandler_ = function(e) {
      return _this.handleMouseUp(e);
    };
    _this.on("mousedown", function(e) {
      return _this.handleMouseDown(e);
    });
    _this.on("touchstart", function(e) {
      return _this.handleMouseDown(e);
    });
    _this.on("mousemove", function(e) {
      return _this.handleMouseMove(e);
    });
    _this.on(_this.volumeBar, ["focus", "slideractive"], function() {
      _this.volumeBar.addClass("vjs-slider-active");
      _this.addClass("vjs-slider-active");
      _this.trigger("slideractive");
    });
    _this.on(_this.volumeBar, ["blur", "sliderinactive"], function() {
      _this.volumeBar.removeClass("vjs-slider-active");
      _this.removeClass("vjs-slider-active");
      _this.trigger("sliderinactive");
    });
    return _this;
  }
  var _proto = VolumeControl2.prototype;
  _proto.createEl = function createEl2() {
    var orientationClass = "vjs-volume-horizontal";
    if (this.options_.vertical) {
      orientationClass = "vjs-volume-vertical";
    }
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-volume-control vjs-control " + orientationClass
    });
  };
  _proto.handleMouseDown = function handleMouseDown(event) {
    var doc = this.el_.ownerDocument;
    this.on(doc, "mousemove", this.throttledHandleMouseMove);
    this.on(doc, "touchmove", this.throttledHandleMouseMove);
    this.on(doc, "mouseup", this.handleMouseUpHandler_);
    this.on(doc, "touchend", this.handleMouseUpHandler_);
  };
  _proto.handleMouseUp = function handleMouseUp(event) {
    var doc = this.el_.ownerDocument;
    this.off(doc, "mousemove", this.throttledHandleMouseMove);
    this.off(doc, "touchmove", this.throttledHandleMouseMove);
    this.off(doc, "mouseup", this.handleMouseUpHandler_);
    this.off(doc, "touchend", this.handleMouseUpHandler_);
  };
  _proto.handleMouseMove = function handleMouseMove(event) {
    this.volumeBar.handleMouseMove(event);
  };
  return VolumeControl2;
}(Component$1);
VolumeControl.prototype.options_ = {
  children: ["volumeBar"]
};
Component$1.registerComponent("VolumeControl", VolumeControl);
var checkMuteSupport = function checkMuteSupport2(self2, player) {
  if (player.tech_ && !player.tech_.featuresMuteControl) {
    self2.addClass("vjs-hidden");
  }
  self2.on(player, "loadstart", function() {
    if (!player.tech_.featuresMuteControl) {
      self2.addClass("vjs-hidden");
    } else {
      self2.removeClass("vjs-hidden");
    }
  });
};
var MuteToggle = /* @__PURE__ */ function(_Button) {
  _inheritsLoose(MuteToggle2, _Button);
  function MuteToggle2(player, options) {
    var _this;
    _this = _Button.call(this, player, options) || this;
    checkMuteSupport(_assertThisInitialized(_this), player);
    _this.on(player, ["loadstart", "volumechange"], function(e) {
      return _this.update(e);
    });
    return _this;
  }
  var _proto = MuteToggle2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-mute-control " + _Button.prototype.buildCSSClass.call(this);
  };
  _proto.handleClick = function handleClick(event) {
    var vol = this.player_.volume();
    var lastVolume = this.player_.lastVolume_();
    if (vol === 0) {
      var volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;
      this.player_.volume(volumeToSet);
      this.player_.muted(false);
    } else {
      this.player_.muted(this.player_.muted() ? false : true);
    }
  };
  _proto.update = function update(event) {
    this.updateIcon_();
    this.updateControlText_();
  };
  _proto.updateIcon_ = function updateIcon_() {
    var vol = this.player_.volume();
    var level = 3;
    if (IS_IOS && this.player_.tech_ && this.player_.tech_.el_) {
      this.player_.muted(this.player_.tech_.el_.muted);
    }
    if (vol === 0 || this.player_.muted()) {
      level = 0;
    } else if (vol < 0.33) {
      level = 1;
    } else if (vol < 0.67) {
      level = 2;
    }
    for (var i = 0; i < 4; i++) {
      removeClass(this.el_, "vjs-vol-" + i);
    }
    addClass(this.el_, "vjs-vol-" + level);
  };
  _proto.updateControlText_ = function updateControlText_() {
    var soundOff = this.player_.muted() || this.player_.volume() === 0;
    var text = soundOff ? "Unmute" : "Mute";
    if (this.controlText() !== text) {
      this.controlText(text);
    }
  };
  return MuteToggle2;
}(Button);
MuteToggle.prototype.controlText_ = "Mute";
Component$1.registerComponent("MuteToggle", MuteToggle);
var VolumePanel = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(VolumePanel2, _Component);
  function VolumePanel2(player, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    if (typeof options.inline !== "undefined") {
      options.inline = options.inline;
    } else {
      options.inline = true;
    }
    if (typeof options.volumeControl === "undefined" || isPlain(options.volumeControl)) {
      options.volumeControl = options.volumeControl || {};
      options.volumeControl.vertical = !options.inline;
    }
    _this = _Component.call(this, player, options) || this;
    _this.handleKeyPressHandler_ = function(e) {
      return _this.handleKeyPress(e);
    };
    _this.on(player, ["loadstart"], function(e) {
      return _this.volumePanelState_(e);
    });
    _this.on(_this.muteToggle, "keyup", function(e) {
      return _this.handleKeyPress(e);
    });
    _this.on(_this.volumeControl, "keyup", function(e) {
      return _this.handleVolumeControlKeyUp(e);
    });
    _this.on("keydown", function(e) {
      return _this.handleKeyPress(e);
    });
    _this.on("mouseover", function(e) {
      return _this.handleMouseOver(e);
    });
    _this.on("mouseout", function(e) {
      return _this.handleMouseOut(e);
    });
    _this.on(_this.volumeControl, ["slideractive"], _this.sliderActive_);
    _this.on(_this.volumeControl, ["sliderinactive"], _this.sliderInactive_);
    return _this;
  }
  var _proto = VolumePanel2.prototype;
  _proto.sliderActive_ = function sliderActive_() {
    this.addClass("vjs-slider-active");
  };
  _proto.sliderInactive_ = function sliderInactive_() {
    this.removeClass("vjs-slider-active");
  };
  _proto.volumePanelState_ = function volumePanelState_() {
    if (this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden")) {
      this.addClass("vjs-hidden");
    }
    if (this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden")) {
      this.addClass("vjs-mute-toggle-only");
    }
  };
  _proto.createEl = function createEl2() {
    var orientationClass = "vjs-volume-panel-horizontal";
    if (!this.options_.inline) {
      orientationClass = "vjs-volume-panel-vertical";
    }
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-volume-panel vjs-control " + orientationClass
    });
  };
  _proto.dispose = function dispose() {
    this.handleMouseOut();
    _Component.prototype.dispose.call(this);
  };
  _proto.handleVolumeControlKeyUp = function handleVolumeControlKeyUp(event) {
    if (import_keycode.default.isEventKey(event, "Esc")) {
      this.muteToggle.focus();
    }
  };
  _proto.handleMouseOver = function handleMouseOver(event) {
    this.addClass("vjs-hover");
    on(import_document.default, "keyup", this.handleKeyPressHandler_);
  };
  _proto.handleMouseOut = function handleMouseOut(event) {
    this.removeClass("vjs-hover");
    off(import_document.default, "keyup", this.handleKeyPressHandler_);
  };
  _proto.handleKeyPress = function handleKeyPress(event) {
    if (import_keycode.default.isEventKey(event, "Esc")) {
      this.handleMouseOut();
    }
  };
  return VolumePanel2;
}(Component$1);
VolumePanel.prototype.options_ = {
  children: ["muteToggle", "volumeControl"]
};
Component$1.registerComponent("VolumePanel", VolumePanel);
var Menu = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(Menu2, _Component);
  function Menu2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    if (options) {
      _this.menuButton_ = options.menuButton;
    }
    _this.focusedChild_ = -1;
    _this.on("keydown", function(e) {
      return _this.handleKeyDown(e);
    });
    _this.boundHandleBlur_ = function(e) {
      return _this.handleBlur(e);
    };
    _this.boundHandleTapClick_ = function(e) {
      return _this.handleTapClick(e);
    };
    return _this;
  }
  var _proto = Menu2.prototype;
  _proto.addEventListenerForItem = function addEventListenerForItem(component) {
    if (!(component instanceof Component$1)) {
      return;
    }
    this.on(component, "blur", this.boundHandleBlur_);
    this.on(component, ["tap", "click"], this.boundHandleTapClick_);
  };
  _proto.removeEventListenerForItem = function removeEventListenerForItem(component) {
    if (!(component instanceof Component$1)) {
      return;
    }
    this.off(component, "blur", this.boundHandleBlur_);
    this.off(component, ["tap", "click"], this.boundHandleTapClick_);
  };
  _proto.removeChild = function removeChild(component) {
    if (typeof component === "string") {
      component = this.getChild(component);
    }
    this.removeEventListenerForItem(component);
    _Component.prototype.removeChild.call(this, component);
  };
  _proto.addItem = function addItem(component) {
    var childComponent = this.addChild(component);
    if (childComponent) {
      this.addEventListenerForItem(childComponent);
    }
  };
  _proto.createEl = function createEl$1() {
    var contentElType = this.options_.contentElType || "ul";
    this.contentEl_ = createEl(contentElType, {
      className: "vjs-menu-content"
    });
    this.contentEl_.setAttribute("role", "menu");
    var el = _Component.prototype.createEl.call(this, "div", {
      append: this.contentEl_,
      className: "vjs-menu"
    });
    el.appendChild(this.contentEl_);
    on(el, "click", function(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    });
    return el;
  };
  _proto.dispose = function dispose() {
    this.contentEl_ = null;
    this.boundHandleBlur_ = null;
    this.boundHandleTapClick_ = null;
    _Component.prototype.dispose.call(this);
  };
  _proto.handleBlur = function handleBlur(event) {
    var relatedTarget = event.relatedTarget || import_document.default.activeElement;
    if (!this.children().some(function(element) {
      return element.el() === relatedTarget;
    })) {
      var btn = this.menuButton_;
      if (btn && btn.buttonPressed_ && relatedTarget !== btn.el().firstChild) {
        btn.unpressButton();
      }
    }
  };
  _proto.handleTapClick = function handleTapClick(event) {
    if (this.menuButton_) {
      this.menuButton_.unpressButton();
      var childComponents = this.children();
      if (!Array.isArray(childComponents)) {
        return;
      }
      var foundComponent = childComponents.filter(function(component) {
        return component.el() === event.target;
      })[0];
      if (!foundComponent) {
        return;
      }
      if (foundComponent.name() !== "CaptionSettingsMenuItem") {
        this.menuButton_.focus();
      }
    }
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    if (import_keycode.default.isEventKey(event, "Left") || import_keycode.default.isEventKey(event, "Down")) {
      event.preventDefault();
      event.stopPropagation();
      this.stepForward();
    } else if (import_keycode.default.isEventKey(event, "Right") || import_keycode.default.isEventKey(event, "Up")) {
      event.preventDefault();
      event.stopPropagation();
      this.stepBack();
    }
  };
  _proto.stepForward = function stepForward() {
    var stepChild = 0;
    if (this.focusedChild_ !== void 0) {
      stepChild = this.focusedChild_ + 1;
    }
    this.focus(stepChild);
  };
  _proto.stepBack = function stepBack() {
    var stepChild = 0;
    if (this.focusedChild_ !== void 0) {
      stepChild = this.focusedChild_ - 1;
    }
    this.focus(stepChild);
  };
  _proto.focus = function focus(item) {
    if (item === void 0) {
      item = 0;
    }
    var children = this.children().slice();
    var haveTitle = children.length && children[0].hasClass("vjs-menu-title");
    if (haveTitle) {
      children.shift();
    }
    if (children.length > 0) {
      if (item < 0) {
        item = 0;
      } else if (item >= children.length) {
        item = children.length - 1;
      }
      this.focusedChild_ = item;
      children[item].el_.focus();
    }
  };
  return Menu2;
}(Component$1);
Component$1.registerComponent("Menu", Menu);
var MenuButton = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(MenuButton3, _Component);
  function MenuButton3(player, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _Component.call(this, player, options) || this;
    _this.menuButton_ = new Button(player, options);
    _this.menuButton_.controlText(_this.controlText_);
    _this.menuButton_.el_.setAttribute("aria-haspopup", "true");
    var buttonClass = Button.prototype.buildCSSClass();
    _this.menuButton_.el_.className = _this.buildCSSClass() + " " + buttonClass;
    _this.menuButton_.removeClass("vjs-control");
    _this.addChild(_this.menuButton_);
    _this.update();
    _this.enabled_ = true;
    var handleClick = function handleClick2(e) {
      return _this.handleClick(e);
    };
    _this.handleMenuKeyUp_ = function(e) {
      return _this.handleMenuKeyUp(e);
    };
    _this.on(_this.menuButton_, "tap", handleClick);
    _this.on(_this.menuButton_, "click", handleClick);
    _this.on(_this.menuButton_, "keydown", function(e) {
      return _this.handleKeyDown(e);
    });
    _this.on(_this.menuButton_, "mouseenter", function() {
      _this.addClass("vjs-hover");
      _this.menu.show();
      on(import_document.default, "keyup", _this.handleMenuKeyUp_);
    });
    _this.on("mouseleave", function(e) {
      return _this.handleMouseLeave(e);
    });
    _this.on("keydown", function(e) {
      return _this.handleSubmenuKeyDown(e);
    });
    return _this;
  }
  var _proto = MenuButton3.prototype;
  _proto.update = function update() {
    var menu = this.createMenu();
    if (this.menu) {
      this.menu.dispose();
      this.removeChild(this.menu);
    }
    this.menu = menu;
    this.addChild(menu);
    this.buttonPressed_ = false;
    this.menuButton_.el_.setAttribute("aria-expanded", "false");
    if (this.items && this.items.length <= this.hideThreshold_) {
      this.hide();
      this.menu.contentEl_.removeAttribute("role");
    } else {
      this.show();
      this.menu.contentEl_.setAttribute("role", "menu");
    }
  };
  _proto.createMenu = function createMenu() {
    var menu = new Menu(this.player_, {
      menuButton: this
    });
    this.hideThreshold_ = 0;
    if (this.options_.title) {
      var titleEl = createEl("li", {
        className: "vjs-menu-title",
        textContent: toTitleCase$1(this.options_.title),
        tabIndex: -1
      });
      var titleComponent = new Component$1(this.player_, {
        el: titleEl
      });
      menu.addItem(titleComponent);
    }
    this.items = this.createItems();
    if (this.items) {
      for (var i = 0; i < this.items.length; i++) {
        menu.addItem(this.items[i]);
      }
    }
    return menu;
  };
  _proto.createItems = function createItems() {
  };
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: this.buildWrapperCSSClass()
    }, {});
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    var menuButtonClass = "vjs-menu-button";
    if (this.options_.inline === true) {
      menuButtonClass += "-inline";
    } else {
      menuButtonClass += "-popup";
    }
    var buttonClass = Button.prototype.buildCSSClass();
    return "vjs-menu-button " + menuButtonClass + " " + buttonClass + " " + _Component.prototype.buildCSSClass.call(this);
  };
  _proto.buildCSSClass = function buildCSSClass() {
    var menuButtonClass = "vjs-menu-button";
    if (this.options_.inline === true) {
      menuButtonClass += "-inline";
    } else {
      menuButtonClass += "-popup";
    }
    return "vjs-menu-button " + menuButtonClass + " " + _Component.prototype.buildCSSClass.call(this);
  };
  _proto.controlText = function controlText(text, el) {
    if (el === void 0) {
      el = this.menuButton_.el();
    }
    return this.menuButton_.controlText(text, el);
  };
  _proto.dispose = function dispose() {
    this.handleMouseLeave();
    _Component.prototype.dispose.call(this);
  };
  _proto.handleClick = function handleClick(event) {
    if (this.buttonPressed_) {
      this.unpressButton();
    } else {
      this.pressButton();
    }
  };
  _proto.handleMouseLeave = function handleMouseLeave(event) {
    this.removeClass("vjs-hover");
    off(import_document.default, "keyup", this.handleMenuKeyUp_);
  };
  _proto.focus = function focus() {
    this.menuButton_.focus();
  };
  _proto.blur = function blur() {
    this.menuButton_.blur();
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    if (import_keycode.default.isEventKey(event, "Esc") || import_keycode.default.isEventKey(event, "Tab")) {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      if (!import_keycode.default.isEventKey(event, "Tab")) {
        event.preventDefault();
        this.menuButton_.focus();
      }
    } else if (import_keycode.default.isEventKey(event, "Up") || import_keycode.default.isEventKey(event, "Down")) {
      if (!this.buttonPressed_) {
        event.preventDefault();
        this.pressButton();
      }
    }
  };
  _proto.handleMenuKeyUp = function handleMenuKeyUp(event) {
    if (import_keycode.default.isEventKey(event, "Esc") || import_keycode.default.isEventKey(event, "Tab")) {
      this.removeClass("vjs-hover");
    }
  };
  _proto.handleSubmenuKeyPress = function handleSubmenuKeyPress(event) {
    this.handleSubmenuKeyDown(event);
  };
  _proto.handleSubmenuKeyDown = function handleSubmenuKeyDown(event) {
    if (import_keycode.default.isEventKey(event, "Esc") || import_keycode.default.isEventKey(event, "Tab")) {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      if (!import_keycode.default.isEventKey(event, "Tab")) {
        event.preventDefault();
        this.menuButton_.focus();
      }
    }
  };
  _proto.pressButton = function pressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = true;
      this.menu.show();
      this.menu.lockShowing();
      this.menuButton_.el_.setAttribute("aria-expanded", "true");
      if (IS_IOS && isInFrame()) {
        return;
      }
      this.menu.focus();
    }
  };
  _proto.unpressButton = function unpressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = false;
      this.menu.unlockShowing();
      this.menu.hide();
      this.menuButton_.el_.setAttribute("aria-expanded", "false");
    }
  };
  _proto.disable = function disable() {
    this.unpressButton();
    this.enabled_ = false;
    this.addClass("vjs-disabled");
    this.menuButton_.disable();
  };
  _proto.enable = function enable() {
    this.enabled_ = true;
    this.removeClass("vjs-disabled");
    this.menuButton_.enable();
  };
  return MenuButton3;
}(Component$1);
Component$1.registerComponent("MenuButton", MenuButton);
var TrackButton = /* @__PURE__ */ function(_MenuButton) {
  _inheritsLoose(TrackButton2, _MenuButton);
  function TrackButton2(player, options) {
    var _this;
    var tracks = options.tracks;
    _this = _MenuButton.call(this, player, options) || this;
    if (_this.items.length <= 1) {
      _this.hide();
    }
    if (!tracks) {
      return _assertThisInitialized(_this);
    }
    var updateHandler = bind(_assertThisInitialized(_this), _this.update);
    tracks.addEventListener("removetrack", updateHandler);
    tracks.addEventListener("addtrack", updateHandler);
    tracks.addEventListener("labelchange", updateHandler);
    _this.player_.on("ready", updateHandler);
    _this.player_.on("dispose", function() {
      tracks.removeEventListener("removetrack", updateHandler);
      tracks.removeEventListener("addtrack", updateHandler);
      tracks.removeEventListener("labelchange", updateHandler);
    });
    return _this;
  }
  return TrackButton2;
}(MenuButton);
Component$1.registerComponent("TrackButton", TrackButton);
var MenuKeys = ["Tab", "Esc", "Up", "Down", "Right", "Left"];
var MenuItem = /* @__PURE__ */ function(_ClickableComponent) {
  _inheritsLoose(MenuItem2, _ClickableComponent);
  function MenuItem2(player, options) {
    var _this;
    _this = _ClickableComponent.call(this, player, options) || this;
    _this.selectable = options.selectable;
    _this.isSelected_ = options.selected || false;
    _this.multiSelectable = options.multiSelectable;
    _this.selected(_this.isSelected_);
    if (_this.selectable) {
      if (_this.multiSelectable) {
        _this.el_.setAttribute("role", "menuitemcheckbox");
      } else {
        _this.el_.setAttribute("role", "menuitemradio");
      }
    } else {
      _this.el_.setAttribute("role", "menuitem");
    }
    return _this;
  }
  var _proto = MenuItem2.prototype;
  _proto.createEl = function createEl$1(type2, props, attrs) {
    this.nonIconControl = true;
    var el = _ClickableComponent.prototype.createEl.call(this, "li", assign({
      className: "vjs-menu-item",
      tabIndex: -1
    }, props), attrs);
    el.replaceChild(createEl("span", {
      className: "vjs-menu-item-text",
      textContent: this.localize(this.options_.label)
    }), el.querySelector(".vjs-icon-placeholder"));
    return el;
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    if (!MenuKeys.some(function(key) {
      return import_keycode.default.isEventKey(event, key);
    })) {
      _ClickableComponent.prototype.handleKeyDown.call(this, event);
    }
  };
  _proto.handleClick = function handleClick(event) {
    this.selected(true);
  };
  _proto.selected = function selected(_selected) {
    if (this.selectable) {
      if (_selected) {
        this.addClass("vjs-selected");
        this.el_.setAttribute("aria-checked", "true");
        this.controlText(", selected");
        this.isSelected_ = true;
      } else {
        this.removeClass("vjs-selected");
        this.el_.setAttribute("aria-checked", "false");
        this.controlText("");
        this.isSelected_ = false;
      }
    }
  };
  return MenuItem2;
}(ClickableComponent);
Component$1.registerComponent("MenuItem", MenuItem);
var TextTrackMenuItem = /* @__PURE__ */ function(_MenuItem) {
  _inheritsLoose(TextTrackMenuItem2, _MenuItem);
  function TextTrackMenuItem2(player, options) {
    var _this;
    var track = options.track;
    var tracks = player.textTracks();
    options.label = track.label || track.language || "Unknown";
    options.selected = track.mode === "showing";
    _this = _MenuItem.call(this, player, options) || this;
    _this.track = track;
    _this.kinds = (options.kinds || [options.kind || _this.track.kind]).filter(Boolean);
    var changeHandler = function changeHandler2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this.handleTracksChange.apply(_assertThisInitialized(_this), args);
    };
    var selectedLanguageChangeHandler = function selectedLanguageChangeHandler2() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      _this.handleSelectedLanguageChange.apply(_assertThisInitialized(_this), args);
    };
    player.on(["loadstart", "texttrackchange"], changeHandler);
    tracks.addEventListener("change", changeHandler);
    tracks.addEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
    _this.on("dispose", function() {
      player.off(["loadstart", "texttrackchange"], changeHandler);
      tracks.removeEventListener("change", changeHandler);
      tracks.removeEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
    });
    if (tracks.onchange === void 0) {
      var event;
      _this.on(["tap", "click"], function() {
        if (typeof import_window6.default.Event !== "object") {
          try {
            event = new import_window6.default.Event("change");
          } catch (err) {
          }
        }
        if (!event) {
          event = import_document.default.createEvent("Event");
          event.initEvent("change", true, true);
        }
        tracks.dispatchEvent(event);
      });
    }
    _this.handleTracksChange();
    return _this;
  }
  var _proto = TextTrackMenuItem2.prototype;
  _proto.handleClick = function handleClick(event) {
    var referenceTrack = this.track;
    var tracks = this.player_.textTracks();
    _MenuItem.prototype.handleClick.call(this, event);
    if (!tracks) {
      return;
    }
    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];
      if (this.kinds.indexOf(track.kind) === -1) {
        continue;
      }
      if (track === referenceTrack) {
        if (track.mode !== "showing") {
          track.mode = "showing";
        }
      } else if (track.mode !== "disabled") {
        track.mode = "disabled";
      }
    }
  };
  _proto.handleTracksChange = function handleTracksChange(event) {
    var shouldBeSelected = this.track.mode === "showing";
    if (shouldBeSelected !== this.isSelected_) {
      this.selected(shouldBeSelected);
    }
  };
  _proto.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {
    if (this.track.mode === "showing") {
      var selectedLanguage = this.player_.cache_.selectedLanguage;
      if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {
        return;
      }
      this.player_.cache_.selectedLanguage = {
        enabled: true,
        language: this.track.language,
        kind: this.track.kind
      };
    }
  };
  _proto.dispose = function dispose() {
    this.track = null;
    _MenuItem.prototype.dispose.call(this);
  };
  return TextTrackMenuItem2;
}(MenuItem);
Component$1.registerComponent("TextTrackMenuItem", TextTrackMenuItem);
var OffTextTrackMenuItem = /* @__PURE__ */ function(_TextTrackMenuItem) {
  _inheritsLoose(OffTextTrackMenuItem2, _TextTrackMenuItem);
  function OffTextTrackMenuItem2(player, options) {
    options.track = {
      player,
      // it is no longer necessary to store `kind` or `kinds` on the track itself
      // since they are now stored in the `kinds` property of all instances of
      // TextTrackMenuItem, but this will remain for backwards compatibility
      kind: options.kind,
      kinds: options.kinds,
      "default": false,
      mode: "disabled"
    };
    if (!options.kinds) {
      options.kinds = [options.kind];
    }
    if (options.label) {
      options.track.label = options.label;
    } else {
      options.track.label = options.kinds.join(" and ") + " off";
    }
    options.selectable = true;
    options.multiSelectable = false;
    return _TextTrackMenuItem.call(this, player, options) || this;
  }
  var _proto = OffTextTrackMenuItem2.prototype;
  _proto.handleTracksChange = function handleTracksChange(event) {
    var tracks = this.player().textTracks();
    var shouldBeSelected = true;
    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];
      if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === "showing") {
        shouldBeSelected = false;
        break;
      }
    }
    if (shouldBeSelected !== this.isSelected_) {
      this.selected(shouldBeSelected);
    }
  };
  _proto.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {
    var tracks = this.player().textTracks();
    var allHidden = true;
    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];
      if (["captions", "descriptions", "subtitles"].indexOf(track.kind) > -1 && track.mode === "showing") {
        allHidden = false;
        break;
      }
    }
    if (allHidden) {
      this.player_.cache_.selectedLanguage = {
        enabled: false
      };
    }
  };
  return OffTextTrackMenuItem2;
}(TextTrackMenuItem);
Component$1.registerComponent("OffTextTrackMenuItem", OffTextTrackMenuItem);
var TextTrackButton = /* @__PURE__ */ function(_TrackButton) {
  _inheritsLoose(TextTrackButton2, _TrackButton);
  function TextTrackButton2(player, options) {
    if (options === void 0) {
      options = {};
    }
    options.tracks = player.textTracks();
    return _TrackButton.call(this, player, options) || this;
  }
  var _proto = TextTrackButton2.prototype;
  _proto.createItems = function createItems(items, TrackMenuItem) {
    if (items === void 0) {
      items = [];
    }
    if (TrackMenuItem === void 0) {
      TrackMenuItem = TextTrackMenuItem;
    }
    var label;
    if (this.label_) {
      label = this.label_ + " off";
    }
    items.push(new OffTextTrackMenuItem(this.player_, {
      kinds: this.kinds_,
      kind: this.kind_,
      label
    }));
    this.hideThreshold_ += 1;
    var tracks = this.player_.textTracks();
    if (!Array.isArray(this.kinds_)) {
      this.kinds_ = [this.kind_];
    }
    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];
      if (this.kinds_.indexOf(track.kind) > -1) {
        var item = new TrackMenuItem(this.player_, {
          track,
          kinds: this.kinds_,
          kind: this.kind_,
          // MenuItem is selectable
          selectable: true,
          // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
          multiSelectable: false
        });
        item.addClass("vjs-" + track.kind + "-menu-item");
        items.push(item);
      }
    }
    return items;
  };
  return TextTrackButton2;
}(TrackButton);
Component$1.registerComponent("TextTrackButton", TextTrackButton);
var ChaptersTrackMenuItem = /* @__PURE__ */ function(_MenuItem) {
  _inheritsLoose(ChaptersTrackMenuItem2, _MenuItem);
  function ChaptersTrackMenuItem2(player, options) {
    var _this;
    var track = options.track;
    var cue = options.cue;
    var currentTime = player.currentTime();
    options.selectable = true;
    options.multiSelectable = false;
    options.label = cue.text;
    options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;
    _this = _MenuItem.call(this, player, options) || this;
    _this.track = track;
    _this.cue = cue;
    return _this;
  }
  var _proto = ChaptersTrackMenuItem2.prototype;
  _proto.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this);
    this.player_.currentTime(this.cue.startTime);
  };
  return ChaptersTrackMenuItem2;
}(MenuItem);
Component$1.registerComponent("ChaptersTrackMenuItem", ChaptersTrackMenuItem);
var ChaptersButton = /* @__PURE__ */ function(_TextTrackButton) {
  _inheritsLoose(ChaptersButton2, _TextTrackButton);
  function ChaptersButton2(player, options, ready) {
    var _this;
    _this = _TextTrackButton.call(this, player, options, ready) || this;
    _this.selectCurrentItem_ = function() {
      _this.items.forEach(function(item) {
        item.selected(_this.track_.activeCues[0] === item.cue);
      });
    };
    return _this;
  }
  var _proto = ChaptersButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-chapters-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-chapters-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };
  _proto.update = function update(event) {
    if (event && event.track && event.track.kind !== "chapters") {
      return;
    }
    var track = this.findChaptersTrack();
    if (track !== this.track_) {
      this.setTrack(track);
      _TextTrackButton.prototype.update.call(this);
    } else if (!this.items || track && track.cues && track.cues.length !== this.items.length) {
      _TextTrackButton.prototype.update.call(this);
    }
  };
  _proto.setTrack = function setTrack(track) {
    if (this.track_ === track) {
      return;
    }
    if (!this.updateHandler_) {
      this.updateHandler_ = this.update.bind(this);
    }
    if (this.track_) {
      var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
      if (remoteTextTrackEl) {
        remoteTextTrackEl.removeEventListener("load", this.updateHandler_);
      }
      this.track_.removeEventListener("cuechange", this.selectCurrentItem_);
      this.track_ = null;
    }
    this.track_ = track;
    if (this.track_) {
      this.track_.mode = "hidden";
      var _remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
      if (_remoteTextTrackEl) {
        _remoteTextTrackEl.addEventListener("load", this.updateHandler_);
      }
      this.track_.addEventListener("cuechange", this.selectCurrentItem_);
    }
  };
  _proto.findChaptersTrack = function findChaptersTrack() {
    var tracks = this.player_.textTracks() || [];
    for (var i = tracks.length - 1; i >= 0; i--) {
      var track = tracks[i];
      if (track.kind === this.kind_) {
        return track;
      }
    }
  };
  _proto.getMenuCaption = function getMenuCaption() {
    if (this.track_ && this.track_.label) {
      return this.track_.label;
    }
    return this.localize(toTitleCase$1(this.kind_));
  };
  _proto.createMenu = function createMenu() {
    this.options_.title = this.getMenuCaption();
    return _TextTrackButton.prototype.createMenu.call(this);
  };
  _proto.createItems = function createItems() {
    var items = [];
    if (!this.track_) {
      return items;
    }
    var cues = this.track_.cues;
    if (!cues) {
      return items;
    }
    for (var i = 0, l = cues.length; i < l; i++) {
      var cue = cues[i];
      var mi = new ChaptersTrackMenuItem(this.player_, {
        track: this.track_,
        cue
      });
      items.push(mi);
    }
    return items;
  };
  return ChaptersButton2;
}(TextTrackButton);
ChaptersButton.prototype.kind_ = "chapters";
ChaptersButton.prototype.controlText_ = "Chapters";
Component$1.registerComponent("ChaptersButton", ChaptersButton);
var DescriptionsButton = /* @__PURE__ */ function(_TextTrackButton) {
  _inheritsLoose(DescriptionsButton2, _TextTrackButton);
  function DescriptionsButton2(player, options, ready) {
    var _this;
    _this = _TextTrackButton.call(this, player, options, ready) || this;
    var tracks = player.textTracks();
    var changeHandler = bind(_assertThisInitialized(_this), _this.handleTracksChange);
    tracks.addEventListener("change", changeHandler);
    _this.on("dispose", function() {
      tracks.removeEventListener("change", changeHandler);
    });
    return _this;
  }
  var _proto = DescriptionsButton2.prototype;
  _proto.handleTracksChange = function handleTracksChange(event) {
    var tracks = this.player().textTracks();
    var disabled = false;
    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];
      if (track.kind !== this.kind_ && track.mode === "showing") {
        disabled = true;
        break;
      }
    }
    if (disabled) {
      this.disable();
    } else {
      this.enable();
    }
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-descriptions-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-descriptions-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };
  return DescriptionsButton2;
}(TextTrackButton);
DescriptionsButton.prototype.kind_ = "descriptions";
DescriptionsButton.prototype.controlText_ = "Descriptions";
Component$1.registerComponent("DescriptionsButton", DescriptionsButton);
var SubtitlesButton = /* @__PURE__ */ function(_TextTrackButton) {
  _inheritsLoose(SubtitlesButton2, _TextTrackButton);
  function SubtitlesButton2(player, options, ready) {
    return _TextTrackButton.call(this, player, options, ready) || this;
  }
  var _proto = SubtitlesButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-subtitles-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-subtitles-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };
  return SubtitlesButton2;
}(TextTrackButton);
SubtitlesButton.prototype.kind_ = "subtitles";
SubtitlesButton.prototype.controlText_ = "Subtitles";
Component$1.registerComponent("SubtitlesButton", SubtitlesButton);
var CaptionSettingsMenuItem = /* @__PURE__ */ function(_TextTrackMenuItem) {
  _inheritsLoose(CaptionSettingsMenuItem2, _TextTrackMenuItem);
  function CaptionSettingsMenuItem2(player, options) {
    var _this;
    options.track = {
      player,
      kind: options.kind,
      label: options.kind + " settings",
      selectable: false,
      "default": false,
      mode: "disabled"
    };
    options.selectable = false;
    options.name = "CaptionSettingsMenuItem";
    _this = _TextTrackMenuItem.call(this, player, options) || this;
    _this.addClass("vjs-texttrack-settings");
    _this.controlText(", opens " + options.kind + " settings dialog");
    return _this;
  }
  var _proto = CaptionSettingsMenuItem2.prototype;
  _proto.handleClick = function handleClick(event) {
    this.player().getChild("textTrackSettings").open();
  };
  return CaptionSettingsMenuItem2;
}(TextTrackMenuItem);
Component$1.registerComponent("CaptionSettingsMenuItem", CaptionSettingsMenuItem);
var CaptionsButton = /* @__PURE__ */ function(_TextTrackButton) {
  _inheritsLoose(CaptionsButton2, _TextTrackButton);
  function CaptionsButton2(player, options, ready) {
    return _TextTrackButton.call(this, player, options, ready) || this;
  }
  var _proto = CaptionsButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-captions-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-captions-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };
  _proto.createItems = function createItems() {
    var items = [];
    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings")) {
      items.push(new CaptionSettingsMenuItem(this.player_, {
        kind: this.kind_
      }));
      this.hideThreshold_ += 1;
    }
    return _TextTrackButton.prototype.createItems.call(this, items);
  };
  return CaptionsButton2;
}(TextTrackButton);
CaptionsButton.prototype.kind_ = "captions";
CaptionsButton.prototype.controlText_ = "Captions";
Component$1.registerComponent("CaptionsButton", CaptionsButton);
var SubsCapsMenuItem = /* @__PURE__ */ function(_TextTrackMenuItem) {
  _inheritsLoose(SubsCapsMenuItem2, _TextTrackMenuItem);
  function SubsCapsMenuItem2() {
    return _TextTrackMenuItem.apply(this, arguments) || this;
  }
  var _proto = SubsCapsMenuItem2.prototype;
  _proto.createEl = function createEl$1(type2, props, attrs) {
    var el = _TextTrackMenuItem.prototype.createEl.call(this, type2, props, attrs);
    var parentSpan = el.querySelector(".vjs-menu-item-text");
    if (this.options_.track.kind === "captions") {
      parentSpan.appendChild(createEl("span", {
        className: "vjs-icon-placeholder"
      }, {
        "aria-hidden": true
      }));
      parentSpan.appendChild(createEl("span", {
        className: "vjs-control-text",
        // space added as the text will visually flow with the
        // label
        textContent: " " + this.localize("Captions")
      }));
    }
    return el;
  };
  return SubsCapsMenuItem2;
}(TextTrackMenuItem);
Component$1.registerComponent("SubsCapsMenuItem", SubsCapsMenuItem);
var SubsCapsButton = /* @__PURE__ */ function(_TextTrackButton) {
  _inheritsLoose(SubsCapsButton2, _TextTrackButton);
  function SubsCapsButton2(player, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _TextTrackButton.call(this, player, options) || this;
    _this.label_ = "subtitles";
    if (["en", "en-us", "en-ca", "fr-ca"].indexOf(_this.player_.language_) > -1) {
      _this.label_ = "captions";
    }
    _this.menuButton_.controlText(toTitleCase$1(_this.label_));
    return _this;
  }
  var _proto = SubsCapsButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-subs-caps-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-subs-caps-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };
  _proto.createItems = function createItems() {
    var items = [];
    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings")) {
      items.push(new CaptionSettingsMenuItem(this.player_, {
        kind: this.label_
      }));
      this.hideThreshold_ += 1;
    }
    items = _TextTrackButton.prototype.createItems.call(this, items, SubsCapsMenuItem);
    return items;
  };
  return SubsCapsButton2;
}(TextTrackButton);
SubsCapsButton.prototype.kinds_ = ["captions", "subtitles"];
SubsCapsButton.prototype.controlText_ = "Subtitles";
Component$1.registerComponent("SubsCapsButton", SubsCapsButton);
var AudioTrackMenuItem = /* @__PURE__ */ function(_MenuItem) {
  _inheritsLoose(AudioTrackMenuItem2, _MenuItem);
  function AudioTrackMenuItem2(player, options) {
    var _this;
    var track = options.track;
    var tracks = player.audioTracks();
    options.label = track.label || track.language || "Unknown";
    options.selected = track.enabled;
    _this = _MenuItem.call(this, player, options) || this;
    _this.track = track;
    _this.addClass("vjs-" + track.kind + "-menu-item");
    var changeHandler = function changeHandler2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this.handleTracksChange.apply(_assertThisInitialized(_this), args);
    };
    tracks.addEventListener("change", changeHandler);
    _this.on("dispose", function() {
      tracks.removeEventListener("change", changeHandler);
    });
    return _this;
  }
  var _proto = AudioTrackMenuItem2.prototype;
  _proto.createEl = function createEl$1(type2, props, attrs) {
    var el = _MenuItem.prototype.createEl.call(this, type2, props, attrs);
    var parentSpan = el.querySelector(".vjs-menu-item-text");
    if (this.options_.track.kind === "main-desc") {
      parentSpan.appendChild(createEl("span", {
        className: "vjs-icon-placeholder"
      }, {
        "aria-hidden": true
      }));
      parentSpan.appendChild(createEl("span", {
        className: "vjs-control-text",
        textContent: " " + this.localize("Descriptions")
      }));
    }
    return el;
  };
  _proto.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this, event);
    this.track.enabled = true;
    if (this.player_.tech_.featuresNativeAudioTracks) {
      var tracks = this.player_.audioTracks();
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        if (track === this.track) {
          continue;
        }
        track.enabled = track === this.track;
      }
    }
  };
  _proto.handleTracksChange = function handleTracksChange(event) {
    this.selected(this.track.enabled);
  };
  return AudioTrackMenuItem2;
}(MenuItem);
Component$1.registerComponent("AudioTrackMenuItem", AudioTrackMenuItem);
var AudioTrackButton = /* @__PURE__ */ function(_TrackButton) {
  _inheritsLoose(AudioTrackButton2, _TrackButton);
  function AudioTrackButton2(player, options) {
    if (options === void 0) {
      options = {};
    }
    options.tracks = player.audioTracks();
    return _TrackButton.call(this, player, options) || this;
  }
  var _proto = AudioTrackButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-audio-button " + _TrackButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-audio-button " + _TrackButton.prototype.buildWrapperCSSClass.call(this);
  };
  _proto.createItems = function createItems(items) {
    if (items === void 0) {
      items = [];
    }
    this.hideThreshold_ = 1;
    var tracks = this.player_.audioTracks();
    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];
      items.push(new AudioTrackMenuItem(this.player_, {
        track,
        // MenuItem is selectable
        selectable: true,
        // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
        multiSelectable: false
      }));
    }
    return items;
  };
  return AudioTrackButton2;
}(TrackButton);
AudioTrackButton.prototype.controlText_ = "Audio Track";
Component$1.registerComponent("AudioTrackButton", AudioTrackButton);
var PlaybackRateMenuItem = /* @__PURE__ */ function(_MenuItem) {
  _inheritsLoose(PlaybackRateMenuItem2, _MenuItem);
  function PlaybackRateMenuItem2(player, options) {
    var _this;
    var label = options.rate;
    var rate = parseFloat(label, 10);
    options.label = label;
    options.selected = rate === player.playbackRate();
    options.selectable = true;
    options.multiSelectable = false;
    _this = _MenuItem.call(this, player, options) || this;
    _this.label = label;
    _this.rate = rate;
    _this.on(player, "ratechange", function(e) {
      return _this.update(e);
    });
    return _this;
  }
  var _proto = PlaybackRateMenuItem2.prototype;
  _proto.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this);
    this.player().playbackRate(this.rate);
  };
  _proto.update = function update(event) {
    this.selected(this.player().playbackRate() === this.rate);
  };
  return PlaybackRateMenuItem2;
}(MenuItem);
PlaybackRateMenuItem.prototype.contentElType = "button";
Component$1.registerComponent("PlaybackRateMenuItem", PlaybackRateMenuItem);
var PlaybackRateMenuButton = /* @__PURE__ */ function(_MenuButton) {
  _inheritsLoose(PlaybackRateMenuButton2, _MenuButton);
  function PlaybackRateMenuButton2(player, options) {
    var _this;
    _this = _MenuButton.call(this, player, options) || this;
    _this.menuButton_.el_.setAttribute("aria-describedby", _this.labelElId_);
    _this.updateVisibility();
    _this.updateLabel();
    _this.on(player, "loadstart", function(e) {
      return _this.updateVisibility(e);
    });
    _this.on(player, "ratechange", function(e) {
      return _this.updateLabel(e);
    });
    _this.on(player, "playbackrateschange", function(e) {
      return _this.handlePlaybackRateschange(e);
    });
    return _this;
  }
  var _proto = PlaybackRateMenuButton2.prototype;
  _proto.createEl = function createEl$1() {
    var el = _MenuButton.prototype.createEl.call(this);
    this.labelElId_ = "vjs-playback-rate-value-label-" + this.id_;
    this.labelEl_ = createEl("div", {
      className: "vjs-playback-rate-value",
      id: this.labelElId_,
      textContent: "1x"
    });
    el.appendChild(this.labelEl_);
    return el;
  };
  _proto.dispose = function dispose() {
    this.labelEl_ = null;
    _MenuButton.prototype.dispose.call(this);
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-playback-rate " + _MenuButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-playback-rate " + _MenuButton.prototype.buildWrapperCSSClass.call(this);
  };
  _proto.createItems = function createItems() {
    var rates = this.playbackRates();
    var items = [];
    for (var i = rates.length - 1; i >= 0; i--) {
      items.push(new PlaybackRateMenuItem(this.player(), {
        rate: rates[i] + "x"
      }));
    }
    return items;
  };
  _proto.updateARIAAttributes = function updateARIAAttributes() {
    this.el().setAttribute("aria-valuenow", this.player().playbackRate());
  };
  _proto.handleClick = function handleClick(event) {
    var currentRate = this.player().playbackRate();
    var rates = this.playbackRates();
    var currentIndex = rates.indexOf(currentRate);
    var newIndex = (currentIndex + 1) % rates.length;
    this.player().playbackRate(rates[newIndex]);
  };
  _proto.handlePlaybackRateschange = function handlePlaybackRateschange(event) {
    this.update();
  };
  _proto.playbackRates = function playbackRates() {
    var player = this.player();
    return player.playbackRates && player.playbackRates() || [];
  };
  _proto.playbackRateSupported = function playbackRateSupported() {
    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
  };
  _proto.updateVisibility = function updateVisibility(event) {
    if (this.playbackRateSupported()) {
      this.removeClass("vjs-hidden");
    } else {
      this.addClass("vjs-hidden");
    }
  };
  _proto.updateLabel = function updateLabel(event) {
    if (this.playbackRateSupported()) {
      this.labelEl_.textContent = this.player().playbackRate() + "x";
    }
  };
  return PlaybackRateMenuButton2;
}(MenuButton);
PlaybackRateMenuButton.prototype.controlText_ = "Playback Rate";
Component$1.registerComponent("PlaybackRateMenuButton", PlaybackRateMenuButton);
var Spacer = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(Spacer2, _Component);
  function Spacer2() {
    return _Component.apply(this, arguments) || this;
  }
  var _proto = Spacer2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-spacer " + _Component.prototype.buildCSSClass.call(this);
  };
  _proto.createEl = function createEl2(tag, props, attributes) {
    if (tag === void 0) {
      tag = "div";
    }
    if (props === void 0) {
      props = {};
    }
    if (attributes === void 0) {
      attributes = {};
    }
    if (!props.className) {
      props.className = this.buildCSSClass();
    }
    return _Component.prototype.createEl.call(this, tag, props, attributes);
  };
  return Spacer2;
}(Component$1);
Component$1.registerComponent("Spacer", Spacer);
var CustomControlSpacer = /* @__PURE__ */ function(_Spacer) {
  _inheritsLoose(CustomControlSpacer2, _Spacer);
  function CustomControlSpacer2() {
    return _Spacer.apply(this, arguments) || this;
  }
  var _proto = CustomControlSpacer2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-custom-control-spacer " + _Spacer.prototype.buildCSSClass.call(this);
  };
  _proto.createEl = function createEl2() {
    return _Spacer.prototype.createEl.call(this, "div", {
      className: this.buildCSSClass(),
      // No-flex/table-cell mode requires there be some content
      // in the cell to fill the remaining space of the table.
      textContent: "\xA0"
    });
  };
  return CustomControlSpacer2;
}(Spacer);
Component$1.registerComponent("CustomControlSpacer", CustomControlSpacer);
var ControlBar = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(ControlBar2, _Component);
  function ControlBar2() {
    return _Component.apply(this, arguments) || this;
  }
  var _proto = ControlBar2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-control-bar",
      dir: "ltr"
    });
  };
  return ControlBar2;
}(Component$1);
ControlBar.prototype.options_ = {
  children: ["playToggle", "volumePanel", "currentTimeDisplay", "timeDivider", "durationDisplay", "progressControl", "liveDisplay", "seekToLive", "remainingTimeDisplay", "customControlSpacer", "playbackRateMenuButton", "chaptersButton", "descriptionsButton", "subsCapsButton", "audioTrackButton", "fullscreenToggle"]
};
if ("exitPictureInPicture" in import_document.default) {
  ControlBar.prototype.options_.children.splice(ControlBar.prototype.options_.children.length - 1, 0, "pictureInPictureToggle");
}
Component$1.registerComponent("ControlBar", ControlBar);
var ErrorDisplay = /* @__PURE__ */ function(_ModalDialog) {
  _inheritsLoose(ErrorDisplay2, _ModalDialog);
  function ErrorDisplay2(player, options) {
    var _this;
    _this = _ModalDialog.call(this, player, options) || this;
    _this.on(player, "error", function(e) {
      return _this.open(e);
    });
    return _this;
  }
  var _proto = ErrorDisplay2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-error-display " + _ModalDialog.prototype.buildCSSClass.call(this);
  };
  _proto.content = function content() {
    var error = this.player().error();
    return error ? this.localize(error.message) : "";
  };
  return ErrorDisplay2;
}(ModalDialog);
ErrorDisplay.prototype.options_ = _extends2({}, ModalDialog.prototype.options_, {
  pauseOnOpen: false,
  fillAlways: true,
  temporary: false,
  uncloseable: true
});
Component$1.registerComponent("ErrorDisplay", ErrorDisplay);
var LOCAL_STORAGE_KEY$1 = "vjs-text-track-settings";
var COLOR_BLACK = ["#000", "Black"];
var COLOR_BLUE = ["#00F", "Blue"];
var COLOR_CYAN = ["#0FF", "Cyan"];
var COLOR_GREEN = ["#0F0", "Green"];
var COLOR_MAGENTA = ["#F0F", "Magenta"];
var COLOR_RED = ["#F00", "Red"];
var COLOR_WHITE = ["#FFF", "White"];
var COLOR_YELLOW = ["#FF0", "Yellow"];
var OPACITY_OPAQUE = ["1", "Opaque"];
var OPACITY_SEMI = ["0.5", "Semi-Transparent"];
var OPACITY_TRANS = ["0", "Transparent"];
var selectConfigs = {
  backgroundColor: {
    selector: ".vjs-bg-color > select",
    id: "captions-background-color-%s",
    label: "Color",
    options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
  },
  backgroundOpacity: {
    selector: ".vjs-bg-opacity > select",
    id: "captions-background-opacity-%s",
    label: "Transparency",
    options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]
  },
  color: {
    selector: ".vjs-fg-color > select",
    id: "captions-foreground-color-%s",
    label: "Color",
    options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
  },
  edgeStyle: {
    selector: ".vjs-edge-style > select",
    id: "%s",
    label: "Text Edge Style",
    options: [["none", "None"], ["raised", "Raised"], ["depressed", "Depressed"], ["uniform", "Uniform"], ["dropshadow", "Dropshadow"]]
  },
  fontFamily: {
    selector: ".vjs-font-family > select",
    id: "captions-font-family-%s",
    label: "Font Family",
    options: [["proportionalSansSerif", "Proportional Sans-Serif"], ["monospaceSansSerif", "Monospace Sans-Serif"], ["proportionalSerif", "Proportional Serif"], ["monospaceSerif", "Monospace Serif"], ["casual", "Casual"], ["script", "Script"], ["small-caps", "Small Caps"]]
  },
  fontPercent: {
    selector: ".vjs-font-percent > select",
    id: "captions-font-size-%s",
    label: "Font Size",
    options: [["0.50", "50%"], ["0.75", "75%"], ["1.00", "100%"], ["1.25", "125%"], ["1.50", "150%"], ["1.75", "175%"], ["2.00", "200%"], ["3.00", "300%"], ["4.00", "400%"]],
    "default": 2,
    parser: function parser5(v) {
      return v === "1.00" ? null : Number(v);
    }
  },
  textOpacity: {
    selector: ".vjs-text-opacity > select",
    id: "captions-foreground-opacity-%s",
    label: "Transparency",
    options: [OPACITY_OPAQUE, OPACITY_SEMI]
  },
  // Options for this object are defined below.
  windowColor: {
    selector: ".vjs-window-color > select",
    id: "captions-window-color-%s",
    label: "Color"
  },
  // Options for this object are defined below.
  windowOpacity: {
    selector: ".vjs-window-opacity > select",
    id: "captions-window-opacity-%s",
    label: "Transparency",
    options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]
  }
};
selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;
function parseOptionValue(value, parser6) {
  if (parser6) {
    value = parser6(value);
  }
  if (value && value !== "none") {
    return value;
  }
}
function getSelectedOptionValue(el, parser6) {
  var value = el.options[el.options.selectedIndex].value;
  return parseOptionValue(value, parser6);
}
function setSelectedOption(el, value, parser6) {
  if (!value) {
    return;
  }
  for (var i = 0; i < el.options.length; i++) {
    if (parseOptionValue(el.options[i].value, parser6) === value) {
      el.selectedIndex = i;
      break;
    }
  }
}
var TextTrackSettings = /* @__PURE__ */ function(_ModalDialog) {
  _inheritsLoose(TextTrackSettings2, _ModalDialog);
  function TextTrackSettings2(player, options) {
    var _this;
    options.temporary = false;
    _this = _ModalDialog.call(this, player, options) || this;
    _this.updateDisplay = _this.updateDisplay.bind(_assertThisInitialized(_this));
    _this.fill();
    _this.hasBeenOpened_ = _this.hasBeenFilled_ = true;
    _this.endDialog = createEl("p", {
      className: "vjs-control-text",
      textContent: _this.localize("End of dialog window.")
    });
    _this.el().appendChild(_this.endDialog);
    _this.setDefaults();
    if (options.persistTextTrackSettings === void 0) {
      _this.options_.persistTextTrackSettings = _this.options_.playerOptions.persistTextTrackSettings;
    }
    _this.on(_this.$(".vjs-done-button"), "click", function() {
      _this.saveSettings();
      _this.close();
    });
    _this.on(_this.$(".vjs-default-button"), "click", function() {
      _this.setDefaults();
      _this.updateDisplay();
    });
    each(selectConfigs, function(config) {
      _this.on(_this.$(config.selector), "change", _this.updateDisplay);
    });
    if (_this.options_.persistTextTrackSettings) {
      _this.restoreSettings();
    }
    return _this;
  }
  var _proto = TextTrackSettings2.prototype;
  _proto.dispose = function dispose() {
    this.endDialog = null;
    _ModalDialog.prototype.dispose.call(this);
  };
  _proto.createElSelect_ = function createElSelect_(key, legendId, type2) {
    var _this2 = this;
    if (legendId === void 0) {
      legendId = "";
    }
    if (type2 === void 0) {
      type2 = "label";
    }
    var config = selectConfigs[key];
    var id = config.id.replace("%s", this.id_);
    var selectLabelledbyIds = [legendId, id].join(" ").trim();
    return ["<" + type2 + ' id="' + id + '" class="' + (type2 === "label" ? "vjs-label" : "") + '">', this.localize(config.label), "</" + type2 + ">", '<select aria-labelledby="' + selectLabelledbyIds + '">'].concat(config.options.map(function(o) {
      var optionId = id + "-" + o[1].replace(/\W+/g, "");
      return ['<option id="' + optionId + '" value="' + o[0] + '" ', 'aria-labelledby="' + selectLabelledbyIds + " " + optionId + '">', _this2.localize(o[1]), "</option>"].join("");
    })).concat("</select>").join("");
  };
  _proto.createElFgColor_ = function createElFgColor_() {
    var legendId = "captions-text-legend-" + this.id_;
    return ['<fieldset class="vjs-fg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize("Text"), "</legend>", this.createElSelect_("color", legendId), '<span class="vjs-text-opacity vjs-opacity">', this.createElSelect_("textOpacity", legendId), "</span>", "</fieldset>"].join("");
  };
  _proto.createElBgColor_ = function createElBgColor_() {
    var legendId = "captions-background-" + this.id_;
    return ['<fieldset class="vjs-bg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize("Background"), "</legend>", this.createElSelect_("backgroundColor", legendId), '<span class="vjs-bg-opacity vjs-opacity">', this.createElSelect_("backgroundOpacity", legendId), "</span>", "</fieldset>"].join("");
  };
  _proto.createElWinColor_ = function createElWinColor_() {
    var legendId = "captions-window-" + this.id_;
    return ['<fieldset class="vjs-window-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize("Window"), "</legend>", this.createElSelect_("windowColor", legendId), '<span class="vjs-window-opacity vjs-opacity">', this.createElSelect_("windowOpacity", legendId), "</span>", "</fieldset>"].join("");
  };
  _proto.createElColors_ = function createElColors_() {
    return createEl("div", {
      className: "vjs-track-settings-colors",
      innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join("")
    });
  };
  _proto.createElFont_ = function createElFont_() {
    return createEl("div", {
      className: "vjs-track-settings-font",
      innerHTML: ['<fieldset class="vjs-font-percent vjs-track-setting">', this.createElSelect_("fontPercent", "", "legend"), "</fieldset>", '<fieldset class="vjs-edge-style vjs-track-setting">', this.createElSelect_("edgeStyle", "", "legend"), "</fieldset>", '<fieldset class="vjs-font-family vjs-track-setting">', this.createElSelect_("fontFamily", "", "legend"), "</fieldset>"].join("")
    });
  };
  _proto.createElControls_ = function createElControls_() {
    var defaultsDescription = this.localize("restore all settings to the default values");
    return createEl("div", {
      className: "vjs-track-settings-controls",
      innerHTML: ['<button type="button" class="vjs-default-button" title="' + defaultsDescription + '">', this.localize("Reset"), '<span class="vjs-control-text"> ' + defaultsDescription + "</span>", "</button>", '<button type="button" class="vjs-done-button">' + this.localize("Done") + "</button>"].join("")
    });
  };
  _proto.content = function content() {
    return [this.createElColors_(), this.createElFont_(), this.createElControls_()];
  };
  _proto.label = function label() {
    return this.localize("Caption Settings Dialog");
  };
  _proto.description = function description() {
    return this.localize("Beginning of dialog window. Escape will cancel and close the window.");
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return _ModalDialog.prototype.buildCSSClass.call(this) + " vjs-text-track-settings";
  };
  _proto.getValues = function getValues() {
    var _this3 = this;
    return reduce(selectConfigs, function(accum, config, key) {
      var value = getSelectedOptionValue(_this3.$(config.selector), config.parser);
      if (value !== void 0) {
        accum[key] = value;
      }
      return accum;
    }, {});
  };
  _proto.setValues = function setValues(values3) {
    var _this4 = this;
    each(selectConfigs, function(config, key) {
      setSelectedOption(_this4.$(config.selector), values3[key], config.parser);
    });
  };
  _proto.setDefaults = function setDefaults() {
    var _this5 = this;
    each(selectConfigs, function(config) {
      var index = config.hasOwnProperty("default") ? config["default"] : 0;
      _this5.$(config.selector).selectedIndex = index;
    });
  };
  _proto.restoreSettings = function restoreSettings() {
    var values3;
    try {
      values3 = JSON.parse(import_window6.default.localStorage.getItem(LOCAL_STORAGE_KEY$1));
    } catch (err) {
      log$1.warn(err);
    }
    if (values3) {
      this.setValues(values3);
    }
  };
  _proto.saveSettings = function saveSettings() {
    if (!this.options_.persistTextTrackSettings) {
      return;
    }
    var values3 = this.getValues();
    try {
      if (Object.keys(values3).length) {
        import_window6.default.localStorage.setItem(LOCAL_STORAGE_KEY$1, JSON.stringify(values3));
      } else {
        import_window6.default.localStorage.removeItem(LOCAL_STORAGE_KEY$1);
      }
    } catch (err) {
      log$1.warn(err);
    }
  };
  _proto.updateDisplay = function updateDisplay() {
    var ttDisplay = this.player_.getChild("textTrackDisplay");
    if (ttDisplay) {
      ttDisplay.updateDisplay();
    }
  };
  _proto.conditionalBlur_ = function conditionalBlur_() {
    this.previouslyActiveEl_ = null;
    var cb = this.player_.controlBar;
    var subsCapsBtn = cb && cb.subsCapsButton;
    var ccBtn = cb && cb.captionsButton;
    if (subsCapsBtn) {
      subsCapsBtn.focus();
    } else if (ccBtn) {
      ccBtn.focus();
    }
  };
  return TextTrackSettings2;
}(ModalDialog);
Component$1.registerComponent("TextTrackSettings", TextTrackSettings);
var ResizeManager = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(ResizeManager2, _Component);
  function ResizeManager2(player, options) {
    var _this;
    var RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || import_window6.default.ResizeObserver;
    if (options.ResizeObserver === null) {
      RESIZE_OBSERVER_AVAILABLE = false;
    }
    var options_ = mergeOptions$3({
      createEl: !RESIZE_OBSERVER_AVAILABLE,
      reportTouchActivity: false
    }, options);
    _this = _Component.call(this, player, options_) || this;
    _this.ResizeObserver = options.ResizeObserver || import_window6.default.ResizeObserver;
    _this.loadListener_ = null;
    _this.resizeObserver_ = null;
    _this.debouncedHandler_ = debounce(function() {
      _this.resizeHandler();
    }, 100, false, _assertThisInitialized(_this));
    if (RESIZE_OBSERVER_AVAILABLE) {
      _this.resizeObserver_ = new _this.ResizeObserver(_this.debouncedHandler_);
      _this.resizeObserver_.observe(player.el());
    } else {
      _this.loadListener_ = function() {
        if (!_this.el_ || !_this.el_.contentWindow) {
          return;
        }
        var debouncedHandler_ = _this.debouncedHandler_;
        var unloadListener_ = _this.unloadListener_ = function() {
          off(this, "resize", debouncedHandler_);
          off(this, "unload", unloadListener_);
          unloadListener_ = null;
        };
        on(_this.el_.contentWindow, "unload", unloadListener_);
        on(_this.el_.contentWindow, "resize", debouncedHandler_);
      };
      _this.one("load", _this.loadListener_);
    }
    return _this;
  }
  var _proto = ResizeManager2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "iframe", {
      className: "vjs-resize-manager",
      tabIndex: -1,
      title: this.localize("No content")
    }, {
      "aria-hidden": "true"
    });
  };
  _proto.resizeHandler = function resizeHandler() {
    if (!this.player_ || !this.player_.trigger) {
      return;
    }
    this.player_.trigger("playerresize");
  };
  _proto.dispose = function dispose() {
    if (this.debouncedHandler_) {
      this.debouncedHandler_.cancel();
    }
    if (this.resizeObserver_) {
      if (this.player_.el()) {
        this.resizeObserver_.unobserve(this.player_.el());
      }
      this.resizeObserver_.disconnect();
    }
    if (this.loadListener_) {
      this.off("load", this.loadListener_);
    }
    if (this.el_ && this.el_.contentWindow && this.unloadListener_) {
      this.unloadListener_.call(this.el_.contentWindow);
    }
    this.ResizeObserver = null;
    this.resizeObserver = null;
    this.debouncedHandler_ = null;
    this.loadListener_ = null;
    _Component.prototype.dispose.call(this);
  };
  return ResizeManager2;
}(Component$1);
Component$1.registerComponent("ResizeManager", ResizeManager);
var defaults2 = {
  trackingThreshold: 20,
  liveTolerance: 15
};
var LiveTracker = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(LiveTracker2, _Component);
  function LiveTracker2(player, options) {
    var _this;
    var options_ = mergeOptions$3(defaults2, options, {
      createEl: false
    });
    _this = _Component.call(this, player, options_) || this;
    _this.handleVisibilityChange_ = function(e) {
      return _this.handleVisibilityChange(e);
    };
    _this.trackLiveHandler_ = function() {
      return _this.trackLive_();
    };
    _this.handlePlay_ = function(e) {
      return _this.handlePlay(e);
    };
    _this.handleFirstTimeupdate_ = function(e) {
      return _this.handleFirstTimeupdate(e);
    };
    _this.handleSeeked_ = function(e) {
      return _this.handleSeeked(e);
    };
    _this.seekToLiveEdge_ = function(e) {
      return _this.seekToLiveEdge(e);
    };
    _this.reset_();
    _this.on(_this.player_, "durationchange", function(e) {
      return _this.handleDurationchange(e);
    });
    _this.on(_this.player_, "canplay", function() {
      return _this.toggleTracking();
    });
    if (IE_VERSION && "hidden" in import_document.default && "visibilityState" in import_document.default) {
      _this.on(import_document.default, "visibilitychange", _this.handleVisibilityChange_);
    }
    return _this;
  }
  var _proto = LiveTracker2.prototype;
  _proto.handleVisibilityChange = function handleVisibilityChange() {
    if (this.player_.duration() !== Infinity) {
      return;
    }
    if (import_document.default.hidden) {
      this.stopTracking();
    } else {
      this.startTracking();
    }
  };
  _proto.trackLive_ = function trackLive_() {
    var seekable3 = this.player_.seekable();
    if (!seekable3 || !seekable3.length) {
      return;
    }
    var newTime = Number(import_window6.default.performance.now().toFixed(4));
    var deltaTime = this.lastTime_ === -1 ? 0 : (newTime - this.lastTime_) / 1e3;
    this.lastTime_ = newTime;
    this.pastSeekEnd_ = this.pastSeekEnd() + deltaTime;
    var liveCurrentTime = this.liveCurrentTime();
    var currentTime = this.player_.currentTime();
    var isBehind = this.player_.paused() || this.seekedBehindLive_ || Math.abs(liveCurrentTime - currentTime) > this.options_.liveTolerance;
    if (!this.timeupdateSeen_ || liveCurrentTime === Infinity) {
      isBehind = false;
    }
    if (isBehind !== this.behindLiveEdge_) {
      this.behindLiveEdge_ = isBehind;
      this.trigger("liveedgechange");
    }
  };
  _proto.handleDurationchange = function handleDurationchange() {
    this.toggleTracking();
  };
  _proto.toggleTracking = function toggleTracking() {
    if (this.player_.duration() === Infinity && this.liveWindow() >= this.options_.trackingThreshold) {
      if (this.player_.options_.liveui) {
        this.player_.addClass("vjs-liveui");
      }
      this.startTracking();
    } else {
      this.player_.removeClass("vjs-liveui");
      this.stopTracking();
    }
  };
  _proto.startTracking = function startTracking() {
    if (this.isTracking()) {
      return;
    }
    if (!this.timeupdateSeen_) {
      this.timeupdateSeen_ = this.player_.hasStarted();
    }
    this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, UPDATE_REFRESH_INTERVAL);
    this.trackLive_();
    this.on(this.player_, ["play", "pause"], this.trackLiveHandler_);
    if (!this.timeupdateSeen_) {
      this.one(this.player_, "play", this.handlePlay_);
      this.one(this.player_, "timeupdate", this.handleFirstTimeupdate_);
    } else {
      this.on(this.player_, "seeked", this.handleSeeked_);
    }
  };
  _proto.handleFirstTimeupdate = function handleFirstTimeupdate() {
    this.timeupdateSeen_ = true;
    this.on(this.player_, "seeked", this.handleSeeked_);
  };
  _proto.handleSeeked = function handleSeeked() {
    var timeDiff = Math.abs(this.liveCurrentTime() - this.player_.currentTime());
    this.seekedBehindLive_ = this.nextSeekedFromUser_ && timeDiff > 2;
    this.nextSeekedFromUser_ = false;
    this.trackLive_();
  };
  _proto.handlePlay = function handlePlay() {
    this.one(this.player_, "timeupdate", this.seekToLiveEdge_);
  };
  _proto.reset_ = function reset_() {
    this.lastTime_ = -1;
    this.pastSeekEnd_ = 0;
    this.lastSeekEnd_ = -1;
    this.behindLiveEdge_ = true;
    this.timeupdateSeen_ = false;
    this.seekedBehindLive_ = false;
    this.nextSeekedFromUser_ = false;
    this.clearInterval(this.trackingInterval_);
    this.trackingInterval_ = null;
    this.off(this.player_, ["play", "pause"], this.trackLiveHandler_);
    this.off(this.player_, "seeked", this.handleSeeked_);
    this.off(this.player_, "play", this.handlePlay_);
    this.off(this.player_, "timeupdate", this.handleFirstTimeupdate_);
    this.off(this.player_, "timeupdate", this.seekToLiveEdge_);
  };
  _proto.nextSeekedFromUser = function nextSeekedFromUser() {
    this.nextSeekedFromUser_ = true;
  };
  _proto.stopTracking = function stopTracking() {
    if (!this.isTracking()) {
      return;
    }
    this.reset_();
    this.trigger("liveedgechange");
  };
  _proto.seekableEnd = function seekableEnd() {
    var seekable3 = this.player_.seekable();
    var seekableEnds = [];
    var i = seekable3 ? seekable3.length : 0;
    while (i--) {
      seekableEnds.push(seekable3.end(i));
    }
    return seekableEnds.length ? seekableEnds.sort()[seekableEnds.length - 1] : Infinity;
  };
  _proto.seekableStart = function seekableStart() {
    var seekable3 = this.player_.seekable();
    var seekableStarts = [];
    var i = seekable3 ? seekable3.length : 0;
    while (i--) {
      seekableStarts.push(seekable3.start(i));
    }
    return seekableStarts.length ? seekableStarts.sort()[0] : 0;
  };
  _proto.liveWindow = function liveWindow() {
    var liveCurrentTime = this.liveCurrentTime();
    if (liveCurrentTime === Infinity) {
      return 0;
    }
    return liveCurrentTime - this.seekableStart();
  };
  _proto.isLive = function isLive() {
    return this.isTracking();
  };
  _proto.atLiveEdge = function atLiveEdge() {
    return !this.behindLiveEdge();
  };
  _proto.liveCurrentTime = function liveCurrentTime() {
    return this.pastSeekEnd() + this.seekableEnd();
  };
  _proto.pastSeekEnd = function pastSeekEnd() {
    var seekableEnd = this.seekableEnd();
    if (this.lastSeekEnd_ !== -1 && seekableEnd !== this.lastSeekEnd_) {
      this.pastSeekEnd_ = 0;
    }
    this.lastSeekEnd_ = seekableEnd;
    return this.pastSeekEnd_;
  };
  _proto.behindLiveEdge = function behindLiveEdge() {
    return this.behindLiveEdge_;
  };
  _proto.isTracking = function isTracking() {
    return typeof this.trackingInterval_ === "number";
  };
  _proto.seekToLiveEdge = function seekToLiveEdge() {
    this.seekedBehindLive_ = false;
    if (this.atLiveEdge()) {
      return;
    }
    this.nextSeekedFromUser_ = false;
    this.player_.currentTime(this.liveCurrentTime());
  };
  _proto.dispose = function dispose() {
    this.off(import_document.default, "visibilitychange", this.handleVisibilityChange_);
    this.stopTracking();
    _Component.prototype.dispose.call(this);
  };
  return LiveTracker2;
}(Component$1);
Component$1.registerComponent("LiveTracker", LiveTracker);
var sourcesetLoad = function sourcesetLoad2(tech) {
  var el = tech.el();
  if (el.hasAttribute("src")) {
    tech.triggerSourceset(el.src);
    return true;
  }
  var sources = tech.$$("source");
  var srcUrls = [];
  var src = "";
  if (!sources.length) {
    return false;
  }
  for (var i = 0; i < sources.length; i++) {
    var url = sources[i].src;
    if (url && srcUrls.indexOf(url) === -1) {
      srcUrls.push(url);
    }
  }
  if (!srcUrls.length) {
    return false;
  }
  if (srcUrls.length === 1) {
    src = srcUrls[0];
  }
  tech.triggerSourceset(src);
  return true;
};
var innerHTMLDescriptorPolyfill = Object.defineProperty({}, "innerHTML", {
  get: function get2() {
    return this.cloneNode(true).innerHTML;
  },
  set: function set2(v) {
    var dummy = import_document.default.createElement(this.nodeName.toLowerCase());
    dummy.innerHTML = v;
    var docFrag = import_document.default.createDocumentFragment();
    while (dummy.childNodes.length) {
      docFrag.appendChild(dummy.childNodes[0]);
    }
    this.innerText = "";
    import_window6.default.Element.prototype.appendChild.call(this, docFrag);
    return this.innerHTML;
  }
});
var getDescriptor = function getDescriptor2(priority, prop) {
  var descriptor = {};
  for (var i = 0; i < priority.length; i++) {
    descriptor = Object.getOwnPropertyDescriptor(priority[i], prop);
    if (descriptor && descriptor.set && descriptor.get) {
      break;
    }
  }
  descriptor.enumerable = true;
  descriptor.configurable = true;
  return descriptor;
};
var getInnerHTMLDescriptor = function getInnerHTMLDescriptor2(tech) {
  return getDescriptor([tech.el(), import_window6.default.HTMLMediaElement.prototype, import_window6.default.Element.prototype, innerHTMLDescriptorPolyfill], "innerHTML");
};
var firstSourceWatch = function firstSourceWatch2(tech) {
  var el = tech.el();
  if (el.resetSourceWatch_) {
    return;
  }
  var old = {};
  var innerDescriptor = getInnerHTMLDescriptor(tech);
  var appendWrapper = function appendWrapper2(appendFn) {
    return function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var retval = appendFn.apply(el, args);
      sourcesetLoad(tech);
      return retval;
    };
  };
  ["append", "appendChild", "insertAdjacentHTML"].forEach(function(k) {
    if (!el[k]) {
      return;
    }
    old[k] = el[k];
    el[k] = appendWrapper(old[k]);
  });
  Object.defineProperty(el, "innerHTML", mergeOptions$3(innerDescriptor, {
    set: appendWrapper(innerDescriptor.set)
  }));
  el.resetSourceWatch_ = function() {
    el.resetSourceWatch_ = null;
    Object.keys(old).forEach(function(k) {
      el[k] = old[k];
    });
    Object.defineProperty(el, "innerHTML", innerDescriptor);
  };
  tech.one("sourceset", el.resetSourceWatch_);
};
var srcDescriptorPolyfill = Object.defineProperty({}, "src", {
  get: function get3() {
    if (this.hasAttribute("src")) {
      return getAbsoluteURL(import_window6.default.Element.prototype.getAttribute.call(this, "src"));
    }
    return "";
  },
  set: function set3(v) {
    import_window6.default.Element.prototype.setAttribute.call(this, "src", v);
    return v;
  }
});
var getSrcDescriptor = function getSrcDescriptor2(tech) {
  return getDescriptor([tech.el(), import_window6.default.HTMLMediaElement.prototype, srcDescriptorPolyfill], "src");
};
var setupSourceset = function setupSourceset2(tech) {
  if (!tech.featuresSourceset) {
    return;
  }
  var el = tech.el();
  if (el.resetSourceset_) {
    return;
  }
  var srcDescriptor = getSrcDescriptor(tech);
  var oldSetAttribute = el.setAttribute;
  var oldLoad = el.load;
  Object.defineProperty(el, "src", mergeOptions$3(srcDescriptor, {
    set: function set4(v) {
      var retval = srcDescriptor.set.call(el, v);
      tech.triggerSourceset(el.src);
      return retval;
    }
  }));
  el.setAttribute = function(n, v) {
    var retval = oldSetAttribute.call(el, n, v);
    if (/src/i.test(n)) {
      tech.triggerSourceset(el.src);
    }
    return retval;
  };
  el.load = function() {
    var retval = oldLoad.call(el);
    if (!sourcesetLoad(tech)) {
      tech.triggerSourceset("");
      firstSourceWatch(tech);
    }
    return retval;
  };
  if (el.currentSrc) {
    tech.triggerSourceset(el.currentSrc);
  } else if (!sourcesetLoad(tech)) {
    firstSourceWatch(tech);
  }
  el.resetSourceset_ = function() {
    el.resetSourceset_ = null;
    el.load = oldLoad;
    el.setAttribute = oldSetAttribute;
    Object.defineProperty(el, "src", srcDescriptor);
    if (el.resetSourceWatch_) {
      el.resetSourceWatch_();
    }
  };
};
var defineLazyProperty = function defineLazyProperty2(obj, key, getValue, setter) {
  if (setter === void 0) {
    setter = true;
  }
  var set4 = function set5(value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      writable: true
    });
  };
  var options = {
    configurable: true,
    enumerable: true,
    get: function get7() {
      var value = getValue();
      set4(value);
      return value;
    }
  };
  if (setter) {
    options.set = set4;
  }
  return Object.defineProperty(obj, key, options);
};
var Html5 = /* @__PURE__ */ function(_Tech) {
  _inheritsLoose(Html52, _Tech);
  function Html52(options, ready) {
    var _this;
    _this = _Tech.call(this, options, ready) || this;
    var source = options.source;
    var crossoriginTracks = false;
    _this.featuresVideoFrameCallback = _this.featuresVideoFrameCallback && _this.el_.tagName === "VIDEO";
    if (source && (_this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {
      _this.setSource(source);
    } else {
      _this.handleLateInit_(_this.el_);
    }
    if (options.enableSourceset) {
      _this.setupSourcesetHandling_();
    }
    _this.isScrubbing_ = false;
    if (_this.el_.hasChildNodes()) {
      var nodes = _this.el_.childNodes;
      var nodesLength = nodes.length;
      var removeNodes = [];
      while (nodesLength--) {
        var node = nodes[nodesLength];
        var nodeName = node.nodeName.toLowerCase();
        if (nodeName === "track") {
          if (!_this.featuresNativeTextTracks) {
            removeNodes.push(node);
          } else {
            _this.remoteTextTrackEls().addTrackElement_(node);
            _this.remoteTextTracks().addTrack(node.track);
            _this.textTracks().addTrack(node.track);
            if (!crossoriginTracks && !_this.el_.hasAttribute("crossorigin") && isCrossOrigin(node.src)) {
              crossoriginTracks = true;
            }
          }
        }
      }
      for (var i = 0; i < removeNodes.length; i++) {
        _this.el_.removeChild(removeNodes[i]);
      }
    }
    _this.proxyNativeTracks_();
    if (_this.featuresNativeTextTracks && crossoriginTracks) {
      log$1.warn("Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.\nThis may prevent text tracks from loading.");
    }
    _this.restoreMetadataTracksInIOSNativePlayer_();
    if ((TOUCH_ENABLED || IS_IPHONE || IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {
      _this.setControls(true);
    }
    _this.proxyWebkitFullscreen_();
    _this.triggerReady();
    return _this;
  }
  var _proto = Html52.prototype;
  _proto.dispose = function dispose() {
    if (this.el_ && this.el_.resetSourceset_) {
      this.el_.resetSourceset_();
    }
    Html52.disposeMediaElement(this.el_);
    this.options_ = null;
    _Tech.prototype.dispose.call(this);
  };
  _proto.setupSourcesetHandling_ = function setupSourcesetHandling_() {
    setupSourceset(this);
  };
  _proto.restoreMetadataTracksInIOSNativePlayer_ = function restoreMetadataTracksInIOSNativePlayer_() {
    var textTracks = this.textTracks();
    var metadataTracksPreFullscreenState;
    var takeMetadataTrackSnapshot = function takeMetadataTrackSnapshot2() {
      metadataTracksPreFullscreenState = [];
      for (var i = 0; i < textTracks.length; i++) {
        var track = textTracks[i];
        if (track.kind === "metadata") {
          metadataTracksPreFullscreenState.push({
            track,
            storedMode: track.mode
          });
        }
      }
    };
    takeMetadataTrackSnapshot();
    textTracks.addEventListener("change", takeMetadataTrackSnapshot);
    this.on("dispose", function() {
      return textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
    });
    var restoreTrackMode = function restoreTrackMode2() {
      for (var i = 0; i < metadataTracksPreFullscreenState.length; i++) {
        var storedTrack = metadataTracksPreFullscreenState[i];
        if (storedTrack.track.mode === "disabled" && storedTrack.track.mode !== storedTrack.storedMode) {
          storedTrack.track.mode = storedTrack.storedMode;
        }
      }
      textTracks.removeEventListener("change", restoreTrackMode2);
    };
    this.on("webkitbeginfullscreen", function() {
      textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
      textTracks.removeEventListener("change", restoreTrackMode);
      textTracks.addEventListener("change", restoreTrackMode);
    });
    this.on("webkitendfullscreen", function() {
      textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
      textTracks.addEventListener("change", takeMetadataTrackSnapshot);
      textTracks.removeEventListener("change", restoreTrackMode);
    });
  };
  _proto.overrideNative_ = function overrideNative_(type2, override) {
    var _this2 = this;
    if (override !== this["featuresNative" + type2 + "Tracks"]) {
      return;
    }
    var lowerCaseType = type2.toLowerCase();
    if (this[lowerCaseType + "TracksListeners_"]) {
      Object.keys(this[lowerCaseType + "TracksListeners_"]).forEach(function(eventName) {
        var elTracks = _this2.el()[lowerCaseType + "Tracks"];
        elTracks.removeEventListener(eventName, _this2[lowerCaseType + "TracksListeners_"][eventName]);
      });
    }
    this["featuresNative" + type2 + "Tracks"] = !override;
    this[lowerCaseType + "TracksListeners_"] = null;
    this.proxyNativeTracksForType_(lowerCaseType);
  };
  _proto.overrideNativeAudioTracks = function overrideNativeAudioTracks(override) {
    this.overrideNative_("Audio", override);
  };
  _proto.overrideNativeVideoTracks = function overrideNativeVideoTracks(override) {
    this.overrideNative_("Video", override);
  };
  _proto.proxyNativeTracksForType_ = function proxyNativeTracksForType_(name) {
    var _this3 = this;
    var props = NORMAL[name];
    var elTracks = this.el()[props.getterName];
    var techTracks = this[props.getterName]();
    if (!this["featuresNative" + props.capitalName + "Tracks"] || !elTracks || !elTracks.addEventListener) {
      return;
    }
    var listeners = {
      change: function change(e) {
        var event = {
          type: "change",
          target: techTracks,
          currentTarget: techTracks,
          srcElement: techTracks
        };
        techTracks.trigger(event);
        if (name === "text") {
          _this3[REMOTE.remoteText.getterName]().trigger(event);
        }
      },
      addtrack: function addtrack(e) {
        techTracks.addTrack(e.track);
      },
      removetrack: function removetrack(e) {
        techTracks.removeTrack(e.track);
      }
    };
    var removeOldTracks = function removeOldTracks2() {
      var removeTracks = [];
      for (var i = 0; i < techTracks.length; i++) {
        var found = false;
        for (var j = 0; j < elTracks.length; j++) {
          if (elTracks[j] === techTracks[i]) {
            found = true;
            break;
          }
        }
        if (!found) {
          removeTracks.push(techTracks[i]);
        }
      }
      while (removeTracks.length) {
        techTracks.removeTrack(removeTracks.shift());
      }
    };
    this[props.getterName + "Listeners_"] = listeners;
    Object.keys(listeners).forEach(function(eventName) {
      var listener = listeners[eventName];
      elTracks.addEventListener(eventName, listener);
      _this3.on("dispose", function(e) {
        return elTracks.removeEventListener(eventName, listener);
      });
    });
    this.on("loadstart", removeOldTracks);
    this.on("dispose", function(e) {
      return _this3.off("loadstart", removeOldTracks);
    });
  };
  _proto.proxyNativeTracks_ = function proxyNativeTracks_() {
    var _this4 = this;
    NORMAL.names.forEach(function(name) {
      _this4.proxyNativeTracksForType_(name);
    });
  };
  _proto.createEl = function createEl2() {
    var el = this.options_.tag;
    if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {
      if (el) {
        var clone = el.cloneNode(true);
        if (el.parentNode) {
          el.parentNode.insertBefore(clone, el);
        }
        Html52.disposeMediaElement(el);
        el = clone;
      } else {
        el = import_document.default.createElement("video");
        var tagAttributes = this.options_.tag && getAttributes(this.options_.tag);
        var attributes = mergeOptions$3({}, tagAttributes);
        if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {
          delete attributes.controls;
        }
        setAttributes(el, assign(attributes, {
          id: this.options_.techId,
          "class": "vjs-tech"
        }));
      }
      el.playerId = this.options_.playerId;
    }
    if (typeof this.options_.preload !== "undefined") {
      setAttribute(el, "preload", this.options_.preload);
    }
    if (this.options_.disablePictureInPicture !== void 0) {
      el.disablePictureInPicture = this.options_.disablePictureInPicture;
    }
    var settingsAttrs = ["loop", "muted", "playsinline", "autoplay"];
    for (var i = 0; i < settingsAttrs.length; i++) {
      var attr = settingsAttrs[i];
      var value = this.options_[attr];
      if (typeof value !== "undefined") {
        if (value) {
          setAttribute(el, attr, attr);
        } else {
          removeAttribute(el, attr);
        }
        el[attr] = value;
      }
    }
    return el;
  };
  _proto.handleLateInit_ = function handleLateInit_(el) {
    if (el.networkState === 0 || el.networkState === 3) {
      return;
    }
    if (el.readyState === 0) {
      var loadstartFired = false;
      var setLoadstartFired = function setLoadstartFired2() {
        loadstartFired = true;
      };
      this.on("loadstart", setLoadstartFired);
      var triggerLoadstart = function triggerLoadstart2() {
        if (!loadstartFired) {
          this.trigger("loadstart");
        }
      };
      this.on("loadedmetadata", triggerLoadstart);
      this.ready(function() {
        this.off("loadstart", setLoadstartFired);
        this.off("loadedmetadata", triggerLoadstart);
        if (!loadstartFired) {
          this.trigger("loadstart");
        }
      });
      return;
    }
    var eventsToTrigger = ["loadstart"];
    eventsToTrigger.push("loadedmetadata");
    if (el.readyState >= 2) {
      eventsToTrigger.push("loadeddata");
    }
    if (el.readyState >= 3) {
      eventsToTrigger.push("canplay");
    }
    if (el.readyState >= 4) {
      eventsToTrigger.push("canplaythrough");
    }
    this.ready(function() {
      eventsToTrigger.forEach(function(type2) {
        this.trigger(type2);
      }, this);
    });
  };
  _proto.setScrubbing = function setScrubbing(isScrubbing) {
    this.isScrubbing_ = isScrubbing;
  };
  _proto.scrubbing = function scrubbing() {
    return this.isScrubbing_;
  };
  _proto.setCurrentTime = function setCurrentTime(seconds) {
    try {
      if (this.isScrubbing_ && this.el_.fastSeek && IS_ANY_SAFARI) {
        this.el_.fastSeek(seconds);
      } else {
        this.el_.currentTime = seconds;
      }
    } catch (e) {
      log$1(e, "Video is not ready. (Video.js)");
    }
  };
  _proto.duration = function duration5() {
    var _this5 = this;
    if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {
      var checkProgress = function checkProgress2() {
        if (_this5.el_.currentTime > 0) {
          if (_this5.el_.duration === Infinity) {
            _this5.trigger("durationchange");
          }
          _this5.off("timeupdate", checkProgress2);
        }
      };
      this.on("timeupdate", checkProgress);
      return NaN;
    }
    return this.el_.duration || NaN;
  };
  _proto.width = function width2() {
    return this.el_.offsetWidth;
  };
  _proto.height = function height2() {
    return this.el_.offsetHeight;
  };
  _proto.proxyWebkitFullscreen_ = function proxyWebkitFullscreen_() {
    var _this6 = this;
    if (!("webkitDisplayingFullscreen" in this.el_)) {
      return;
    }
    var endFn = function endFn2() {
      this.trigger("fullscreenchange", {
        isFullscreen: false
      });
      if (this.el_.controls && !this.options_.nativeControlsForTouch && this.controls()) {
        this.el_.controls = false;
      }
    };
    var beginFn = function beginFn2() {
      if ("webkitPresentationMode" in this.el_ && this.el_.webkitPresentationMode !== "picture-in-picture") {
        this.one("webkitendfullscreen", endFn);
        this.trigger("fullscreenchange", {
          isFullscreen: true,
          // set a flag in case another tech triggers fullscreenchange
          nativeIOSFullscreen: true
        });
      }
    };
    this.on("webkitbeginfullscreen", beginFn);
    this.on("dispose", function() {
      _this6.off("webkitbeginfullscreen", beginFn);
      _this6.off("webkitendfullscreen", endFn);
    });
  };
  _proto.supportsFullScreen = function supportsFullScreen() {
    if (typeof this.el_.webkitEnterFullScreen === "function") {
      var userAgent = import_window6.default.navigator && import_window6.default.navigator.userAgent || "";
      if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {
        return true;
      }
    }
    return false;
  };
  _proto.enterFullScreen = function enterFullScreen() {
    var video = this.el_;
    if (video.paused && video.networkState <= video.HAVE_METADATA) {
      silencePromise(this.el_.play());
      this.setTimeout(function() {
        video.pause();
        try {
          video.webkitEnterFullScreen();
        } catch (e) {
          this.trigger("fullscreenerror", e);
        }
      }, 0);
    } else {
      try {
        video.webkitEnterFullScreen();
      } catch (e) {
        this.trigger("fullscreenerror", e);
      }
    }
  };
  _proto.exitFullScreen = function exitFullScreen() {
    if (!this.el_.webkitDisplayingFullscreen) {
      this.trigger("fullscreenerror", new Error("The video is not fullscreen"));
      return;
    }
    this.el_.webkitExitFullScreen();
  };
  _proto.requestPictureInPicture = function requestPictureInPicture() {
    return this.el_.requestPictureInPicture();
  };
  _proto.requestVideoFrameCallback = function requestVideoFrameCallback(cb) {
    if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {
      return this.el_.requestVideoFrameCallback(cb);
    }
    return _Tech.prototype.requestVideoFrameCallback.call(this, cb);
  };
  _proto.cancelVideoFrameCallback = function cancelVideoFrameCallback(id) {
    if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {
      this.el_.cancelVideoFrameCallback(id);
    } else {
      _Tech.prototype.cancelVideoFrameCallback.call(this, id);
    }
  };
  _proto.src = function src(_src) {
    if (_src === void 0) {
      return this.el_.src;
    }
    this.setSrc(_src);
  };
  _proto.reset = function reset3() {
    Html52.resetMediaElement(this.el_);
  };
  _proto.currentSrc = function currentSrc() {
    if (this.currentSource_) {
      return this.currentSource_.src;
    }
    return this.el_.currentSrc;
  };
  _proto.setControls = function setControls(val) {
    this.el_.controls = !!val;
  };
  _proto.addTextTrack = function addTextTrack(kind, label, language) {
    if (!this.featuresNativeTextTracks) {
      return _Tech.prototype.addTextTrack.call(this, kind, label, language);
    }
    return this.el_.addTextTrack(kind, label, language);
  };
  _proto.createRemoteTextTrack = function createRemoteTextTrack(options) {
    if (!this.featuresNativeTextTracks) {
      return _Tech.prototype.createRemoteTextTrack.call(this, options);
    }
    var htmlTrackElement = import_document.default.createElement("track");
    if (options.kind) {
      htmlTrackElement.kind = options.kind;
    }
    if (options.label) {
      htmlTrackElement.label = options.label;
    }
    if (options.language || options.srclang) {
      htmlTrackElement.srclang = options.language || options.srclang;
    }
    if (options["default"]) {
      htmlTrackElement["default"] = options["default"];
    }
    if (options.id) {
      htmlTrackElement.id = options.id;
    }
    if (options.src) {
      htmlTrackElement.src = options.src;
    }
    return htmlTrackElement;
  };
  _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    var htmlTrackElement = _Tech.prototype.addRemoteTextTrack.call(this, options, manualCleanup);
    if (this.featuresNativeTextTracks) {
      this.el().appendChild(htmlTrackElement);
    }
    return htmlTrackElement;
  };
  _proto.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
    _Tech.prototype.removeRemoteTextTrack.call(this, track);
    if (this.featuresNativeTextTracks) {
      var tracks = this.$$("track");
      var i = tracks.length;
      while (i--) {
        if (track === tracks[i] || track === tracks[i].track) {
          this.el().removeChild(tracks[i]);
        }
      }
    }
  };
  _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    if (typeof this.el().getVideoPlaybackQuality === "function") {
      return this.el().getVideoPlaybackQuality();
    }
    var videoPlaybackQuality = {};
    if (typeof this.el().webkitDroppedFrameCount !== "undefined" && typeof this.el().webkitDecodedFrameCount !== "undefined") {
      videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;
      videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;
    }
    if (import_window6.default.performance && typeof import_window6.default.performance.now === "function") {
      videoPlaybackQuality.creationTime = import_window6.default.performance.now();
    } else if (import_window6.default.performance && import_window6.default.performance.timing && typeof import_window6.default.performance.timing.navigationStart === "number") {
      videoPlaybackQuality.creationTime = import_window6.default.Date.now() - import_window6.default.performance.timing.navigationStart;
    }
    return videoPlaybackQuality;
  };
  return Html52;
}(Tech);
defineLazyProperty(Html5, "TEST_VID", function() {
  if (!isReal()) {
    return;
  }
  var video = import_document.default.createElement("video");
  var track = import_document.default.createElement("track");
  track.kind = "captions";
  track.srclang = "en";
  track.label = "English";
  video.appendChild(track);
  return video;
});
Html5.isSupported = function() {
  try {
    Html5.TEST_VID.volume = 0.5;
  } catch (e) {
    return false;
  }
  return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);
};
Html5.canPlayType = function(type2) {
  return Html5.TEST_VID.canPlayType(type2);
};
Html5.canPlaySource = function(srcObj, options) {
  return Html5.canPlayType(srcObj.type);
};
Html5.canControlVolume = function() {
  try {
    var volume = Html5.TEST_VID.volume;
    Html5.TEST_VID.volume = volume / 2 + 0.1;
    var canControl = volume !== Html5.TEST_VID.volume;
    if (canControl && IS_IOS) {
      import_window6.default.setTimeout(function() {
        if (Html5 && Html5.prototype) {
          Html5.prototype.featuresVolumeControl = volume !== Html5.TEST_VID.volume;
        }
      });
      return false;
    }
    return canControl;
  } catch (e) {
    return false;
  }
};
Html5.canMuteVolume = function() {
  try {
    var muted = Html5.TEST_VID.muted;
    Html5.TEST_VID.muted = !muted;
    if (Html5.TEST_VID.muted) {
      setAttribute(Html5.TEST_VID, "muted", "muted");
    } else {
      removeAttribute(Html5.TEST_VID, "muted", "muted");
    }
    return muted !== Html5.TEST_VID.muted;
  } catch (e) {
    return false;
  }
};
Html5.canControlPlaybackRate = function() {
  if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {
    return false;
  }
  try {
    var playbackRate = Html5.TEST_VID.playbackRate;
    Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
    return playbackRate !== Html5.TEST_VID.playbackRate;
  } catch (e) {
    return false;
  }
};
Html5.canOverrideAttributes = function() {
  try {
    var noop4 = function noop5() {
    };
    Object.defineProperty(import_document.default.createElement("video"), "src", {
      get: noop4,
      set: noop4
    });
    Object.defineProperty(import_document.default.createElement("audio"), "src", {
      get: noop4,
      set: noop4
    });
    Object.defineProperty(import_document.default.createElement("video"), "innerHTML", {
      get: noop4,
      set: noop4
    });
    Object.defineProperty(import_document.default.createElement("audio"), "innerHTML", {
      get: noop4,
      set: noop4
    });
  } catch (e) {
    return false;
  }
  return true;
};
Html5.supportsNativeTextTracks = function() {
  return IS_ANY_SAFARI || IS_IOS && IS_CHROME;
};
Html5.supportsNativeVideoTracks = function() {
  return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);
};
Html5.supportsNativeAudioTracks = function() {
  return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);
};
Html5.Events = ["loadstart", "suspend", "abort", "error", "emptied", "stalled", "loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "seeking", "seeked", "ended", "durationchange", "timeupdate", "progress", "play", "pause", "ratechange", "resize", "volumechange"];
[["featuresMuteControl", "canMuteVolume"], ["featuresPlaybackRate", "canControlPlaybackRate"], ["featuresSourceset", "canOverrideAttributes"], ["featuresNativeTextTracks", "supportsNativeTextTracks"], ["featuresNativeVideoTracks", "supportsNativeVideoTracks"], ["featuresNativeAudioTracks", "supportsNativeAudioTracks"]].forEach(function(_ref) {
  var key = _ref[0], fn = _ref[1];
  defineLazyProperty(Html5.prototype, key, function() {
    return Html5[fn]();
  }, true);
});
Html5.prototype.featuresVolumeControl = Html5.canControlVolume();
Html5.prototype.movingMediaElementInDOM = !IS_IOS;
Html5.prototype.featuresFullscreenResize = true;
Html5.prototype.featuresProgressEvents = true;
Html5.prototype.featuresTimeupdateEvents = true;
Html5.prototype.featuresVideoFrameCallback = !!(Html5.TEST_VID && Html5.TEST_VID.requestVideoFrameCallback);
var canPlayType;
Html5.patchCanPlayType = function() {
  if (ANDROID_VERSION >= 4 && !IS_FIREFOX && !IS_CHROME) {
    canPlayType = Html5.TEST_VID && Html5.TEST_VID.constructor.prototype.canPlayType;
    Html5.TEST_VID.constructor.prototype.canPlayType = function(type2) {
      var mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
      if (type2 && mpegurlRE.test(type2)) {
        return "maybe";
      }
      return canPlayType.call(this, type2);
    };
  }
};
Html5.unpatchCanPlayType = function() {
  var r2 = Html5.TEST_VID.constructor.prototype.canPlayType;
  if (canPlayType) {
    Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;
  }
  return r2;
};
Html5.patchCanPlayType();
Html5.disposeMediaElement = function(el) {
  if (!el) {
    return;
  }
  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
  while (el.hasChildNodes()) {
    el.removeChild(el.firstChild);
  }
  el.removeAttribute("src");
  if (typeof el.load === "function") {
    (function() {
      try {
        el.load();
      } catch (e) {
      }
    })();
  }
};
Html5.resetMediaElement = function(el) {
  if (!el) {
    return;
  }
  var sources = el.querySelectorAll("source");
  var i = sources.length;
  while (i--) {
    el.removeChild(sources[i]);
  }
  el.removeAttribute("src");
  if (typeof el.load === "function") {
    (function() {
      try {
        el.load();
      } catch (e) {
      }
    })();
  }
};
[
  /**
   * Get the value of `muted` from the media element. `muted` indicates
   * that the volume for the media should be set to silent. This does not actually change
   * the `volume` attribute.
   *
   * @method Html5#muted
   * @return {boolean}
   *         - True if the value of `volume` should be ignored and the audio set to silent.
   *         - False if the value of `volume` should be used.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
   */
  "muted",
  /**
   * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates
   * whether the media should start muted or not. Only changes the default state of the
   * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the
   * current state.
   *
   * @method Html5#defaultMuted
   * @return {boolean}
   *         - The value of `defaultMuted` from the media element.
   *         - True indicates that the media should start muted.
   *         - False indicates that the media should not start muted
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
   */
  "defaultMuted",
  /**
   * Get the value of `autoplay` from the media element. `autoplay` indicates
   * that the media should start to play as soon as the page is ready.
   *
   * @method Html5#autoplay
   * @return {boolean}
   *         - The value of `autoplay` from the media element.
   *         - True indicates that the media should start as soon as the page loads.
   *         - False indicates that the media should not start as soon as the page loads.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
   */
  "autoplay",
  /**
   * Get the value of `controls` from the media element. `controls` indicates
   * whether the native media controls should be shown or hidden.
   *
   * @method Html5#controls
   * @return {boolean}
   *         - The value of `controls` from the media element.
   *         - True indicates that native controls should be showing.
   *         - False indicates that native controls should be hidden.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}
   */
  "controls",
  /**
   * Get the value of `loop` from the media element. `loop` indicates
   * that the media should return to the start of the media and continue playing once
   * it reaches the end.
   *
   * @method Html5#loop
   * @return {boolean}
   *         - The value of `loop` from the media element.
   *         - True indicates that playback should seek back to start once
   *           the end of a media is reached.
   *         - False indicates that playback should not loop back to the start when the
   *           end of the media is reached.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
   */
  "loop",
  /**
   * Get the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#playsinline
   * @return {boolean}
   *         - The value of `playsinline` from the media element.
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  "playsinline"
].forEach(function(prop) {
  Html5.prototype[prop] = function() {
    return this.el_[prop] || this.el_.hasAttribute(prop);
  };
});
[
  /**
   * Set the value of `muted` on the media element. `muted` indicates that the current
   * audio level should be silent.
   *
   * @method Html5#setMuted
   * @param {boolean} muted
   *        - True if the audio should be set to silent
   *        - False otherwise
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
   */
  "muted",
  /**
   * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current
   * audio level should be silent, but will only effect the muted level on initial playback..
   *
   * @method Html5.prototype.setDefaultMuted
   * @param {boolean} defaultMuted
   *        - True if the audio should be set to silent
   *        - False otherwise
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
   */
  "defaultMuted",
  /**
   * Set the value of `autoplay` on the media element. `autoplay` indicates
   * that the media should start to play as soon as the page is ready.
   *
   * @method Html5#setAutoplay
   * @param {boolean} autoplay
   *         - True indicates that the media should start as soon as the page loads.
   *         - False indicates that the media should not start as soon as the page loads.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
   */
  "autoplay",
  /**
   * Set the value of `loop` on the media element. `loop` indicates
   * that the media should return to the start of the media and continue playing once
   * it reaches the end.
   *
   * @method Html5#setLoop
   * @param {boolean} loop
   *         - True indicates that playback should seek back to start once
   *           the end of a media is reached.
   *         - False indicates that playback should not loop back to the start when the
   *           end of the media is reached.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
   */
  "loop",
  /**
   * Set the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#setPlaysinline
   * @param {boolean} playsinline
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  "playsinline"
].forEach(function(prop) {
  Html5.prototype["set" + toTitleCase$1(prop)] = function(v) {
    this.el_[prop] = v;
    if (v) {
      this.el_.setAttribute(prop, prop);
    } else {
      this.el_.removeAttribute(prop);
    }
  };
});
[
  /**
   * Get the value of `paused` from the media element. `paused` indicates whether the media element
   * is currently paused or not.
   *
   * @method Html5#paused
   * @return {boolean}
   *         The value of `paused` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}
   */
  "paused",
  /**
   * Get the value of `currentTime` from the media element. `currentTime` indicates
   * the current second that the media is at in playback.
   *
   * @method Html5#currentTime
   * @return {number}
   *         The value of `currentTime` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}
   */
  "currentTime",
  /**
   * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`
   * object that represents the parts of the media that are already downloaded and
   * available for playback.
   *
   * @method Html5#buffered
   * @return {TimeRange}
   *         The value of `buffered` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}
   */
  "buffered",
  /**
   * Get the value of `volume` from the media element. `volume` indicates
   * the current playback volume of audio for a media. `volume` will be a value from 0
   * (silent) to 1 (loudest and default).
   *
   * @method Html5#volume
   * @return {number}
   *         The value of `volume` from the media element. Value will be between 0-1.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
   */
  "volume",
  /**
   * Get the value of `poster` from the media element. `poster` indicates
   * that the url of an image file that can/will be shown when no media data is available.
   *
   * @method Html5#poster
   * @return {string}
   *         The value of `poster` from the media element. Value will be a url to an
   *         image.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}
   */
  "poster",
  /**
   * Get the value of `preload` from the media element. `preload` indicates
   * what should download before the media is interacted with. It can have the following
   * values:
   * - none: nothing should be downloaded
   * - metadata: poster and the first few frames of the media may be downloaded to get
   *   media dimensions and other metadata
   * - auto: allow the media and metadata for the media to be downloaded before
   *    interaction
   *
   * @method Html5#preload
   * @return {string}
   *         The value of `preload` from the media element. Will be 'none', 'metadata',
   *         or 'auto'.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
   */
  "preload",
  /**
   * Get the value of the `error` from the media element. `error` indicates any
   * MediaError that may have occurred during playback. If error returns null there is no
   * current error.
   *
   * @method Html5#error
   * @return {MediaError|null}
   *         The value of `error` from the media element. Will be `MediaError` if there
   *         is a current error and null otherwise.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}
   */
  "error",
  /**
   * Get the value of `seeking` from the media element. `seeking` indicates whether the
   * media is currently seeking to a new position or not.
   *
   * @method Html5#seeking
   * @return {boolean}
   *         - The value of `seeking` from the media element.
   *         - True indicates that the media is currently seeking to a new position.
   *         - False indicates that the media is not seeking to a new position at this time.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}
   */
  "seeking",
  /**
   * Get the value of `seekable` from the media element. `seekable` returns a
   * `TimeRange` object indicating ranges of time that can currently be `seeked` to.
   *
   * @method Html5#seekable
   * @return {TimeRange}
   *         The value of `seekable` from the media element. A `TimeRange` object
   *         indicating the current ranges of time that can be seeked to.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}
   */
  "seekable",
  /**
   * Get the value of `ended` from the media element. `ended` indicates whether
   * the media has reached the end or not.
   *
   * @method Html5#ended
   * @return {boolean}
   *         - The value of `ended` from the media element.
   *         - True indicates that the media has ended.
   *         - False indicates that the media has not ended.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}
   */
  "ended",
  /**
   * Get the value of `playbackRate` from the media element. `playbackRate` indicates
   * the rate at which the media is currently playing back. Examples:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5#playbackRate
   * @return {number}
   *         The value of `playbackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "playbackRate",
  /**
   * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates
   * the rate at which the media is currently playing back. This value will not indicate the current
   * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.
   *
   * Examples:
   *   - if defaultPlaybackRate is set to 2, media will play twice as fast.
   *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5.prototype.defaultPlaybackRate
   * @return {number}
   *         The value of `defaultPlaybackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "defaultPlaybackRate",
  /**
   * Get the value of 'disablePictureInPicture' from the video element.
   *
   * @method Html5#disablePictureInPicture
   * @return {boolean} value
   *         - The value of `disablePictureInPicture` from the video element.
   *         - True indicates that the video can't be played in Picture-In-Picture mode
   *         - False indicates that the video can be played in Picture-In-Picture mode
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
   */
  "disablePictureInPicture",
  /**
   * Get the value of `played` from the media element. `played` returns a `TimeRange`
   * object representing points in the media timeline that have been played.
   *
   * @method Html5#played
   * @return {TimeRange}
   *         The value of `played` from the media element. A `TimeRange` object indicating
   *         the ranges of time that have been played.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}
   */
  "played",
  /**
   * Get the value of `networkState` from the media element. `networkState` indicates
   * the current network state. It returns an enumeration from the following list:
   * - 0: NETWORK_EMPTY
   * - 1: NETWORK_IDLE
   * - 2: NETWORK_LOADING
   * - 3: NETWORK_NO_SOURCE
   *
   * @method Html5#networkState
   * @return {number}
   *         The value of `networkState` from the media element. This will be a number
   *         from the list in the description.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}
   */
  "networkState",
  /**
   * Get the value of `readyState` from the media element. `readyState` indicates
   * the current state of the media element. It returns an enumeration from the
   * following list:
   * - 0: HAVE_NOTHING
   * - 1: HAVE_METADATA
   * - 2: HAVE_CURRENT_DATA
   * - 3: HAVE_FUTURE_DATA
   * - 4: HAVE_ENOUGH_DATA
   *
   * @method Html5#readyState
   * @return {number}
   *         The value of `readyState` from the media element. This will be a number
   *         from the list in the description.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}
   */
  "readyState",
  /**
   * Get the value of `videoWidth` from the video element. `videoWidth` indicates
   * the current width of the video in css pixels.
   *
   * @method Html5#videoWidth
   * @return {number}
   *         The value of `videoWidth` from the video element. This will be a number
   *         in css pixels.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
   */
  "videoWidth",
  /**
   * Get the value of `videoHeight` from the video element. `videoHeight` indicates
   * the current height of the video in css pixels.
   *
   * @method Html5#videoHeight
   * @return {number}
   *         The value of `videoHeight` from the video element. This will be a number
   *         in css pixels.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
   */
  "videoHeight",
  /**
   * Get the value of `crossOrigin` from the media element. `crossOrigin` indicates
   * to the browser that should sent the cookies along with the requests for the
   * different assets/playlists
   *
   * @method Html5#crossOrigin
   * @return {string}
   *         - anonymous indicates that the media should not sent cookies.
   *         - use-credentials indicates that the media should sent cookies along the requests.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
   */
  "crossOrigin"
].forEach(function(prop) {
  Html5.prototype[prop] = function() {
    return this.el_[prop];
  };
});
[
  /**
   * Set the value of `volume` on the media element. `volume` indicates the current
   * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and
   * so on.
   *
   * @method Html5#setVolume
   * @param {number} percentAsDecimal
   *        The volume percent as a decimal. Valid range is from 0-1.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
   */
  "volume",
  /**
   * Set the value of `src` on the media element. `src` indicates the current
   * {@link Tech~SourceObject} for the media.
   *
   * @method Html5#setSrc
   * @param {Tech~SourceObject} src
   *        The source object to set as the current source.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}
   */
  "src",
  /**
   * Set the value of `poster` on the media element. `poster` is the url to
   * an image file that can/will be shown when no media data is available.
   *
   * @method Html5#setPoster
   * @param {string} poster
   *        The url to an image that should be used as the `poster` for the media
   *        element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}
   */
  "poster",
  /**
   * Set the value of `preload` on the media element. `preload` indicates
   * what should download before the media is interacted with. It can have the following
   * values:
   * - none: nothing should be downloaded
   * - metadata: poster and the first few frames of the media may be downloaded to get
   *   media dimensions and other metadata
   * - auto: allow the media and metadata for the media to be downloaded before
   *    interaction
   *
   * @method Html5#setPreload
   * @param {string} preload
   *         The value of `preload` to set on the media element. Must be 'none', 'metadata',
   *         or 'auto'.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
   */
  "preload",
  /**
   * Set the value of `playbackRate` on the media element. `playbackRate` indicates
   * the rate at which the media should play back. Examples:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5#setPlaybackRate
   * @return {number}
   *         The value of `playbackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "playbackRate",
  /**
   * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates
   * the rate at which the media should play back upon initial startup. Changing this value
   * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.
   *
   * Example Values:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5.prototype.setDefaultPlaybackRate
   * @return {number}
   *         The value of `defaultPlaybackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}
   */
  "defaultPlaybackRate",
  /**
   * Prevents the browser from suggesting a Picture-in-Picture context menu
   * or to request Picture-in-Picture automatically in some cases.
   *
   * @method Html5#setDisablePictureInPicture
   * @param {boolean} value
   *         The true value will disable Picture-in-Picture mode.
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
   */
  "disablePictureInPicture",
  /**
   * Set the value of `crossOrigin` from the media element. `crossOrigin` indicates
   * to the browser that should sent the cookies along with the requests for the
   * different assets/playlists
   *
   * @method Html5#setCrossOrigin
   * @param {string} crossOrigin
   *         - anonymous indicates that the media should not sent cookies.
   *         - use-credentials indicates that the media should sent cookies along the requests.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
   */
  "crossOrigin"
].forEach(function(prop) {
  Html5.prototype["set" + toTitleCase$1(prop)] = function(v) {
    this.el_[prop] = v;
  };
});
[
  /**
   * A wrapper around the media elements `pause` function. This will call the `HTML5`
   * media elements `pause` function.
   *
   * @method Html5#pause
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}
   */
  "pause",
  /**
   * A wrapper around the media elements `load` function. This will call the `HTML5`s
   * media element `load` function.
   *
   * @method Html5#load
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}
   */
  "load",
  /**
   * A wrapper around the media elements `play` function. This will call the `HTML5`s
   * media element `play` function.
   *
   * @method Html5#play
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}
   */
  "play"
].forEach(function(prop) {
  Html5.prototype[prop] = function() {
    return this.el_[prop]();
  };
});
Tech.withSourceHandlers(Html5);
Html5.nativeSourceHandler = {};
Html5.nativeSourceHandler.canPlayType = function(type2) {
  try {
    return Html5.TEST_VID.canPlayType(type2);
  } catch (e) {
    return "";
  }
};
Html5.nativeSourceHandler.canHandleSource = function(source, options) {
  if (source.type) {
    return Html5.nativeSourceHandler.canPlayType(source.type);
  } else if (source.src) {
    var ext = getFileExtension(source.src);
    return Html5.nativeSourceHandler.canPlayType("video/" + ext);
  }
  return "";
};
Html5.nativeSourceHandler.handleSource = function(source, tech, options) {
  tech.setSrc(source.src);
};
Html5.nativeSourceHandler.dispose = function() {
};
Html5.registerSourceHandler(Html5.nativeSourceHandler);
Tech.registerTech("Html5", Html5);
var TECH_EVENTS_RETRIGGER = [
  /**
   * Fired while the user agent is downloading media data.
   *
   * @event Player#progress
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `progress` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechProgress_
   * @fires Player#progress
   * @listens Tech#progress
   */
  "progress",
  /**
   * Fires when the loading of an audio/video is aborted.
   *
   * @event Player#abort
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `abort` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechAbort_
   * @fires Player#abort
   * @listens Tech#abort
   */
  "abort",
  /**
   * Fires when the browser is intentionally not getting media data.
   *
   * @event Player#suspend
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `suspend` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechSuspend_
   * @fires Player#suspend
   * @listens Tech#suspend
   */
  "suspend",
  /**
   * Fires when the current playlist is empty.
   *
   * @event Player#emptied
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `emptied` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechEmptied_
   * @fires Player#emptied
   * @listens Tech#emptied
   */
  "emptied",
  /**
   * Fires when the browser is trying to get media data, but data is not available.
   *
   * @event Player#stalled
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `stalled` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechStalled_
   * @fires Player#stalled
   * @listens Tech#stalled
   */
  "stalled",
  /**
   * Fires when the browser has loaded meta data for the audio/video.
   *
   * @event Player#loadedmetadata
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `loadedmetadata` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechLoadedmetadata_
   * @fires Player#loadedmetadata
   * @listens Tech#loadedmetadata
   */
  "loadedmetadata",
  /**
   * Fires when the browser has loaded the current frame of the audio/video.
   *
   * @event Player#loadeddata
   * @type {event}
   */
  /**
   * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechLoaddeddata_
   * @fires Player#loadeddata
   * @listens Tech#loadeddata
   */
  "loadeddata",
  /**
   * Fires when the current playback position has changed.
   *
   * @event Player#timeupdate
   * @type {event}
   */
  /**
   * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechTimeUpdate_
   * @fires Player#timeupdate
   * @listens Tech#timeupdate
   */
  "timeupdate",
  /**
   * Fires when the video's intrinsic dimensions change
   *
   * @event Player#resize
   * @type {event}
   */
  /**
   * Retrigger the `resize` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechResize_
   * @fires Player#resize
   * @listens Tech#resize
   */
  "resize",
  /**
   * Fires when the volume has been changed
   *
   * @event Player#volumechange
   * @type {event}
   */
  /**
   * Retrigger the `volumechange` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechVolumechange_
   * @fires Player#volumechange
   * @listens Tech#volumechange
   */
  "volumechange",
  /**
   * Fires when the text track has been changed
   *
   * @event Player#texttrackchange
   * @type {event}
   */
  /**
   * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechTexttrackchange_
   * @fires Player#texttrackchange
   * @listens Tech#texttrackchange
   */
  "texttrackchange"
];
var TECH_EVENTS_QUEUE = {
  canplay: "CanPlay",
  canplaythrough: "CanPlayThrough",
  playing: "Playing",
  seeked: "Seeked"
};
var BREAKPOINT_ORDER = ["tiny", "xsmall", "small", "medium", "large", "xlarge", "huge"];
var BREAKPOINT_CLASSES = {};
BREAKPOINT_ORDER.forEach(function(k) {
  var v = k.charAt(0) === "x" ? "x-" + k.substring(1) : k;
  BREAKPOINT_CLASSES[k] = "vjs-layout-" + v;
});
var DEFAULT_BREAKPOINTS = {
  tiny: 210,
  xsmall: 320,
  small: 425,
  medium: 768,
  large: 1440,
  xlarge: 2560,
  huge: Infinity
};
var Player = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(Player2, _Component);
  function Player2(tag, options, ready) {
    var _this;
    tag.id = tag.id || options.id || "vjs_video_" + newGUID();
    options = assign(Player2.getTagSettings(tag), options);
    options.initChildren = false;
    options.createEl = false;
    options.evented = false;
    options.reportTouchActivity = false;
    if (!options.language) {
      if (typeof tag.closest === "function") {
        var closest = tag.closest("[lang]");
        if (closest && closest.getAttribute) {
          options.language = closest.getAttribute("lang");
        }
      } else {
        var element = tag;
        while (element && element.nodeType === 1) {
          if (getAttributes(element).hasOwnProperty("lang")) {
            options.language = element.getAttribute("lang");
            break;
          }
          element = element.parentNode;
        }
      }
    }
    _this = _Component.call(this, null, options, ready) || this;
    _this.boundDocumentFullscreenChange_ = function(e) {
      return _this.documentFullscreenChange_(e);
    };
    _this.boundFullWindowOnEscKey_ = function(e) {
      return _this.fullWindowOnEscKey(e);
    };
    _this.boundUpdateStyleEl_ = function(e) {
      return _this.updateStyleEl_(e);
    };
    _this.boundApplyInitTime_ = function(e) {
      return _this.applyInitTime_(e);
    };
    _this.boundUpdateCurrentBreakpoint_ = function(e) {
      return _this.updateCurrentBreakpoint_(e);
    };
    _this.boundHandleTechClick_ = function(e) {
      return _this.handleTechClick_(e);
    };
    _this.boundHandleTechDoubleClick_ = function(e) {
      return _this.handleTechDoubleClick_(e);
    };
    _this.boundHandleTechTouchStart_ = function(e) {
      return _this.handleTechTouchStart_(e);
    };
    _this.boundHandleTechTouchMove_ = function(e) {
      return _this.handleTechTouchMove_(e);
    };
    _this.boundHandleTechTouchEnd_ = function(e) {
      return _this.handleTechTouchEnd_(e);
    };
    _this.boundHandleTechTap_ = function(e) {
      return _this.handleTechTap_(e);
    };
    _this.isFullscreen_ = false;
    _this.log = createLogger(_this.id_);
    _this.fsApi_ = FullscreenApi;
    _this.isPosterFromTech_ = false;
    _this.queuedCallbacks_ = [];
    _this.isReady_ = false;
    _this.hasStarted_ = false;
    _this.userActive_ = false;
    _this.debugEnabled_ = false;
    _this.audioOnlyMode_ = false;
    _this.audioPosterMode_ = false;
    _this.audioOnlyCache_ = {
      playerHeight: null,
      hiddenChildren: []
    };
    if (!_this.options_ || !_this.options_.techOrder || !_this.options_.techOrder.length) {
      throw new Error("No techOrder specified. Did you overwrite videojs.options instead of just changing the properties you want to override?");
    }
    _this.tag = tag;
    _this.tagAttributes = tag && getAttributes(tag);
    _this.language(_this.options_.language);
    if (options.languages) {
      var languagesToLower = {};
      Object.getOwnPropertyNames(options.languages).forEach(function(name) {
        languagesToLower[name.toLowerCase()] = options.languages[name];
      });
      _this.languages_ = languagesToLower;
    } else {
      _this.languages_ = Player2.prototype.options_.languages;
    }
    _this.resetCache_();
    _this.poster_ = options.poster || "";
    _this.controls_ = !!options.controls;
    tag.controls = false;
    tag.removeAttribute("controls");
    _this.changingSrc_ = false;
    _this.playCallbacks_ = [];
    _this.playTerminatedQueue_ = [];
    if (tag.hasAttribute("autoplay")) {
      _this.autoplay(true);
    } else {
      _this.autoplay(_this.options_.autoplay);
    }
    if (options.plugins) {
      Object.keys(options.plugins).forEach(function(name) {
        if (typeof _this[name] !== "function") {
          throw new Error('plugin "' + name + '" does not exist');
        }
      });
    }
    _this.scrubbing_ = false;
    _this.el_ = _this.createEl();
    evented(_assertThisInitialized(_this), {
      eventBusKey: "el_"
    });
    if (_this.fsApi_.requestFullscreen) {
      on(import_document.default, _this.fsApi_.fullscreenchange, _this.boundDocumentFullscreenChange_);
      _this.on(_this.fsApi_.fullscreenchange, _this.boundDocumentFullscreenChange_);
    }
    if (_this.fluid_) {
      _this.on(["playerreset", "resize"], _this.boundUpdateStyleEl_);
    }
    var playerOptionsCopy = mergeOptions$3(_this.options_);
    if (options.plugins) {
      Object.keys(options.plugins).forEach(function(name) {
        _this[name](options.plugins[name]);
      });
    }
    if (options.debug) {
      _this.debug(true);
    }
    _this.options_.playerOptions = playerOptionsCopy;
    _this.middleware_ = [];
    _this.playbackRates(options.playbackRates);
    _this.initChildren();
    _this.isAudio(tag.nodeName.toLowerCase() === "audio");
    if (_this.controls()) {
      _this.addClass("vjs-controls-enabled");
    } else {
      _this.addClass("vjs-controls-disabled");
    }
    _this.el_.setAttribute("role", "region");
    if (_this.isAudio()) {
      _this.el_.setAttribute("aria-label", _this.localize("Audio Player"));
    } else {
      _this.el_.setAttribute("aria-label", _this.localize("Video Player"));
    }
    if (_this.isAudio()) {
      _this.addClass("vjs-audio");
    }
    if (_this.flexNotSupported_()) {
      _this.addClass("vjs-no-flex");
    }
    if (TOUCH_ENABLED) {
      _this.addClass("vjs-touch-enabled");
    }
    if (!IS_IOS) {
      _this.addClass("vjs-workinghover");
    }
    Player2.players[_this.id_] = _assertThisInitialized(_this);
    var majorVersion = version$5.split(".")[0];
    _this.addClass("vjs-v" + majorVersion);
    _this.userActive(true);
    _this.reportUserActivity();
    _this.one("play", function(e) {
      return _this.listenForUserActivity_(e);
    });
    _this.on("stageclick", function(e) {
      return _this.handleStageClick_(e);
    });
    _this.on("keydown", function(e) {
      return _this.handleKeyDown(e);
    });
    _this.on("languagechange", function(e) {
      return _this.handleLanguagechange(e);
    });
    _this.breakpoints(_this.options_.breakpoints);
    _this.responsive(_this.options_.responsive);
    _this.on("ready", function() {
      _this.audioPosterMode(_this.options_.audioPosterMode);
      _this.audioOnlyMode(_this.options_.audioOnlyMode);
    });
    return _this;
  }
  var _proto = Player2.prototype;
  _proto.dispose = function dispose() {
    var _this2 = this;
    this.trigger("dispose");
    this.off("dispose");
    off(import_document.default, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
    off(import_document.default, "keydown", this.boundFullWindowOnEscKey_);
    if (this.styleEl_ && this.styleEl_.parentNode) {
      this.styleEl_.parentNode.removeChild(this.styleEl_);
      this.styleEl_ = null;
    }
    Player2.players[this.id_] = null;
    if (this.tag && this.tag.player) {
      this.tag.player = null;
    }
    if (this.el_ && this.el_.player) {
      this.el_.player = null;
    }
    if (this.tech_) {
      this.tech_.dispose();
      this.isPosterFromTech_ = false;
      this.poster_ = "";
    }
    if (this.playerElIngest_) {
      this.playerElIngest_ = null;
    }
    if (this.tag) {
      this.tag = null;
    }
    clearCacheForPlayer(this);
    ALL.names.forEach(function(name) {
      var props = ALL[name];
      var list = _this2[props.getterName]();
      if (list && list.off) {
        list.off();
      }
    });
    _Component.prototype.dispose.call(this, {
      restoreEl: this.options_.restoreEl
    });
  };
  _proto.createEl = function createEl2() {
    var tag = this.tag;
    var el;
    var playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute("data-vjs-player");
    var divEmbed = this.tag.tagName.toLowerCase() === "video-js";
    if (playerElIngest) {
      el = this.el_ = tag.parentNode;
    } else if (!divEmbed) {
      el = this.el_ = _Component.prototype.createEl.call(this, "div");
    }
    var attrs = getAttributes(tag);
    if (divEmbed) {
      el = this.el_ = tag;
      tag = this.tag = import_document.default.createElement("video");
      while (el.children.length) {
        tag.appendChild(el.firstChild);
      }
      if (!hasClass(el, "video-js")) {
        addClass(el, "video-js");
      }
      el.appendChild(tag);
      playerElIngest = this.playerElIngest_ = el;
      Object.keys(el).forEach(function(k) {
        try {
          tag[k] = el[k];
        } catch (e) {
        }
      });
    }
    tag.setAttribute("tabindex", "-1");
    attrs.tabindex = "-1";
    if (IE_VERSION || IS_CHROME && IS_WINDOWS) {
      tag.setAttribute("role", "application");
      attrs.role = "application";
    }
    tag.removeAttribute("width");
    tag.removeAttribute("height");
    if ("width" in attrs) {
      delete attrs.width;
    }
    if ("height" in attrs) {
      delete attrs.height;
    }
    Object.getOwnPropertyNames(attrs).forEach(function(attr) {
      if (!(divEmbed && attr === "class")) {
        el.setAttribute(attr, attrs[attr]);
      }
      if (divEmbed) {
        tag.setAttribute(attr, attrs[attr]);
      }
    });
    tag.playerId = tag.id;
    tag.id += "_html5_api";
    tag.className = "vjs-tech";
    tag.player = el.player = this;
    this.addClass("vjs-paused");
    if (import_window6.default.VIDEOJS_NO_DYNAMIC_STYLE !== true) {
      this.styleEl_ = createStyleElement("vjs-styles-dimensions");
      var defaultsStyleEl = $(".vjs-styles-defaults");
      var head = $("head");
      head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);
    }
    this.fill_ = false;
    this.fluid_ = false;
    this.width(this.options_.width);
    this.height(this.options_.height);
    this.fill(this.options_.fill);
    this.fluid(this.options_.fluid);
    this.aspectRatio(this.options_.aspectRatio);
    this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);
    var links = tag.getElementsByTagName("a");
    for (var i = 0; i < links.length; i++) {
      var linkEl = links.item(i);
      addClass(linkEl, "vjs-hidden");
      linkEl.setAttribute("hidden", "hidden");
    }
    tag.initNetworkState_ = tag.networkState;
    if (tag.parentNode && !playerElIngest) {
      tag.parentNode.insertBefore(el, tag);
    }
    prependTo(tag, el);
    this.children_.unshift(tag);
    this.el_.setAttribute("lang", this.language_);
    this.el_.setAttribute("translate", "no");
    this.el_ = el;
    return el;
  };
  _proto.crossOrigin = function crossOrigin(value) {
    if (!value) {
      return this.techGet_("crossOrigin");
    }
    if (value !== "anonymous" && value !== "use-credentials") {
      log$1.warn('crossOrigin must be "anonymous" or "use-credentials", given "' + value + '"');
      return;
    }
    this.techCall_("setCrossOrigin", value);
    return;
  };
  _proto.width = function width2(value) {
    return this.dimension("width", value);
  };
  _proto.height = function height2(value) {
    return this.dimension("height", value);
  };
  _proto.dimension = function dimension(_dimension, value) {
    var privDimension = _dimension + "_";
    if (value === void 0) {
      return this[privDimension] || 0;
    }
    if (value === "" || value === "auto") {
      this[privDimension] = void 0;
      this.updateStyleEl_();
      return;
    }
    var parsedVal = parseFloat(value);
    if (isNaN(parsedVal)) {
      log$1.error('Improper value "' + value + '" supplied for for ' + _dimension);
      return;
    }
    this[privDimension] = parsedVal;
    this.updateStyleEl_();
  };
  _proto.fluid = function fluid(bool) {
    var _this3 = this;
    if (bool === void 0) {
      return !!this.fluid_;
    }
    this.fluid_ = !!bool;
    if (isEvented(this)) {
      this.off(["playerreset", "resize"], this.boundUpdateStyleEl_);
    }
    if (bool) {
      this.addClass("vjs-fluid");
      this.fill(false);
      addEventedCallback(this, function() {
        _this3.on(["playerreset", "resize"], _this3.boundUpdateStyleEl_);
      });
    } else {
      this.removeClass("vjs-fluid");
    }
    this.updateStyleEl_();
  };
  _proto.fill = function fill(bool) {
    if (bool === void 0) {
      return !!this.fill_;
    }
    this.fill_ = !!bool;
    if (bool) {
      this.addClass("vjs-fill");
      this.fluid(false);
    } else {
      this.removeClass("vjs-fill");
    }
  };
  _proto.aspectRatio = function aspectRatio(ratio) {
    if (ratio === void 0) {
      return this.aspectRatio_;
    }
    if (!/^\d+\:\d+$/.test(ratio)) {
      throw new Error("Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.");
    }
    this.aspectRatio_ = ratio;
    this.fluid(true);
    this.updateStyleEl_();
  };
  _proto.updateStyleEl_ = function updateStyleEl_() {
    if (import_window6.default.VIDEOJS_NO_DYNAMIC_STYLE === true) {
      var _width = typeof this.width_ === "number" ? this.width_ : this.options_.width;
      var _height = typeof this.height_ === "number" ? this.height_ : this.options_.height;
      var techEl = this.tech_ && this.tech_.el();
      if (techEl) {
        if (_width >= 0) {
          techEl.width = _width;
        }
        if (_height >= 0) {
          techEl.height = _height;
        }
      }
      return;
    }
    var width2;
    var height2;
    var aspectRatio;
    var idClass;
    if (this.aspectRatio_ !== void 0 && this.aspectRatio_ !== "auto") {
      aspectRatio = this.aspectRatio_;
    } else if (this.videoWidth() > 0) {
      aspectRatio = this.videoWidth() + ":" + this.videoHeight();
    } else {
      aspectRatio = "16:9";
    }
    var ratioParts = aspectRatio.split(":");
    var ratioMultiplier = ratioParts[1] / ratioParts[0];
    if (this.width_ !== void 0) {
      width2 = this.width_;
    } else if (this.height_ !== void 0) {
      width2 = this.height_ / ratioMultiplier;
    } else {
      width2 = this.videoWidth() || 300;
    }
    if (this.height_ !== void 0) {
      height2 = this.height_;
    } else {
      height2 = width2 * ratioMultiplier;
    }
    if (/^[^a-zA-Z]/.test(this.id())) {
      idClass = "dimensions-" + this.id();
    } else {
      idClass = this.id() + "-dimensions";
    }
    this.addClass(idClass);
    setTextContent(this.styleEl_, "\n      ." + idClass + " {\n        width: " + width2 + "px;\n        height: " + height2 + "px;\n      }\n\n      ." + idClass + ".vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: " + ratioMultiplier * 100 + "%;\n      }\n    ");
  };
  _proto.loadTech_ = function loadTech_(techName, source) {
    var _this4 = this;
    if (this.tech_) {
      this.unloadTech_();
    }
    var titleTechName = toTitleCase$1(techName);
    var camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);
    if (titleTechName !== "Html5" && this.tag) {
      Tech.getTech("Html5").disposeMediaElement(this.tag);
      this.tag.player = null;
      this.tag = null;
    }
    this.techName_ = titleTechName;
    this.isReady_ = false;
    var autoplay = this.autoplay();
    if (typeof this.autoplay() === "string" || this.autoplay() === true && this.options_.normalizeAutoplay) {
      autoplay = false;
    }
    var techOptions = {
      source,
      autoplay,
      "nativeControlsForTouch": this.options_.nativeControlsForTouch,
      "playerId": this.id(),
      "techId": this.id() + "_" + camelTechName + "_api",
      "playsinline": this.options_.playsinline,
      "preload": this.options_.preload,
      "loop": this.options_.loop,
      "disablePictureInPicture": this.options_.disablePictureInPicture,
      "muted": this.options_.muted,
      "poster": this.poster(),
      "language": this.language(),
      "playerElIngest": this.playerElIngest_ || false,
      "vtt.js": this.options_["vtt.js"],
      "canOverridePoster": !!this.options_.techCanOverridePoster,
      "enableSourceset": this.options_.enableSourceset,
      "Promise": this.options_.Promise
    };
    ALL.names.forEach(function(name) {
      var props = ALL[name];
      techOptions[props.getterName] = _this4[props.privateName];
    });
    assign(techOptions, this.options_[titleTechName]);
    assign(techOptions, this.options_[camelTechName]);
    assign(techOptions, this.options_[techName.toLowerCase()]);
    if (this.tag) {
      techOptions.tag = this.tag;
    }
    if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {
      techOptions.startTime = this.cache_.currentTime;
    }
    var TechClass = Tech.getTech(techName);
    if (!TechClass) {
      throw new Error("No Tech named '" + titleTechName + "' exists! '" + titleTechName + "' should be registered using videojs.registerTech()'");
    }
    this.tech_ = new TechClass(techOptions);
    this.tech_.ready(bind(this, this.handleTechReady_), true);
    textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);
    TECH_EVENTS_RETRIGGER.forEach(function(event) {
      _this4.on(_this4.tech_, event, function(e) {
        return _this4["handleTech" + toTitleCase$1(event) + "_"](e);
      });
    });
    Object.keys(TECH_EVENTS_QUEUE).forEach(function(event) {
      _this4.on(_this4.tech_, event, function(eventObj) {
        if (_this4.tech_.playbackRate() === 0 && _this4.tech_.seeking()) {
          _this4.queuedCallbacks_.push({
            callback: _this4["handleTech" + TECH_EVENTS_QUEUE[event] + "_"].bind(_this4),
            event: eventObj
          });
          return;
        }
        _this4["handleTech" + TECH_EVENTS_QUEUE[event] + "_"](eventObj);
      });
    });
    this.on(this.tech_, "loadstart", function(e) {
      return _this4.handleTechLoadStart_(e);
    });
    this.on(this.tech_, "sourceset", function(e) {
      return _this4.handleTechSourceset_(e);
    });
    this.on(this.tech_, "waiting", function(e) {
      return _this4.handleTechWaiting_(e);
    });
    this.on(this.tech_, "ended", function(e) {
      return _this4.handleTechEnded_(e);
    });
    this.on(this.tech_, "seeking", function(e) {
      return _this4.handleTechSeeking_(e);
    });
    this.on(this.tech_, "play", function(e) {
      return _this4.handleTechPlay_(e);
    });
    this.on(this.tech_, "firstplay", function(e) {
      return _this4.handleTechFirstPlay_(e);
    });
    this.on(this.tech_, "pause", function(e) {
      return _this4.handleTechPause_(e);
    });
    this.on(this.tech_, "durationchange", function(e) {
      return _this4.handleTechDurationChange_(e);
    });
    this.on(this.tech_, "fullscreenchange", function(e, data) {
      return _this4.handleTechFullscreenChange_(e, data);
    });
    this.on(this.tech_, "fullscreenerror", function(e, err) {
      return _this4.handleTechFullscreenError_(e, err);
    });
    this.on(this.tech_, "enterpictureinpicture", function(e) {
      return _this4.handleTechEnterPictureInPicture_(e);
    });
    this.on(this.tech_, "leavepictureinpicture", function(e) {
      return _this4.handleTechLeavePictureInPicture_(e);
    });
    this.on(this.tech_, "error", function(e) {
      return _this4.handleTechError_(e);
    });
    this.on(this.tech_, "posterchange", function(e) {
      return _this4.handleTechPosterChange_(e);
    });
    this.on(this.tech_, "textdata", function(e) {
      return _this4.handleTechTextData_(e);
    });
    this.on(this.tech_, "ratechange", function(e) {
      return _this4.handleTechRateChange_(e);
    });
    this.on(this.tech_, "loadedmetadata", this.boundUpdateStyleEl_);
    this.usingNativeControls(this.techGet_("controls"));
    if (this.controls() && !this.usingNativeControls()) {
      this.addTechControlsListeners_();
    }
    if (this.tech_.el().parentNode !== this.el() && (titleTechName !== "Html5" || !this.tag)) {
      prependTo(this.tech_.el(), this.el());
    }
    if (this.tag) {
      this.tag.player = null;
      this.tag = null;
    }
  };
  _proto.unloadTech_ = function unloadTech_() {
    var _this5 = this;
    ALL.names.forEach(function(name) {
      var props = ALL[name];
      _this5[props.privateName] = _this5[props.getterName]();
    });
    this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);
    this.isReady_ = false;
    this.tech_.dispose();
    this.tech_ = false;
    if (this.isPosterFromTech_) {
      this.poster_ = "";
      this.trigger("posterchange");
    }
    this.isPosterFromTech_ = false;
  };
  _proto.tech = function tech(safety) {
    if (safety === void 0) {
      log$1.warn("Using the tech directly can be dangerous. I hope you know what you're doing.\nSee https://github.com/videojs/video.js/issues/2617 for more info.\n");
    }
    return this.tech_;
  };
  _proto.addTechControlsListeners_ = function addTechControlsListeners_() {
    this.removeTechControlsListeners_();
    this.on(this.tech_, "click", this.boundHandleTechClick_);
    this.on(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
    this.on(this.tech_, "touchstart", this.boundHandleTechTouchStart_);
    this.on(this.tech_, "touchmove", this.boundHandleTechTouchMove_);
    this.on(this.tech_, "touchend", this.boundHandleTechTouchEnd_);
    this.on(this.tech_, "tap", this.boundHandleTechTap_);
  };
  _proto.removeTechControlsListeners_ = function removeTechControlsListeners_() {
    this.off(this.tech_, "tap", this.boundHandleTechTap_);
    this.off(this.tech_, "touchstart", this.boundHandleTechTouchStart_);
    this.off(this.tech_, "touchmove", this.boundHandleTechTouchMove_);
    this.off(this.tech_, "touchend", this.boundHandleTechTouchEnd_);
    this.off(this.tech_, "click", this.boundHandleTechClick_);
    this.off(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
  };
  _proto.handleTechReady_ = function handleTechReady_() {
    this.triggerReady();
    if (this.cache_.volume) {
      this.techCall_("setVolume", this.cache_.volume);
    }
    this.handleTechPosterChange_();
    this.handleTechDurationChange_();
  };
  _proto.handleTechLoadStart_ = function handleTechLoadStart_() {
    this.removeClass("vjs-ended");
    this.removeClass("vjs-seeking");
    this.error(null);
    this.handleTechDurationChange_();
    if (!this.paused()) {
      this.trigger("loadstart");
      this.trigger("firstplay");
    } else {
      this.hasStarted(false);
      this.trigger("loadstart");
    }
    this.manualAutoplay_(this.autoplay() === true && this.options_.normalizeAutoplay ? "play" : this.autoplay());
  };
  _proto.manualAutoplay_ = function manualAutoplay_(type2) {
    var _this6 = this;
    if (!this.tech_ || typeof type2 !== "string") {
      return;
    }
    var resolveMuted = function resolveMuted2() {
      var previouslyMuted = _this6.muted();
      _this6.muted(true);
      var restoreMuted = function restoreMuted2() {
        _this6.muted(previouslyMuted);
      };
      _this6.playTerminatedQueue_.push(restoreMuted);
      var mutedPromise = _this6.play();
      if (!isPromise2(mutedPromise)) {
        return;
      }
      return mutedPromise["catch"](function(err) {
        restoreMuted();
        throw new Error("Rejection at manualAutoplay. Restoring muted value. " + (err ? err : ""));
      });
    };
    var promise;
    if (type2 === "any" && !this.muted()) {
      promise = this.play();
      if (isPromise2(promise)) {
        promise = promise["catch"](resolveMuted);
      }
    } else if (type2 === "muted" && !this.muted()) {
      promise = resolveMuted();
    } else {
      promise = this.play();
    }
    if (!isPromise2(promise)) {
      return;
    }
    return promise.then(function() {
      _this6.trigger({
        type: "autoplay-success",
        autoplay: type2
      });
    })["catch"](function() {
      _this6.trigger({
        type: "autoplay-failure",
        autoplay: type2
      });
    });
  };
  _proto.updateSourceCaches_ = function updateSourceCaches_(srcObj) {
    if (srcObj === void 0) {
      srcObj = "";
    }
    var src = srcObj;
    var type2 = "";
    if (typeof src !== "string") {
      src = srcObj.src;
      type2 = srcObj.type;
    }
    this.cache_.source = this.cache_.source || {};
    this.cache_.sources = this.cache_.sources || [];
    if (src && !type2) {
      type2 = findMimetype(this, src);
    }
    this.cache_.source = mergeOptions$3({}, srcObj, {
      src,
      type: type2
    });
    var matchingSources = this.cache_.sources.filter(function(s) {
      return s.src && s.src === src;
    });
    var sourceElSources = [];
    var sourceEls = this.$$("source");
    var matchingSourceEls = [];
    for (var i = 0; i < sourceEls.length; i++) {
      var sourceObj = getAttributes(sourceEls[i]);
      sourceElSources.push(sourceObj);
      if (sourceObj.src && sourceObj.src === src) {
        matchingSourceEls.push(sourceObj.src);
      }
    }
    if (matchingSourceEls.length && !matchingSources.length) {
      this.cache_.sources = sourceElSources;
    } else if (!matchingSources.length) {
      this.cache_.sources = [this.cache_.source];
    }
    this.cache_.src = src;
  };
  _proto.handleTechSourceset_ = function handleTechSourceset_(event) {
    var _this7 = this;
    if (!this.changingSrc_) {
      var updateSourceCaches = function updateSourceCaches2(src) {
        return _this7.updateSourceCaches_(src);
      };
      var playerSrc = this.currentSource().src;
      var eventSrc = event.src;
      if (playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc)) {
        if (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) {
          updateSourceCaches = function updateSourceCaches2() {
          };
        }
      }
      updateSourceCaches(eventSrc);
      if (!event.src) {
        this.tech_.any(["sourceset", "loadstart"], function(e) {
          if (e.type === "sourceset") {
            return;
          }
          var techSrc = _this7.techGet("currentSrc");
          _this7.lastSource_.tech = techSrc;
          _this7.updateSourceCaches_(techSrc);
        });
      }
    }
    this.lastSource_ = {
      player: this.currentSource().src,
      tech: event.src
    };
    this.trigger({
      src: event.src,
      type: "sourceset"
    });
  };
  _proto.hasStarted = function hasStarted(request) {
    if (request === void 0) {
      return this.hasStarted_;
    }
    if (request === this.hasStarted_) {
      return;
    }
    this.hasStarted_ = request;
    if (this.hasStarted_) {
      this.addClass("vjs-has-started");
      this.trigger("firstplay");
    } else {
      this.removeClass("vjs-has-started");
    }
  };
  _proto.handleTechPlay_ = function handleTechPlay_() {
    this.removeClass("vjs-ended");
    this.removeClass("vjs-paused");
    this.addClass("vjs-playing");
    this.hasStarted(true);
    this.trigger("play");
  };
  _proto.handleTechRateChange_ = function handleTechRateChange_() {
    if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {
      this.queuedCallbacks_.forEach(function(queued) {
        return queued.callback(queued.event);
      });
      this.queuedCallbacks_ = [];
    }
    this.cache_.lastPlaybackRate = this.tech_.playbackRate();
    this.trigger("ratechange");
  };
  _proto.handleTechWaiting_ = function handleTechWaiting_() {
    var _this8 = this;
    this.addClass("vjs-waiting");
    this.trigger("waiting");
    var timeWhenWaiting = this.currentTime();
    var timeUpdateListener = function timeUpdateListener2() {
      if (timeWhenWaiting !== _this8.currentTime()) {
        _this8.removeClass("vjs-waiting");
        _this8.off("timeupdate", timeUpdateListener2);
      }
    };
    this.on("timeupdate", timeUpdateListener);
  };
  _proto.handleTechCanPlay_ = function handleTechCanPlay_() {
    this.removeClass("vjs-waiting");
    this.trigger("canplay");
  };
  _proto.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {
    this.removeClass("vjs-waiting");
    this.trigger("canplaythrough");
  };
  _proto.handleTechPlaying_ = function handleTechPlaying_() {
    this.removeClass("vjs-waiting");
    this.trigger("playing");
  };
  _proto.handleTechSeeking_ = function handleTechSeeking_() {
    this.addClass("vjs-seeking");
    this.trigger("seeking");
  };
  _proto.handleTechSeeked_ = function handleTechSeeked_() {
    this.removeClass("vjs-seeking");
    this.removeClass("vjs-ended");
    this.trigger("seeked");
  };
  _proto.handleTechFirstPlay_ = function handleTechFirstPlay_() {
    if (this.options_.starttime) {
      log$1.warn("Passing the `starttime` option to the player will be deprecated in 6.0");
      this.currentTime(this.options_.starttime);
    }
    this.addClass("vjs-has-started");
    this.trigger("firstplay");
  };
  _proto.handleTechPause_ = function handleTechPause_() {
    this.removeClass("vjs-playing");
    this.addClass("vjs-paused");
    this.trigger("pause");
  };
  _proto.handleTechEnded_ = function handleTechEnded_() {
    this.addClass("vjs-ended");
    this.removeClass("vjs-waiting");
    if (this.options_.loop) {
      this.currentTime(0);
      this.play();
    } else if (!this.paused()) {
      this.pause();
    }
    this.trigger("ended");
  };
  _proto.handleTechDurationChange_ = function handleTechDurationChange_() {
    this.duration(this.techGet_("duration"));
  };
  _proto.handleTechClick_ = function handleTechClick_(event) {
    if (!this.controls_) {
      return;
    }
    if (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.click === void 0 || this.options_.userActions.click !== false) {
      if (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.click === "function") {
        this.options_.userActions.click.call(this, event);
      } else if (this.paused()) {
        silencePromise(this.play());
      } else {
        this.pause();
      }
    }
  };
  _proto.handleTechDoubleClick_ = function handleTechDoubleClick_(event) {
    if (!this.controls_) {
      return;
    }
    var inAllowedEls = Array.prototype.some.call(this.$$(".vjs-control-bar, .vjs-modal-dialog"), function(el) {
      return el.contains(event.target);
    });
    if (!inAllowedEls) {
      if (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.doubleClick === void 0 || this.options_.userActions.doubleClick !== false) {
        if (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.doubleClick === "function") {
          this.options_.userActions.doubleClick.call(this, event);
        } else if (this.isFullscreen()) {
          this.exitFullscreen();
        } else {
          this.requestFullscreen();
        }
      }
    }
  };
  _proto.handleTechTap_ = function handleTechTap_() {
    this.userActive(!this.userActive());
  };
  _proto.handleTechTouchStart_ = function handleTechTouchStart_() {
    this.userWasActive = this.userActive();
  };
  _proto.handleTechTouchMove_ = function handleTechTouchMove_() {
    if (this.userWasActive) {
      this.reportUserActivity();
    }
  };
  _proto.handleTechTouchEnd_ = function handleTechTouchEnd_(event) {
    if (event.cancelable) {
      event.preventDefault();
    }
  };
  _proto.handleStageClick_ = function handleStageClick_() {
    this.reportUserActivity();
  };
  _proto.toggleFullscreenClass_ = function toggleFullscreenClass_() {
    if (this.isFullscreen()) {
      this.addClass("vjs-fullscreen");
    } else {
      this.removeClass("vjs-fullscreen");
    }
  };
  _proto.documentFullscreenChange_ = function documentFullscreenChange_(e) {
    var targetPlayer = e.target.player;
    if (targetPlayer && targetPlayer !== this) {
      return;
    }
    var el = this.el();
    var isFs = import_document.default[this.fsApi_.fullscreenElement] === el;
    if (!isFs && el.matches) {
      isFs = el.matches(":" + this.fsApi_.fullscreen);
    } else if (!isFs && el.msMatchesSelector) {
      isFs = el.msMatchesSelector(":" + this.fsApi_.fullscreen);
    }
    this.isFullscreen(isFs);
  };
  _proto.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event, data) {
    var _this9 = this;
    if (data) {
      if (data.nativeIOSFullscreen) {
        this.addClass("vjs-ios-native-fs");
        this.tech_.one("webkitendfullscreen", function() {
          _this9.removeClass("vjs-ios-native-fs");
        });
      }
      this.isFullscreen(data.isFullscreen);
    }
  };
  _proto.handleTechFullscreenError_ = function handleTechFullscreenError_(event, err) {
    this.trigger("fullscreenerror", err);
  };
  _proto.togglePictureInPictureClass_ = function togglePictureInPictureClass_() {
    if (this.isInPictureInPicture()) {
      this.addClass("vjs-picture-in-picture");
    } else {
      this.removeClass("vjs-picture-in-picture");
    }
  };
  _proto.handleTechEnterPictureInPicture_ = function handleTechEnterPictureInPicture_(event) {
    this.isInPictureInPicture(true);
  };
  _proto.handleTechLeavePictureInPicture_ = function handleTechLeavePictureInPicture_(event) {
    this.isInPictureInPicture(false);
  };
  _proto.handleTechError_ = function handleTechError_() {
    var error = this.tech_.error();
    this.error(error);
  };
  _proto.handleTechTextData_ = function handleTechTextData_() {
    var data = null;
    if (arguments.length > 1) {
      data = arguments[1];
    }
    this.trigger("textdata", data);
  };
  _proto.getCache = function getCache() {
    return this.cache_;
  };
  _proto.resetCache_ = function resetCache_() {
    this.cache_ = {
      // Right now, the currentTime is not _really_ cached because it is always
      // retrieved from the tech (see: currentTime). However, for completeness,
      // we set it to zero here to ensure that if we do start actually caching
      // it, we reset it along with everything else.
      currentTime: 0,
      initTime: 0,
      inactivityTimeout: this.options_.inactivityTimeout,
      duration: NaN,
      lastVolume: 1,
      lastPlaybackRate: this.defaultPlaybackRate(),
      media: null,
      src: "",
      source: {},
      sources: [],
      playbackRates: [],
      volume: 1
    };
  };
  _proto.techCall_ = function techCall_(method, arg) {
    this.ready(function() {
      if (method in allowedSetters) {
        return set(this.middleware_, this.tech_, method, arg);
      } else if (method in allowedMediators) {
        return mediate(this.middleware_, this.tech_, method, arg);
      }
      try {
        if (this.tech_) {
          this.tech_[method](arg);
        }
      } catch (e) {
        log$1(e);
        throw e;
      }
    }, true);
  };
  _proto.techGet_ = function techGet_(method) {
    if (!this.tech_ || !this.tech_.isReady_) {
      return;
    }
    if (method in allowedGetters) {
      return get(this.middleware_, this.tech_, method);
    } else if (method in allowedMediators) {
      return mediate(this.middleware_, this.tech_, method);
    }
    try {
      return this.tech_[method]();
    } catch (e) {
      if (this.tech_[method] === void 0) {
        log$1("Video.js: " + method + " method not defined for " + this.techName_ + " playback technology.", e);
        throw e;
      }
      if (e.name === "TypeError") {
        log$1("Video.js: " + method + " unavailable on " + this.techName_ + " playback technology element.", e);
        this.tech_.isReady_ = false;
        throw e;
      }
      log$1(e);
      throw e;
    }
  };
  _proto.play = function play() {
    var _this10 = this;
    var PromiseClass = this.options_.Promise || import_window6.default.Promise;
    if (PromiseClass) {
      return new PromiseClass(function(resolve) {
        _this10.play_(resolve);
      });
    }
    return this.play_();
  };
  _proto.play_ = function play_(callback2) {
    var _this11 = this;
    if (callback2 === void 0) {
      callback2 = silencePromise;
    }
    this.playCallbacks_.push(callback2);
    var isSrcReady = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc()));
    if (this.waitToPlay_) {
      this.off(["ready", "loadstart"], this.waitToPlay_);
      this.waitToPlay_ = null;
    }
    if (!this.isReady_ || !isSrcReady) {
      this.waitToPlay_ = function(e) {
        _this11.play_();
      };
      this.one(["ready", "loadstart"], this.waitToPlay_);
      if (!isSrcReady && (IS_ANY_SAFARI || IS_IOS)) {
        this.load();
      }
      return;
    }
    var val = this.techGet_("play");
    if (val === null) {
      this.runPlayTerminatedQueue_();
    } else {
      this.runPlayCallbacks_(val);
    }
  };
  _proto.runPlayTerminatedQueue_ = function runPlayTerminatedQueue_() {
    var queue = this.playTerminatedQueue_.slice(0);
    this.playTerminatedQueue_ = [];
    queue.forEach(function(q) {
      q();
    });
  };
  _proto.runPlayCallbacks_ = function runPlayCallbacks_(val) {
    var callbacks = this.playCallbacks_.slice(0);
    this.playCallbacks_ = [];
    this.playTerminatedQueue_ = [];
    callbacks.forEach(function(cb) {
      cb(val);
    });
  };
  _proto.pause = function pause() {
    this.techCall_("pause");
  };
  _proto.paused = function paused() {
    return this.techGet_("paused") === false ? false : true;
  };
  _proto.played = function played() {
    return this.techGet_("played") || createTimeRanges(0, 0);
  };
  _proto.scrubbing = function scrubbing(isScrubbing) {
    if (typeof isScrubbing === "undefined") {
      return this.scrubbing_;
    }
    this.scrubbing_ = !!isScrubbing;
    this.techCall_("setScrubbing", this.scrubbing_);
    if (isScrubbing) {
      this.addClass("vjs-scrubbing");
    } else {
      this.removeClass("vjs-scrubbing");
    }
  };
  _proto.currentTime = function currentTime(seconds) {
    if (typeof seconds !== "undefined") {
      if (seconds < 0) {
        seconds = 0;
      }
      if (!this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {
        this.cache_.initTime = seconds;
        this.off("canplay", this.boundApplyInitTime_);
        this.one("canplay", this.boundApplyInitTime_);
        return;
      }
      this.techCall_("setCurrentTime", seconds);
      this.cache_.initTime = 0;
      return;
    }
    this.cache_.currentTime = this.techGet_("currentTime") || 0;
    return this.cache_.currentTime;
  };
  _proto.applyInitTime_ = function applyInitTime_() {
    this.currentTime(this.cache_.initTime);
  };
  _proto.duration = function duration5(seconds) {
    if (seconds === void 0) {
      return this.cache_.duration !== void 0 ? this.cache_.duration : NaN;
    }
    seconds = parseFloat(seconds);
    if (seconds < 0) {
      seconds = Infinity;
    }
    if (seconds !== this.cache_.duration) {
      this.cache_.duration = seconds;
      if (seconds === Infinity) {
        this.addClass("vjs-live");
      } else {
        this.removeClass("vjs-live");
      }
      if (!isNaN(seconds)) {
        this.trigger("durationchange");
      }
    }
  };
  _proto.remainingTime = function remainingTime() {
    return this.duration() - this.currentTime();
  };
  _proto.remainingTimeDisplay = function remainingTimeDisplay() {
    return Math.floor(this.duration()) - Math.floor(this.currentTime());
  };
  _proto.buffered = function buffered() {
    var buffered2 = this.techGet_("buffered");
    if (!buffered2 || !buffered2.length) {
      buffered2 = createTimeRanges(0, 0);
    }
    return buffered2;
  };
  _proto.bufferedPercent = function bufferedPercent$1() {
    return bufferedPercent(this.buffered(), this.duration());
  };
  _proto.bufferedEnd = function bufferedEnd() {
    var buffered = this.buffered();
    var duration5 = this.duration();
    var end = buffered.end(buffered.length - 1);
    if (end > duration5) {
      end = duration5;
    }
    return end;
  };
  _proto.volume = function volume(percentAsDecimal) {
    var vol;
    if (percentAsDecimal !== void 0) {
      vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));
      this.cache_.volume = vol;
      this.techCall_("setVolume", vol);
      if (vol > 0) {
        this.lastVolume_(vol);
      }
      return;
    }
    vol = parseFloat(this.techGet_("volume"));
    return isNaN(vol) ? 1 : vol;
  };
  _proto.muted = function muted(_muted) {
    if (_muted !== void 0) {
      this.techCall_("setMuted", _muted);
      return;
    }
    return this.techGet_("muted") || false;
  };
  _proto.defaultMuted = function defaultMuted(_defaultMuted) {
    if (_defaultMuted !== void 0) {
      return this.techCall_("setDefaultMuted", _defaultMuted);
    }
    return this.techGet_("defaultMuted") || false;
  };
  _proto.lastVolume_ = function lastVolume_(percentAsDecimal) {
    if (percentAsDecimal !== void 0 && percentAsDecimal !== 0) {
      this.cache_.lastVolume = percentAsDecimal;
      return;
    }
    return this.cache_.lastVolume;
  };
  _proto.supportsFullScreen = function supportsFullScreen() {
    return this.techGet_("supportsFullScreen") || false;
  };
  _proto.isFullscreen = function isFullscreen(isFS) {
    if (isFS !== void 0) {
      var oldValue = this.isFullscreen_;
      this.isFullscreen_ = Boolean(isFS);
      if (this.isFullscreen_ !== oldValue && this.fsApi_.prefixed) {
        this.trigger("fullscreenchange");
      }
      this.toggleFullscreenClass_();
      return;
    }
    return this.isFullscreen_;
  };
  _proto.requestFullscreen = function requestFullscreen(fullscreenOptions) {
    var PromiseClass = this.options_.Promise || import_window6.default.Promise;
    if (PromiseClass) {
      var self2 = this;
      return new PromiseClass(function(resolve, reject) {
        function offHandler() {
          self2.off("fullscreenerror", errorHandler);
          self2.off("fullscreenchange", changeHandler);
        }
        function changeHandler() {
          offHandler();
          resolve();
        }
        function errorHandler(e, err) {
          offHandler();
          reject(err);
        }
        self2.one("fullscreenchange", changeHandler);
        self2.one("fullscreenerror", errorHandler);
        var promise = self2.requestFullscreenHelper_(fullscreenOptions);
        if (promise) {
          promise.then(offHandler, offHandler);
          promise.then(resolve, reject);
        }
      });
    }
    return this.requestFullscreenHelper_();
  };
  _proto.requestFullscreenHelper_ = function requestFullscreenHelper_(fullscreenOptions) {
    var _this12 = this;
    var fsOptions;
    if (!this.fsApi_.prefixed) {
      fsOptions = this.options_.fullscreen && this.options_.fullscreen.options || {};
      if (fullscreenOptions !== void 0) {
        fsOptions = fullscreenOptions;
      }
    }
    if (this.fsApi_.requestFullscreen) {
      var promise = this.el_[this.fsApi_.requestFullscreen](fsOptions);
      if (promise) {
        promise.then(function() {
          return _this12.isFullscreen(true);
        }, function() {
          return _this12.isFullscreen(false);
        });
      }
      return promise;
    } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {
      this.techCall_("enterFullScreen");
    } else {
      this.enterFullWindow();
    }
  };
  _proto.exitFullscreen = function exitFullscreen() {
    var PromiseClass = this.options_.Promise || import_window6.default.Promise;
    if (PromiseClass) {
      var self2 = this;
      return new PromiseClass(function(resolve, reject) {
        function offHandler() {
          self2.off("fullscreenerror", errorHandler);
          self2.off("fullscreenchange", changeHandler);
        }
        function changeHandler() {
          offHandler();
          resolve();
        }
        function errorHandler(e, err) {
          offHandler();
          reject(err);
        }
        self2.one("fullscreenchange", changeHandler);
        self2.one("fullscreenerror", errorHandler);
        var promise = self2.exitFullscreenHelper_();
        if (promise) {
          promise.then(offHandler, offHandler);
          promise.then(resolve, reject);
        }
      });
    }
    return this.exitFullscreenHelper_();
  };
  _proto.exitFullscreenHelper_ = function exitFullscreenHelper_() {
    var _this13 = this;
    if (this.fsApi_.requestFullscreen) {
      var promise = import_document.default[this.fsApi_.exitFullscreen]();
      if (promise) {
        silencePromise(promise.then(function() {
          return _this13.isFullscreen(false);
        }));
      }
      return promise;
    } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {
      this.techCall_("exitFullScreen");
    } else {
      this.exitFullWindow();
    }
  };
  _proto.enterFullWindow = function enterFullWindow() {
    this.isFullscreen(true);
    this.isFullWindow = true;
    this.docOrigOverflow = import_document.default.documentElement.style.overflow;
    on(import_document.default, "keydown", this.boundFullWindowOnEscKey_);
    import_document.default.documentElement.style.overflow = "hidden";
    addClass(import_document.default.body, "vjs-full-window");
    this.trigger("enterFullWindow");
  };
  _proto.fullWindowOnEscKey = function fullWindowOnEscKey(event) {
    if (import_keycode.default.isEventKey(event, "Esc")) {
      if (this.isFullscreen() === true) {
        if (!this.isFullWindow) {
          this.exitFullscreen();
        } else {
          this.exitFullWindow();
        }
      }
    }
  };
  _proto.exitFullWindow = function exitFullWindow() {
    this.isFullscreen(false);
    this.isFullWindow = false;
    off(import_document.default, "keydown", this.boundFullWindowOnEscKey_);
    import_document.default.documentElement.style.overflow = this.docOrigOverflow;
    removeClass(import_document.default.body, "vjs-full-window");
    this.trigger("exitFullWindow");
  };
  _proto.disablePictureInPicture = function disablePictureInPicture(value) {
    if (value === void 0) {
      return this.techGet_("disablePictureInPicture");
    }
    this.techCall_("setDisablePictureInPicture", value);
    this.options_.disablePictureInPicture = value;
    this.trigger("disablepictureinpicturechanged");
  };
  _proto.isInPictureInPicture = function isInPictureInPicture(isPiP) {
    if (isPiP !== void 0) {
      this.isInPictureInPicture_ = !!isPiP;
      this.togglePictureInPictureClass_();
      return;
    }
    return !!this.isInPictureInPicture_;
  };
  _proto.requestPictureInPicture = function requestPictureInPicture() {
    if ("pictureInPictureEnabled" in import_document.default && this.disablePictureInPicture() === false) {
      return this.techGet_("requestPictureInPicture");
    }
  };
  _proto.exitPictureInPicture = function exitPictureInPicture() {
    if ("pictureInPictureEnabled" in import_document.default) {
      return import_document.default.exitPictureInPicture();
    }
  };
  _proto.handleKeyDown = function handleKeyDown(event) {
    var userActions = this.options_.userActions;
    if (!userActions || !userActions.hotkeys) {
      return;
    }
    var excludeElement = function excludeElement2(el) {
      var tagName = el.tagName.toLowerCase();
      if (el.isContentEditable) {
        return true;
      }
      var allowedInputTypes = ["button", "checkbox", "hidden", "radio", "reset", "submit"];
      if (tagName === "input") {
        return allowedInputTypes.indexOf(el.type) === -1;
      }
      var excludedTags = ["textarea"];
      return excludedTags.indexOf(tagName) !== -1;
    };
    if (excludeElement(this.el_.ownerDocument.activeElement)) {
      return;
    }
    if (typeof userActions.hotkeys === "function") {
      userActions.hotkeys.call(this, event);
    } else {
      this.handleHotkeys(event);
    }
  };
  _proto.handleHotkeys = function handleHotkeys(event) {
    var hotkeys = this.options_.userActions ? this.options_.userActions.hotkeys : {};
    var _hotkeys$fullscreenKe = hotkeys.fullscreenKey, fullscreenKey = _hotkeys$fullscreenKe === void 0 ? function(keydownEvent) {
      return import_keycode.default.isEventKey(keydownEvent, "f");
    } : _hotkeys$fullscreenKe, _hotkeys$muteKey = hotkeys.muteKey, muteKey = _hotkeys$muteKey === void 0 ? function(keydownEvent) {
      return import_keycode.default.isEventKey(keydownEvent, "m");
    } : _hotkeys$muteKey, _hotkeys$playPauseKey = hotkeys.playPauseKey, playPauseKey = _hotkeys$playPauseKey === void 0 ? function(keydownEvent) {
      return import_keycode.default.isEventKey(keydownEvent, "k") || import_keycode.default.isEventKey(keydownEvent, "Space");
    } : _hotkeys$playPauseKey;
    if (fullscreenKey.call(this, event)) {
      event.preventDefault();
      event.stopPropagation();
      var FSToggle = Component$1.getComponent("FullscreenToggle");
      if (import_document.default[this.fsApi_.fullscreenEnabled] !== false) {
        FSToggle.prototype.handleClick.call(this, event);
      }
    } else if (muteKey.call(this, event)) {
      event.preventDefault();
      event.stopPropagation();
      var MuteToggle2 = Component$1.getComponent("MuteToggle");
      MuteToggle2.prototype.handleClick.call(this, event);
    } else if (playPauseKey.call(this, event)) {
      event.preventDefault();
      event.stopPropagation();
      var PlayToggle2 = Component$1.getComponent("PlayToggle");
      PlayToggle2.prototype.handleClick.call(this, event);
    }
  };
  _proto.canPlayType = function canPlayType3(type2) {
    var can;
    for (var i = 0, j = this.options_.techOrder; i < j.length; i++) {
      var techName = j[i];
      var tech = Tech.getTech(techName);
      if (!tech) {
        tech = Component$1.getComponent(techName);
      }
      if (!tech) {
        log$1.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
        continue;
      }
      if (tech.isSupported()) {
        can = tech.canPlayType(type2);
        if (can) {
          return can;
        }
      }
    }
    return "";
  };
  _proto.selectSource = function selectSource(sources) {
    var _this14 = this;
    var techs = this.options_.techOrder.map(function(techName) {
      return [techName, Tech.getTech(techName)];
    }).filter(function(_ref) {
      var techName = _ref[0], tech = _ref[1];
      if (tech) {
        return tech.isSupported();
      }
      log$1.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
      return false;
    });
    var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair2(outerArray, innerArray, tester) {
      var found;
      outerArray.some(function(outerChoice) {
        return innerArray.some(function(innerChoice) {
          found = tester(outerChoice, innerChoice);
          if (found) {
            return true;
          }
        });
      });
      return found;
    };
    var foundSourceAndTech;
    var flip = function flip2(fn) {
      return function(a, b) {
        return fn(b, a);
      };
    };
    var finder = function finder2(_ref2, source) {
      var techName = _ref2[0], tech = _ref2[1];
      if (tech.canPlaySource(source, _this14.options_[techName.toLowerCase()])) {
        return {
          source,
          tech: techName
        };
      }
    };
    if (this.options_.sourceOrder) {
      foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));
    } else {
      foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);
    }
    return foundSourceAndTech || false;
  };
  _proto.handleSrc_ = function handleSrc_(source, isRetry) {
    var _this15 = this;
    if (typeof source === "undefined") {
      return this.cache_.src || "";
    }
    if (this.resetRetryOnError_) {
      this.resetRetryOnError_();
    }
    var sources = filterSource(source);
    if (!sources.length) {
      this.setTimeout(function() {
        this.error({
          code: 4,
          message: this.options_.notSupportedMessage
        });
      }, 0);
      return;
    }
    this.changingSrc_ = true;
    if (!isRetry) {
      this.cache_.sources = sources;
    }
    this.updateSourceCaches_(sources[0]);
    setSource(this, sources[0], function(middlewareSource, mws) {
      _this15.middleware_ = mws;
      if (!isRetry) {
        _this15.cache_.sources = sources;
      }
      _this15.updateSourceCaches_(middlewareSource);
      var err = _this15.src_(middlewareSource);
      if (err) {
        if (sources.length > 1) {
          return _this15.handleSrc_(sources.slice(1));
        }
        _this15.changingSrc_ = false;
        _this15.setTimeout(function() {
          this.error({
            code: 4,
            message: this.options_.notSupportedMessage
          });
        }, 0);
        _this15.triggerReady();
        return;
      }
      setTech(mws, _this15.tech_);
    });
    if (this.options_.retryOnError && sources.length > 1) {
      var retry = function retry2() {
        _this15.error(null);
        _this15.handleSrc_(sources.slice(1), true);
      };
      var stopListeningForErrors = function stopListeningForErrors2() {
        _this15.off("error", retry);
      };
      this.one("error", retry);
      this.one("playing", stopListeningForErrors);
      this.resetRetryOnError_ = function() {
        _this15.off("error", retry);
        _this15.off("playing", stopListeningForErrors);
      };
    }
  };
  _proto.src = function src(source) {
    return this.handleSrc_(source, false);
  };
  _proto.src_ = function src_(source) {
    var _this16 = this;
    var sourceTech = this.selectSource([source]);
    if (!sourceTech) {
      return true;
    }
    if (!titleCaseEquals(sourceTech.tech, this.techName_)) {
      this.changingSrc_ = true;
      this.loadTech_(sourceTech.tech, sourceTech.source);
      this.tech_.ready(function() {
        _this16.changingSrc_ = false;
      });
      return false;
    }
    this.ready(function() {
      if (this.tech_.constructor.prototype.hasOwnProperty("setSource")) {
        this.techCall_("setSource", source);
      } else {
        this.techCall_("src", source.src);
      }
      this.changingSrc_ = false;
    }, true);
    return false;
  };
  _proto.load = function load() {
    this.techCall_("load");
  };
  _proto.reset = function reset3() {
    var _this17 = this;
    var PromiseClass = this.options_.Promise || import_window6.default.Promise;
    if (this.paused() || !PromiseClass) {
      this.doReset_();
    } else {
      var playPromise = this.play();
      silencePromise(playPromise.then(function() {
        return _this17.doReset_();
      }));
    }
  };
  _proto.doReset_ = function doReset_() {
    if (this.tech_) {
      this.tech_.clearTracks("text");
    }
    this.resetCache_();
    this.poster("");
    this.loadTech_(this.options_.techOrder[0], null);
    this.techCall_("reset");
    this.resetControlBarUI_();
    if (isEvented(this)) {
      this.trigger("playerreset");
    }
  };
  _proto.resetControlBarUI_ = function resetControlBarUI_() {
    this.resetProgressBar_();
    this.resetPlaybackRate_();
    this.resetVolumeBar_();
  };
  _proto.resetProgressBar_ = function resetProgressBar_() {
    this.currentTime(0);
    var _ref3 = this.controlBar || {}, durationDisplay = _ref3.durationDisplay, remainingTimeDisplay = _ref3.remainingTimeDisplay;
    if (durationDisplay) {
      durationDisplay.updateContent();
    }
    if (remainingTimeDisplay) {
      remainingTimeDisplay.updateContent();
    }
  };
  _proto.resetPlaybackRate_ = function resetPlaybackRate_() {
    this.playbackRate(this.defaultPlaybackRate());
    this.handleTechRateChange_();
  };
  _proto.resetVolumeBar_ = function resetVolumeBar_() {
    this.volume(1);
    this.trigger("volumechange");
  };
  _proto.currentSources = function currentSources() {
    var source = this.currentSource();
    var sources = [];
    if (Object.keys(source).length !== 0) {
      sources.push(source);
    }
    return this.cache_.sources || sources;
  };
  _proto.currentSource = function currentSource() {
    return this.cache_.source || {};
  };
  _proto.currentSrc = function currentSrc() {
    return this.currentSource() && this.currentSource().src || "";
  };
  _proto.currentType = function currentType() {
    return this.currentSource() && this.currentSource().type || "";
  };
  _proto.preload = function preload(value) {
    if (value !== void 0) {
      this.techCall_("setPreload", value);
      this.options_.preload = value;
      return;
    }
    return this.techGet_("preload");
  };
  _proto.autoplay = function autoplay(value) {
    if (value === void 0) {
      return this.options_.autoplay || false;
    }
    var techAutoplay;
    if (typeof value === "string" && /(any|play|muted)/.test(value) || value === true && this.options_.normalizeAutoplay) {
      this.options_.autoplay = value;
      this.manualAutoplay_(typeof value === "string" ? value : "play");
      techAutoplay = false;
    } else if (!value) {
      this.options_.autoplay = false;
    } else {
      this.options_.autoplay = true;
    }
    techAutoplay = typeof techAutoplay === "undefined" ? this.options_.autoplay : techAutoplay;
    if (this.tech_) {
      this.techCall_("setAutoplay", techAutoplay);
    }
  };
  _proto.playsinline = function playsinline(value) {
    if (value !== void 0) {
      this.techCall_("setPlaysinline", value);
      this.options_.playsinline = value;
      return this;
    }
    return this.techGet_("playsinline");
  };
  _proto.loop = function loop(value) {
    if (value !== void 0) {
      this.techCall_("setLoop", value);
      this.options_.loop = value;
      return;
    }
    return this.techGet_("loop");
  };
  _proto.poster = function poster(src) {
    if (src === void 0) {
      return this.poster_;
    }
    if (!src) {
      src = "";
    }
    if (src === this.poster_) {
      return;
    }
    this.poster_ = src;
    this.techCall_("setPoster", src);
    this.isPosterFromTech_ = false;
    this.trigger("posterchange");
  };
  _proto.handleTechPosterChange_ = function handleTechPosterChange_() {
    if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
      var newPoster = this.tech_.poster() || "";
      if (newPoster !== this.poster_) {
        this.poster_ = newPoster;
        this.isPosterFromTech_ = true;
        this.trigger("posterchange");
      }
    }
  };
  _proto.controls = function controls(bool) {
    if (bool === void 0) {
      return !!this.controls_;
    }
    bool = !!bool;
    if (this.controls_ === bool) {
      return;
    }
    this.controls_ = bool;
    if (this.usingNativeControls()) {
      this.techCall_("setControls", bool);
    }
    if (this.controls_) {
      this.removeClass("vjs-controls-disabled");
      this.addClass("vjs-controls-enabled");
      this.trigger("controlsenabled");
      if (!this.usingNativeControls()) {
        this.addTechControlsListeners_();
      }
    } else {
      this.removeClass("vjs-controls-enabled");
      this.addClass("vjs-controls-disabled");
      this.trigger("controlsdisabled");
      if (!this.usingNativeControls()) {
        this.removeTechControlsListeners_();
      }
    }
  };
  _proto.usingNativeControls = function usingNativeControls(bool) {
    if (bool === void 0) {
      return !!this.usingNativeControls_;
    }
    bool = !!bool;
    if (this.usingNativeControls_ === bool) {
      return;
    }
    this.usingNativeControls_ = bool;
    if (this.usingNativeControls_) {
      this.addClass("vjs-using-native-controls");
      this.trigger("usingnativecontrols");
    } else {
      this.removeClass("vjs-using-native-controls");
      this.trigger("usingcustomcontrols");
    }
  };
  _proto.error = function error(err) {
    var _this18 = this;
    if (err === void 0) {
      return this.error_ || null;
    }
    hooks("beforeerror").forEach(function(hookFunction) {
      var newErr = hookFunction(_this18, err);
      if (!(isObject3(newErr) && !Array.isArray(newErr) || typeof newErr === "string" || typeof newErr === "number" || newErr === null)) {
        _this18.log.error("please return a value that MediaError expects in beforeerror hooks");
        return;
      }
      err = newErr;
    });
    if (this.options_.suppressNotSupportedError && err && err.code === 4) {
      var triggerSuppressedError = function triggerSuppressedError2() {
        this.error(err);
      };
      this.options_.suppressNotSupportedError = false;
      this.any(["click", "touchstart"], triggerSuppressedError);
      this.one("loadstart", function() {
        this.off(["click", "touchstart"], triggerSuppressedError);
      });
      return;
    }
    if (err === null) {
      this.error_ = err;
      this.removeClass("vjs-error");
      if (this.errorDisplay) {
        this.errorDisplay.close();
      }
      return;
    }
    this.error_ = new MediaError(err);
    this.addClass("vjs-error");
    log$1.error("(CODE:" + this.error_.code + " " + MediaError.errorTypes[this.error_.code] + ")", this.error_.message, this.error_);
    this.trigger("error");
    hooks("error").forEach(function(hookFunction) {
      return hookFunction(_this18, _this18.error_);
    });
    return;
  };
  _proto.reportUserActivity = function reportUserActivity(event) {
    this.userActivity_ = true;
  };
  _proto.userActive = function userActive(bool) {
    if (bool === void 0) {
      return this.userActive_;
    }
    bool = !!bool;
    if (bool === this.userActive_) {
      return;
    }
    this.userActive_ = bool;
    if (this.userActive_) {
      this.userActivity_ = true;
      this.removeClass("vjs-user-inactive");
      this.addClass("vjs-user-active");
      this.trigger("useractive");
      return;
    }
    if (this.tech_) {
      this.tech_.one("mousemove", function(e) {
        e.stopPropagation();
        e.preventDefault();
      });
    }
    this.userActivity_ = false;
    this.removeClass("vjs-user-active");
    this.addClass("vjs-user-inactive");
    this.trigger("userinactive");
  };
  _proto.listenForUserActivity_ = function listenForUserActivity_() {
    var mouseInProgress;
    var lastMoveX;
    var lastMoveY;
    var handleActivity = bind(this, this.reportUserActivity);
    var handleMouseMove = function handleMouseMove2(e) {
      if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
        lastMoveX = e.screenX;
        lastMoveY = e.screenY;
        handleActivity();
      }
    };
    var handleMouseDown = function handleMouseDown2() {
      handleActivity();
      this.clearInterval(mouseInProgress);
      mouseInProgress = this.setInterval(handleActivity, 250);
    };
    var handleMouseUpAndMouseLeave = function handleMouseUpAndMouseLeave2(event) {
      handleActivity();
      this.clearInterval(mouseInProgress);
    };
    this.on("mousedown", handleMouseDown);
    this.on("mousemove", handleMouseMove);
    this.on("mouseup", handleMouseUpAndMouseLeave);
    this.on("mouseleave", handleMouseUpAndMouseLeave);
    var controlBar = this.getChild("controlBar");
    if (controlBar && !IS_IOS && !IS_ANDROID) {
      controlBar.on("mouseenter", function(event) {
        if (this.player().options_.inactivityTimeout !== 0) {
          this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout;
        }
        this.player().options_.inactivityTimeout = 0;
      });
      controlBar.on("mouseleave", function(event) {
        this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;
      });
    }
    this.on("keydown", handleActivity);
    this.on("keyup", handleActivity);
    var inactivityTimeout;
    this.setInterval(function() {
      if (!this.userActivity_) {
        return;
      }
      this.userActivity_ = false;
      this.userActive(true);
      this.clearTimeout(inactivityTimeout);
      var timeout = this.options_.inactivityTimeout;
      if (timeout <= 0) {
        return;
      }
      inactivityTimeout = this.setTimeout(function() {
        if (!this.userActivity_) {
          this.userActive(false);
        }
      }, timeout);
    }, 250);
  };
  _proto.playbackRate = function playbackRate(rate) {
    if (rate !== void 0) {
      this.techCall_("setPlaybackRate", rate);
      return;
    }
    if (this.tech_ && this.tech_.featuresPlaybackRate) {
      return this.cache_.lastPlaybackRate || this.techGet_("playbackRate");
    }
    return 1;
  };
  _proto.defaultPlaybackRate = function defaultPlaybackRate(rate) {
    if (rate !== void 0) {
      return this.techCall_("setDefaultPlaybackRate", rate);
    }
    if (this.tech_ && this.tech_.featuresPlaybackRate) {
      return this.techGet_("defaultPlaybackRate");
    }
    return 1;
  };
  _proto.isAudio = function isAudio(bool) {
    if (bool !== void 0) {
      this.isAudio_ = !!bool;
      return;
    }
    return !!this.isAudio_;
  };
  _proto.enableAudioOnlyUI_ = function enableAudioOnlyUI_() {
    var _this19 = this;
    this.addClass("vjs-audio-only-mode");
    var playerChildren = this.children();
    var controlBar = this.getChild("ControlBar");
    var controlBarHeight = controlBar && controlBar.currentHeight();
    playerChildren.forEach(function(child) {
      if (child === controlBar) {
        return;
      }
      if (child.el_ && !child.hasClass("vjs-hidden")) {
        child.hide();
        _this19.audioOnlyCache_.hiddenChildren.push(child);
      }
    });
    this.audioOnlyCache_.playerHeight = this.currentHeight();
    this.height(controlBarHeight);
    this.trigger("audioonlymodechange");
  };
  _proto.disableAudioOnlyUI_ = function disableAudioOnlyUI_() {
    this.removeClass("vjs-audio-only-mode");
    this.audioOnlyCache_.hiddenChildren.forEach(function(child) {
      return child.show();
    });
    this.height(this.audioOnlyCache_.playerHeight);
    this.trigger("audioonlymodechange");
  };
  _proto.audioOnlyMode = function audioOnlyMode(value) {
    var _this20 = this;
    if (typeof value !== "boolean" || value === this.audioOnlyMode_) {
      return this.audioOnlyMode_;
    }
    this.audioOnlyMode_ = value;
    var PromiseClass = this.options_.Promise || import_window6.default.Promise;
    if (PromiseClass) {
      if (value) {
        var exitPromises = [];
        if (this.isInPictureInPicture()) {
          exitPromises.push(this.exitPictureInPicture());
        }
        if (this.isFullscreen()) {
          exitPromises.push(this.exitFullscreen());
        }
        if (this.audioPosterMode()) {
          exitPromises.push(this.audioPosterMode(false));
        }
        return PromiseClass.all(exitPromises).then(function() {
          return _this20.enableAudioOnlyUI_();
        });
      }
      return PromiseClass.resolve().then(function() {
        return _this20.disableAudioOnlyUI_();
      });
    }
    if (value) {
      if (this.isInPictureInPicture()) {
        this.exitPictureInPicture();
      }
      if (this.isFullscreen()) {
        this.exitFullscreen();
      }
      this.enableAudioOnlyUI_();
    } else {
      this.disableAudioOnlyUI_();
    }
  };
  _proto.enablePosterModeUI_ = function enablePosterModeUI_() {
    var tech = this.tech_ && this.tech_;
    tech.hide();
    this.addClass("vjs-audio-poster-mode");
    this.trigger("audiopostermodechange");
  };
  _proto.disablePosterModeUI_ = function disablePosterModeUI_() {
    var tech = this.tech_ && this.tech_;
    tech.show();
    this.removeClass("vjs-audio-poster-mode");
    this.trigger("audiopostermodechange");
  };
  _proto.audioPosterMode = function audioPosterMode(value) {
    var _this21 = this;
    if (typeof value !== "boolean" || value === this.audioPosterMode_) {
      return this.audioPosterMode_;
    }
    this.audioPosterMode_ = value;
    var PromiseClass = this.options_.Promise || import_window6.default.Promise;
    if (PromiseClass) {
      if (value) {
        if (this.audioOnlyMode()) {
          var audioOnlyModePromise = this.audioOnlyMode(false);
          return audioOnlyModePromise.then(function() {
            _this21.enablePosterModeUI_();
          });
        }
        return PromiseClass.resolve().then(function() {
          _this21.enablePosterModeUI_();
        });
      }
      return PromiseClass.resolve().then(function() {
        _this21.disablePosterModeUI_();
      });
    }
    if (value) {
      if (this.audioOnlyMode()) {
        this.audioOnlyMode(false);
      }
      this.enablePosterModeUI_();
      return;
    }
    this.disablePosterModeUI_();
  };
  _proto.addTextTrack = function addTextTrack(kind, label, language) {
    if (this.tech_) {
      return this.tech_.addTextTrack(kind, label, language);
    }
  };
  _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    if (this.tech_) {
      return this.tech_.addRemoteTextTrack(options, manualCleanup);
    }
  };
  _proto.removeRemoteTextTrack = function removeRemoteTextTrack(obj) {
    if (obj === void 0) {
      obj = {};
    }
    var _obj = obj, track = _obj.track;
    if (!track) {
      track = obj;
    }
    if (this.tech_) {
      return this.tech_.removeRemoteTextTrack(track);
    }
  };
  _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    return this.techGet_("getVideoPlaybackQuality");
  };
  _proto.videoWidth = function videoWidth() {
    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
  };
  _proto.videoHeight = function videoHeight() {
    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
  };
  _proto.language = function language(code) {
    if (code === void 0) {
      return this.language_;
    }
    if (this.language_ !== String(code).toLowerCase()) {
      this.language_ = String(code).toLowerCase();
      if (isEvented(this)) {
        this.trigger("languagechange");
      }
    }
  };
  _proto.languages = function languages() {
    return mergeOptions$3(Player2.prototype.options_.languages, this.languages_);
  };
  _proto.toJSON = function toJSON() {
    var options = mergeOptions$3(this.options_);
    var tracks = options.tracks;
    options.tracks = [];
    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];
      track = mergeOptions$3(track);
      track.player = void 0;
      options.tracks[i] = track;
    }
    return options;
  };
  _proto.createModal = function createModal(content, options) {
    var _this22 = this;
    options = options || {};
    options.content = content || "";
    var modal = new ModalDialog(this, options);
    this.addChild(modal);
    modal.on("dispose", function() {
      _this22.removeChild(modal);
    });
    modal.open();
    return modal;
  };
  _proto.updateCurrentBreakpoint_ = function updateCurrentBreakpoint_() {
    if (!this.responsive()) {
      return;
    }
    var currentBreakpoint = this.currentBreakpoint();
    var currentWidth = this.currentWidth();
    for (var i = 0; i < BREAKPOINT_ORDER.length; i++) {
      var candidateBreakpoint = BREAKPOINT_ORDER[i];
      var maxWidth = this.breakpoints_[candidateBreakpoint];
      if (currentWidth <= maxWidth) {
        if (currentBreakpoint === candidateBreakpoint) {
          return;
        }
        if (currentBreakpoint) {
          this.removeClass(BREAKPOINT_CLASSES[currentBreakpoint]);
        }
        this.addClass(BREAKPOINT_CLASSES[candidateBreakpoint]);
        this.breakpoint_ = candidateBreakpoint;
        break;
      }
    }
  };
  _proto.removeCurrentBreakpoint_ = function removeCurrentBreakpoint_() {
    var className = this.currentBreakpointClass();
    this.breakpoint_ = "";
    if (className) {
      this.removeClass(className);
    }
  };
  _proto.breakpoints = function breakpoints(_breakpoints) {
    if (_breakpoints === void 0) {
      return assign(this.breakpoints_);
    }
    this.breakpoint_ = "";
    this.breakpoints_ = assign({}, DEFAULT_BREAKPOINTS, _breakpoints);
    this.updateCurrentBreakpoint_();
    return assign(this.breakpoints_);
  };
  _proto.responsive = function responsive(value) {
    if (value === void 0) {
      return this.responsive_;
    }
    value = Boolean(value);
    var current = this.responsive_;
    if (value === current) {
      return;
    }
    this.responsive_ = value;
    if (value) {
      this.on("playerresize", this.boundUpdateCurrentBreakpoint_);
      this.updateCurrentBreakpoint_();
    } else {
      this.off("playerresize", this.boundUpdateCurrentBreakpoint_);
      this.removeCurrentBreakpoint_();
    }
    return value;
  };
  _proto.currentBreakpoint = function currentBreakpoint() {
    return this.breakpoint_;
  };
  _proto.currentBreakpointClass = function currentBreakpointClass() {
    return BREAKPOINT_CLASSES[this.breakpoint_] || "";
  };
  _proto.loadMedia = function loadMedia(media, ready) {
    var _this23 = this;
    if (!media || typeof media !== "object") {
      return;
    }
    this.reset();
    this.cache_.media = mergeOptions$3(media);
    var _this$cache_$media = this.cache_.media, artwork = _this$cache_$media.artwork, poster = _this$cache_$media.poster, src = _this$cache_$media.src, textTracks = _this$cache_$media.textTracks;
    if (!artwork && poster) {
      this.cache_.media.artwork = [{
        src: poster,
        type: getMimetype(poster)
      }];
    }
    if (src) {
      this.src(src);
    }
    if (poster) {
      this.poster(poster);
    }
    if (Array.isArray(textTracks)) {
      textTracks.forEach(function(tt) {
        return _this23.addRemoteTextTrack(tt, false);
      });
    }
    this.ready(ready);
  };
  _proto.getMedia = function getMedia() {
    if (!this.cache_.media) {
      var poster = this.poster();
      var src = this.currentSources();
      var textTracks = Array.prototype.map.call(this.remoteTextTracks(), function(tt) {
        return {
          kind: tt.kind,
          label: tt.label,
          language: tt.language,
          src: tt.src
        };
      });
      var media = {
        src,
        textTracks
      };
      if (poster) {
        media.poster = poster;
        media.artwork = [{
          src: media.poster,
          type: getMimetype(media.poster)
        }];
      }
      return media;
    }
    return mergeOptions$3(this.cache_.media);
  };
  Player2.getTagSettings = function getTagSettings(tag) {
    var baseOptions = {
      sources: [],
      tracks: []
    };
    var tagOptions = getAttributes(tag);
    var dataSetup = tagOptions["data-setup"];
    if (hasClass(tag, "vjs-fill")) {
      tagOptions.fill = true;
    }
    if (hasClass(tag, "vjs-fluid")) {
      tagOptions.fluid = true;
    }
    if (dataSetup !== null) {
      var _safeParseTuple = (0, import_tuple.default)(dataSetup || "{}"), err = _safeParseTuple[0], data = _safeParseTuple[1];
      if (err) {
        log$1.error(err);
      }
      assign(tagOptions, data);
    }
    assign(baseOptions, tagOptions);
    if (tag.hasChildNodes()) {
      var children = tag.childNodes;
      for (var i = 0, j = children.length; i < j; i++) {
        var child = children[i];
        var childName = child.nodeName.toLowerCase();
        if (childName === "source") {
          baseOptions.sources.push(getAttributes(child));
        } else if (childName === "track") {
          baseOptions.tracks.push(getAttributes(child));
        }
      }
    }
    return baseOptions;
  };
  _proto.flexNotSupported_ = function flexNotSupported_() {
    var elem = import_document.default.createElement("i");
    return !("flexBasis" in elem.style || "webkitFlexBasis" in elem.style || "mozFlexBasis" in elem.style || "msFlexBasis" in elem.style || // IE10-specific (2012 flex spec), available for completeness
    "msFlexOrder" in elem.style);
  };
  _proto.debug = function debug(enabled) {
    if (enabled === void 0) {
      return this.debugEnabled_;
    }
    if (enabled) {
      this.trigger("debugon");
      this.previousLogLevel_ = this.log.level;
      this.log.level("debug");
      this.debugEnabled_ = true;
    } else {
      this.trigger("debugoff");
      this.log.level(this.previousLogLevel_);
      this.previousLogLevel_ = void 0;
      this.debugEnabled_ = false;
    }
  };
  _proto.playbackRates = function playbackRates(newRates) {
    if (newRates === void 0) {
      return this.cache_.playbackRates;
    }
    if (!Array.isArray(newRates)) {
      return;
    }
    if (!newRates.every(function(rate) {
      return typeof rate === "number";
    })) {
      return;
    }
    this.cache_.playbackRates = newRates;
    this.trigger("playbackrateschange");
  };
  return Player2;
}(Component$1);
ALL.names.forEach(function(name) {
  var props = ALL[name];
  Player.prototype[props.getterName] = function() {
    if (this.tech_) {
      return this.tech_[props.getterName]();
    }
    this[props.privateName] = this[props.privateName] || new props.ListClass();
    return this[props.privateName];
  };
});
Player.prototype.crossorigin = Player.prototype.crossOrigin;
Player.players = {};
var navigator2 = import_window6.default.navigator;
Player.prototype.options_ = {
  // Default order of fallback technology
  techOrder: Tech.defaultTechOrder_,
  html5: {},
  // default inactivity timeout
  inactivityTimeout: 2e3,
  // default playback rates
  playbackRates: [],
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],
  liveui: false,
  // Included control sets
  children: ["mediaLoader", "posterImage", "textTrackDisplay", "loadingSpinner", "bigPlayButton", "liveTracker", "controlBar", "errorDisplay", "textTrackSettings", "resizeManager"],
  language: navigator2 && (navigator2.languages && navigator2.languages[0] || navigator2.userLanguage || navigator2.language) || "en",
  // locales and their language translations
  languages: {},
  // Default message to show when a video cannot be played.
  notSupportedMessage: "No compatible source was found for this media.",
  normalizeAutoplay: false,
  fullscreen: {
    options: {
      navigationUI: "hide"
    }
  },
  breakpoints: {},
  responsive: false,
  audioOnlyMode: false,
  audioPosterMode: false
};
[
  /**
   * Returns whether or not the player is in the "ended" state.
   *
   * @return {Boolean} True if the player is in the ended state, false if not.
   * @method Player#ended
   */
  "ended",
  /**
   * Returns whether or not the player is in the "seeking" state.
   *
   * @return {Boolean} True if the player is in the seeking state, false if not.
   * @method Player#seeking
   */
  "seeking",
  /**
   * Returns the TimeRanges of the media that are currently available
   * for seeking to.
   *
   * @return {TimeRanges} the seekable intervals of the media timeline
   * @method Player#seekable
   */
  "seekable",
  /**
   * Returns the current state of network activity for the element, from
   * the codes in the list below.
   * - NETWORK_EMPTY (numeric value 0)
   *   The element has not yet been initialised. All attributes are in
   *   their initial states.
   * - NETWORK_IDLE (numeric value 1)
   *   The element's resource selection algorithm is active and has
   *   selected a resource, but it is not actually using the network at
   *   this time.
   * - NETWORK_LOADING (numeric value 2)
   *   The user agent is actively trying to download data.
   * - NETWORK_NO_SOURCE (numeric value 3)
   *   The element's resource selection algorithm is active, but it has
   *   not yet found a resource to use.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
   * @return {number} the current network activity state
   * @method Player#networkState
   */
  "networkState",
  /**
   * Returns a value that expresses the current state of the element
   * with respect to rendering the current playback position, from the
   * codes in the list below.
   * - HAVE_NOTHING (numeric value 0)
   *   No information regarding the media resource is available.
   * - HAVE_METADATA (numeric value 1)
   *   Enough of the resource has been obtained that the duration of the
   *   resource is available.
   * - HAVE_CURRENT_DATA (numeric value 2)
   *   Data for the immediate current playback position is available.
   * - HAVE_FUTURE_DATA (numeric value 3)
   *   Data for the immediate current playback position is available, as
   *   well as enough data for the user agent to advance the current
   *   playback position in the direction of playback.
   * - HAVE_ENOUGH_DATA (numeric value 4)
   *   The user agent estimates that enough data is available for
   *   playback to proceed uninterrupted.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
   * @return {number} the current playback rendering state
   * @method Player#readyState
   */
  "readyState"
].forEach(function(fn) {
  Player.prototype[fn] = function() {
    return this.techGet_(fn);
  };
});
TECH_EVENTS_RETRIGGER.forEach(function(event) {
  Player.prototype["handleTech" + toTitleCase$1(event) + "_"] = function() {
    return this.trigger(event);
  };
});
Component$1.registerComponent("Player", Player);
var BASE_PLUGIN_NAME = "plugin";
var PLUGIN_CACHE_KEY = "activePlugins_";
var pluginStorage = {};
var pluginExists = function pluginExists2(name) {
  return pluginStorage.hasOwnProperty(name);
};
var getPlugin = function getPlugin2(name) {
  return pluginExists(name) ? pluginStorage[name] : void 0;
};
var markPluginAsActive = function markPluginAsActive2(player, name) {
  player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};
  player[PLUGIN_CACHE_KEY][name] = true;
};
var triggerSetupEvent = function triggerSetupEvent2(player, hash3, before) {
  var eventName = (before ? "before" : "") + "pluginsetup";
  player.trigger(eventName, hash3);
  player.trigger(eventName + ":" + hash3.name, hash3);
};
var createBasicPlugin = function createBasicPlugin2(name, plugin) {
  var basicPluginWrapper = function basicPluginWrapper2() {
    triggerSetupEvent(this, {
      name,
      plugin,
      instance: null
    }, true);
    var instance = plugin.apply(this, arguments);
    markPluginAsActive(this, name);
    triggerSetupEvent(this, {
      name,
      plugin,
      instance
    });
    return instance;
  };
  Object.keys(plugin).forEach(function(prop) {
    basicPluginWrapper[prop] = plugin[prop];
  });
  return basicPluginWrapper;
};
var createPluginFactory = function createPluginFactory2(name, PluginSubClass) {
  PluginSubClass.prototype.name = name;
  return function() {
    triggerSetupEvent(this, {
      name,
      plugin: PluginSubClass,
      instance: null
    }, true);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var instance = _construct(PluginSubClass, [this].concat(args));
    this[name] = function() {
      return instance;
    };
    triggerSetupEvent(this, instance.getEventHash());
    return instance;
  };
};
var Plugin = /* @__PURE__ */ function() {
  function Plugin3(player) {
    if (this.constructor === Plugin3) {
      throw new Error("Plugin must be sub-classed; not directly instantiated.");
    }
    this.player = player;
    if (!this.log) {
      this.log = this.player.log.createLogger(this.name);
    }
    evented(this);
    delete this.trigger;
    stateful(this, this.constructor.defaultState);
    markPluginAsActive(player, this.name);
    this.dispose = this.dispose.bind(this);
    player.on("dispose", this.dispose);
  }
  var _proto = Plugin3.prototype;
  _proto.version = function version5() {
    return this.constructor.VERSION;
  };
  _proto.getEventHash = function getEventHash(hash3) {
    if (hash3 === void 0) {
      hash3 = {};
    }
    hash3.name = this.name;
    hash3.plugin = this.constructor;
    hash3.instance = this;
    return hash3;
  };
  _proto.trigger = function trigger$12(event, hash3) {
    if (hash3 === void 0) {
      hash3 = {};
    }
    return trigger(this.eventBusEl_, event, this.getEventHash(hash3));
  };
  _proto.handleStateChanged = function handleStateChanged(e) {
  };
  _proto.dispose = function dispose() {
    var name = this.name, player = this.player;
    this.trigger("dispose");
    this.off();
    player.off("dispose", this.dispose);
    player[PLUGIN_CACHE_KEY][name] = false;
    this.player = this.state = null;
    player[name] = createPluginFactory(name, pluginStorage[name]);
  };
  Plugin3.isBasic = function isBasic(plugin) {
    var p = typeof plugin === "string" ? getPlugin(plugin) : plugin;
    return typeof p === "function" && !Plugin3.prototype.isPrototypeOf(p.prototype);
  };
  Plugin3.registerPlugin = function registerPlugin3(name, plugin) {
    if (typeof name !== "string") {
      throw new Error('Illegal plugin name, "' + name + '", must be a string, was ' + typeof name + ".");
    }
    if (pluginExists(name)) {
      log$1.warn('A plugin named "' + name + '" already exists. You may want to avoid re-registering plugins!');
    } else if (Player.prototype.hasOwnProperty(name)) {
      throw new Error('Illegal plugin name, "' + name + '", cannot share a name with an existing player method!');
    }
    if (typeof plugin !== "function") {
      throw new Error('Illegal plugin for "' + name + '", must be a function, was ' + typeof plugin + ".");
    }
    pluginStorage[name] = plugin;
    if (name !== BASE_PLUGIN_NAME) {
      if (Plugin3.isBasic(plugin)) {
        Player.prototype[name] = createBasicPlugin(name, plugin);
      } else {
        Player.prototype[name] = createPluginFactory(name, plugin);
      }
    }
    return plugin;
  };
  Plugin3.deregisterPlugin = function deregisterPlugin(name) {
    if (name === BASE_PLUGIN_NAME) {
      throw new Error("Cannot de-register base plugin.");
    }
    if (pluginExists(name)) {
      delete pluginStorage[name];
      delete Player.prototype[name];
    }
  };
  Plugin3.getPlugins = function getPlugins(names) {
    if (names === void 0) {
      names = Object.keys(pluginStorage);
    }
    var result;
    names.forEach(function(name) {
      var plugin = getPlugin(name);
      if (plugin) {
        result = result || {};
        result[name] = plugin;
      }
    });
    return result;
  };
  Plugin3.getPluginVersion = function getPluginVersion(name) {
    var plugin = getPlugin(name);
    return plugin && plugin.VERSION || "";
  };
  return Plugin3;
}();
Plugin.getPlugin = getPlugin;
Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;
Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);
Player.prototype.usingPlugin = function(name) {
  return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;
};
Player.prototype.hasPlugin = function(name) {
  return !!pluginExists(name);
};
var extend = function extend2(superClass, subClassMethods) {
  if (subClassMethods === void 0) {
    subClassMethods = {};
  }
  var subClass = function subClass2() {
    superClass.apply(this, arguments);
  };
  var methods = {};
  if (typeof subClassMethods === "object") {
    if (subClassMethods.constructor !== Object.prototype.constructor) {
      subClass = subClassMethods.constructor;
    }
    methods = subClassMethods;
  } else if (typeof subClassMethods === "function") {
    subClass = subClassMethods;
  }
  _inherits(subClass, superClass);
  if (superClass) {
    subClass.super_ = superClass;
  }
  for (var name in methods) {
    if (methods.hasOwnProperty(name)) {
      subClass.prototype[name] = methods[name];
    }
  }
  return subClass;
};
var normalizeId = function normalizeId2(id) {
  return id.indexOf("#") === 0 ? id.slice(1) : id;
};
function videojs(id, options, ready) {
  var player = videojs.getPlayer(id);
  if (player) {
    if (options) {
      log$1.warn('Player "' + id + '" is already initialised. Options will not be applied.');
    }
    if (ready) {
      player.ready(ready);
    }
    return player;
  }
  var el = typeof id === "string" ? $("#" + normalizeId(id)) : id;
  if (!isEl(el)) {
    throw new TypeError("The element or ID supplied is not valid. (videojs)");
  }
  if (!el.ownerDocument.defaultView || !el.ownerDocument.body.contains(el)) {
    log$1.warn("The element supplied is not included in the DOM");
  }
  options = options || {};
  if (options.restoreEl === true) {
    options.restoreEl = (el.parentNode && el.parentNode.hasAttribute("data-vjs-player") ? el.parentNode : el).cloneNode(true);
  }
  hooks("beforesetup").forEach(function(hookFunction) {
    var opts = hookFunction(el, mergeOptions$3(options));
    if (!isObject3(opts) || Array.isArray(opts)) {
      log$1.error("please return an object in beforesetup hooks");
      return;
    }
    options = mergeOptions$3(options, opts);
  });
  var PlayerComponent = Component$1.getComponent("Player");
  player = new PlayerComponent(el, options, ready);
  hooks("setup").forEach(function(hookFunction) {
    return hookFunction(player);
  });
  return player;
}
videojs.hooks_ = hooks_;
videojs.hooks = hooks;
videojs.hook = hook;
videojs.hookOnce = hookOnce;
videojs.removeHook = removeHook;
if (import_window6.default.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {
  style = $(".vjs-styles-defaults");
  if (!style) {
    style = createStyleElement("vjs-styles-defaults");
    head = $("head");
    if (head) {
      head.insertBefore(style, head.firstChild);
    }
    setTextContent(style, "\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: 56.25%\n      }\n    ");
  }
}
var style;
var head;
autoSetupTimeout(1, videojs);
videojs.VERSION = version$5;
videojs.options = Player.prototype.options_;
videojs.getPlayers = function() {
  return Player.players;
};
videojs.getPlayer = function(id) {
  var players = Player.players;
  var tag;
  if (typeof id === "string") {
    var nId = normalizeId(id);
    var player = players[nId];
    if (player) {
      return player;
    }
    tag = $("#" + nId);
  } else {
    tag = id;
  }
  if (isEl(tag)) {
    var _tag = tag, _player = _tag.player, playerId = _tag.playerId;
    if (_player || players[playerId]) {
      return _player || players[playerId];
    }
  }
};
videojs.getAllPlayers = function() {
  return (
    // Disposed players leave a key with a `null` value, so we need to make sure
    // we filter those out.
    Object.keys(Player.players).map(function(k) {
      return Player.players[k];
    }).filter(Boolean)
  );
};
videojs.players = Player.players;
videojs.getComponent = Component$1.getComponent;
videojs.registerComponent = function(name, comp) {
  if (Tech.isTech(comp)) {
    log$1.warn("The " + name + " tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)");
  }
  Component$1.registerComponent.call(Component$1, name, comp);
};
videojs.getTech = Tech.getTech;
videojs.registerTech = Tech.registerTech;
videojs.use = use;
Object.defineProperty(videojs, "middleware", {
  value: {},
  writeable: false,
  enumerable: true
});
Object.defineProperty(videojs.middleware, "TERMINATOR", {
  value: TERMINATOR,
  writeable: false,
  enumerable: true
});
videojs.browser = browser;
videojs.TOUCH_ENABLED = TOUCH_ENABLED;
videojs.extend = extend;
videojs.mergeOptions = mergeOptions$3;
videojs.bind = bind;
videojs.registerPlugin = Plugin.registerPlugin;
videojs.deregisterPlugin = Plugin.deregisterPlugin;
videojs.plugin = function(name, plugin) {
  log$1.warn("videojs.plugin() is deprecated; use videojs.registerPlugin() instead");
  return Plugin.registerPlugin(name, plugin);
};
videojs.getPlugins = Plugin.getPlugins;
videojs.getPlugin = Plugin.getPlugin;
videojs.getPluginVersion = Plugin.getPluginVersion;
videojs.addLanguage = function(code, data) {
  var _mergeOptions;
  code = ("" + code).toLowerCase();
  videojs.options.languages = mergeOptions$3(videojs.options.languages, (_mergeOptions = {}, _mergeOptions[code] = data, _mergeOptions));
  return videojs.options.languages[code];
};
videojs.log = log$1;
videojs.createLogger = createLogger;
videojs.createTimeRange = videojs.createTimeRanges = createTimeRanges;
videojs.formatTime = formatTime;
videojs.setFormatTime = setFormatTime;
videojs.resetFormatTime = resetFormatTime;
videojs.parseUrl = parseUrl;
videojs.isCrossOrigin = isCrossOrigin;
videojs.EventTarget = EventTarget$2;
videojs.on = on;
videojs.one = one;
videojs.off = off;
videojs.trigger = trigger;
videojs.xhr = import_xhr.default;
videojs.TextTrack = TextTrack;
videojs.AudioTrack = AudioTrack;
videojs.VideoTrack = VideoTrack;
["isEl", "isTextNode", "createEl", "hasClass", "addClass", "removeClass", "toggleClass", "setAttributes", "getAttributes", "emptyEl", "appendContent", "insertContent"].forEach(function(k) {
  videojs[k] = function() {
    log$1.warn("videojs." + k + "() is deprecated; use videojs.dom." + k + "() instead");
    return Dom[k].apply(null, arguments);
  };
});
videojs.computedStyle = computedStyle;
videojs.dom = Dom;
videojs.url = Url;
videojs.defineLazyProperty = defineLazyProperty;
videojs.addLanguage("en", {
  "Non-Fullscreen": "Exit Fullscreen"
});
var resolveUrl3 = resolve_url_default;
var resolveManifestRedirect = function resolveManifestRedirect2(handleManifestRedirect, url, req) {
  if (handleManifestRedirect && req && req.responseURL && url !== req.responseURL) {
    return req.responseURL;
  }
  return url;
};
var logger2 = function logger3(source) {
  if (videojs.log.debug) {
    return videojs.log.debug.bind(videojs, "VHS:", source + " >");
  }
  return function() {
  };
};
var TIME_FUDGE_FACTOR = 1 / 30;
var SAFE_TIME_DELTA = TIME_FUDGE_FACTOR * 3;
var filterRanges = function filterRanges2(timeRanges, predicate) {
  var results = [];
  var i;
  if (timeRanges && timeRanges.length) {
    for (i = 0; i < timeRanges.length; i++) {
      if (predicate(timeRanges.start(i), timeRanges.end(i))) {
        results.push([timeRanges.start(i), timeRanges.end(i)]);
      }
    }
  }
  return videojs.createTimeRanges(results);
};
var findRange = function findRange2(buffered, time) {
  return filterRanges(buffered, function(start2, end) {
    return start2 - SAFE_TIME_DELTA <= time && end + SAFE_TIME_DELTA >= time;
  });
};
var findNextRange = function findNextRange2(timeRanges, time) {
  return filterRanges(timeRanges, function(start2) {
    return start2 - TIME_FUDGE_FACTOR >= time;
  });
};
var findGaps = function findGaps2(buffered) {
  if (buffered.length < 2) {
    return videojs.createTimeRanges();
  }
  var ranges = [];
  for (var i = 1; i < buffered.length; i++) {
    var start2 = buffered.end(i - 1);
    var end = buffered.start(i);
    ranges.push([start2, end]);
  }
  return videojs.createTimeRanges(ranges);
};
var bufferIntersection = function bufferIntersection2(bufferA, bufferB) {
  var start2 = null;
  var end = null;
  var arity = 0;
  var extents = [];
  var ranges = [];
  if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) {
    return videojs.createTimeRange();
  }
  var count = bufferA.length;
  while (count--) {
    extents.push({
      time: bufferA.start(count),
      type: "start"
    });
    extents.push({
      time: bufferA.end(count),
      type: "end"
    });
  }
  count = bufferB.length;
  while (count--) {
    extents.push({
      time: bufferB.start(count),
      type: "start"
    });
    extents.push({
      time: bufferB.end(count),
      type: "end"
    });
  }
  extents.sort(function(a, b) {
    return a.time - b.time;
  });
  for (count = 0; count < extents.length; count++) {
    if (extents[count].type === "start") {
      arity++;
      if (arity === 2) {
        start2 = extents[count].time;
      }
    } else if (extents[count].type === "end") {
      arity--;
      if (arity === 1) {
        end = extents[count].time;
      }
    }
    if (start2 !== null && end !== null) {
      ranges.push([start2, end]);
      start2 = null;
      end = null;
    }
  }
  return videojs.createTimeRanges(ranges);
};
var printableRange = function printableRange2(range3) {
  var strArr = [];
  if (!range3 || !range3.length) {
    return "";
  }
  for (var i = 0; i < range3.length; i++) {
    strArr.push(range3.start(i) + " => " + range3.end(i));
  }
  return strArr.join(", ");
};
var timeUntilRebuffer = function timeUntilRebuffer2(buffered, currentTime, playbackRate) {
  if (playbackRate === void 0) {
    playbackRate = 1;
  }
  var bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;
  return (bufferedEnd - currentTime) / playbackRate;
};
var timeRangesToArray = function timeRangesToArray2(timeRanges) {
  var timeRangesList = [];
  for (var i = 0; i < timeRanges.length; i++) {
    timeRangesList.push({
      start: timeRanges.start(i),
      end: timeRanges.end(i)
    });
  }
  return timeRangesList;
};
var isRangeDifferent = function isRangeDifferent2(a, b) {
  if (a === b) {
    return false;
  }
  if (!a && b || !b && a) {
    return true;
  }
  if (a.length !== b.length) {
    return true;
  }
  for (var i = 0; i < a.length; i++) {
    if (a.start(i) !== b.start(i) || a.end(i) !== b.end(i)) {
      return true;
    }
  }
  return false;
};
var lastBufferedEnd = function lastBufferedEnd2(a) {
  if (!a || !a.length || !a.end) {
    return;
  }
  return a.end(a.length - 1);
};
var timeAheadOf = function timeAheadOf2(range3, startTime) {
  var time = 0;
  if (!range3 || !range3.length) {
    return time;
  }
  for (var i = 0; i < range3.length; i++) {
    var start2 = range3.start(i);
    var end = range3.end(i);
    if (startTime > end) {
      continue;
    }
    if (startTime > start2 && startTime <= end) {
      time += end - startTime;
      continue;
    }
    time += end - start2;
  }
  return time;
};
var createTimeRange = videojs.createTimeRange;
var segmentDurationWithParts = function segmentDurationWithParts2(playlist, segment) {
  if (!segment.preload) {
    return segment.duration;
  }
  var result = 0;
  (segment.parts || []).forEach(function(p) {
    result += p.duration;
  });
  (segment.preloadHints || []).forEach(function(p) {
    if (p.type === "PART") {
      result += playlist.partTargetDuration;
    }
  });
  return result;
};
var getPartsAndSegments = function getPartsAndSegments2(playlist) {
  return (playlist.segments || []).reduce(function(acc, segment, si) {
    if (segment.parts) {
      segment.parts.forEach(function(part, pi) {
        acc.push({
          duration: part.duration,
          segmentIndex: si,
          partIndex: pi,
          part,
          segment
        });
      });
    } else {
      acc.push({
        duration: segment.duration,
        segmentIndex: si,
        partIndex: null,
        segment,
        part: null
      });
    }
    return acc;
  }, []);
};
var getLastParts = function getLastParts2(media) {
  var lastSegment = media.segments && media.segments.length && media.segments[media.segments.length - 1];
  return lastSegment && lastSegment.parts || [];
};
var getKnownPartCount = function getKnownPartCount2(_ref) {
  var preloadSegment = _ref.preloadSegment;
  if (!preloadSegment) {
    return;
  }
  var parts = preloadSegment.parts, preloadHints = preloadSegment.preloadHints;
  var partCount = (preloadHints || []).reduce(function(count, hint) {
    return count + (hint.type === "PART" ? 1 : 0);
  }, 0);
  partCount += parts && parts.length ? parts.length : 0;
  return partCount;
};
var liveEdgeDelay = function liveEdgeDelay2(master, media) {
  if (media.endList) {
    return 0;
  }
  if (master && master.suggestedPresentationDelay) {
    return master.suggestedPresentationDelay;
  }
  var hasParts = getLastParts(media).length > 0;
  if (hasParts && media.serverControl && media.serverControl.partHoldBack) {
    return media.serverControl.partHoldBack;
  } else if (hasParts && media.partTargetDuration) {
    return media.partTargetDuration * 3;
  } else if (media.serverControl && media.serverControl.holdBack) {
    return media.serverControl.holdBack;
  } else if (media.targetDuration) {
    return media.targetDuration * 3;
  }
  return 0;
};
var backwardDuration = function backwardDuration2(playlist, endSequence) {
  var result = 0;
  var i = endSequence - playlist.mediaSequence;
  var segment = playlist.segments[i];
  if (segment) {
    if (typeof segment.start !== "undefined") {
      return {
        result: segment.start,
        precise: true
      };
    }
    if (typeof segment.end !== "undefined") {
      return {
        result: segment.end - segment.duration,
        precise: true
      };
    }
  }
  while (i--) {
    segment = playlist.segments[i];
    if (typeof segment.end !== "undefined") {
      return {
        result: result + segment.end,
        precise: true
      };
    }
    result += segmentDurationWithParts(playlist, segment);
    if (typeof segment.start !== "undefined") {
      return {
        result: result + segment.start,
        precise: true
      };
    }
  }
  return {
    result,
    precise: false
  };
};
var forwardDuration = function forwardDuration2(playlist, endSequence) {
  var result = 0;
  var segment;
  var i = endSequence - playlist.mediaSequence;
  for (; i < playlist.segments.length; i++) {
    segment = playlist.segments[i];
    if (typeof segment.start !== "undefined") {
      return {
        result: segment.start - result,
        precise: true
      };
    }
    result += segmentDurationWithParts(playlist, segment);
    if (typeof segment.end !== "undefined") {
      return {
        result: segment.end - result,
        precise: true
      };
    }
  }
  return {
    result: -1,
    precise: false
  };
};
var intervalDuration = function intervalDuration2(playlist, endSequence, expired) {
  if (typeof endSequence === "undefined") {
    endSequence = playlist.mediaSequence + playlist.segments.length;
  }
  if (endSequence < playlist.mediaSequence) {
    return 0;
  }
  var backward = backwardDuration(playlist, endSequence);
  if (backward.precise) {
    return backward.result;
  }
  var forward = forwardDuration(playlist, endSequence);
  if (forward.precise) {
    return forward.result;
  }
  return backward.result + expired;
};
var duration2 = function duration3(playlist, endSequence, expired) {
  if (!playlist) {
    return 0;
  }
  if (typeof expired !== "number") {
    expired = 0;
  }
  if (typeof endSequence === "undefined") {
    if (playlist.totalDuration) {
      return playlist.totalDuration;
    }
    if (!playlist.endList) {
      return import_window6.default.Infinity;
    }
  }
  return intervalDuration(playlist, endSequence, expired);
};
var sumDurations = function sumDurations2(_ref2) {
  var defaultDuration = _ref2.defaultDuration, durationList = _ref2.durationList, startIndex = _ref2.startIndex, endIndex = _ref2.endIndex;
  var durations = 0;
  if (startIndex > endIndex) {
    var _ref3 = [endIndex, startIndex];
    startIndex = _ref3[0];
    endIndex = _ref3[1];
  }
  if (startIndex < 0) {
    for (var i = startIndex; i < Math.min(0, endIndex); i++) {
      durations += defaultDuration;
    }
    startIndex = 0;
  }
  for (var _i = startIndex; _i < endIndex; _i++) {
    durations += durationList[_i].duration;
  }
  return durations;
};
var playlistEnd = function playlistEnd2(playlist, expired, useSafeLiveEnd, liveEdgePadding) {
  if (!playlist || !playlist.segments) {
    return null;
  }
  if (playlist.endList) {
    return duration2(playlist);
  }
  if (expired === null) {
    return null;
  }
  expired = expired || 0;
  var lastSegmentEndTime = intervalDuration(playlist, playlist.mediaSequence + playlist.segments.length, expired);
  if (useSafeLiveEnd) {
    liveEdgePadding = typeof liveEdgePadding === "number" ? liveEdgePadding : liveEdgeDelay(null, playlist);
    lastSegmentEndTime -= liveEdgePadding;
  }
  return Math.max(0, lastSegmentEndTime);
};
var seekable = function seekable2(playlist, expired, liveEdgePadding) {
  var useSafeLiveEnd = true;
  var seekableStart = expired || 0;
  var seekableEnd = playlistEnd(playlist, expired, useSafeLiveEnd, liveEdgePadding);
  if (seekableEnd === null) {
    return createTimeRange();
  }
  return createTimeRange(seekableStart, seekableEnd);
};
var getMediaInfoForTime = function getMediaInfoForTime2(_ref4) {
  var playlist = _ref4.playlist, currentTime = _ref4.currentTime, startingSegmentIndex = _ref4.startingSegmentIndex, startingPartIndex = _ref4.startingPartIndex, startTime = _ref4.startTime, experimentalExactManifestTimings = _ref4.experimentalExactManifestTimings;
  var time = currentTime - startTime;
  var partsAndSegments = getPartsAndSegments(playlist);
  var startIndex = 0;
  for (var i = 0; i < partsAndSegments.length; i++) {
    var partAndSegment = partsAndSegments[i];
    if (startingSegmentIndex !== partAndSegment.segmentIndex) {
      continue;
    }
    if (typeof startingPartIndex === "number" && typeof partAndSegment.partIndex === "number" && startingPartIndex !== partAndSegment.partIndex) {
      continue;
    }
    startIndex = i;
    break;
  }
  if (time < 0) {
    if (startIndex > 0) {
      for (var _i2 = startIndex - 1; _i2 >= 0; _i2--) {
        var _partAndSegment = partsAndSegments[_i2];
        time += _partAndSegment.duration;
        if (experimentalExactManifestTimings) {
          if (time < 0) {
            continue;
          }
        } else if (time + TIME_FUDGE_FACTOR <= 0) {
          continue;
        }
        return {
          partIndex: _partAndSegment.partIndex,
          segmentIndex: _partAndSegment.segmentIndex,
          startTime: startTime - sumDurations({
            defaultDuration: playlist.targetDuration,
            durationList: partsAndSegments,
            startIndex,
            endIndex: _i2
          })
        };
      }
    }
    return {
      partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
      segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
      startTime: currentTime
    };
  }
  if (startIndex < 0) {
    for (var _i3 = startIndex; _i3 < 0; _i3++) {
      time -= playlist.targetDuration;
      if (time < 0) {
        return {
          partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
          segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
          startTime: currentTime
        };
      }
    }
    startIndex = 0;
  }
  for (var _i4 = startIndex; _i4 < partsAndSegments.length; _i4++) {
    var _partAndSegment2 = partsAndSegments[_i4];
    time -= _partAndSegment2.duration;
    if (experimentalExactManifestTimings) {
      if (time > 0) {
        continue;
      }
    } else if (time - TIME_FUDGE_FACTOR >= 0) {
      continue;
    }
    return {
      partIndex: _partAndSegment2.partIndex,
      segmentIndex: _partAndSegment2.segmentIndex,
      startTime: startTime + sumDurations({
        defaultDuration: playlist.targetDuration,
        durationList: partsAndSegments,
        startIndex,
        endIndex: _i4
      })
    };
  }
  return {
    segmentIndex: partsAndSegments[partsAndSegments.length - 1].segmentIndex,
    partIndex: partsAndSegments[partsAndSegments.length - 1].partIndex,
    startTime: currentTime
  };
};
var isBlacklisted = function isBlacklisted2(playlist) {
  return playlist.excludeUntil && playlist.excludeUntil > Date.now();
};
var isIncompatible = function isIncompatible2(playlist) {
  return playlist.excludeUntil && playlist.excludeUntil === Infinity;
};
var isEnabled = function isEnabled2(playlist) {
  var blacklisted = isBlacklisted(playlist);
  return !playlist.disabled && !blacklisted;
};
var isDisabled = function isDisabled2(playlist) {
  return playlist.disabled;
};
var isAes = function isAes2(media) {
  for (var i = 0; i < media.segments.length; i++) {
    if (media.segments[i].key) {
      return true;
    }
  }
  return false;
};
var hasAttribute = function hasAttribute2(attr, playlist) {
  return playlist.attributes && playlist.attributes[attr];
};
var estimateSegmentRequestTime = function estimateSegmentRequestTime2(segmentDuration, bandwidth2, playlist, bytesReceived) {
  if (bytesReceived === void 0) {
    bytesReceived = 0;
  }
  if (!hasAttribute("BANDWIDTH", playlist)) {
    return NaN;
  }
  var size = segmentDuration * playlist.attributes.BANDWIDTH;
  return (size - bytesReceived * 8) / bandwidth2;
};
var isLowestEnabledRendition = function isLowestEnabledRendition2(master, media) {
  if (master.playlists.length === 1) {
    return true;
  }
  var currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;
  return master.playlists.filter(function(playlist) {
    if (!isEnabled(playlist)) {
      return false;
    }
    return (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;
  }).length === 0;
};
var playlistMatch = function playlistMatch2(a, b) {
  if (!a && !b || !a && b || a && !b) {
    return false;
  }
  if (a === b) {
    return true;
  }
  if (a.id && b.id && a.id === b.id) {
    return true;
  }
  if (a.resolvedUri && b.resolvedUri && a.resolvedUri === b.resolvedUri) {
    return true;
  }
  if (a.uri && b.uri && a.uri === b.uri) {
    return true;
  }
  return false;
};
var someAudioVariant = function someAudioVariant2(master, callback2) {
  var AUDIO5 = master && master.mediaGroups && master.mediaGroups.AUDIO || {};
  var found = false;
  for (var groupName in AUDIO5) {
    for (var label in AUDIO5[groupName]) {
      found = callback2(AUDIO5[groupName][label]);
      if (found) {
        break;
      }
    }
    if (found) {
      break;
    }
  }
  return !!found;
};
var isAudioOnly = function isAudioOnly2(master) {
  if (!master || !master.playlists || !master.playlists.length) {
    var found = someAudioVariant(master, function(variant) {
      return variant.playlists && variant.playlists.length || variant.uri;
    });
    return found;
  }
  var _loop = function _loop2(i2) {
    var playlist = master.playlists[i2];
    var CODECS = playlist.attributes && playlist.attributes.CODECS;
    if (CODECS && CODECS.split(",").every(function(c) {
      return isAudioCodec(c);
    })) {
      return "continue";
    }
    var found2 = someAudioVariant(master, function(variant) {
      return playlistMatch(playlist, variant);
    });
    if (found2) {
      return "continue";
    }
    return {
      v: false
    };
  };
  for (var i = 0; i < master.playlists.length; i++) {
    var _ret = _loop(i);
    if (_ret === "continue") continue;
    if (typeof _ret === "object") return _ret.v;
  }
  return true;
};
var Playlist = {
  liveEdgeDelay,
  duration: duration2,
  seekable,
  getMediaInfoForTime,
  isEnabled,
  isDisabled,
  isBlacklisted,
  isIncompatible,
  playlistEnd,
  isAes,
  hasAttribute,
  estimateSegmentRequestTime,
  isLowestEnabledRendition,
  isAudioOnly,
  playlistMatch,
  segmentDurationWithParts
};
var log = videojs.log;
var createPlaylistID = function createPlaylistID2(index, uri) {
  return index + "-" + uri;
};
var parseManifest = function parseManifest2(_ref) {
  var onwarn = _ref.onwarn, oninfo = _ref.oninfo, manifestString = _ref.manifestString, _ref$customTagParsers = _ref.customTagParsers, customTagParsers = _ref$customTagParsers === void 0 ? [] : _ref$customTagParsers, _ref$customTagMappers = _ref.customTagMappers, customTagMappers = _ref$customTagMappers === void 0 ? [] : _ref$customTagMappers, experimentalLLHLS = _ref.experimentalLLHLS;
  var parser6 = new Parser();
  if (onwarn) {
    parser6.on("warn", onwarn);
  }
  if (oninfo) {
    parser6.on("info", oninfo);
  }
  customTagParsers.forEach(function(customParser) {
    return parser6.addParser(customParser);
  });
  customTagMappers.forEach(function(mapper) {
    return parser6.addTagMapper(mapper);
  });
  parser6.push(manifestString);
  parser6.end();
  var manifest = parser6.manifest;
  if (!experimentalLLHLS) {
    ["preloadSegment", "skip", "serverControl", "renditionReports", "partInf", "partTargetDuration"].forEach(function(k) {
      if (manifest.hasOwnProperty(k)) {
        delete manifest[k];
      }
    });
    if (manifest.segments) {
      manifest.segments.forEach(function(segment) {
        ["parts", "preloadHints"].forEach(function(k) {
          if (segment.hasOwnProperty(k)) {
            delete segment[k];
          }
        });
      });
    }
  }
  if (!manifest.targetDuration) {
    var targetDuration = 10;
    if (manifest.segments && manifest.segments.length) {
      targetDuration = manifest.segments.reduce(function(acc, s) {
        return Math.max(acc, s.duration);
      }, 0);
    }
    if (onwarn) {
      onwarn("manifest has no targetDuration defaulting to " + targetDuration);
    }
    manifest.targetDuration = targetDuration;
  }
  var parts = getLastParts(manifest);
  if (parts.length && !manifest.partTargetDuration) {
    var partTargetDuration = parts.reduce(function(acc, p) {
      return Math.max(acc, p.duration);
    }, 0);
    if (onwarn) {
      onwarn("manifest has no partTargetDuration defaulting to " + partTargetDuration);
      log.error("LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.");
    }
    manifest.partTargetDuration = partTargetDuration;
  }
  return manifest;
};
var forEachMediaGroup3 = function forEachMediaGroup4(master, callback2) {
  if (!master.mediaGroups) {
    return;
  }
  ["AUDIO", "SUBTITLES"].forEach(function(mediaType) {
    if (!master.mediaGroups[mediaType]) {
      return;
    }
    for (var groupKey in master.mediaGroups[mediaType]) {
      for (var labelKey in master.mediaGroups[mediaType][groupKey]) {
        var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];
        callback2(mediaProperties, mediaType, groupKey, labelKey);
      }
    }
  });
};
var setupMediaPlaylist = function setupMediaPlaylist2(_ref2) {
  var playlist = _ref2.playlist, uri = _ref2.uri, id = _ref2.id;
  playlist.id = id;
  playlist.playlistErrors_ = 0;
  if (uri) {
    playlist.uri = uri;
  }
  playlist.attributes = playlist.attributes || {};
};
var setupMediaPlaylists = function setupMediaPlaylists2(master) {
  var i = master.playlists.length;
  while (i--) {
    var playlist = master.playlists[i];
    setupMediaPlaylist({
      playlist,
      id: createPlaylistID(i, playlist.uri)
    });
    playlist.resolvedUri = resolveUrl3(master.uri, playlist.uri);
    master.playlists[playlist.id] = playlist;
    master.playlists[playlist.uri] = playlist;
    if (!playlist.attributes.BANDWIDTH) {
      log.warn("Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.");
    }
  }
};
var resolveMediaGroupUris = function resolveMediaGroupUris2(master) {
  forEachMediaGroup3(master, function(properties) {
    if (properties.uri) {
      properties.resolvedUri = resolveUrl3(master.uri, properties.uri);
    }
  });
};
var masterForMedia = function masterForMedia2(media, uri) {
  var id = createPlaylistID(0, uri);
  var master = {
    mediaGroups: {
      "AUDIO": {},
      "VIDEO": {},
      "CLOSED-CAPTIONS": {},
      "SUBTITLES": {}
    },
    uri: import_window6.default.location.href,
    resolvedUri: import_window6.default.location.href,
    playlists: [{
      uri,
      id,
      resolvedUri: uri,
      // m3u8-parser does not attach an attributes property to media playlists so make
      // sure that the property is attached to avoid undefined reference errors
      attributes: {}
    }]
  };
  master.playlists[id] = master.playlists[0];
  master.playlists[uri] = master.playlists[0];
  return master;
};
var addPropertiesToMaster = function addPropertiesToMaster2(master, uri) {
  master.uri = uri;
  for (var i = 0; i < master.playlists.length; i++) {
    if (!master.playlists[i].uri) {
      var phonyUri = "placeholder-uri-" + i;
      master.playlists[i].uri = phonyUri;
    }
  }
  var audioOnlyMaster = isAudioOnly(master);
  forEachMediaGroup3(master, function(properties, mediaType, groupKey, labelKey) {
    var groupId = "placeholder-uri-" + mediaType + "-" + groupKey + "-" + labelKey;
    if (!properties.playlists || !properties.playlists.length) {
      if (audioOnlyMaster && mediaType === "AUDIO" && !properties.uri) {
        for (var _i = 0; _i < master.playlists.length; _i++) {
          var p = master.playlists[_i];
          if (p.attributes && p.attributes.AUDIO && p.attributes.AUDIO === groupKey) {
            return;
          }
        }
      }
      properties.playlists = [_extends2({}, properties)];
    }
    properties.playlists.forEach(function(p2, i2) {
      var id = createPlaylistID(i2, groupId);
      if (p2.uri) {
        p2.resolvedUri = p2.resolvedUri || resolveUrl3(master.uri, p2.uri);
      } else {
        p2.uri = i2 === 0 ? groupId : id;
        p2.resolvedUri = p2.uri;
      }
      p2.id = p2.id || id;
      p2.attributes = p2.attributes || {};
      master.playlists[p2.id] = p2;
      master.playlists[p2.uri] = p2;
    });
  });
  setupMediaPlaylists(master);
  resolveMediaGroupUris(master);
};
var mergeOptions$2 = videojs.mergeOptions;
var EventTarget$1 = videojs.EventTarget;
var addLLHLSQueryDirectives = function addLLHLSQueryDirectives2(uri, media) {
  if (media.endList || !media.serverControl) {
    return uri;
  }
  var parameters = {};
  if (media.serverControl.canBlockReload) {
    var preloadSegment = media.preloadSegment;
    var nextMSN = media.mediaSequence + media.segments.length;
    if (preloadSegment) {
      var parts = preloadSegment.parts || [];
      var nextPart = getKnownPartCount(media) - 1;
      if (nextPart > -1 && nextPart !== parts.length - 1) {
        parameters._HLS_part = nextPart;
      }
      if (nextPart > -1 || parts.length) {
        nextMSN--;
      }
    }
    parameters._HLS_msn = nextMSN;
  }
  if (media.serverControl && media.serverControl.canSkipUntil) {
    parameters._HLS_skip = media.serverControl.canSkipDateranges ? "v2" : "YES";
  }
  if (Object.keys(parameters).length) {
    var parsedUri = new import_window6.default.URL(uri);
    ["_HLS_skip", "_HLS_msn", "_HLS_part"].forEach(function(name) {
      if (!parameters.hasOwnProperty(name)) {
        return;
      }
      parsedUri.searchParams.set(name, parameters[name]);
    });
    uri = parsedUri.toString();
  }
  return uri;
};
var updateSegment = function updateSegment2(a, b) {
  if (!a) {
    return b;
  }
  var result = mergeOptions$2(a, b);
  if (a.preloadHints && !b.preloadHints) {
    delete result.preloadHints;
  }
  if (a.parts && !b.parts) {
    delete result.parts;
  } else if (a.parts && b.parts) {
    for (var i = 0; i < b.parts.length; i++) {
      if (a.parts && a.parts[i]) {
        result.parts[i] = mergeOptions$2(a.parts[i], b.parts[i]);
      }
    }
  }
  if (!a.skipped && b.skipped) {
    result.skipped = false;
  }
  if (a.preload && !b.preload) {
    result.preload = false;
  }
  return result;
};
var updateSegments = function updateSegments2(original, update, offset) {
  var oldSegments = original.slice();
  var newSegments = update.slice();
  offset = offset || 0;
  var result = [];
  var currentMap;
  for (var newIndex = 0; newIndex < newSegments.length; newIndex++) {
    var oldSegment = oldSegments[newIndex + offset];
    var newSegment = newSegments[newIndex];
    if (oldSegment) {
      currentMap = oldSegment.map || currentMap;
      result.push(updateSegment(oldSegment, newSegment));
    } else {
      if (currentMap && !newSegment.map) {
        newSegment.map = currentMap;
      }
      result.push(newSegment);
    }
  }
  return result;
};
var resolveSegmentUris = function resolveSegmentUris2(segment, baseUri) {
  if (!segment.resolvedUri && segment.uri) {
    segment.resolvedUri = resolveUrl3(baseUri, segment.uri);
  }
  if (segment.key && !segment.key.resolvedUri) {
    segment.key.resolvedUri = resolveUrl3(baseUri, segment.key.uri);
  }
  if (segment.map && !segment.map.resolvedUri) {
    segment.map.resolvedUri = resolveUrl3(baseUri, segment.map.uri);
  }
  if (segment.map && segment.map.key && !segment.map.key.resolvedUri) {
    segment.map.key.resolvedUri = resolveUrl3(baseUri, segment.map.key.uri);
  }
  if (segment.parts && segment.parts.length) {
    segment.parts.forEach(function(p) {
      if (p.resolvedUri) {
        return;
      }
      p.resolvedUri = resolveUrl3(baseUri, p.uri);
    });
  }
  if (segment.preloadHints && segment.preloadHints.length) {
    segment.preloadHints.forEach(function(p) {
      if (p.resolvedUri) {
        return;
      }
      p.resolvedUri = resolveUrl3(baseUri, p.uri);
    });
  }
};
var getAllSegments = function getAllSegments2(media) {
  var segments = media.segments || [];
  var preloadSegment = media.preloadSegment;
  if (preloadSegment && preloadSegment.parts && preloadSegment.parts.length) {
    if (preloadSegment.preloadHints) {
      for (var i = 0; i < preloadSegment.preloadHints.length; i++) {
        if (preloadSegment.preloadHints[i].type === "MAP") {
          return segments;
        }
      }
    }
    preloadSegment.duration = media.targetDuration;
    preloadSegment.preload = true;
    segments.push(preloadSegment);
  }
  return segments;
};
var isPlaylistUnchanged = function isPlaylistUnchanged2(a, b) {
  return a === b || a.segments && b.segments && a.segments.length === b.segments.length && a.endList === b.endList && a.mediaSequence === b.mediaSequence && a.preloadSegment === b.preloadSegment;
};
var updateMaster$1 = function updateMaster(master, newMedia, unchangedCheck) {
  if (unchangedCheck === void 0) {
    unchangedCheck = isPlaylistUnchanged;
  }
  var result = mergeOptions$2(master, {});
  var oldMedia = result.playlists[newMedia.id];
  if (!oldMedia) {
    return null;
  }
  if (unchangedCheck(oldMedia, newMedia)) {
    return null;
  }
  newMedia.segments = getAllSegments(newMedia);
  var mergedPlaylist = mergeOptions$2(oldMedia, newMedia);
  if (mergedPlaylist.preloadSegment && !newMedia.preloadSegment) {
    delete mergedPlaylist.preloadSegment;
  }
  if (oldMedia.segments) {
    if (newMedia.skip) {
      newMedia.segments = newMedia.segments || [];
      for (var i = 0; i < newMedia.skip.skippedSegments; i++) {
        newMedia.segments.unshift({
          skipped: true
        });
      }
    }
    mergedPlaylist.segments = updateSegments(oldMedia.segments, newMedia.segments, newMedia.mediaSequence - oldMedia.mediaSequence);
  }
  mergedPlaylist.segments.forEach(function(segment) {
    resolveSegmentUris(segment, mergedPlaylist.resolvedUri);
  });
  for (var _i = 0; _i < result.playlists.length; _i++) {
    if (result.playlists[_i].id === newMedia.id) {
      result.playlists[_i] = mergedPlaylist;
    }
  }
  result.playlists[newMedia.id] = mergedPlaylist;
  result.playlists[newMedia.uri] = mergedPlaylist;
  forEachMediaGroup3(master, function(properties, mediaType, groupKey, labelKey) {
    if (!properties.playlists) {
      return;
    }
    for (var _i2 = 0; _i2 < properties.playlists.length; _i2++) {
      if (newMedia.id === properties.playlists[_i2].id) {
        properties.playlists[_i2] = mergedPlaylist;
      }
    }
  });
  return result;
};
var refreshDelay = function refreshDelay2(media, update) {
  var segments = media.segments || [];
  var lastSegment = segments[segments.length - 1];
  var lastPart = lastSegment && lastSegment.parts && lastSegment.parts[lastSegment.parts.length - 1];
  var lastDuration = lastPart && lastPart.duration || lastSegment && lastSegment.duration;
  if (update && lastDuration) {
    return lastDuration * 1e3;
  }
  return (media.partTargetDuration || media.targetDuration || 10) * 500;
};
var PlaylistLoader2 = /* @__PURE__ */ function(_EventTarget) {
  _inheritsLoose(PlaylistLoader3, _EventTarget);
  function PlaylistLoader3(src, vhs, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _EventTarget.call(this) || this;
    if (!src) {
      throw new Error("A non-empty playlist URL or object is required");
    }
    _this.logger_ = logger2("PlaylistLoader");
    var _options = options, _options$withCredenti = _options.withCredentials, withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti, _options$handleManife = _options.handleManifestRedirects, handleManifestRedirects = _options$handleManife === void 0 ? false : _options$handleManife;
    _this.src = src;
    _this.vhs_ = vhs;
    _this.withCredentials = withCredentials;
    _this.handleManifestRedirects = handleManifestRedirects;
    var vhsOptions = vhs.options_;
    _this.customTagParsers = vhsOptions && vhsOptions.customTagParsers || [];
    _this.customTagMappers = vhsOptions && vhsOptions.customTagMappers || [];
    _this.experimentalLLHLS = vhsOptions && vhsOptions.experimentalLLHLS || false;
    if (videojs.browser.IE_VERSION) {
      _this.experimentalLLHLS = false;
    }
    _this.state = "HAVE_NOTHING";
    _this.handleMediaupdatetimeout_ = _this.handleMediaupdatetimeout_.bind(_assertThisInitialized(_this));
    _this.on("mediaupdatetimeout", _this.handleMediaupdatetimeout_);
    return _this;
  }
  var _proto = PlaylistLoader3.prototype;
  _proto.handleMediaupdatetimeout_ = function handleMediaupdatetimeout_() {
    var _this2 = this;
    if (this.state !== "HAVE_METADATA") {
      return;
    }
    var media = this.media();
    var uri = resolveUrl3(this.master.uri, media.uri);
    if (this.experimentalLLHLS) {
      uri = addLLHLSQueryDirectives(uri, media);
    }
    this.state = "HAVE_CURRENT_METADATA";
    this.request = this.vhs_.xhr({
      uri,
      withCredentials: this.withCredentials
    }, function(error, req) {
      if (!_this2.request) {
        return;
      }
      if (error) {
        return _this2.playlistRequestError(_this2.request, _this2.media(), "HAVE_METADATA");
      }
      _this2.haveMetadata({
        playlistString: _this2.request.responseText,
        url: _this2.media().uri,
        id: _this2.media().id
      });
    });
  };
  _proto.playlistRequestError = function playlistRequestError(xhr, playlist, startingState) {
    var uri = playlist.uri, id = playlist.id;
    this.request = null;
    if (startingState) {
      this.state = startingState;
    }
    this.error = {
      playlist: this.master.playlists[id],
      status: xhr.status,
      message: "HLS playlist request error at URL: " + uri + ".",
      responseText: xhr.responseText,
      code: xhr.status >= 500 ? 4 : 2
    };
    this.trigger("error");
  };
  _proto.parseManifest_ = function parseManifest_(_ref) {
    var _this3 = this;
    var url = _ref.url, manifestString = _ref.manifestString;
    return parseManifest({
      onwarn: function onwarn(_ref2) {
        var message = _ref2.message;
        return _this3.logger_("m3u8-parser warn for " + url + ": " + message);
      },
      oninfo: function oninfo(_ref3) {
        var message = _ref3.message;
        return _this3.logger_("m3u8-parser info for " + url + ": " + message);
      },
      manifestString,
      customTagParsers: this.customTagParsers,
      customTagMappers: this.customTagMappers,
      experimentalLLHLS: this.experimentalLLHLS
    });
  };
  _proto.haveMetadata = function haveMetadata(_ref4) {
    var playlistString = _ref4.playlistString, playlistObject = _ref4.playlistObject, url = _ref4.url, id = _ref4.id;
    this.request = null;
    this.state = "HAVE_METADATA";
    var playlist = playlistObject || this.parseManifest_({
      url,
      manifestString: playlistString
    });
    playlist.lastRequest = Date.now();
    setupMediaPlaylist({
      playlist,
      uri: url,
      id
    });
    var update = updateMaster$1(this.master, playlist);
    this.targetDuration = playlist.partTargetDuration || playlist.targetDuration;
    this.pendingMedia_ = null;
    if (update) {
      this.master = update;
      this.media_ = this.master.playlists[id];
    } else {
      this.trigger("playlistunchanged");
    }
    this.updateMediaUpdateTimeout_(refreshDelay(this.media(), !!update));
    this.trigger("loadedplaylist");
  };
  _proto.dispose = function dispose() {
    this.trigger("dispose");
    this.stopRequest();
    import_window6.default.clearTimeout(this.mediaUpdateTimeout);
    import_window6.default.clearTimeout(this.finalRenditionTimeout);
    this.off();
  };
  _proto.stopRequest = function stopRequest() {
    if (this.request) {
      var oldRequest = this.request;
      this.request = null;
      oldRequest.onreadystatechange = null;
      oldRequest.abort();
    }
  };
  _proto.media = function media(playlist, shouldDelay) {
    var _this4 = this;
    if (!playlist) {
      return this.media_;
    }
    if (this.state === "HAVE_NOTHING") {
      throw new Error("Cannot switch media playlist from " + this.state);
    }
    if (typeof playlist === "string") {
      if (!this.master.playlists[playlist]) {
        throw new Error("Unknown playlist URI: " + playlist);
      }
      playlist = this.master.playlists[playlist];
    }
    import_window6.default.clearTimeout(this.finalRenditionTimeout);
    if (shouldDelay) {
      var delay = (playlist.partTargetDuration || playlist.targetDuration) / 2 * 1e3 || 5 * 1e3;
      this.finalRenditionTimeout = import_window6.default.setTimeout(this.media.bind(this, playlist, false), delay);
      return;
    }
    var startingState = this.state;
    var mediaChange = !this.media_ || playlist.id !== this.media_.id;
    var masterPlaylistRef = this.master.playlists[playlist.id];
    if (masterPlaylistRef && masterPlaylistRef.endList || // handle the case of a playlist object (e.g., if using vhs-json with a resolved
    // media playlist or, for the case of demuxed audio, a resolved audio media group)
    playlist.endList && playlist.segments.length) {
      if (this.request) {
        this.request.onreadystatechange = null;
        this.request.abort();
        this.request = null;
      }
      this.state = "HAVE_METADATA";
      this.media_ = playlist;
      if (mediaChange) {
        this.trigger("mediachanging");
        if (startingState === "HAVE_MASTER") {
          this.trigger("loadedmetadata");
        } else {
          this.trigger("mediachange");
        }
      }
      return;
    }
    this.updateMediaUpdateTimeout_(refreshDelay(playlist, true));
    if (!mediaChange) {
      return;
    }
    this.state = "SWITCHING_MEDIA";
    if (this.request) {
      if (playlist.resolvedUri === this.request.url) {
        return;
      }
      this.request.onreadystatechange = null;
      this.request.abort();
      this.request = null;
    }
    if (this.media_) {
      this.trigger("mediachanging");
    }
    this.pendingMedia_ = playlist;
    this.request = this.vhs_.xhr({
      uri: playlist.resolvedUri,
      withCredentials: this.withCredentials
    }, function(error, req) {
      if (!_this4.request) {
        return;
      }
      playlist.lastRequest = Date.now();
      playlist.resolvedUri = resolveManifestRedirect(_this4.handleManifestRedirects, playlist.resolvedUri, req);
      if (error) {
        return _this4.playlistRequestError(_this4.request, playlist, startingState);
      }
      _this4.haveMetadata({
        playlistString: req.responseText,
        url: playlist.uri,
        id: playlist.id
      });
      if (startingState === "HAVE_MASTER") {
        _this4.trigger("loadedmetadata");
      } else {
        _this4.trigger("mediachange");
      }
    });
  };
  _proto.pause = function pause() {
    if (this.mediaUpdateTimeout) {
      import_window6.default.clearTimeout(this.mediaUpdateTimeout);
      this.mediaUpdateTimeout = null;
    }
    this.stopRequest();
    if (this.state === "HAVE_NOTHING") {
      this.started = false;
    }
    if (this.state === "SWITCHING_MEDIA") {
      if (this.media_) {
        this.state = "HAVE_METADATA";
      } else {
        this.state = "HAVE_MASTER";
      }
    } else if (this.state === "HAVE_CURRENT_METADATA") {
      this.state = "HAVE_METADATA";
    }
  };
  _proto.load = function load(shouldDelay) {
    var _this5 = this;
    if (this.mediaUpdateTimeout) {
      import_window6.default.clearTimeout(this.mediaUpdateTimeout);
      this.mediaUpdateTimeout = null;
    }
    var media = this.media();
    if (shouldDelay) {
      var delay = media ? (media.partTargetDuration || media.targetDuration) / 2 * 1e3 : 5 * 1e3;
      this.mediaUpdateTimeout = import_window6.default.setTimeout(function() {
        _this5.mediaUpdateTimeout = null;
        _this5.load();
      }, delay);
      return;
    }
    if (!this.started) {
      this.start();
      return;
    }
    if (media && !media.endList) {
      this.trigger("mediaupdatetimeout");
    } else {
      this.trigger("loadedplaylist");
    }
  };
  _proto.updateMediaUpdateTimeout_ = function updateMediaUpdateTimeout_(delay) {
    var _this6 = this;
    if (this.mediaUpdateTimeout) {
      import_window6.default.clearTimeout(this.mediaUpdateTimeout);
      this.mediaUpdateTimeout = null;
    }
    if (!this.media() || this.media().endList) {
      return;
    }
    this.mediaUpdateTimeout = import_window6.default.setTimeout(function() {
      _this6.mediaUpdateTimeout = null;
      _this6.trigger("mediaupdatetimeout");
      _this6.updateMediaUpdateTimeout_(delay);
    }, delay);
  };
  _proto.start = function start2() {
    var _this7 = this;
    this.started = true;
    if (typeof this.src === "object") {
      if (!this.src.uri) {
        this.src.uri = import_window6.default.location.href;
      }
      this.src.resolvedUri = this.src.uri;
      setTimeout(function() {
        _this7.setupInitialPlaylist(_this7.src);
      }, 0);
      return;
    }
    this.request = this.vhs_.xhr({
      uri: this.src,
      withCredentials: this.withCredentials
    }, function(error, req) {
      if (!_this7.request) {
        return;
      }
      _this7.request = null;
      if (error) {
        _this7.error = {
          status: req.status,
          message: "HLS playlist request error at URL: " + _this7.src + ".",
          responseText: req.responseText,
          // MEDIA_ERR_NETWORK
          code: 2
        };
        if (_this7.state === "HAVE_NOTHING") {
          _this7.started = false;
        }
        return _this7.trigger("error");
      }
      _this7.src = resolveManifestRedirect(_this7.handleManifestRedirects, _this7.src, req);
      var manifest = _this7.parseManifest_({
        manifestString: req.responseText,
        url: _this7.src
      });
      _this7.setupInitialPlaylist(manifest);
    });
  };
  _proto.srcUri = function srcUri() {
    return typeof this.src === "string" ? this.src : this.src.uri;
  };
  _proto.setupInitialPlaylist = function setupInitialPlaylist(manifest) {
    this.state = "HAVE_MASTER";
    if (manifest.playlists) {
      this.master = manifest;
      addPropertiesToMaster(this.master, this.srcUri());
      manifest.playlists.forEach(function(playlist) {
        playlist.segments = getAllSegments(playlist);
        playlist.segments.forEach(function(segment) {
          resolveSegmentUris(segment, playlist.resolvedUri);
        });
      });
      this.trigger("loadedplaylist");
      if (!this.request) {
        this.media(this.master.playlists[0]);
      }
      return;
    }
    var uri = this.srcUri() || import_window6.default.location.href;
    this.master = masterForMedia(manifest, uri);
    this.haveMetadata({
      playlistObject: manifest,
      url: uri,
      id: this.master.playlists[0].id
    });
    this.trigger("loadedmetadata");
  };
  return PlaylistLoader3;
}(EventTarget$1);
var videojsXHR = videojs.xhr;
var mergeOptions$1 = videojs.mergeOptions;
var callbackWrapper = function callbackWrapper2(request, error, response, callback2) {
  var reqResponse = request.responseType === "arraybuffer" ? request.response : request.responseText;
  if (!error && reqResponse) {
    request.responseTime = Date.now();
    request.roundTripTime = request.responseTime - request.requestTime;
    request.bytesReceived = reqResponse.byteLength || reqResponse.length;
    if (!request.bandwidth) {
      request.bandwidth = Math.floor(request.bytesReceived / request.roundTripTime * 8 * 1e3);
    }
  }
  if (response.headers) {
    request.responseHeaders = response.headers;
  }
  if (error && error.code === "ETIMEDOUT") {
    request.timedout = true;
  }
  if (!error && !request.aborted && response.statusCode !== 200 && response.statusCode !== 206 && response.statusCode !== 0) {
    error = new Error("XHR Failed with a response of: " + (request && (reqResponse || request.responseText)));
  }
  callback2(error, request);
};
var xhrFactory = function xhrFactory2() {
  var xhr = function XhrFunction(options, callback2) {
    options = mergeOptions$1({
      timeout: 45e3
    }, options);
    var beforeRequest = XhrFunction.beforeRequest || videojs.Vhs.xhr.beforeRequest;
    if (beforeRequest && typeof beforeRequest === "function") {
      var newOptions = beforeRequest(options);
      if (newOptions) {
        options = newOptions;
      }
    }
    var xhrMethod = videojs.Vhs.xhr.original === true ? videojsXHR : videojs.Vhs.xhr;
    var request = xhrMethod(options, function(error, response) {
      return callbackWrapper(request, error, response, callback2);
    });
    var originalAbort = request.abort;
    request.abort = function() {
      request.aborted = true;
      return originalAbort.apply(request, arguments);
    };
    request.uri = options.uri;
    request.requestTime = Date.now();
    return request;
  };
  xhr.original = true;
  return xhr;
};
var byterangeStr = function byterangeStr2(byterange) {
  var byterangeEnd;
  var byterangeStart = byterange.offset;
  if (typeof byterange.offset === "bigint" || typeof byterange.length === "bigint") {
    byterangeEnd = import_window6.default.BigInt(byterange.offset) + import_window6.default.BigInt(byterange.length) - import_window6.default.BigInt(1);
  } else {
    byterangeEnd = byterange.offset + byterange.length - 1;
  }
  return "bytes=" + byterangeStart + "-" + byterangeEnd;
};
var segmentXhrHeaders = function segmentXhrHeaders2(segment) {
  var headers = {};
  if (segment.byterange) {
    headers.Range = byterangeStr(segment.byterange);
  }
  return headers;
};
var textRange = function textRange2(range3, i) {
  return range3.start(i) + "-" + range3.end(i);
};
var formatHexString = function formatHexString2(e, i) {
  var value = e.toString(16);
  return "00".substring(0, 2 - value.length) + value + (i % 2 ? " " : "");
};
var formatAsciiString = function formatAsciiString2(e) {
  if (e >= 32 && e < 126) {
    return String.fromCharCode(e);
  }
  return ".";
};
var createTransferableMessage = function createTransferableMessage2(message) {
  var transferable = {};
  Object.keys(message).forEach(function(key) {
    var value = message[key];
    if (isArrayBufferView(value)) {
      transferable[key] = {
        bytes: value.buffer,
        byteOffset: value.byteOffset,
        byteLength: value.byteLength
      };
    } else {
      transferable[key] = value;
    }
  });
  return transferable;
};
var initSegmentId = function initSegmentId2(initSegment) {
  var byterange = initSegment.byterange || {
    length: Infinity,
    offset: 0
  };
  return [byterange.length, byterange.offset, initSegment.resolvedUri].join(",");
};
var segmentKeyId = function segmentKeyId2(key) {
  return key.resolvedUri;
};
var hexDump = function hexDump2(data) {
  var bytes = Array.prototype.slice.call(data);
  var step = 16;
  var result = "";
  var hex;
  var ascii;
  for (var j = 0; j < bytes.length / step; j++) {
    hex = bytes.slice(j * step, j * step + step).map(formatHexString).join("");
    ascii = bytes.slice(j * step, j * step + step).map(formatAsciiString).join("");
    result += hex + " " + ascii + "\n";
  }
  return result;
};
var tagDump = function tagDump2(_ref) {
  var bytes = _ref.bytes;
  return hexDump(bytes);
};
var textRanges = function textRanges2(ranges) {
  var result = "";
  var i;
  for (i = 0; i < ranges.length; i++) {
    result += textRange(ranges, i) + " ";
  }
  return result;
};
var utils = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createTransferableMessage,
  initSegmentId,
  segmentKeyId,
  hexDump,
  tagDump,
  textRanges
});
var SEGMENT_END_FUDGE_PERCENT = 0.25;
var playerTimeToProgramTime = function playerTimeToProgramTime2(playerTime, segment) {
  if (!segment.dateTimeObject) {
    return null;
  }
  var transmuxerPrependedSeconds = segment.videoTimingInfo.transmuxerPrependedSeconds;
  var transmuxedStart = segment.videoTimingInfo.transmuxedPresentationStart;
  var startOfSegment = transmuxedStart + transmuxerPrependedSeconds;
  var offsetFromSegmentStart = playerTime - startOfSegment;
  return new Date(segment.dateTimeObject.getTime() + offsetFromSegmentStart * 1e3);
};
var originalSegmentVideoDuration = function originalSegmentVideoDuration2(videoTimingInfo) {
  return videoTimingInfo.transmuxedPresentationEnd - videoTimingInfo.transmuxedPresentationStart - videoTimingInfo.transmuxerPrependedSeconds;
};
var findSegmentForProgramTime = function findSegmentForProgramTime2(programTime, playlist) {
  var dateTimeObject;
  try {
    dateTimeObject = new Date(programTime);
  } catch (e) {
    return null;
  }
  if (!playlist || !playlist.segments || playlist.segments.length === 0) {
    return null;
  }
  var segment = playlist.segments[0];
  if (dateTimeObject < segment.dateTimeObject) {
    return null;
  }
  for (var i = 0; i < playlist.segments.length - 1; i++) {
    segment = playlist.segments[i];
    var nextSegmentStart = playlist.segments[i + 1].dateTimeObject;
    if (dateTimeObject < nextSegmentStart) {
      break;
    }
  }
  var lastSegment = playlist.segments[playlist.segments.length - 1];
  var lastSegmentStart = lastSegment.dateTimeObject;
  var lastSegmentDuration = lastSegment.videoTimingInfo ? originalSegmentVideoDuration(lastSegment.videoTimingInfo) : lastSegment.duration + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT;
  var lastSegmentEnd = new Date(lastSegmentStart.getTime() + lastSegmentDuration * 1e3);
  if (dateTimeObject > lastSegmentEnd) {
    return null;
  }
  if (dateTimeObject > lastSegmentStart) {
    segment = lastSegment;
  }
  return {
    segment,
    estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : Playlist.duration(playlist, playlist.mediaSequence + playlist.segments.indexOf(segment)),
    // Although, given that all segments have accurate date time objects, the segment
    // selected should be accurate, unless the video has been transmuxed at some point
    // (determined by the presence of the videoTimingInfo object), the segment's "player
    // time" (the start time in the player) can't be considered accurate.
    type: segment.videoTimingInfo ? "accurate" : "estimate"
  };
};
var findSegmentForPlayerTime = function findSegmentForPlayerTime2(time, playlist) {
  if (!playlist || !playlist.segments || playlist.segments.length === 0) {
    return null;
  }
  var segmentEnd = 0;
  var segment;
  for (var i = 0; i < playlist.segments.length; i++) {
    segment = playlist.segments[i];
    segmentEnd = segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationEnd : segmentEnd + segment.duration;
    if (time <= segmentEnd) {
      break;
    }
  }
  var lastSegment = playlist.segments[playlist.segments.length - 1];
  if (lastSegment.videoTimingInfo && lastSegment.videoTimingInfo.transmuxedPresentationEnd < time) {
    return null;
  }
  if (time > segmentEnd) {
    if (time > segmentEnd + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT) {
      return null;
    }
    segment = lastSegment;
  }
  return {
    segment,
    estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : segmentEnd - segment.duration,
    // Because videoTimingInfo is only set after transmux, it is the only way to get
    // accurate timing values.
    type: segment.videoTimingInfo ? "accurate" : "estimate"
  };
};
var getOffsetFromTimestamp = function getOffsetFromTimestamp2(comparisonTimeStamp, programTime) {
  var segmentDateTime;
  var programDateTime;
  try {
    segmentDateTime = new Date(comparisonTimeStamp);
    programDateTime = new Date(programTime);
  } catch (e) {
  }
  var segmentTimeEpoch = segmentDateTime.getTime();
  var programTimeEpoch = programDateTime.getTime();
  return (programTimeEpoch - segmentTimeEpoch) / 1e3;
};
var verifyProgramDateTimeTags = function verifyProgramDateTimeTags2(playlist) {
  if (!playlist.segments || playlist.segments.length === 0) {
    return false;
  }
  for (var i = 0; i < playlist.segments.length; i++) {
    var segment = playlist.segments[i];
    if (!segment.dateTimeObject) {
      return false;
    }
  }
  return true;
};
var getProgramTime = function getProgramTime2(_ref) {
  var playlist = _ref.playlist, _ref$time = _ref.time, time = _ref$time === void 0 ? void 0 : _ref$time, callback2 = _ref.callback;
  if (!callback2) {
    throw new Error("getProgramTime: callback must be provided");
  }
  if (!playlist || time === void 0) {
    return callback2({
      message: "getProgramTime: playlist and time must be provided"
    });
  }
  var matchedSegment = findSegmentForPlayerTime(time, playlist);
  if (!matchedSegment) {
    return callback2({
      message: "valid programTime was not found"
    });
  }
  if (matchedSegment.type === "estimate") {
    return callback2({
      message: "Accurate programTime could not be determined. Please seek to e.seekTime and try again",
      seekTime: matchedSegment.estimatedStart
    });
  }
  var programTimeObject = {
    mediaSeconds: time
  };
  var programTime = playerTimeToProgramTime(time, matchedSegment.segment);
  if (programTime) {
    programTimeObject.programDateTime = programTime.toISOString();
  }
  return callback2(null, programTimeObject);
};
var seekToProgramTime = function seekToProgramTime2(_ref2) {
  var programTime = _ref2.programTime, playlist = _ref2.playlist, _ref2$retryCount = _ref2.retryCount, retryCount = _ref2$retryCount === void 0 ? 2 : _ref2$retryCount, seekTo = _ref2.seekTo, _ref2$pauseAfterSeek = _ref2.pauseAfterSeek, pauseAfterSeek = _ref2$pauseAfterSeek === void 0 ? true : _ref2$pauseAfterSeek, tech = _ref2.tech, callback2 = _ref2.callback;
  if (!callback2) {
    throw new Error("seekToProgramTime: callback must be provided");
  }
  if (typeof programTime === "undefined" || !playlist || !seekTo) {
    return callback2({
      message: "seekToProgramTime: programTime, seekTo and playlist must be provided"
    });
  }
  if (!playlist.endList && !tech.hasStarted_) {
    return callback2({
      message: "player must be playing a live stream to start buffering"
    });
  }
  if (!verifyProgramDateTimeTags(playlist)) {
    return callback2({
      message: "programDateTime tags must be provided in the manifest " + playlist.resolvedUri
    });
  }
  var matchedSegment = findSegmentForProgramTime(programTime, playlist);
  if (!matchedSegment) {
    return callback2({
      message: programTime + " was not found in the stream"
    });
  }
  var segment = matchedSegment.segment;
  var mediaOffset = getOffsetFromTimestamp(segment.dateTimeObject, programTime);
  if (matchedSegment.type === "estimate") {
    if (retryCount === 0) {
      return callback2({
        message: programTime + " is not buffered yet. Try again"
      });
    }
    seekTo(matchedSegment.estimatedStart + mediaOffset);
    tech.one("seeked", function() {
      seekToProgramTime2({
        programTime,
        playlist,
        retryCount: retryCount - 1,
        seekTo,
        pauseAfterSeek,
        tech,
        callback: callback2
      });
    });
    return;
  }
  var seekToTime = segment.start + mediaOffset;
  var seekedCallback = function seekedCallback2() {
    return callback2(null, tech.currentTime());
  };
  tech.one("seeked", seekedCallback);
  if (pauseAfterSeek) {
    tech.pause();
  }
  seekTo(seekToTime);
};
var callbackOnCompleted = function callbackOnCompleted2(request, cb) {
  if (request.readyState === 4) {
    return cb();
  }
  return;
};
var containerRequest = function containerRequest2(uri, xhr, cb) {
  var bytes = [];
  var id3Offset;
  var finished = false;
  var endRequestAndCallback = function endRequestAndCallback2(err, req, type2, _bytes) {
    req.abort();
    finished = true;
    return cb(err, req, type2, _bytes);
  };
  var progressListener = function progressListener2(error, request2) {
    if (finished) {
      return;
    }
    if (error) {
      return endRequestAndCallback(error, request2, "", bytes);
    }
    var newPart = request2.responseText.substring(bytes && bytes.byteLength || 0, request2.responseText.length);
    bytes = concatTypedArrays(bytes, stringToBytes(newPart, true));
    id3Offset = id3Offset || getId3Offset(bytes);
    if (bytes.length < 10 || id3Offset && bytes.length < id3Offset + 2) {
      return callbackOnCompleted(request2, function() {
        return endRequestAndCallback(error, request2, "", bytes);
      });
    }
    var type2 = detectContainerForBytes(bytes);
    if (type2 === "ts" && bytes.length < 188) {
      return callbackOnCompleted(request2, function() {
        return endRequestAndCallback(error, request2, "", bytes);
      });
    }
    if (!type2 && bytes.length < 376) {
      return callbackOnCompleted(request2, function() {
        return endRequestAndCallback(error, request2, "", bytes);
      });
    }
    return endRequestAndCallback(null, request2, type2, bytes);
  };
  var options = {
    uri,
    beforeSend: function beforeSend(request2) {
      request2.overrideMimeType("text/plain; charset=x-user-defined");
      request2.addEventListener("progress", function(_ref) {
        _ref.total;
        _ref.loaded;
        return callbackWrapper(request2, null, {
          statusCode: request2.status
        }, progressListener);
      });
    }
  };
  var request = xhr(options, function(error, response) {
    return callbackWrapper(request, error, response, progressListener);
  });
  return request;
};
var EventTarget2 = videojs.EventTarget;
var mergeOptions = videojs.mergeOptions;
var dashPlaylistUnchanged = function dashPlaylistUnchanged2(a, b) {
  if (!isPlaylistUnchanged(a, b)) {
    return false;
  }
  if (a.sidx && b.sidx && (a.sidx.offset !== b.sidx.offset || a.sidx.length !== b.sidx.length)) {
    return false;
  } else if (!a.sidx && b.sidx || a.sidx && !b.sidx) {
    return false;
  }
  if (a.segments && !b.segments || !a.segments && b.segments) {
    return false;
  }
  if (!a.segments && !b.segments) {
    return true;
  }
  for (var i = 0; i < a.segments.length; i++) {
    var aSegment = a.segments[i];
    var bSegment = b.segments[i];
    if (aSegment.uri !== bSegment.uri) {
      return false;
    }
    if (!aSegment.byterange && !bSegment.byterange) {
      continue;
    }
    var aByterange = aSegment.byterange;
    var bByterange = bSegment.byterange;
    if (aByterange && !bByterange || !aByterange && bByterange) {
      return false;
    }
    if (aByterange.offset !== bByterange.offset || aByterange.length !== bByterange.length) {
      return false;
    }
  }
  return true;
};
var parseMasterXml = function parseMasterXml2(_ref) {
  var masterXml = _ref.masterXml, srcUrl = _ref.srcUrl, clientOffset = _ref.clientOffset, sidxMapping = _ref.sidxMapping, previousManifest = _ref.previousManifest;
  var manifest = parse(masterXml, {
    manifestUri: srcUrl,
    clientOffset,
    sidxMapping,
    previousManifest
  });
  addPropertiesToMaster(manifest, srcUrl);
  return manifest;
};
var updateMaster2 = function updateMaster3(oldMaster, newMaster, sidxMapping) {
  var noChanges = true;
  var update = mergeOptions(oldMaster, {
    // These are top level properties that can be updated
    duration: newMaster.duration,
    minimumUpdatePeriod: newMaster.minimumUpdatePeriod,
    timelineStarts: newMaster.timelineStarts
  });
  for (var i = 0; i < newMaster.playlists.length; i++) {
    var playlist = newMaster.playlists[i];
    if (playlist.sidx) {
      var sidxKey = generateSidxKey(playlist.sidx);
      if (sidxMapping && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx) {
        addSidxSegmentsToPlaylist$1(playlist, sidxMapping[sidxKey].sidx, playlist.sidx.resolvedUri);
      }
    }
    var playlistUpdate = updateMaster$1(update, playlist, dashPlaylistUnchanged);
    if (playlistUpdate) {
      update = playlistUpdate;
      noChanges = false;
    }
  }
  forEachMediaGroup3(newMaster, function(properties, type2, group, label) {
    if (properties.playlists && properties.playlists.length) {
      var id = properties.playlists[0].id;
      var _playlistUpdate = updateMaster$1(update, properties.playlists[0], dashPlaylistUnchanged);
      if (_playlistUpdate) {
        update = _playlistUpdate;
        update.mediaGroups[type2][group][label].playlists[0] = update.playlists[id];
        noChanges = false;
      }
    }
  });
  if (newMaster.minimumUpdatePeriod !== oldMaster.minimumUpdatePeriod) {
    noChanges = false;
  }
  if (noChanges) {
    return null;
  }
  return update;
};
var equivalentSidx = function equivalentSidx2(a, b) {
  var neitherMap = Boolean(!a.map && !b.map);
  var equivalentMap = neitherMap || Boolean(a.map && b.map && a.map.byterange.offset === b.map.byterange.offset && a.map.byterange.length === b.map.byterange.length);
  return equivalentMap && a.uri === b.uri && a.byterange.offset === b.byterange.offset && a.byterange.length === b.byterange.length;
};
var compareSidxEntry = function compareSidxEntry2(playlists, oldSidxMapping) {
  var newSidxMapping = {};
  for (var id in playlists) {
    var playlist = playlists[id];
    var currentSidxInfo = playlist.sidx;
    if (currentSidxInfo) {
      var key = generateSidxKey(currentSidxInfo);
      if (!oldSidxMapping[key]) {
        break;
      }
      var savedSidxInfo = oldSidxMapping[key].sidxInfo;
      if (equivalentSidx(savedSidxInfo, currentSidxInfo)) {
        newSidxMapping[key] = oldSidxMapping[key];
      }
    }
  }
  return newSidxMapping;
};
var filterChangedSidxMappings = function filterChangedSidxMappings2(master, oldSidxMapping) {
  var videoSidx = compareSidxEntry(master.playlists, oldSidxMapping);
  var mediaGroupSidx = videoSidx;
  forEachMediaGroup3(master, function(properties, mediaType, groupKey, labelKey) {
    if (properties.playlists && properties.playlists.length) {
      var playlists = properties.playlists;
      mediaGroupSidx = mergeOptions(mediaGroupSidx, compareSidxEntry(playlists, oldSidxMapping));
    }
  });
  return mediaGroupSidx;
};
var DashPlaylistLoader = /* @__PURE__ */ function(_EventTarget) {
  _inheritsLoose(DashPlaylistLoader2, _EventTarget);
  function DashPlaylistLoader2(srcUrlOrPlaylist, vhs, options, masterPlaylistLoader) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _EventTarget.call(this) || this;
    _this.masterPlaylistLoader_ = masterPlaylistLoader || _assertThisInitialized(_this);
    if (!masterPlaylistLoader) {
      _this.isMaster_ = true;
    }
    var _options = options, _options$withCredenti = _options.withCredentials, withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti, _options$handleManife = _options.handleManifestRedirects, handleManifestRedirects = _options$handleManife === void 0 ? false : _options$handleManife;
    _this.vhs_ = vhs;
    _this.withCredentials = withCredentials;
    _this.handleManifestRedirects = handleManifestRedirects;
    if (!srcUrlOrPlaylist) {
      throw new Error("A non-empty playlist URL or object is required");
    }
    _this.on("minimumUpdatePeriod", function() {
      _this.refreshXml_();
    });
    _this.on("mediaupdatetimeout", function() {
      _this.refreshMedia_(_this.media().id);
    });
    _this.state = "HAVE_NOTHING";
    _this.loadedPlaylists_ = {};
    _this.logger_ = logger2("DashPlaylistLoader");
    if (_this.isMaster_) {
      _this.masterPlaylistLoader_.srcUrl = srcUrlOrPlaylist;
      _this.masterPlaylistLoader_.sidxMapping_ = {};
    } else {
      _this.childPlaylist_ = srcUrlOrPlaylist;
    }
    return _this;
  }
  var _proto = DashPlaylistLoader2.prototype;
  _proto.requestErrored_ = function requestErrored_(err, request, startingState) {
    if (!this.request) {
      return true;
    }
    this.request = null;
    if (err) {
      this.error = typeof err === "object" && !(err instanceof Error) ? err : {
        status: request.status,
        message: "DASH request error at URL: " + request.uri,
        response: request.response,
        // MEDIA_ERR_NETWORK
        code: 2
      };
      if (startingState) {
        this.state = startingState;
      }
      this.trigger("error");
      return true;
    }
  };
  _proto.addSidxSegments_ = function addSidxSegments_(playlist, startingState, cb) {
    var _this2 = this;
    var sidxKey = playlist.sidx && generateSidxKey(playlist.sidx);
    if (!playlist.sidx || !sidxKey || this.masterPlaylistLoader_.sidxMapping_[sidxKey]) {
      this.mediaRequest_ = import_window6.default.setTimeout(function() {
        return cb(false);
      }, 0);
      return;
    }
    var uri = resolveManifestRedirect(this.handleManifestRedirects, playlist.sidx.resolvedUri);
    var fin = function fin2(err, request) {
      if (_this2.requestErrored_(err, request, startingState)) {
        return;
      }
      var sidxMapping = _this2.masterPlaylistLoader_.sidxMapping_;
      var sidx;
      try {
        sidx = (0, import_parse_sidx.default)(toUint8(request.response).subarray(8));
      } catch (e) {
        _this2.requestErrored_(e, request, startingState);
        return;
      }
      sidxMapping[sidxKey] = {
        sidxInfo: playlist.sidx,
        sidx
      };
      addSidxSegmentsToPlaylist$1(playlist, sidx, playlist.sidx.resolvedUri);
      return cb(true);
    };
    this.request = containerRequest(uri, this.vhs_.xhr, function(err, request, container, bytes) {
      if (err) {
        return fin(err, request);
      }
      if (!container || container !== "mp4") {
        return fin({
          status: request.status,
          message: "Unsupported " + (container || "unknown") + " container type for sidx segment at URL: " + uri,
          // response is just bytes in this case
          // but we really don't want to return that.
          response: "",
          playlist,
          internal: true,
          blacklistDuration: Infinity,
          // MEDIA_ERR_NETWORK
          code: 2
        }, request);
      }
      var _playlist$sidx$bytera = playlist.sidx.byterange, offset = _playlist$sidx$bytera.offset, length = _playlist$sidx$bytera.length;
      if (bytes.length >= length + offset) {
        return fin(err, {
          response: bytes.subarray(offset, offset + length),
          status: request.status,
          uri: request.uri
        });
      }
      _this2.request = _this2.vhs_.xhr({
        uri,
        responseType: "arraybuffer",
        headers: segmentXhrHeaders({
          byterange: playlist.sidx.byterange
        })
      }, fin);
    });
  };
  _proto.dispose = function dispose() {
    this.trigger("dispose");
    this.stopRequest();
    this.loadedPlaylists_ = {};
    import_window6.default.clearTimeout(this.minimumUpdatePeriodTimeout_);
    import_window6.default.clearTimeout(this.mediaRequest_);
    import_window6.default.clearTimeout(this.mediaUpdateTimeout);
    this.mediaUpdateTimeout = null;
    this.mediaRequest_ = null;
    this.minimumUpdatePeriodTimeout_ = null;
    if (this.masterPlaylistLoader_.createMupOnMedia_) {
      this.off("loadedmetadata", this.masterPlaylistLoader_.createMupOnMedia_);
      this.masterPlaylistLoader_.createMupOnMedia_ = null;
    }
    this.off();
  };
  _proto.hasPendingRequest = function hasPendingRequest() {
    return this.request || this.mediaRequest_;
  };
  _proto.stopRequest = function stopRequest() {
    if (this.request) {
      var oldRequest = this.request;
      this.request = null;
      oldRequest.onreadystatechange = null;
      oldRequest.abort();
    }
  };
  _proto.media = function media(playlist) {
    var _this3 = this;
    if (!playlist) {
      return this.media_;
    }
    if (this.state === "HAVE_NOTHING") {
      throw new Error("Cannot switch media playlist from " + this.state);
    }
    var startingState = this.state;
    if (typeof playlist === "string") {
      if (!this.masterPlaylistLoader_.master.playlists[playlist]) {
        throw new Error("Unknown playlist URI: " + playlist);
      }
      playlist = this.masterPlaylistLoader_.master.playlists[playlist];
    }
    var mediaChange = !this.media_ || playlist.id !== this.media_.id;
    if (mediaChange && this.loadedPlaylists_[playlist.id] && this.loadedPlaylists_[playlist.id].endList) {
      this.state = "HAVE_METADATA";
      this.media_ = playlist;
      if (mediaChange) {
        this.trigger("mediachanging");
        this.trigger("mediachange");
      }
      return;
    }
    if (!mediaChange) {
      return;
    }
    if (this.media_) {
      this.trigger("mediachanging");
    }
    this.addSidxSegments_(playlist, startingState, function(sidxChanged) {
      _this3.haveMetadata({
        startingState,
        playlist
      });
    });
  };
  _proto.haveMetadata = function haveMetadata(_ref2) {
    var startingState = _ref2.startingState, playlist = _ref2.playlist;
    this.state = "HAVE_METADATA";
    this.loadedPlaylists_[playlist.id] = playlist;
    this.mediaRequest_ = null;
    this.refreshMedia_(playlist.id);
    if (startingState === "HAVE_MASTER") {
      this.trigger("loadedmetadata");
    } else {
      this.trigger("mediachange");
    }
  };
  _proto.pause = function pause() {
    if (this.masterPlaylistLoader_.createMupOnMedia_) {
      this.off("loadedmetadata", this.masterPlaylistLoader_.createMupOnMedia_);
      this.masterPlaylistLoader_.createMupOnMedia_ = null;
    }
    this.stopRequest();
    import_window6.default.clearTimeout(this.mediaUpdateTimeout);
    this.mediaUpdateTimeout = null;
    if (this.isMaster_) {
      import_window6.default.clearTimeout(this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_);
      this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_ = null;
    }
    if (this.state === "HAVE_NOTHING") {
      this.started = false;
    }
  };
  _proto.load = function load(isFinalRendition) {
    var _this4 = this;
    import_window6.default.clearTimeout(this.mediaUpdateTimeout);
    this.mediaUpdateTimeout = null;
    var media = this.media();
    if (isFinalRendition) {
      var delay = media ? media.targetDuration / 2 * 1e3 : 5 * 1e3;
      this.mediaUpdateTimeout = import_window6.default.setTimeout(function() {
        return _this4.load();
      }, delay);
      return;
    }
    if (!this.started) {
      this.start();
      return;
    }
    if (media && !media.endList) {
      if (this.isMaster_ && !this.minimumUpdatePeriodTimeout_) {
        this.trigger("minimumUpdatePeriod");
        this.updateMinimumUpdatePeriodTimeout_();
      }
      this.trigger("mediaupdatetimeout");
    } else {
      this.trigger("loadedplaylist");
    }
  };
  _proto.start = function start2() {
    var _this5 = this;
    this.started = true;
    if (!this.isMaster_) {
      this.mediaRequest_ = import_window6.default.setTimeout(function() {
        return _this5.haveMaster_();
      }, 0);
      return;
    }
    this.requestMaster_(function(req, masterChanged) {
      _this5.haveMaster_();
      if (!_this5.hasPendingRequest() && !_this5.media_) {
        _this5.media(_this5.masterPlaylistLoader_.master.playlists[0]);
      }
    });
  };
  _proto.requestMaster_ = function requestMaster_(cb) {
    var _this6 = this;
    this.request = this.vhs_.xhr({
      uri: this.masterPlaylistLoader_.srcUrl,
      withCredentials: this.withCredentials
    }, function(error, req) {
      if (_this6.requestErrored_(error, req)) {
        if (_this6.state === "HAVE_NOTHING") {
          _this6.started = false;
        }
        return;
      }
      var masterChanged = req.responseText !== _this6.masterPlaylistLoader_.masterXml_;
      _this6.masterPlaylistLoader_.masterXml_ = req.responseText;
      if (req.responseHeaders && req.responseHeaders.date) {
        _this6.masterLoaded_ = Date.parse(req.responseHeaders.date);
      } else {
        _this6.masterLoaded_ = Date.now();
      }
      _this6.masterPlaylistLoader_.srcUrl = resolveManifestRedirect(_this6.handleManifestRedirects, _this6.masterPlaylistLoader_.srcUrl, req);
      if (masterChanged) {
        _this6.handleMaster_();
        _this6.syncClientServerClock_(function() {
          return cb(req, masterChanged);
        });
        return;
      }
      return cb(req, masterChanged);
    });
  };
  _proto.syncClientServerClock_ = function syncClientServerClock_(done) {
    var _this7 = this;
    var utcTiming = parseUTCTiming(this.masterPlaylistLoader_.masterXml_);
    if (utcTiming === null) {
      this.masterPlaylistLoader_.clientOffset_ = this.masterLoaded_ - Date.now();
      return done();
    }
    if (utcTiming.method === "DIRECT") {
      this.masterPlaylistLoader_.clientOffset_ = utcTiming.value - Date.now();
      return done();
    }
    this.request = this.vhs_.xhr({
      uri: resolveUrl3(this.masterPlaylistLoader_.srcUrl, utcTiming.value),
      method: utcTiming.method,
      withCredentials: this.withCredentials
    }, function(error, req) {
      if (!_this7.request) {
        return;
      }
      if (error) {
        _this7.masterPlaylistLoader_.clientOffset_ = _this7.masterLoaded_ - Date.now();
        return done();
      }
      var serverTime;
      if (utcTiming.method === "HEAD") {
        if (!req.responseHeaders || !req.responseHeaders.date) {
          serverTime = _this7.masterLoaded_;
        } else {
          serverTime = Date.parse(req.responseHeaders.date);
        }
      } else {
        serverTime = Date.parse(req.responseText);
      }
      _this7.masterPlaylistLoader_.clientOffset_ = serverTime - Date.now();
      done();
    });
  };
  _proto.haveMaster_ = function haveMaster_() {
    this.state = "HAVE_MASTER";
    if (this.isMaster_) {
      this.trigger("loadedplaylist");
    } else if (!this.media_) {
      this.media(this.childPlaylist_);
    }
  };
  _proto.handleMaster_ = function handleMaster_() {
    this.mediaRequest_ = null;
    var oldMaster = this.masterPlaylistLoader_.master;
    var newMaster = parseMasterXml({
      masterXml: this.masterPlaylistLoader_.masterXml_,
      srcUrl: this.masterPlaylistLoader_.srcUrl,
      clientOffset: this.masterPlaylistLoader_.clientOffset_,
      sidxMapping: this.masterPlaylistLoader_.sidxMapping_,
      previousManifest: oldMaster
    });
    if (oldMaster) {
      newMaster = updateMaster2(oldMaster, newMaster, this.masterPlaylistLoader_.sidxMapping_);
    }
    this.masterPlaylistLoader_.master = newMaster ? newMaster : oldMaster;
    var location2 = this.masterPlaylistLoader_.master.locations && this.masterPlaylistLoader_.master.locations[0];
    if (location2 && location2 !== this.masterPlaylistLoader_.srcUrl) {
      this.masterPlaylistLoader_.srcUrl = location2;
    }
    if (!oldMaster || newMaster && newMaster.minimumUpdatePeriod !== oldMaster.minimumUpdatePeriod) {
      this.updateMinimumUpdatePeriodTimeout_();
    }
    return Boolean(newMaster);
  };
  _proto.updateMinimumUpdatePeriodTimeout_ = function updateMinimumUpdatePeriodTimeout_() {
    var mpl = this.masterPlaylistLoader_;
    if (mpl.createMupOnMedia_) {
      mpl.off("loadedmetadata", mpl.createMupOnMedia_);
      mpl.createMupOnMedia_ = null;
    }
    if (mpl.minimumUpdatePeriodTimeout_) {
      import_window6.default.clearTimeout(mpl.minimumUpdatePeriodTimeout_);
      mpl.minimumUpdatePeriodTimeout_ = null;
    }
    var mup = mpl.master && mpl.master.minimumUpdatePeriod;
    if (mup === 0) {
      if (mpl.media()) {
        mup = mpl.media().targetDuration * 1e3;
      } else {
        mpl.createMupOnMedia_ = mpl.updateMinimumUpdatePeriodTimeout_;
        mpl.one("loadedmetadata", mpl.createMupOnMedia_);
      }
    }
    if (typeof mup !== "number" || mup <= 0) {
      if (mup < 0) {
        this.logger_("found invalid minimumUpdatePeriod of " + mup + ", not setting a timeout");
      }
      return;
    }
    this.createMUPTimeout_(mup);
  };
  _proto.createMUPTimeout_ = function createMUPTimeout_(mup) {
    var mpl = this.masterPlaylistLoader_;
    mpl.minimumUpdatePeriodTimeout_ = import_window6.default.setTimeout(function() {
      mpl.minimumUpdatePeriodTimeout_ = null;
      mpl.trigger("minimumUpdatePeriod");
      mpl.createMUPTimeout_(mup);
    }, mup);
  };
  _proto.refreshXml_ = function refreshXml_() {
    var _this8 = this;
    this.requestMaster_(function(req, masterChanged) {
      if (!masterChanged) {
        return;
      }
      if (_this8.media_) {
        _this8.media_ = _this8.masterPlaylistLoader_.master.playlists[_this8.media_.id];
      }
      _this8.masterPlaylistLoader_.sidxMapping_ = filterChangedSidxMappings(_this8.masterPlaylistLoader_.master, _this8.masterPlaylistLoader_.sidxMapping_);
      _this8.addSidxSegments_(_this8.media(), _this8.state, function(sidxChanged) {
        _this8.refreshMedia_(_this8.media().id);
      });
    });
  };
  _proto.refreshMedia_ = function refreshMedia_(mediaID) {
    var _this9 = this;
    if (!mediaID) {
      throw new Error("refreshMedia_ must take a media id");
    }
    if (this.media_ && this.isMaster_) {
      this.handleMaster_();
    }
    var playlists = this.masterPlaylistLoader_.master.playlists;
    var mediaChanged = !this.media_ || this.media_ !== playlists[mediaID];
    if (mediaChanged) {
      this.media_ = playlists[mediaID];
    } else {
      this.trigger("playlistunchanged");
    }
    if (!this.mediaUpdateTimeout) {
      var createMediaUpdateTimeout = function createMediaUpdateTimeout2() {
        if (_this9.media().endList) {
          return;
        }
        _this9.mediaUpdateTimeout = import_window6.default.setTimeout(function() {
          _this9.trigger("mediaupdatetimeout");
          createMediaUpdateTimeout2();
        }, refreshDelay(_this9.media(), Boolean(mediaChanged)));
      };
      createMediaUpdateTimeout();
    }
    this.trigger("loadedplaylist");
  };
  return DashPlaylistLoader2;
}(EventTarget2);
var Config = {
  GOAL_BUFFER_LENGTH: 30,
  MAX_GOAL_BUFFER_LENGTH: 60,
  BACK_BUFFER_LENGTH: 30,
  GOAL_BUFFER_LENGTH_RATE: 1,
  // 0.5 MB/s
  INITIAL_BANDWIDTH: 4194304,
  // A fudge factor to apply to advertised playlist bitrates to account for
  // temporary flucations in client bandwidth
  BANDWIDTH_VARIANCE: 1.2,
  // How much of the buffer must be filled before we consider upswitching
  BUFFER_LOW_WATER_LINE: 0,
  MAX_BUFFER_LOW_WATER_LINE: 30,
  // TODO: Remove this when experimentalBufferBasedABR is removed
  EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,
  BUFFER_LOW_WATER_LINE_RATE: 1,
  // If the buffer is greater than the high water line, we won't switch down
  BUFFER_HIGH_WATER_LINE: 30
};
var stringToArrayBuffer = function stringToArrayBuffer2(string) {
  var view = new Uint8Array(new ArrayBuffer(string.length));
  for (var i = 0; i < string.length; i++) {
    view[i] = string.charCodeAt(i);
  }
  return view.buffer;
};
var browserWorkerPolyFill = function browserWorkerPolyFill2(workerObj) {
  workerObj.on = workerObj.addEventListener;
  workerObj.off = workerObj.removeEventListener;
  return workerObj;
};
var createObjectURL = function createObjectURL2(str) {
  try {
    return URL.createObjectURL(new Blob([str], {
      type: "application/javascript"
    }));
  } catch (e) {
    var blob = new BlobBuilder();
    blob.append(str);
    return URL.createObjectURL(blob.getBlob());
  }
};
var factory = function factory2(code) {
  return function() {
    var objectUrl = createObjectURL(code);
    var worker = browserWorkerPolyFill(new Worker(objectUrl));
    worker.objURL = objectUrl;
    var terminate = worker.terminate;
    worker.on = worker.addEventListener;
    worker.off = worker.removeEventListener;
    worker.terminate = function() {
      URL.revokeObjectURL(objectUrl);
      return terminate.call(this);
    };
    return worker;
  };
};
var transform = function transform2(code) {
  return "var browserWorkerPolyFill = " + browserWorkerPolyFill.toString() + ";\nbrowserWorkerPolyFill(self);\n" + code;
};
var getWorkerString = function getWorkerString2(fn) {
  return fn.toString().replace(/^function.+?{/, "").slice(0, -1);
};
var workerCode$1 = transform(getWorkerString(function() {
  var Stream2 = function Stream3() {
    this.init = function() {
      var listeners = {};
      this.on = function(type3, listener) {
        if (!listeners[type3]) {
          listeners[type3] = [];
        }
        listeners[type3] = listeners[type3].concat(listener);
      };
      this.off = function(type3, listener) {
        var index;
        if (!listeners[type3]) {
          return false;
        }
        index = listeners[type3].indexOf(listener);
        listeners[type3] = listeners[type3].slice();
        listeners[type3].splice(index, 1);
        return index > -1;
      };
      this.trigger = function(type3) {
        var callbacks, i, length, args;
        callbacks = listeners[type3];
        if (!callbacks) {
          return;
        }
        if (arguments.length === 2) {
          length = callbacks.length;
          for (i = 0; i < length; ++i) {
            callbacks[i].call(this, arguments[1]);
          }
        } else {
          args = [];
          i = arguments.length;
          for (i = 1; i < arguments.length; ++i) {
            args.push(arguments[i]);
          }
          length = callbacks.length;
          for (i = 0; i < length; ++i) {
            callbacks[i].apply(this, args);
          }
        }
      };
      this.dispose = function() {
        listeners = {};
      };
    };
  };
  Stream2.prototype.pipe = function(destination) {
    this.on("data", function(data) {
      destination.push(data);
    });
    this.on("done", function(flushSource) {
      destination.flush(flushSource);
    });
    this.on("partialdone", function(flushSource) {
      destination.partialFlush(flushSource);
    });
    this.on("endedtimeline", function(flushSource) {
      destination.endTimeline(flushSource);
    });
    this.on("reset", function(flushSource) {
      destination.reset(flushSource);
    });
    return destination;
  };
  Stream2.prototype.push = function(data) {
    this.trigger("data", data);
  };
  Stream2.prototype.flush = function(flushSource) {
    this.trigger("done", flushSource);
  };
  Stream2.prototype.partialFlush = function(flushSource) {
    this.trigger("partialdone", flushSource);
  };
  Stream2.prototype.endTimeline = function(flushSource) {
    this.trigger("endedtimeline", flushSource);
  };
  Stream2.prototype.reset = function(flushSource) {
    this.trigger("reset", flushSource);
  };
  var stream = Stream2;
  var MAX_UINT32$1 = Math.pow(2, 32);
  var getUint64$2 = function getUint642(uint8) {
    var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
    var value;
    if (dv.getBigUint64) {
      value = dv.getBigUint64(0);
      if (value < Number.MAX_SAFE_INTEGER) {
        return Number(value);
      }
      return value;
    }
    return dv.getUint32(0) * MAX_UINT32$1 + dv.getUint32(4);
  };
  var numbers = {
    getUint64: getUint64$2,
    MAX_UINT32: MAX_UINT32$1
  };
  var MAX_UINT32 = numbers.MAX_UINT32;
  var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun$1, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;
  (function() {
    var i;
    types = {
      avc1: [],
      // codingname
      avcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      // codingname
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      smhd: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      styp: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: []
    };
    if (typeof Uint8Array === "undefined") {
      return;
    }
    for (i in types) {
      if (types.hasOwnProperty(i)) {
        types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
      }
    }
    MAJOR_BRAND = new Uint8Array(["i".charCodeAt(0), "s".charCodeAt(0), "o".charCodeAt(0), "m".charCodeAt(0)]);
    AVC1_BRAND = new Uint8Array(["a".charCodeAt(0), "v".charCodeAt(0), "c".charCodeAt(0), "1".charCodeAt(0)]);
    MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);
    VIDEO_HDLR = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      118,
      105,
      100,
      101,
      // handler_type: 'vide'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      86,
      105,
      100,
      101,
      111,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'VideoHandler'
    ]);
    AUDIO_HDLR = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      115,
      111,
      117,
      110,
      // handler_type: 'soun'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      83,
      111,
      117,
      110,
      100,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'SoundHandler'
    ]);
    HDLR_TYPES = {
      video: VIDEO_HDLR,
      audio: AUDIO_HDLR
    };
    DREF = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1,
      // entry_count
      0,
      0,
      0,
      12,
      // entry_size
      117,
      114,
      108,
      32,
      // 'url' type
      0,
      // version 0
      0,
      0,
      1
      // entry_flags
    ]);
    SMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      // balance, 0 means centered
      0,
      0
      // reserved
    ]);
    STCO = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0
      // entry_count
    ]);
    STSC = STCO;
    STSZ = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // sample_size
      0,
      0,
      0,
      0
      // sample_count
    ]);
    STTS = STCO;
    VMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      1,
      // flags
      0,
      0,
      // graphicsmode
      0,
      0,
      0,
      0,
      0,
      0
      // opcolor
    ]);
  })();
  box = function box2(type3) {
    var payload = [], size = 0, i, result, view;
    for (i = 1; i < arguments.length; i++) {
      payload.push(arguments[i]);
    }
    i = payload.length;
    while (i--) {
      size += payload[i].byteLength;
    }
    result = new Uint8Array(size + 8);
    view = new DataView(result.buffer, result.byteOffset, result.byteLength);
    view.setUint32(0, result.byteLength);
    result.set(type3, 4);
    for (i = 0, size = 8; i < payload.length; i++) {
      result.set(payload[i], size);
      size += payload[i].byteLength;
    }
    return result;
  };
  dinf = function dinf2() {
    return box(types.dinf, box(types.dref, DREF));
  };
  esds = function esds2(track) {
    return box(types.esds, new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      // ES_Descriptor
      3,
      // tag, ES_DescrTag
      25,
      // length
      0,
      0,
      // ES_ID
      0,
      // streamDependenceFlag, URL_flag, reserved, streamPriority
      // DecoderConfigDescriptor
      4,
      // tag, DecoderConfigDescrTag
      17,
      // length
      64,
      // object type
      21,
      // streamType
      0,
      6,
      0,
      // bufferSizeDB
      0,
      0,
      218,
      192,
      // maxBitrate
      0,
      0,
      218,
      192,
      // avgBitrate
      // DecoderSpecificInfo
      5,
      // tag, DecoderSpecificInfoTag
      2,
      // length
      // ISO/IEC 14496-3, AudioSpecificConfig
      // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35
      track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1,
      track.samplingfrequencyindex << 7 | track.channelcount << 3,
      6,
      1,
      2
      // GASpecificConfig
    ]));
  };
  ftyp = function ftyp2() {
    return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);
  };
  hdlr = function hdlr2(type3) {
    return box(types.hdlr, HDLR_TYPES[type3]);
  };
  mdat = function mdat2(data) {
    return box(types.mdat, data);
  };
  mdhd = function mdhd2(track) {
    var result = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      3,
      // modification_time
      0,
      1,
      95,
      144,
      // timescale, 90,000 "ticks" per second
      track.duration >>> 24 & 255,
      track.duration >>> 16 & 255,
      track.duration >>> 8 & 255,
      track.duration & 255,
      // duration
      85,
      196,
      // 'und' language (undetermined)
      0,
      0
    ]);
    if (track.samplerate) {
      result[12] = track.samplerate >>> 24 & 255;
      result[13] = track.samplerate >>> 16 & 255;
      result[14] = track.samplerate >>> 8 & 255;
      result[15] = track.samplerate & 255;
    }
    return box(types.mdhd, result);
  };
  mdia = function mdia2(track) {
    return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));
  };
  mfhd = function mfhd2(sequenceNumber) {
    return box(types.mfhd, new Uint8Array([
      0,
      0,
      0,
      0,
      // flags
      (sequenceNumber & 4278190080) >> 24,
      (sequenceNumber & 16711680) >> 16,
      (sequenceNumber & 65280) >> 8,
      sequenceNumber & 255
      // sequence_number
    ]));
  };
  minf = function minf2(track) {
    return box(types.minf, track.type === "video" ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));
  };
  moof = function moof2(sequenceNumber, tracks) {
    var trackFragments = [], i = tracks.length;
    while (i--) {
      trackFragments[i] = traf(tracks[i]);
    }
    return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));
  };
  moov = function moov2(tracks) {
    var i = tracks.length, boxes = [];
    while (i--) {
      boxes[i] = trak(tracks[i]);
    }
    return box.apply(null, [types.moov, mvhd(4294967295)].concat(boxes).concat(mvex(tracks)));
  };
  mvex = function mvex2(tracks) {
    var i = tracks.length, boxes = [];
    while (i--) {
      boxes[i] = trex(tracks[i]);
    }
    return box.apply(null, [types.mvex].concat(boxes));
  };
  mvhd = function mvhd2(duration5) {
    var bytes = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1,
      // creation_time
      0,
      0,
      0,
      2,
      // modification_time
      0,
      1,
      95,
      144,
      // timescale, 90,000 "ticks" per second
      (duration5 & 4278190080) >> 24,
      (duration5 & 16711680) >> 16,
      (duration5 & 65280) >> 8,
      duration5 & 255,
      // duration
      0,
      1,
      0,
      0,
      // 1.0 rate
      1,
      0,
      // 1.0 volume
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // pre_defined
      255,
      255,
      255,
      255
      // next_track_ID
    ]);
    return box(types.mvhd, bytes);
  };
  sdtp = function sdtp2(track) {
    var samples = track.samples || [], bytes = new Uint8Array(4 + samples.length), flags, i;
    for (i = 0; i < samples.length; i++) {
      flags = samples[i].flags;
      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
    }
    return box(types.sdtp, bytes);
  };
  stbl = function stbl2(track) {
    return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));
  };
  (function() {
    var videoSample, audioSample;
    stsd = function stsd2(track) {
      return box(types.stsd, new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        1
      ]), track.type === "video" ? videoSample(track) : audioSample(track));
    };
    videoSample = function videoSample2(track) {
      var sps = track.sps || [], pps = track.pps || [], sequenceParameterSets = [], pictureParameterSets = [], i, avc1Box;
      for (i = 0; i < sps.length; i++) {
        sequenceParameterSets.push((sps[i].byteLength & 65280) >>> 8);
        sequenceParameterSets.push(sps[i].byteLength & 255);
        sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i]));
      }
      for (i = 0; i < pps.length; i++) {
        pictureParameterSets.push((pps[i].byteLength & 65280) >>> 8);
        pictureParameterSets.push(pps[i].byteLength & 255);
        pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));
      }
      avc1Box = [types.avc1, new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        (track.width & 65280) >> 8,
        track.width & 255,
        // width
        (track.height & 65280) >> 8,
        track.height & 255,
        // height
        0,
        72,
        0,
        0,
        // horizresolution
        0,
        72,
        0,
        0,
        // vertresolution
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // frame_count
        19,
        118,
        105,
        100,
        101,
        111,
        106,
        115,
        45,
        99,
        111,
        110,
        116,
        114,
        105,
        98,
        45,
        104,
        108,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // compressorname
        0,
        24,
        // depth = 24
        17,
        17
        // pre_defined = -1
      ]), box(types.avcC, new Uint8Array([
        1,
        // configurationVersion
        track.profileIdc,
        // AVCProfileIndication
        track.profileCompatibility,
        // profile_compatibility
        track.levelIdc,
        // AVCLevelIndication
        255
        // lengthSizeMinusOne, hard-coded to 4 bytes
      ].concat(
        [sps.length],
        // numOfSequenceParameterSets
        sequenceParameterSets,
        // "SPS"
        [pps.length],
        // numOfPictureParameterSets
        pictureParameterSets
        // "PPS"
      ))), box(types.btrt, new Uint8Array([
        0,
        28,
        156,
        128,
        // bufferSizeDB
        0,
        45,
        198,
        192,
        // maxBitrate
        0,
        45,
        198,
        192
        // avgBitrate
      ]))];
      if (track.sarRatio) {
        var hSpacing = track.sarRatio[0], vSpacing = track.sarRatio[1];
        avc1Box.push(box(types.pasp, new Uint8Array([(hSpacing & 4278190080) >> 24, (hSpacing & 16711680) >> 16, (hSpacing & 65280) >> 8, hSpacing & 255, (vSpacing & 4278190080) >> 24, (vSpacing & 16711680) >> 16, (vSpacing & 65280) >> 8, vSpacing & 255])));
      }
      return box.apply(null, avc1Box);
    };
    audioSample = function audioSample2(track) {
      return box(types.mp4a, new Uint8Array([
        // SampleEntry, ISO/IEC 14496-12
        0,
        0,
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        // AudioSampleEntry, ISO/IEC 14496-12
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        (track.channelcount & 65280) >> 8,
        track.channelcount & 255,
        // channelcount
        (track.samplesize & 65280) >> 8,
        track.samplesize & 255,
        // samplesize
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        (track.samplerate & 65280) >> 8,
        track.samplerate & 255,
        0,
        0
        // samplerate, 16.16
        // MP4AudioSampleEntry, ISO/IEC 14496-14
      ]), esds(track));
    };
  })();
  tkhd = function tkhd2(track) {
    var result = new Uint8Array([
      0,
      // version 0
      0,
      0,
      7,
      // flags
      0,
      0,
      0,
      0,
      // creation_time
      0,
      0,
      0,
      0,
      // modification_time
      (track.id & 4278190080) >> 24,
      (track.id & 16711680) >> 16,
      (track.id & 65280) >> 8,
      track.id & 255,
      // track_ID
      0,
      0,
      0,
      0,
      // reserved
      (track.duration & 4278190080) >> 24,
      (track.duration & 16711680) >> 16,
      (track.duration & 65280) >> 8,
      track.duration & 255,
      // duration
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      // layer
      0,
      0,
      // alternate_group
      1,
      0,
      // non-audio track volume
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      (track.width & 65280) >> 8,
      track.width & 255,
      0,
      0,
      // width
      (track.height & 65280) >> 8,
      track.height & 255,
      0,
      0
      // height
    ]);
    return box(types.tkhd, result);
  };
  traf = function traf2(track) {
    var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;
    trackFragmentHeader = box(types.tfhd, new Uint8Array([
      0,
      // version 0
      0,
      0,
      58,
      // flags
      (track.id & 4278190080) >> 24,
      (track.id & 16711680) >> 16,
      (track.id & 65280) >> 8,
      track.id & 255,
      // track_ID
      0,
      0,
      0,
      1,
      // sample_description_index
      0,
      0,
      0,
      0,
      // default_sample_duration
      0,
      0,
      0,
      0,
      // default_sample_size
      0,
      0,
      0,
      0
      // default_sample_flags
    ]));
    upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / MAX_UINT32);
    lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % MAX_UINT32);
    trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([
      1,
      // version 1
      0,
      0,
      0,
      // flags
      // baseMediaDecodeTime
      upperWordBaseMediaDecodeTime >>> 24 & 255,
      upperWordBaseMediaDecodeTime >>> 16 & 255,
      upperWordBaseMediaDecodeTime >>> 8 & 255,
      upperWordBaseMediaDecodeTime & 255,
      lowerWordBaseMediaDecodeTime >>> 24 & 255,
      lowerWordBaseMediaDecodeTime >>> 16 & 255,
      lowerWordBaseMediaDecodeTime >>> 8 & 255,
      lowerWordBaseMediaDecodeTime & 255
    ]));
    dataOffset = 32 + // tfhd
    20 + // tfdt
    8 + // traf header
    16 + // mfhd
    8 + // moof header
    8;
    if (track.type === "audio") {
      trackFragmentRun = trun$1(track, dataOffset);
      return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);
    }
    sampleDependencyTable = sdtp(track);
    trackFragmentRun = trun$1(track, sampleDependencyTable.length + dataOffset);
    return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);
  };
  trak = function trak2(track) {
    track.duration = track.duration || 4294967295;
    return box(types.trak, tkhd(track), mdia(track));
  };
  trex = function trex2(track) {
    var result = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      (track.id & 4278190080) >> 24,
      (track.id & 16711680) >> 16,
      (track.id & 65280) >> 8,
      track.id & 255,
      // track_ID
      0,
      0,
      0,
      1,
      // default_sample_description_index
      0,
      0,
      0,
      0,
      // default_sample_duration
      0,
      0,
      0,
      0,
      // default_sample_size
      0,
      1,
      0,
      1
      // default_sample_flags
    ]);
    if (track.type !== "video") {
      result[result.length - 1] = 0;
    }
    return box(types.trex, result);
  };
  (function() {
    var audioTrun, videoTrun, trunHeader;
    trunHeader = function trunHeader2(samples, offset) {
      var durationPresent = 0, sizePresent = 0, flagsPresent = 0, compositionTimeOffset = 0;
      if (samples.length) {
        if (samples[0].duration !== void 0) {
          durationPresent = 1;
        }
        if (samples[0].size !== void 0) {
          sizePresent = 2;
        }
        if (samples[0].flags !== void 0) {
          flagsPresent = 4;
        }
        if (samples[0].compositionTimeOffset !== void 0) {
          compositionTimeOffset = 8;
        }
      }
      return [
        0,
        // version 0
        0,
        durationPresent | sizePresent | flagsPresent | compositionTimeOffset,
        1,
        // flags
        (samples.length & 4278190080) >>> 24,
        (samples.length & 16711680) >>> 16,
        (samples.length & 65280) >>> 8,
        samples.length & 255,
        // sample_count
        (offset & 4278190080) >>> 24,
        (offset & 16711680) >>> 16,
        (offset & 65280) >>> 8,
        offset & 255
        // data_offset
      ];
    };
    videoTrun = function videoTrun2(track, offset) {
      var bytesOffest, bytes, header, samples, sample, i;
      samples = track.samples || [];
      offset += 8 + 12 + 16 * samples.length;
      header = trunHeader(samples, offset);
      bytes = new Uint8Array(header.length + samples.length * 16);
      bytes.set(header);
      bytesOffest = header.length;
      for (i = 0; i < samples.length; i++) {
        sample = samples[i];
        bytes[bytesOffest++] = (sample.duration & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.duration & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.duration & 65280) >>> 8;
        bytes[bytesOffest++] = sample.duration & 255;
        bytes[bytesOffest++] = (sample.size & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.size & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.size & 65280) >>> 8;
        bytes[bytesOffest++] = sample.size & 255;
        bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn;
        bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample;
        bytes[bytesOffest++] = sample.flags.degradationPriority & 240 << 8;
        bytes[bytesOffest++] = sample.flags.degradationPriority & 15;
        bytes[bytesOffest++] = (sample.compositionTimeOffset & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.compositionTimeOffset & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.compositionTimeOffset & 65280) >>> 8;
        bytes[bytesOffest++] = sample.compositionTimeOffset & 255;
      }
      return box(types.trun, bytes);
    };
    audioTrun = function audioTrun2(track, offset) {
      var bytes, bytesOffest, header, samples, sample, i;
      samples = track.samples || [];
      offset += 8 + 12 + 8 * samples.length;
      header = trunHeader(samples, offset);
      bytes = new Uint8Array(header.length + samples.length * 8);
      bytes.set(header);
      bytesOffest = header.length;
      for (i = 0; i < samples.length; i++) {
        sample = samples[i];
        bytes[bytesOffest++] = (sample.duration & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.duration & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.duration & 65280) >>> 8;
        bytes[bytesOffest++] = sample.duration & 255;
        bytes[bytesOffest++] = (sample.size & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.size & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.size & 65280) >>> 8;
        bytes[bytesOffest++] = sample.size & 255;
      }
      return box(types.trun, bytes);
    };
    trun$1 = function trun2(track, offset) {
      if (track.type === "audio") {
        return audioTrun(track, offset);
      }
      return videoTrun(track, offset);
    };
  })();
  var mp4Generator = {
    ftyp,
    mdat,
    moof,
    moov,
    initSegment: function initSegment(tracks) {
      var fileType = ftyp(), movie = moov(tracks), result;
      result = new Uint8Array(fileType.byteLength + movie.byteLength);
      result.set(fileType);
      result.set(movie, fileType.byteLength);
      return result;
    }
  };
  var groupNalsIntoFrames = function groupNalsIntoFrames2(nalUnits) {
    var i, currentNal, currentFrame = [], frames = [];
    frames.byteLength = 0;
    frames.nalCount = 0;
    frames.duration = 0;
    currentFrame.byteLength = 0;
    for (i = 0; i < nalUnits.length; i++) {
      currentNal = nalUnits[i];
      if (currentNal.nalUnitType === "access_unit_delimiter_rbsp") {
        if (currentFrame.length) {
          currentFrame.duration = currentNal.dts - currentFrame.dts;
          frames.byteLength += currentFrame.byteLength;
          frames.nalCount += currentFrame.length;
          frames.duration += currentFrame.duration;
          frames.push(currentFrame);
        }
        currentFrame = [currentNal];
        currentFrame.byteLength = currentNal.data.byteLength;
        currentFrame.pts = currentNal.pts;
        currentFrame.dts = currentNal.dts;
      } else {
        if (currentNal.nalUnitType === "slice_layer_without_partitioning_rbsp_idr") {
          currentFrame.keyFrame = true;
        }
        currentFrame.duration = currentNal.dts - currentFrame.dts;
        currentFrame.byteLength += currentNal.data.byteLength;
        currentFrame.push(currentNal);
      }
    }
    if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) {
      currentFrame.duration = frames[frames.length - 1].duration;
    }
    frames.byteLength += currentFrame.byteLength;
    frames.nalCount += currentFrame.length;
    frames.duration += currentFrame.duration;
    frames.push(currentFrame);
    return frames;
  };
  var groupFramesIntoGops = function groupFramesIntoGops2(frames) {
    var i, currentFrame, currentGop = [], gops = [];
    currentGop.byteLength = 0;
    currentGop.nalCount = 0;
    currentGop.duration = 0;
    currentGop.pts = frames[0].pts;
    currentGop.dts = frames[0].dts;
    gops.byteLength = 0;
    gops.nalCount = 0;
    gops.duration = 0;
    gops.pts = frames[0].pts;
    gops.dts = frames[0].dts;
    for (i = 0; i < frames.length; i++) {
      currentFrame = frames[i];
      if (currentFrame.keyFrame) {
        if (currentGop.length) {
          gops.push(currentGop);
          gops.byteLength += currentGop.byteLength;
          gops.nalCount += currentGop.nalCount;
          gops.duration += currentGop.duration;
        }
        currentGop = [currentFrame];
        currentGop.nalCount = currentFrame.length;
        currentGop.byteLength = currentFrame.byteLength;
        currentGop.pts = currentFrame.pts;
        currentGop.dts = currentFrame.dts;
        currentGop.duration = currentFrame.duration;
      } else {
        currentGop.duration += currentFrame.duration;
        currentGop.nalCount += currentFrame.length;
        currentGop.byteLength += currentFrame.byteLength;
        currentGop.push(currentFrame);
      }
    }
    if (gops.length && currentGop.duration <= 0) {
      currentGop.duration = gops[gops.length - 1].duration;
    }
    gops.byteLength += currentGop.byteLength;
    gops.nalCount += currentGop.nalCount;
    gops.duration += currentGop.duration;
    gops.push(currentGop);
    return gops;
  };
  var extendFirstKeyFrame = function extendFirstKeyFrame2(gops) {
    var currentGop;
    if (!gops[0][0].keyFrame && gops.length > 1) {
      currentGop = gops.shift();
      gops.byteLength -= currentGop.byteLength;
      gops.nalCount -= currentGop.nalCount;
      gops[0][0].dts = currentGop.dts;
      gops[0][0].pts = currentGop.pts;
      gops[0][0].duration += currentGop.duration;
    }
    return gops;
  };
  var createDefaultSample = function createDefaultSample2() {
    return {
      size: 0,
      flags: {
        isLeading: 0,
        dependsOn: 1,
        isDependedOn: 0,
        hasRedundancy: 0,
        degradationPriority: 0,
        isNonSyncSample: 1
      }
    };
  };
  var sampleForFrame = function sampleForFrame2(frame, dataOffset) {
    var sample = createDefaultSample();
    sample.dataOffset = dataOffset;
    sample.compositionTimeOffset = frame.pts - frame.dts;
    sample.duration = frame.duration;
    sample.size = 4 * frame.length;
    sample.size += frame.byteLength;
    if (frame.keyFrame) {
      sample.flags.dependsOn = 2;
      sample.flags.isNonSyncSample = 0;
    }
    return sample;
  };
  var generateSampleTable$1 = function generateSampleTable2(gops, baseDataOffset) {
    var h, i, sample, currentGop, currentFrame, dataOffset = baseDataOffset || 0, samples = [];
    for (h = 0; h < gops.length; h++) {
      currentGop = gops[h];
      for (i = 0; i < currentGop.length; i++) {
        currentFrame = currentGop[i];
        sample = sampleForFrame(currentFrame, dataOffset);
        dataOffset += sample.size;
        samples.push(sample);
      }
    }
    return samples;
  };
  var concatenateNalData = function concatenateNalData2(gops) {
    var h, i, j, currentGop, currentFrame, currentNal, dataOffset = 0, nalsByteLength = gops.byteLength, numberOfNals = gops.nalCount, totalByteLength = nalsByteLength + 4 * numberOfNals, data = new Uint8Array(totalByteLength), view = new DataView(data.buffer);
    for (h = 0; h < gops.length; h++) {
      currentGop = gops[h];
      for (i = 0; i < currentGop.length; i++) {
        currentFrame = currentGop[i];
        for (j = 0; j < currentFrame.length; j++) {
          currentNal = currentFrame[j];
          view.setUint32(dataOffset, currentNal.data.byteLength);
          dataOffset += 4;
          data.set(currentNal.data, dataOffset);
          dataOffset += currentNal.data.byteLength;
        }
      }
    }
    return data;
  };
  var generateSampleTableForFrame = function generateSampleTableForFrame2(frame, baseDataOffset) {
    var sample, dataOffset = baseDataOffset || 0, samples = [];
    sample = sampleForFrame(frame, dataOffset);
    samples.push(sample);
    return samples;
  };
  var concatenateNalDataForFrame = function concatenateNalDataForFrame2(frame) {
    var i, currentNal, dataOffset = 0, nalsByteLength = frame.byteLength, numberOfNals = frame.length, totalByteLength = nalsByteLength + 4 * numberOfNals, data = new Uint8Array(totalByteLength), view = new DataView(data.buffer);
    for (i = 0; i < frame.length; i++) {
      currentNal = frame[i];
      view.setUint32(dataOffset, currentNal.data.byteLength);
      dataOffset += 4;
      data.set(currentNal.data, dataOffset);
      dataOffset += currentNal.data.byteLength;
    }
    return data;
  };
  var frameUtils = {
    groupNalsIntoFrames,
    groupFramesIntoGops,
    extendFirstKeyFrame,
    generateSampleTable: generateSampleTable$1,
    concatenateNalData,
    generateSampleTableForFrame,
    concatenateNalDataForFrame
  };
  var highPrefix = [33, 16, 5, 32, 164, 27];
  var lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];
  var zeroFill = function zeroFill2(count) {
    var a = [];
    while (count--) {
      a.push(0);
    }
    return a;
  };
  var makeTable = function makeTable2(metaTable) {
    return Object.keys(metaTable).reduce(function(obj, key) {
      obj[key] = new Uint8Array(metaTable[key].reduce(function(arr, part) {
        return arr.concat(part);
      }, []));
      return obj;
    }, {});
  };
  var silence;
  var silence_1 = function silence_12() {
    if (!silence) {
      var coneOfSilence = {
        96e3: [highPrefix, [227, 64], zeroFill(154), [56]],
        88200: [highPrefix, [231], zeroFill(170), [56]],
        64e3: [highPrefix, [248, 192], zeroFill(240), [56]],
        48e3: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],
        44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],
        32e3: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],
        24e3: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],
        16e3: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],
        12e3: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],
        11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],
        8e3: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]
      };
      silence = makeTable(coneOfSilence);
    }
    return silence;
  };
  var ONE_SECOND_IN_TS$4 = 9e4, secondsToVideoTs, secondsToAudioTs, videoTsToSeconds, audioTsToSeconds, audioTsToVideoTs, videoTsToAudioTs, metadataTsToSeconds;
  secondsToVideoTs = function secondsToVideoTs2(seconds) {
    return seconds * ONE_SECOND_IN_TS$4;
  };
  secondsToAudioTs = function secondsToAudioTs2(seconds, sampleRate) {
    return seconds * sampleRate;
  };
  videoTsToSeconds = function videoTsToSeconds2(timestamp) {
    return timestamp / ONE_SECOND_IN_TS$4;
  };
  audioTsToSeconds = function audioTsToSeconds2(timestamp, sampleRate) {
    return timestamp / sampleRate;
  };
  audioTsToVideoTs = function audioTsToVideoTs2(timestamp, sampleRate) {
    return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));
  };
  videoTsToAudioTs = function videoTsToAudioTs2(timestamp, sampleRate) {
    return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);
  };
  metadataTsToSeconds = function metadataTsToSeconds2(timestamp, timelineStartPts, keepOriginalTimestamps) {
    return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
  };
  var clock = {
    ONE_SECOND_IN_TS: ONE_SECOND_IN_TS$4,
    secondsToVideoTs,
    secondsToAudioTs,
    videoTsToSeconds,
    audioTsToSeconds,
    audioTsToVideoTs,
    videoTsToAudioTs,
    metadataTsToSeconds
  };
  var sumFrameByteLengths = function sumFrameByteLengths2(array) {
    var i, currentObj, sum = 0;
    for (i = 0; i < array.length; i++) {
      currentObj = array[i];
      sum += currentObj.data.byteLength;
    }
    return sum;
  };
  var prefixWithSilence = function prefixWithSilence2(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {
    var baseMediaDecodeTimeTs, frameDuration = 0, audioGapDuration = 0, audioFillFrameCount = 0, audioFillDuration = 0, silentFrame, i, firstFrame;
    if (!frames.length) {
      return;
    }
    baseMediaDecodeTimeTs = clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate);
    frameDuration = Math.ceil(clock.ONE_SECOND_IN_TS / (track.samplerate / 1024));
    if (audioAppendStartTs && videoBaseMediaDecodeTime) {
      audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime);
      audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);
      audioFillDuration = audioFillFrameCount * frameDuration;
    }
    if (audioFillFrameCount < 1 || audioFillDuration > clock.ONE_SECOND_IN_TS / 2) {
      return;
    }
    silentFrame = silence_1()[track.samplerate];
    if (!silentFrame) {
      silentFrame = frames[0].data;
    }
    for (i = 0; i < audioFillFrameCount; i++) {
      firstFrame = frames[0];
      frames.splice(0, 0, {
        data: silentFrame,
        dts: firstFrame.dts - frameDuration,
        pts: firstFrame.pts - frameDuration
      });
    }
    track.baseMediaDecodeTime -= Math.floor(clock.videoTsToAudioTs(audioFillDuration, track.samplerate));
    return audioFillDuration;
  };
  var trimAdtsFramesByEarliestDts = function trimAdtsFramesByEarliestDts2(adtsFrames, track, earliestAllowedDts) {
    if (track.minSegmentDts >= earliestAllowedDts) {
      return adtsFrames;
    }
    track.minSegmentDts = Infinity;
    return adtsFrames.filter(function(currentFrame) {
      if (currentFrame.dts >= earliestAllowedDts) {
        track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);
        track.minSegmentPts = track.minSegmentDts;
        return true;
      }
      return false;
    });
  };
  var generateSampleTable = function generateSampleTable2(frames) {
    var i, currentFrame, samples = [];
    for (i = 0; i < frames.length; i++) {
      currentFrame = frames[i];
      samples.push({
        size: currentFrame.data.byteLength,
        duration: 1024
        // For AAC audio, all samples contain 1024 samples
      });
    }
    return samples;
  };
  var concatenateFrameData = function concatenateFrameData2(frames) {
    var i, currentFrame, dataOffset = 0, data = new Uint8Array(sumFrameByteLengths(frames));
    for (i = 0; i < frames.length; i++) {
      currentFrame = frames[i];
      data.set(currentFrame.data, dataOffset);
      dataOffset += currentFrame.data.byteLength;
    }
    return data;
  };
  var audioFrameUtils = {
    prefixWithSilence,
    trimAdtsFramesByEarliestDts,
    generateSampleTable,
    concatenateFrameData
  };
  var ONE_SECOND_IN_TS$3 = clock.ONE_SECOND_IN_TS;
  var collectDtsInfo = function collectDtsInfo2(track, data) {
    if (typeof data.pts === "number") {
      if (track.timelineStartInfo.pts === void 0) {
        track.timelineStartInfo.pts = data.pts;
      }
      if (track.minSegmentPts === void 0) {
        track.minSegmentPts = data.pts;
      } else {
        track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);
      }
      if (track.maxSegmentPts === void 0) {
        track.maxSegmentPts = data.pts;
      } else {
        track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);
      }
    }
    if (typeof data.dts === "number") {
      if (track.timelineStartInfo.dts === void 0) {
        track.timelineStartInfo.dts = data.dts;
      }
      if (track.minSegmentDts === void 0) {
        track.minSegmentDts = data.dts;
      } else {
        track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);
      }
      if (track.maxSegmentDts === void 0) {
        track.maxSegmentDts = data.dts;
      } else {
        track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);
      }
    }
  };
  var clearDtsInfo = function clearDtsInfo2(track) {
    delete track.minSegmentDts;
    delete track.maxSegmentDts;
    delete track.minSegmentPts;
    delete track.maxSegmentPts;
  };
  var calculateTrackBaseMediaDecodeTime = function calculateTrackBaseMediaDecodeTime2(track, keepOriginalTimestamps) {
    var baseMediaDecodeTime, scale, minSegmentDts = track.minSegmentDts;
    if (!keepOriginalTimestamps) {
      minSegmentDts -= track.timelineStartInfo.dts;
    }
    baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;
    baseMediaDecodeTime += minSegmentDts;
    baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);
    if (track.type === "audio") {
      scale = track.samplerate / ONE_SECOND_IN_TS$3;
      baseMediaDecodeTime *= scale;
      baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);
    }
    return baseMediaDecodeTime;
  };
  var trackDecodeInfo = {
    clearDtsInfo,
    calculateTrackBaseMediaDecodeTime,
    collectDtsInfo
  };
  var USER_DATA_REGISTERED_ITU_T_T35 = 4, RBSP_TRAILING_BITS = 128;
  var parseSei = function parseSei2(bytes) {
    var i = 0, result = {
      payloadType: -1,
      payloadSize: 0
    }, payloadType = 0, payloadSize = 0;
    while (i < bytes.byteLength) {
      if (bytes[i] === RBSP_TRAILING_BITS) {
        break;
      }
      while (bytes[i] === 255) {
        payloadType += 255;
        i++;
      }
      payloadType += bytes[i++];
      while (bytes[i] === 255) {
        payloadSize += 255;
        i++;
      }
      payloadSize += bytes[i++];
      if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {
        var userIdentifier = String.fromCharCode(bytes[i + 3], bytes[i + 4], bytes[i + 5], bytes[i + 6]);
        if (userIdentifier === "GA94") {
          result.payloadType = payloadType;
          result.payloadSize = payloadSize;
          result.payload = bytes.subarray(i, i + payloadSize);
          break;
        } else {
          result.payload = void 0;
        }
      }
      i += payloadSize;
      payloadType = 0;
      payloadSize = 0;
    }
    return result;
  };
  var parseUserData = function parseUserData2(sei) {
    if (sei.payload[0] !== 181) {
      return null;
    }
    if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {
      return null;
    }
    if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== "GA94") {
      return null;
    }
    if (sei.payload[7] !== 3) {
      return null;
    }
    return sei.payload.subarray(8, sei.payload.length - 1);
  };
  var parseCaptionPackets = function parseCaptionPackets2(pts, userData) {
    var results = [], i, count, offset, data;
    if (!(userData[0] & 64)) {
      return results;
    }
    count = userData[0] & 31;
    for (i = 0; i < count; i++) {
      offset = i * 3;
      data = {
        type: userData[offset + 2] & 3,
        pts
      };
      if (userData[offset + 2] & 4) {
        data.ccData = userData[offset + 3] << 8 | userData[offset + 4];
        results.push(data);
      }
    }
    return results;
  };
  var discardEmulationPreventionBytes$1 = function discardEmulationPreventionBytes4(data) {
    var length = data.byteLength, emulationPreventionBytesPositions = [], i = 1, newLength, newData;
    while (i < length - 2) {
      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
        emulationPreventionBytesPositions.push(i + 2);
        i += 2;
      } else {
        i++;
      }
    }
    if (emulationPreventionBytesPositions.length === 0) {
      return data;
    }
    newLength = length - emulationPreventionBytesPositions.length;
    newData = new Uint8Array(newLength);
    var sourceIndex = 0;
    for (i = 0; i < newLength; sourceIndex++, i++) {
      if (sourceIndex === emulationPreventionBytesPositions[0]) {
        sourceIndex++;
        emulationPreventionBytesPositions.shift();
      }
      newData[i] = data[sourceIndex];
    }
    return newData;
  };
  var captionPacketParser = {
    parseSei,
    parseUserData,
    parseCaptionPackets,
    discardEmulationPreventionBytes: discardEmulationPreventionBytes$1,
    USER_DATA_REGISTERED_ITU_T_T35
  };
  var CaptionStream$1 = function CaptionStream2(options) {
    options = options || {};
    CaptionStream2.prototype.init.call(this);
    this.parse708captions_ = typeof options.parse708captions === "boolean" ? options.parse708captions : true;
    this.captionPackets_ = [];
    this.ccStreams_ = [
      new Cea608Stream(0, 0),
      // eslint-disable-line no-use-before-define
      new Cea608Stream(0, 1),
      // eslint-disable-line no-use-before-define
      new Cea608Stream(1, 0),
      // eslint-disable-line no-use-before-define
      new Cea608Stream(1, 1)
      // eslint-disable-line no-use-before-define
    ];
    if (this.parse708captions_) {
      this.cc708Stream_ = new Cea708Stream({
        captionServices: options.captionServices
      });
    }
    this.reset();
    this.ccStreams_.forEach(function(cc) {
      cc.on("data", this.trigger.bind(this, "data"));
      cc.on("partialdone", this.trigger.bind(this, "partialdone"));
      cc.on("done", this.trigger.bind(this, "done"));
    }, this);
    if (this.parse708captions_) {
      this.cc708Stream_.on("data", this.trigger.bind(this, "data"));
      this.cc708Stream_.on("partialdone", this.trigger.bind(this, "partialdone"));
      this.cc708Stream_.on("done", this.trigger.bind(this, "done"));
    }
  };
  CaptionStream$1.prototype = new stream();
  CaptionStream$1.prototype.push = function(event) {
    var sei, userData, newCaptionPackets;
    if (event.nalUnitType !== "sei_rbsp") {
      return;
    }
    sei = captionPacketParser.parseSei(event.escapedRBSP);
    if (!sei.payload) {
      return;
    }
    if (sei.payloadType !== captionPacketParser.USER_DATA_REGISTERED_ITU_T_T35) {
      return;
    }
    userData = captionPacketParser.parseUserData(sei);
    if (!userData) {
      return;
    }
    if (event.dts < this.latestDts_) {
      this.ignoreNextEqualDts_ = true;
      return;
    } else if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {
      this.numSameDts_--;
      if (!this.numSameDts_) {
        this.ignoreNextEqualDts_ = false;
      }
      return;
    }
    newCaptionPackets = captionPacketParser.parseCaptionPackets(event.pts, userData);
    this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);
    if (this.latestDts_ !== event.dts) {
      this.numSameDts_ = 0;
    }
    this.numSameDts_++;
    this.latestDts_ = event.dts;
  };
  CaptionStream$1.prototype.flushCCStreams = function(flushType) {
    this.ccStreams_.forEach(function(cc) {
      return flushType === "flush" ? cc.flush() : cc.partialFlush();
    }, this);
  };
  CaptionStream$1.prototype.flushStream = function(flushType) {
    if (!this.captionPackets_.length) {
      this.flushCCStreams(flushType);
      return;
    }
    this.captionPackets_.forEach(function(elem, idx) {
      elem.presortIndex = idx;
    });
    this.captionPackets_.sort(function(a, b) {
      if (a.pts === b.pts) {
        return a.presortIndex - b.presortIndex;
      }
      return a.pts - b.pts;
    });
    this.captionPackets_.forEach(function(packet) {
      if (packet.type < 2) {
        this.dispatchCea608Packet(packet);
      } else {
        this.dispatchCea708Packet(packet);
      }
    }, this);
    this.captionPackets_.length = 0;
    this.flushCCStreams(flushType);
  };
  CaptionStream$1.prototype.flush = function() {
    return this.flushStream("flush");
  };
  CaptionStream$1.prototype.partialFlush = function() {
    return this.flushStream("partialFlush");
  };
  CaptionStream$1.prototype.reset = function() {
    this.latestDts_ = null;
    this.ignoreNextEqualDts_ = false;
    this.numSameDts_ = 0;
    this.activeCea608Channel_ = [null, null];
    this.ccStreams_.forEach(function(ccStream) {
      ccStream.reset();
    });
  };
  CaptionStream$1.prototype.dispatchCea608Packet = function(packet) {
    if (this.setsTextOrXDSActive(packet)) {
      this.activeCea608Channel_[packet.type] = null;
    } else if (this.setsChannel1Active(packet)) {
      this.activeCea608Channel_[packet.type] = 0;
    } else if (this.setsChannel2Active(packet)) {
      this.activeCea608Channel_[packet.type] = 1;
    }
    if (this.activeCea608Channel_[packet.type] === null) {
      return;
    }
    this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);
  };
  CaptionStream$1.prototype.setsChannel1Active = function(packet) {
    return (packet.ccData & 30720) === 4096;
  };
  CaptionStream$1.prototype.setsChannel2Active = function(packet) {
    return (packet.ccData & 30720) === 6144;
  };
  CaptionStream$1.prototype.setsTextOrXDSActive = function(packet) {
    return (packet.ccData & 28928) === 256 || (packet.ccData & 30974) === 4138 || (packet.ccData & 30974) === 6186;
  };
  CaptionStream$1.prototype.dispatchCea708Packet = function(packet) {
    if (this.parse708captions_) {
      this.cc708Stream_.push(packet);
    }
  };
  var CHARACTER_TRANSLATION_708 = {
    127: 9834,
    // ♪
    4128: 32,
    // Transparent Space
    4129: 160,
    // Nob-breaking Transparent Space
    4133: 8230,
    // …
    4138: 352,
    // Š
    4140: 338,
    // Œ
    4144: 9608,
    // █
    4145: 8216,
    // ‘
    4146: 8217,
    // ’
    4147: 8220,
    // “
    4148: 8221,
    // ”
    4149: 8226,
    // •
    4153: 8482,
    // ™
    4154: 353,
    // š
    4156: 339,
    // œ
    4157: 8480,
    // ℠
    4159: 376,
    // Ÿ
    4214: 8539,
    // ⅛
    4215: 8540,
    // ⅜
    4216: 8541,
    // ⅝
    4217: 8542,
    // ⅞
    4218: 9168,
    // ⏐
    4219: 9124,
    // ⎤
    4220: 9123,
    // ⎣
    4221: 9135,
    // ⎯
    4222: 9126,
    // ⎦
    4223: 9121,
    // ⎡
    4256: 12600
    // ㄸ (CC char)
  };
  var get708CharFromCode = function get708CharFromCode2(code) {
    var newCode = CHARACTER_TRANSLATION_708[code] || code;
    if (code & 4096 && code === newCode) {
      return "";
    }
    return String.fromCharCode(newCode);
  };
  var within708TextBlock = function within708TextBlock2(b) {
    return 32 <= b && b <= 127 || 160 <= b && b <= 255;
  };
  var Cea708Window = function Cea708Window2(windowNum) {
    this.windowNum = windowNum;
    this.reset();
  };
  Cea708Window.prototype.reset = function() {
    this.clearText();
    this.pendingNewLine = false;
    this.winAttr = {};
    this.penAttr = {};
    this.penLoc = {};
    this.penColor = {};
    this.visible = 0;
    this.rowLock = 0;
    this.columnLock = 0;
    this.priority = 0;
    this.relativePositioning = 0;
    this.anchorVertical = 0;
    this.anchorHorizontal = 0;
    this.anchorPoint = 0;
    this.rowCount = 1;
    this.virtualRowCount = this.rowCount + 1;
    this.columnCount = 41;
    this.windowStyle = 0;
    this.penStyle = 0;
  };
  Cea708Window.prototype.getText = function() {
    return this.rows.join("\n");
  };
  Cea708Window.prototype.clearText = function() {
    this.rows = [""];
    this.rowIdx = 0;
  };
  Cea708Window.prototype.newLine = function(pts) {
    if (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow === "function") {
      this.beforeRowOverflow(pts);
    }
    if (this.rows.length > 0) {
      this.rows.push("");
      this.rowIdx++;
    }
    while (this.rows.length > this.virtualRowCount) {
      this.rows.shift();
      this.rowIdx--;
    }
  };
  Cea708Window.prototype.isEmpty = function() {
    if (this.rows.length === 0) {
      return true;
    } else if (this.rows.length === 1) {
      return this.rows[0] === "";
    }
    return false;
  };
  Cea708Window.prototype.addText = function(text) {
    this.rows[this.rowIdx] += text;
  };
  Cea708Window.prototype.backspace = function() {
    if (!this.isEmpty()) {
      var row = this.rows[this.rowIdx];
      this.rows[this.rowIdx] = row.substr(0, row.length - 1);
    }
  };
  var Cea708Service = function Cea708Service2(serviceNum, encoding, stream2) {
    this.serviceNum = serviceNum;
    this.text = "";
    this.currentWindow = new Cea708Window(-1);
    this.windows = [];
    this.stream = stream2;
    if (typeof encoding === "string") {
      this.createTextDecoder(encoding);
    }
  };
  Cea708Service.prototype.init = function(pts, beforeRowOverflow) {
    this.startPts = pts;
    for (var win2 = 0; win2 < 8; win2++) {
      this.windows[win2] = new Cea708Window(win2);
      if (typeof beforeRowOverflow === "function") {
        this.windows[win2].beforeRowOverflow = beforeRowOverflow;
      }
    }
  };
  Cea708Service.prototype.setCurrentWindow = function(windowNum) {
    this.currentWindow = this.windows[windowNum];
  };
  Cea708Service.prototype.createTextDecoder = function(encoding) {
    if (typeof TextDecoder === "undefined") {
      this.stream.trigger("log", {
        level: "warn",
        message: "The `encoding` option is unsupported without TextDecoder support"
      });
    } else {
      try {
        this.textDecoder_ = new TextDecoder(encoding);
      } catch (error) {
        this.stream.trigger("log", {
          level: "warn",
          message: "TextDecoder could not be created with " + encoding + " encoding. " + error
        });
      }
    }
  };
  var Cea708Stream = function Cea708Stream2(options) {
    options = options || {};
    Cea708Stream2.prototype.init.call(this);
    var self2 = this;
    var captionServices = options.captionServices || {};
    var captionServiceEncodings = {};
    var serviceProps;
    Object.keys(captionServices).forEach(function(serviceName) {
      serviceProps = captionServices[serviceName];
      if (/^SERVICE/.test(serviceName)) {
        captionServiceEncodings[serviceName] = serviceProps.encoding;
      }
    });
    this.serviceEncodings = captionServiceEncodings;
    this.current708Packet = null;
    this.services = {};
    this.push = function(packet) {
      if (packet.type === 3) {
        self2.new708Packet();
        self2.add708Bytes(packet);
      } else {
        if (self2.current708Packet === null) {
          self2.new708Packet();
        }
        self2.add708Bytes(packet);
      }
    };
  };
  Cea708Stream.prototype = new stream();
  Cea708Stream.prototype.new708Packet = function() {
    if (this.current708Packet !== null) {
      this.push708Packet();
    }
    this.current708Packet = {
      data: [],
      ptsVals: []
    };
  };
  Cea708Stream.prototype.add708Bytes = function(packet) {
    var data = packet.ccData;
    var byte0 = data >>> 8;
    var byte1 = data & 255;
    this.current708Packet.ptsVals.push(packet.pts);
    this.current708Packet.data.push(byte0);
    this.current708Packet.data.push(byte1);
  };
  Cea708Stream.prototype.push708Packet = function() {
    var packet708 = this.current708Packet;
    var packetData = packet708.data;
    var serviceNum = null;
    var blockSize = null;
    var i = 0;
    var b = packetData[i++];
    packet708.seq = b >> 6;
    packet708.sizeCode = b & 63;
    for (; i < packetData.length; i++) {
      b = packetData[i++];
      serviceNum = b >> 5;
      blockSize = b & 31;
      if (serviceNum === 7 && blockSize > 0) {
        b = packetData[i++];
        serviceNum = b;
      }
      this.pushServiceBlock(serviceNum, i, blockSize);
      if (blockSize > 0) {
        i += blockSize - 1;
      }
    }
  };
  Cea708Stream.prototype.pushServiceBlock = function(serviceNum, start2, size) {
    var b;
    var i = start2;
    var packetData = this.current708Packet.data;
    var service = this.services[serviceNum];
    if (!service) {
      service = this.initService(serviceNum, i);
    }
    for (; i < start2 + size && i < packetData.length; i++) {
      b = packetData[i];
      if (within708TextBlock(b)) {
        i = this.handleText(i, service);
      } else if (b === 24) {
        i = this.multiByteCharacter(i, service);
      } else if (b === 16) {
        i = this.extendedCommands(i, service);
      } else if (128 <= b && b <= 135) {
        i = this.setCurrentWindow(i, service);
      } else if (152 <= b && b <= 159) {
        i = this.defineWindow(i, service);
      } else if (b === 136) {
        i = this.clearWindows(i, service);
      } else if (b === 140) {
        i = this.deleteWindows(i, service);
      } else if (b === 137) {
        i = this.displayWindows(i, service);
      } else if (b === 138) {
        i = this.hideWindows(i, service);
      } else if (b === 139) {
        i = this.toggleWindows(i, service);
      } else if (b === 151) {
        i = this.setWindowAttributes(i, service);
      } else if (b === 144) {
        i = this.setPenAttributes(i, service);
      } else if (b === 145) {
        i = this.setPenColor(i, service);
      } else if (b === 146) {
        i = this.setPenLocation(i, service);
      } else if (b === 143) {
        service = this.reset(i, service);
      } else if (b === 8) {
        service.currentWindow.backspace();
      } else if (b === 12) {
        service.currentWindow.clearText();
      } else if (b === 13) {
        service.currentWindow.pendingNewLine = true;
      } else if (b === 14) {
        service.currentWindow.clearText();
      } else if (b === 141) {
        i++;
      } else ;
    }
  };
  Cea708Stream.prototype.extendedCommands = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[++i];
    if (within708TextBlock(b)) {
      i = this.handleText(i, service, {
        isExtended: true
      });
    }
    return i;
  };
  Cea708Stream.prototype.getPts = function(byteIndex) {
    return this.current708Packet.ptsVals[Math.floor(byteIndex / 2)];
  };
  Cea708Stream.prototype.initService = function(serviceNum, i) {
    var serviceName = "SERVICE" + serviceNum;
    var self2 = this;
    var serviceName;
    var encoding;
    if (serviceName in this.serviceEncodings) {
      encoding = this.serviceEncodings[serviceName];
    }
    this.services[serviceNum] = new Cea708Service(serviceNum, encoding, self2);
    this.services[serviceNum].init(this.getPts(i), function(pts) {
      self2.flushDisplayed(pts, self2.services[serviceNum]);
    });
    return this.services[serviceNum];
  };
  Cea708Stream.prototype.handleText = function(i, service, options) {
    var isExtended = options && options.isExtended;
    var isMultiByte = options && options.isMultiByte;
    var packetData = this.current708Packet.data;
    var extended = isExtended ? 4096 : 0;
    var currentByte = packetData[i];
    var nextByte = packetData[i + 1];
    var win2 = service.currentWindow;
    var _char;
    var charCodeArray;
    if (service.textDecoder_ && !isExtended) {
      if (isMultiByte) {
        charCodeArray = [currentByte, nextByte];
        i++;
      } else {
        charCodeArray = [currentByte];
      }
      _char = service.textDecoder_.decode(new Uint8Array(charCodeArray));
    } else {
      _char = get708CharFromCode(extended | currentByte);
    }
    if (win2.pendingNewLine && !win2.isEmpty()) {
      win2.newLine(this.getPts(i));
    }
    win2.pendingNewLine = false;
    win2.addText(_char);
    return i;
  };
  Cea708Stream.prototype.multiByteCharacter = function(i, service) {
    var packetData = this.current708Packet.data;
    var firstByte = packetData[i + 1];
    var secondByte = packetData[i + 2];
    if (within708TextBlock(firstByte) && within708TextBlock(secondByte)) {
      i = this.handleText(++i, service, {
        isMultiByte: true
      });
    }
    return i;
  };
  Cea708Stream.prototype.setCurrentWindow = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[i];
    var windowNum = b & 7;
    service.setCurrentWindow(windowNum);
    return i;
  };
  Cea708Stream.prototype.defineWindow = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[i];
    var windowNum = b & 7;
    service.setCurrentWindow(windowNum);
    var win2 = service.currentWindow;
    b = packetData[++i];
    win2.visible = (b & 32) >> 5;
    win2.rowLock = (b & 16) >> 4;
    win2.columnLock = (b & 8) >> 3;
    win2.priority = b & 7;
    b = packetData[++i];
    win2.relativePositioning = (b & 128) >> 7;
    win2.anchorVertical = b & 127;
    b = packetData[++i];
    win2.anchorHorizontal = b;
    b = packetData[++i];
    win2.anchorPoint = (b & 240) >> 4;
    win2.rowCount = b & 15;
    b = packetData[++i];
    win2.columnCount = b & 63;
    b = packetData[++i];
    win2.windowStyle = (b & 56) >> 3;
    win2.penStyle = b & 7;
    win2.virtualRowCount = win2.rowCount + 1;
    return i;
  };
  Cea708Stream.prototype.setWindowAttributes = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[i];
    var winAttr = service.currentWindow.winAttr;
    b = packetData[++i];
    winAttr.fillOpacity = (b & 192) >> 6;
    winAttr.fillRed = (b & 48) >> 4;
    winAttr.fillGreen = (b & 12) >> 2;
    winAttr.fillBlue = b & 3;
    b = packetData[++i];
    winAttr.borderType = (b & 192) >> 6;
    winAttr.borderRed = (b & 48) >> 4;
    winAttr.borderGreen = (b & 12) >> 2;
    winAttr.borderBlue = b & 3;
    b = packetData[++i];
    winAttr.borderType += (b & 128) >> 5;
    winAttr.wordWrap = (b & 64) >> 6;
    winAttr.printDirection = (b & 48) >> 4;
    winAttr.scrollDirection = (b & 12) >> 2;
    winAttr.justify = b & 3;
    b = packetData[++i];
    winAttr.effectSpeed = (b & 240) >> 4;
    winAttr.effectDirection = (b & 12) >> 2;
    winAttr.displayEffect = b & 3;
    return i;
  };
  Cea708Stream.prototype.flushDisplayed = function(pts, service) {
    var displayedText = [];
    for (var winId = 0; winId < 8; winId++) {
      if (service.windows[winId].visible && !service.windows[winId].isEmpty()) {
        displayedText.push(service.windows[winId].getText());
      }
    }
    service.endPts = pts;
    service.text = displayedText.join("\n\n");
    this.pushCaption(service);
    service.startPts = pts;
  };
  Cea708Stream.prototype.pushCaption = function(service) {
    if (service.text !== "") {
      this.trigger("data", {
        startPts: service.startPts,
        endPts: service.endPts,
        text: service.text,
        stream: "cc708_" + service.serviceNum
      });
      service.text = "";
      service.startPts = service.endPts;
    }
  };
  Cea708Stream.prototype.displayWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b & 1 << winId) {
        service.windows[winId].visible = 1;
      }
    }
    return i;
  };
  Cea708Stream.prototype.hideWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b & 1 << winId) {
        service.windows[winId].visible = 0;
      }
    }
    return i;
  };
  Cea708Stream.prototype.toggleWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b & 1 << winId) {
        service.windows[winId].visible ^= 1;
      }
    }
    return i;
  };
  Cea708Stream.prototype.clearWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b & 1 << winId) {
        service.windows[winId].clearText();
      }
    }
    return i;
  };
  Cea708Stream.prototype.deleteWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b & 1 << winId) {
        service.windows[winId].reset();
      }
    }
    return i;
  };
  Cea708Stream.prototype.setPenAttributes = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[i];
    var penAttr = service.currentWindow.penAttr;
    b = packetData[++i];
    penAttr.textTag = (b & 240) >> 4;
    penAttr.offset = (b & 12) >> 2;
    penAttr.penSize = b & 3;
    b = packetData[++i];
    penAttr.italics = (b & 128) >> 7;
    penAttr.underline = (b & 64) >> 6;
    penAttr.edgeType = (b & 56) >> 3;
    penAttr.fontStyle = b & 7;
    return i;
  };
  Cea708Stream.prototype.setPenColor = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[i];
    var penColor = service.currentWindow.penColor;
    b = packetData[++i];
    penColor.fgOpacity = (b & 192) >> 6;
    penColor.fgRed = (b & 48) >> 4;
    penColor.fgGreen = (b & 12) >> 2;
    penColor.fgBlue = b & 3;
    b = packetData[++i];
    penColor.bgOpacity = (b & 192) >> 6;
    penColor.bgRed = (b & 48) >> 4;
    penColor.bgGreen = (b & 12) >> 2;
    penColor.bgBlue = b & 3;
    b = packetData[++i];
    penColor.edgeRed = (b & 48) >> 4;
    penColor.edgeGreen = (b & 12) >> 2;
    penColor.edgeBlue = b & 3;
    return i;
  };
  Cea708Stream.prototype.setPenLocation = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[i];
    var penLoc = service.currentWindow.penLoc;
    service.currentWindow.pendingNewLine = true;
    b = packetData[++i];
    penLoc.row = b & 15;
    b = packetData[++i];
    penLoc.column = b & 63;
    return i;
  };
  Cea708Stream.prototype.reset = function(i, service) {
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    return this.initService(service.serviceNum, i);
  };
  var CHARACTER_TRANSLATION = {
    42: 225,
    // á
    92: 233,
    // é
    94: 237,
    // í
    95: 243,
    // ó
    96: 250,
    // ú
    123: 231,
    // ç
    124: 247,
    // ÷
    125: 209,
    // Ñ
    126: 241,
    // ñ
    127: 9608,
    // █
    304: 174,
    // ®
    305: 176,
    // °
    306: 189,
    // ½
    307: 191,
    // ¿
    308: 8482,
    // ™
    309: 162,
    // ¢
    310: 163,
    // £
    311: 9834,
    // ♪
    312: 224,
    // à
    313: 160,
    //
    314: 232,
    // è
    315: 226,
    // â
    316: 234,
    // ê
    317: 238,
    // î
    318: 244,
    // ô
    319: 251,
    // û
    544: 193,
    // Á
    545: 201,
    // É
    546: 211,
    // Ó
    547: 218,
    // Ú
    548: 220,
    // Ü
    549: 252,
    // ü
    550: 8216,
    // ‘
    551: 161,
    // ¡
    552: 42,
    // *
    553: 39,
    // '
    554: 8212,
    // —
    555: 169,
    // ©
    556: 8480,
    // ℠
    557: 8226,
    // •
    558: 8220,
    // “
    559: 8221,
    // ”
    560: 192,
    // À
    561: 194,
    // Â
    562: 199,
    // Ç
    563: 200,
    // È
    564: 202,
    // Ê
    565: 203,
    // Ë
    566: 235,
    // ë
    567: 206,
    // Î
    568: 207,
    // Ï
    569: 239,
    // ï
    570: 212,
    // Ô
    571: 217,
    // Ù
    572: 249,
    // ù
    573: 219,
    // Û
    574: 171,
    // «
    575: 187,
    // »
    800: 195,
    // Ã
    801: 227,
    // ã
    802: 205,
    // Í
    803: 204,
    // Ì
    804: 236,
    // ì
    805: 210,
    // Ò
    806: 242,
    // ò
    807: 213,
    // Õ
    808: 245,
    // õ
    809: 123,
    // {
    810: 125,
    // }
    811: 92,
    // \
    812: 94,
    // ^
    813: 95,
    // _
    814: 124,
    // |
    815: 126,
    // ~
    816: 196,
    // Ä
    817: 228,
    // ä
    818: 214,
    // Ö
    819: 246,
    // ö
    820: 223,
    // ß
    821: 165,
    // ¥
    822: 164,
    // ¤
    823: 9474,
    // │
    824: 197,
    // Å
    825: 229,
    // å
    826: 216,
    // Ø
    827: 248,
    // ø
    828: 9484,
    // ┌
    829: 9488,
    // ┐
    830: 9492,
    // └
    831: 9496
    // ┘
  };
  var getCharFromCode = function getCharFromCode2(code) {
    if (code === null) {
      return "";
    }
    code = CHARACTER_TRANSLATION[code] || code;
    return String.fromCharCode(code);
  };
  var BOTTOM_ROW = 14;
  var ROWS = [4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096, 4864, 4896, 5120, 5152];
  var createDisplayBuffer = function createDisplayBuffer2() {
    var result = [], i = BOTTOM_ROW + 1;
    while (i--) {
      result.push("");
    }
    return result;
  };
  var Cea608Stream = function Cea608Stream2(field, dataChannel) {
    Cea608Stream2.prototype.init.call(this);
    this.field_ = field || 0;
    this.dataChannel_ = dataChannel || 0;
    this.name_ = "CC" + ((this.field_ << 1 | this.dataChannel_) + 1);
    this.setConstants();
    this.reset();
    this.push = function(packet) {
      var data, swap, char0, char1, text;
      data = packet.ccData & 32639;
      if (data === this.lastControlCode_) {
        this.lastControlCode_ = null;
        return;
      }
      if ((data & 61440) === 4096) {
        this.lastControlCode_ = data;
      } else if (data !== this.PADDING_) {
        this.lastControlCode_ = null;
      }
      char0 = data >>> 8;
      char1 = data & 255;
      if (data === this.PADDING_) {
        return;
      } else if (data === this.RESUME_CAPTION_LOADING_) {
        this.mode_ = "popOn";
      } else if (data === this.END_OF_CAPTION_) {
        this.mode_ = "popOn";
        this.clearFormatting(packet.pts);
        this.flushDisplayed(packet.pts);
        swap = this.displayed_;
        this.displayed_ = this.nonDisplayed_;
        this.nonDisplayed_ = swap;
        this.startPts_ = packet.pts;
      } else if (data === this.ROLL_UP_2_ROWS_) {
        this.rollUpRows_ = 2;
        this.setRollUp(packet.pts);
      } else if (data === this.ROLL_UP_3_ROWS_) {
        this.rollUpRows_ = 3;
        this.setRollUp(packet.pts);
      } else if (data === this.ROLL_UP_4_ROWS_) {
        this.rollUpRows_ = 4;
        this.setRollUp(packet.pts);
      } else if (data === this.CARRIAGE_RETURN_) {
        this.clearFormatting(packet.pts);
        this.flushDisplayed(packet.pts);
        this.shiftRowsUp_();
        this.startPts_ = packet.pts;
      } else if (data === this.BACKSPACE_) {
        if (this.mode_ === "popOn") {
          this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);
        } else {
          this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);
        }
      } else if (data === this.ERASE_DISPLAYED_MEMORY_) {
        this.flushDisplayed(packet.pts);
        this.displayed_ = createDisplayBuffer();
      } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {
        this.nonDisplayed_ = createDisplayBuffer();
      } else if (data === this.RESUME_DIRECT_CAPTIONING_) {
        if (this.mode_ !== "paintOn") {
          this.flushDisplayed(packet.pts);
          this.displayed_ = createDisplayBuffer();
        }
        this.mode_ = "paintOn";
        this.startPts_ = packet.pts;
      } else if (this.isSpecialCharacter(char0, char1)) {
        char0 = (char0 & 3) << 8;
        text = getCharFromCode(char0 | char1);
        this[this.mode_](packet.pts, text);
        this.column_++;
      } else if (this.isExtCharacter(char0, char1)) {
        if (this.mode_ === "popOn") {
          this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);
        } else {
          this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);
        }
        char0 = (char0 & 3) << 8;
        text = getCharFromCode(char0 | char1);
        this[this.mode_](packet.pts, text);
        this.column_++;
      } else if (this.isMidRowCode(char0, char1)) {
        this.clearFormatting(packet.pts);
        this[this.mode_](packet.pts, " ");
        this.column_++;
        if ((char1 & 14) === 14) {
          this.addFormatting(packet.pts, ["i"]);
        }
        if ((char1 & 1) === 1) {
          this.addFormatting(packet.pts, ["u"]);
        }
      } else if (this.isOffsetControlCode(char0, char1)) {
        this.column_ += char1 & 3;
      } else if (this.isPAC(char0, char1)) {
        var row = ROWS.indexOf(data & 7968);
        if (this.mode_ === "rollUp") {
          if (row - this.rollUpRows_ + 1 < 0) {
            row = this.rollUpRows_ - 1;
          }
          this.setRollUp(packet.pts, row);
        }
        if (row !== this.row_) {
          this.clearFormatting(packet.pts);
          this.row_ = row;
        }
        if (char1 & 1 && this.formatting_.indexOf("u") === -1) {
          this.addFormatting(packet.pts, ["u"]);
        }
        if ((data & 16) === 16) {
          this.column_ = ((data & 14) >> 1) * 4;
        }
        if (this.isColorPAC(char1)) {
          if ((char1 & 14) === 14) {
            this.addFormatting(packet.pts, ["i"]);
          }
        }
      } else if (this.isNormalChar(char0)) {
        if (char1 === 0) {
          char1 = null;
        }
        text = getCharFromCode(char0);
        text += getCharFromCode(char1);
        this[this.mode_](packet.pts, text);
        this.column_ += text.length;
      }
    };
  };
  Cea608Stream.prototype = new stream();
  Cea608Stream.prototype.flushDisplayed = function(pts) {
    var content = this.displayed_.map(function(row, index) {
      try {
        return row.trim();
      } catch (e) {
        this.trigger("log", {
          level: "warn",
          message: "Skipping a malformed 608 caption at index " + index + "."
        });
        return "";
      }
    }, this).join("\n").replace(/^\n+|\n+$/g, "");
    if (content.length) {
      this.trigger("data", {
        startPts: this.startPts_,
        endPts: pts,
        text: content,
        stream: this.name_
      });
    }
  };
  Cea608Stream.prototype.reset = function() {
    this.mode_ = "popOn";
    this.topRow_ = 0;
    this.startPts_ = 0;
    this.displayed_ = createDisplayBuffer();
    this.nonDisplayed_ = createDisplayBuffer();
    this.lastControlCode_ = null;
    this.column_ = 0;
    this.row_ = BOTTOM_ROW;
    this.rollUpRows_ = 2;
    this.formatting_ = [];
  };
  Cea608Stream.prototype.setConstants = function() {
    if (this.dataChannel_ === 0) {
      this.BASE_ = 16;
      this.EXT_ = 17;
      this.CONTROL_ = (20 | this.field_) << 8;
      this.OFFSET_ = 23;
    } else if (this.dataChannel_ === 1) {
      this.BASE_ = 24;
      this.EXT_ = 25;
      this.CONTROL_ = (28 | this.field_) << 8;
      this.OFFSET_ = 31;
    }
    this.PADDING_ = 0;
    this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 32;
    this.END_OF_CAPTION_ = this.CONTROL_ | 47;
    this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 37;
    this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 38;
    this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 39;
    this.CARRIAGE_RETURN_ = this.CONTROL_ | 45;
    this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 41;
    this.BACKSPACE_ = this.CONTROL_ | 33;
    this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 44;
    this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 46;
  };
  Cea608Stream.prototype.isSpecialCharacter = function(char0, char1) {
    return char0 === this.EXT_ && char1 >= 48 && char1 <= 63;
  };
  Cea608Stream.prototype.isExtCharacter = function(char0, char1) {
    return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 32 && char1 <= 63;
  };
  Cea608Stream.prototype.isMidRowCode = function(char0, char1) {
    return char0 === this.EXT_ && char1 >= 32 && char1 <= 47;
  };
  Cea608Stream.prototype.isOffsetControlCode = function(char0, char1) {
    return char0 === this.OFFSET_ && char1 >= 33 && char1 <= 35;
  };
  Cea608Stream.prototype.isPAC = function(char0, char1) {
    return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 64 && char1 <= 127;
  };
  Cea608Stream.prototype.isColorPAC = function(char1) {
    return char1 >= 64 && char1 <= 79 || char1 >= 96 && char1 <= 127;
  };
  Cea608Stream.prototype.isNormalChar = function(_char2) {
    return _char2 >= 32 && _char2 <= 127;
  };
  Cea608Stream.prototype.setRollUp = function(pts, newBaseRow) {
    if (this.mode_ !== "rollUp") {
      this.row_ = BOTTOM_ROW;
      this.mode_ = "rollUp";
      this.flushDisplayed(pts);
      this.nonDisplayed_ = createDisplayBuffer();
      this.displayed_ = createDisplayBuffer();
    }
    if (newBaseRow !== void 0 && newBaseRow !== this.row_) {
      for (var i = 0; i < this.rollUpRows_; i++) {
        this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];
        this.displayed_[this.row_ - i] = "";
      }
    }
    if (newBaseRow === void 0) {
      newBaseRow = this.row_;
    }
    this.topRow_ = newBaseRow - this.rollUpRows_ + 1;
  };
  Cea608Stream.prototype.addFormatting = function(pts, format) {
    this.formatting_ = this.formatting_.concat(format);
    var text = format.reduce(function(text2, format2) {
      return text2 + "<" + format2 + ">";
    }, "");
    this[this.mode_](pts, text);
  };
  Cea608Stream.prototype.clearFormatting = function(pts) {
    if (!this.formatting_.length) {
      return;
    }
    var text = this.formatting_.reverse().reduce(function(text2, format) {
      return text2 + "</" + format + ">";
    }, "");
    this.formatting_ = [];
    this[this.mode_](pts, text);
  };
  Cea608Stream.prototype.popOn = function(pts, text) {
    var baseRow = this.nonDisplayed_[this.row_];
    baseRow += text;
    this.nonDisplayed_[this.row_] = baseRow;
  };
  Cea608Stream.prototype.rollUp = function(pts, text) {
    var baseRow = this.displayed_[this.row_];
    baseRow += text;
    this.displayed_[this.row_] = baseRow;
  };
  Cea608Stream.prototype.shiftRowsUp_ = function() {
    var i;
    for (i = 0; i < this.topRow_; i++) {
      this.displayed_[i] = "";
    }
    for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) {
      this.displayed_[i] = "";
    }
    for (i = this.topRow_; i < this.row_; i++) {
      this.displayed_[i] = this.displayed_[i + 1];
    }
    this.displayed_[this.row_] = "";
  };
  Cea608Stream.prototype.paintOn = function(pts, text) {
    var baseRow = this.displayed_[this.row_];
    baseRow += text;
    this.displayed_[this.row_] = baseRow;
  };
  var captionStream = {
    CaptionStream: CaptionStream$1,
    Cea608Stream,
    Cea708Stream
  };
  var streamTypes = {
    H264_STREAM_TYPE: 27,
    ADTS_STREAM_TYPE: 15,
    METADATA_STREAM_TYPE: 21
  };
  var MAX_TS = 8589934592;
  var RO_THRESH = 4294967296;
  var TYPE_SHARED = "shared";
  var handleRollover$1 = function handleRollover2(value, reference) {
    var direction = 1;
    if (value > reference) {
      direction = -1;
    }
    while (Math.abs(reference - value) > RO_THRESH) {
      value += direction * MAX_TS;
    }
    return value;
  };
  var TimestampRolloverStream$1 = function TimestampRolloverStream2(type3) {
    var lastDTS, referenceDTS;
    TimestampRolloverStream2.prototype.init.call(this);
    this.type_ = type3 || TYPE_SHARED;
    this.push = function(data) {
      if (this.type_ !== TYPE_SHARED && data.type !== this.type_) {
        return;
      }
      if (referenceDTS === void 0) {
        referenceDTS = data.dts;
      }
      data.dts = handleRollover$1(data.dts, referenceDTS);
      data.pts = handleRollover$1(data.pts, referenceDTS);
      lastDTS = data.dts;
      this.trigger("data", data);
    };
    this.flush = function() {
      referenceDTS = lastDTS;
      this.trigger("done");
    };
    this.endTimeline = function() {
      this.flush();
      this.trigger("endedtimeline");
    };
    this.discontinuity = function() {
      referenceDTS = void 0;
      lastDTS = void 0;
    };
    this.reset = function() {
      this.discontinuity();
      this.trigger("reset");
    };
  };
  TimestampRolloverStream$1.prototype = new stream();
  var timestampRolloverStream = {
    TimestampRolloverStream: TimestampRolloverStream$1,
    handleRollover: handleRollover$1
  };
  var percentEncode$1 = function percentEncode2(bytes, start2, end) {
    var i, result = "";
    for (i = start2; i < end; i++) {
      result += "%" + ("00" + bytes[i].toString(16)).slice(-2);
    }
    return result;
  }, parseUtf8 = function parseUtf82(bytes, start2, end) {
    return decodeURIComponent(percentEncode$1(bytes, start2, end));
  }, parseIso88591$1 = function parseIso885912(bytes, start2, end) {
    return unescape(percentEncode$1(bytes, start2, end));
  }, parseSyncSafeInteger$1 = function parseSyncSafeInteger2(data) {
    return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
  }, tagParsers = {
    TXXX: function TXXX(tag) {
      var i;
      if (tag.data[0] !== 3) {
        return;
      }
      for (i = 1; i < tag.data.length; i++) {
        if (tag.data[i] === 0) {
          tag.description = parseUtf8(tag.data, 1, i);
          tag.value = parseUtf8(tag.data, i + 1, tag.data.length).replace(/\0*$/, "");
          break;
        }
      }
      tag.data = tag.value;
    },
    WXXX: function WXXX(tag) {
      var i;
      if (tag.data[0] !== 3) {
        return;
      }
      for (i = 1; i < tag.data.length; i++) {
        if (tag.data[i] === 0) {
          tag.description = parseUtf8(tag.data, 1, i);
          tag.url = parseUtf8(tag.data, i + 1, tag.data.length);
          break;
        }
      }
    },
    PRIV: function PRIV(tag) {
      var i;
      for (i = 0; i < tag.data.length; i++) {
        if (tag.data[i] === 0) {
          tag.owner = parseIso88591$1(tag.data, 0, i);
          break;
        }
      }
      tag.privateData = tag.data.subarray(i + 1);
      tag.data = tag.privateData;
    }
  }, _MetadataStream;
  _MetadataStream = function MetadataStream(options) {
    var settings = {
      // the bytes of the program-level descriptor field in MP2T
      // see ISO/IEC 13818-1:2013 (E), section 2.6 "Program and
      // program element descriptors"
      descriptor: options && options.descriptor
    }, tagSize = 0, buffer = [], bufferSize = 0, i;
    _MetadataStream.prototype.init.call(this);
    this.dispatchType = streamTypes.METADATA_STREAM_TYPE.toString(16);
    if (settings.descriptor) {
      for (i = 0; i < settings.descriptor.length; i++) {
        this.dispatchType += ("00" + settings.descriptor[i].toString(16)).slice(-2);
      }
    }
    this.push = function(chunk) {
      var tag, frameStart, frameSize, frame, i2, frameHeader;
      if (chunk.type !== "timed-metadata") {
        return;
      }
      if (chunk.dataAlignmentIndicator) {
        bufferSize = 0;
        buffer.length = 0;
      }
      if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== "I".charCodeAt(0) || chunk.data[1] !== "D".charCodeAt(0) || chunk.data[2] !== "3".charCodeAt(0))) {
        this.trigger("log", {
          level: "warn",
          message: "Skipping unrecognized metadata packet"
        });
        return;
      }
      buffer.push(chunk);
      bufferSize += chunk.data.byteLength;
      if (buffer.length === 1) {
        tagSize = parseSyncSafeInteger$1(chunk.data.subarray(6, 10));
        tagSize += 10;
      }
      if (bufferSize < tagSize) {
        return;
      }
      tag = {
        data: new Uint8Array(tagSize),
        frames: [],
        pts: buffer[0].pts,
        dts: buffer[0].dts
      };
      for (i2 = 0; i2 < tagSize; ) {
        tag.data.set(buffer[0].data.subarray(0, tagSize - i2), i2);
        i2 += buffer[0].data.byteLength;
        bufferSize -= buffer[0].data.byteLength;
        buffer.shift();
      }
      frameStart = 10;
      if (tag.data[5] & 64) {
        frameStart += 4;
        frameStart += parseSyncSafeInteger$1(tag.data.subarray(10, 14));
        tagSize -= parseSyncSafeInteger$1(tag.data.subarray(16, 20));
      }
      do {
        frameSize = parseSyncSafeInteger$1(tag.data.subarray(frameStart + 4, frameStart + 8));
        if (frameSize < 1) {
          this.trigger("log", {
            level: "warn",
            message: "Malformed ID3 frame encountered. Skipping metadata parsing."
          });
          return;
        }
        frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);
        frame = {
          id: frameHeader,
          data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)
        };
        frame.key = frame.id;
        if (tagParsers[frame.id]) {
          tagParsers[frame.id](frame);
          if (frame.owner === "com.apple.streaming.transportStreamTimestamp") {
            var d2 = frame.data, size = (d2[3] & 1) << 30 | d2[4] << 22 | d2[5] << 14 | d2[6] << 6 | d2[7] >>> 2;
            size *= 4;
            size += d2[7] & 3;
            frame.timeStamp = size;
            if (tag.pts === void 0 && tag.dts === void 0) {
              tag.pts = frame.timeStamp;
              tag.dts = frame.timeStamp;
            }
            this.trigger("timestamp", frame);
          }
        }
        tag.frames.push(frame);
        frameStart += 10;
        frameStart += frameSize;
      } while (frameStart < tagSize);
      this.trigger("data", tag);
    };
  };
  _MetadataStream.prototype = new stream();
  var metadataStream = _MetadataStream;
  var TimestampRolloverStream = timestampRolloverStream.TimestampRolloverStream;
  var _TransportPacketStream, _TransportParseStream, _ElementaryStream;
  var MP2T_PACKET_LENGTH$1 = 188, SYNC_BYTE$1 = 71;
  _TransportPacketStream = function TransportPacketStream() {
    var buffer = new Uint8Array(MP2T_PACKET_LENGTH$1), bytesInBuffer = 0;
    _TransportPacketStream.prototype.init.call(this);
    this.push = function(bytes) {
      var startIndex = 0, endIndex = MP2T_PACKET_LENGTH$1, everything;
      if (bytesInBuffer) {
        everything = new Uint8Array(bytes.byteLength + bytesInBuffer);
        everything.set(buffer.subarray(0, bytesInBuffer));
        everything.set(bytes, bytesInBuffer);
        bytesInBuffer = 0;
      } else {
        everything = bytes;
      }
      while (endIndex < everything.byteLength) {
        if (everything[startIndex] === SYNC_BYTE$1 && everything[endIndex] === SYNC_BYTE$1) {
          this.trigger("data", everything.subarray(startIndex, endIndex));
          startIndex += MP2T_PACKET_LENGTH$1;
          endIndex += MP2T_PACKET_LENGTH$1;
          continue;
        }
        startIndex++;
        endIndex++;
      }
      if (startIndex < everything.byteLength) {
        buffer.set(everything.subarray(startIndex), 0);
        bytesInBuffer = everything.byteLength - startIndex;
      }
    };
    this.flush = function() {
      if (bytesInBuffer === MP2T_PACKET_LENGTH$1 && buffer[0] === SYNC_BYTE$1) {
        this.trigger("data", buffer);
        bytesInBuffer = 0;
      }
      this.trigger("done");
    };
    this.endTimeline = function() {
      this.flush();
      this.trigger("endedtimeline");
    };
    this.reset = function() {
      bytesInBuffer = 0;
      this.trigger("reset");
    };
  };
  _TransportPacketStream.prototype = new stream();
  _TransportParseStream = function TransportParseStream() {
    var parsePsi, parsePat2, parsePmt2, self2;
    _TransportParseStream.prototype.init.call(this);
    self2 = this;
    this.packetsWaitingForPmt = [];
    this.programMapTable = void 0;
    parsePsi = function parsePsi2(payload, psi) {
      var offset = 0;
      if (psi.payloadUnitStartIndicator) {
        offset += payload[offset] + 1;
      }
      if (psi.type === "pat") {
        parsePat2(payload.subarray(offset), psi);
      } else {
        parsePmt2(payload.subarray(offset), psi);
      }
    };
    parsePat2 = function parsePat3(payload, pat) {
      pat.section_number = payload[7];
      pat.last_section_number = payload[8];
      self2.pmtPid = (payload[10] & 31) << 8 | payload[11];
      pat.pmtPid = self2.pmtPid;
    };
    parsePmt2 = function parsePmt3(payload, pmt) {
      var sectionLength, tableEnd, programInfoLength, offset;
      if (!(payload[5] & 1)) {
        return;
      }
      self2.programMapTable = {
        video: null,
        audio: null,
        "timed-metadata": {}
      };
      sectionLength = (payload[1] & 15) << 8 | payload[2];
      tableEnd = 3 + sectionLength - 4;
      programInfoLength = (payload[10] & 15) << 8 | payload[11];
      offset = 12 + programInfoLength;
      while (offset < tableEnd) {
        var streamType = payload[offset];
        var pid = (payload[offset + 1] & 31) << 8 | payload[offset + 2];
        if (streamType === streamTypes.H264_STREAM_TYPE && self2.programMapTable.video === null) {
          self2.programMapTable.video = pid;
        } else if (streamType === streamTypes.ADTS_STREAM_TYPE && self2.programMapTable.audio === null) {
          self2.programMapTable.audio = pid;
        } else if (streamType === streamTypes.METADATA_STREAM_TYPE) {
          self2.programMapTable["timed-metadata"][pid] = streamType;
        }
        offset += ((payload[offset + 3] & 15) << 8 | payload[offset + 4]) + 5;
      }
      pmt.programMapTable = self2.programMapTable;
    };
    this.push = function(packet) {
      var result = {}, offset = 4;
      result.payloadUnitStartIndicator = !!(packet[1] & 64);
      result.pid = packet[1] & 31;
      result.pid <<= 8;
      result.pid |= packet[2];
      if ((packet[3] & 48) >>> 4 > 1) {
        offset += packet[offset] + 1;
      }
      if (result.pid === 0) {
        result.type = "pat";
        parsePsi(packet.subarray(offset), result);
        this.trigger("data", result);
      } else if (result.pid === this.pmtPid) {
        result.type = "pmt";
        parsePsi(packet.subarray(offset), result);
        this.trigger("data", result);
        while (this.packetsWaitingForPmt.length) {
          this.processPes_.apply(this, this.packetsWaitingForPmt.shift());
        }
      } else if (this.programMapTable === void 0) {
        this.packetsWaitingForPmt.push([packet, offset, result]);
      } else {
        this.processPes_(packet, offset, result);
      }
    };
    this.processPes_ = function(packet, offset, result) {
      if (result.pid === this.programMapTable.video) {
        result.streamType = streamTypes.H264_STREAM_TYPE;
      } else if (result.pid === this.programMapTable.audio) {
        result.streamType = streamTypes.ADTS_STREAM_TYPE;
      } else {
        result.streamType = this.programMapTable["timed-metadata"][result.pid];
      }
      result.type = "pes";
      result.data = packet.subarray(offset);
      this.trigger("data", result);
    };
  };
  _TransportParseStream.prototype = new stream();
  _TransportParseStream.STREAM_TYPES = {
    h264: 27,
    adts: 15
  };
  _ElementaryStream = function ElementaryStream() {
    var self2 = this, segmentHadPmt = false, video = {
      data: [],
      size: 0
    }, audio = {
      data: [],
      size: 0
    }, timedMetadata = {
      data: [],
      size: 0
    }, programMapTable, parsePes = function parsePes2(payload, pes) {
      var ptsDtsFlags;
      var startPrefix = payload[0] << 16 | payload[1] << 8 | payload[2];
      pes.data = new Uint8Array();
      if (startPrefix !== 1) {
        return;
      }
      pes.packetLength = 6 + (payload[4] << 8 | payload[5]);
      pes.dataAlignmentIndicator = (payload[6] & 4) !== 0;
      ptsDtsFlags = payload[7];
      if (ptsDtsFlags & 192) {
        pes.pts = (payload[9] & 14) << 27 | (payload[10] & 255) << 20 | (payload[11] & 254) << 12 | (payload[12] & 255) << 5 | (payload[13] & 254) >>> 3;
        pes.pts *= 4;
        pes.pts += (payload[13] & 6) >>> 1;
        pes.dts = pes.pts;
        if (ptsDtsFlags & 64) {
          pes.dts = (payload[14] & 14) << 27 | (payload[15] & 255) << 20 | (payload[16] & 254) << 12 | (payload[17] & 255) << 5 | (payload[18] & 254) >>> 3;
          pes.dts *= 4;
          pes.dts += (payload[18] & 6) >>> 1;
        }
      }
      pes.data = payload.subarray(9 + payload[8]);
    }, flushStream = function flushStream2(stream2, type3, forceFlush) {
      var packetData = new Uint8Array(stream2.size), event = {
        type: type3
      }, i = 0, offset = 0, packetFlushable = false, fragment;
      if (!stream2.data.length || stream2.size < 9) {
        return;
      }
      event.trackId = stream2.data[0].pid;
      for (i = 0; i < stream2.data.length; i++) {
        fragment = stream2.data[i];
        packetData.set(fragment.data, offset);
        offset += fragment.data.byteLength;
      }
      parsePes(packetData, event);
      packetFlushable = type3 === "video" || event.packetLength <= stream2.size;
      if (forceFlush || packetFlushable) {
        stream2.size = 0;
        stream2.data.length = 0;
      }
      if (packetFlushable) {
        self2.trigger("data", event);
      }
    };
    _ElementaryStream.prototype.init.call(this);
    this.push = function(data) {
      ({
        pat: function pat() {
        },
        pes: function pes() {
          var stream2, streamType;
          switch (data.streamType) {
            case streamTypes.H264_STREAM_TYPE:
              stream2 = video;
              streamType = "video";
              break;
            case streamTypes.ADTS_STREAM_TYPE:
              stream2 = audio;
              streamType = "audio";
              break;
            case streamTypes.METADATA_STREAM_TYPE:
              stream2 = timedMetadata;
              streamType = "timed-metadata";
              break;
            default:
              return;
          }
          if (data.payloadUnitStartIndicator) {
            flushStream(stream2, streamType, true);
          }
          stream2.data.push(data);
          stream2.size += data.data.byteLength;
        },
        pmt: function pmt() {
          var event = {
            type: "metadata",
            tracks: []
          };
          programMapTable = data.programMapTable;
          if (programMapTable.video !== null) {
            event.tracks.push({
              timelineStartInfo: {
                baseMediaDecodeTime: 0
              },
              id: +programMapTable.video,
              codec: "avc",
              type: "video"
            });
          }
          if (programMapTable.audio !== null) {
            event.tracks.push({
              timelineStartInfo: {
                baseMediaDecodeTime: 0
              },
              id: +programMapTable.audio,
              codec: "adts",
              type: "audio"
            });
          }
          segmentHadPmt = true;
          self2.trigger("data", event);
        }
      })[data.type]();
    };
    this.reset = function() {
      video.size = 0;
      video.data.length = 0;
      audio.size = 0;
      audio.data.length = 0;
      this.trigger("reset");
    };
    this.flushStreams_ = function() {
      flushStream(video, "video");
      flushStream(audio, "audio");
      flushStream(timedMetadata, "timed-metadata");
    };
    this.flush = function() {
      if (!segmentHadPmt && programMapTable) {
        var pmt = {
          type: "metadata",
          tracks: []
        };
        if (programMapTable.video !== null) {
          pmt.tracks.push({
            timelineStartInfo: {
              baseMediaDecodeTime: 0
            },
            id: +programMapTable.video,
            codec: "avc",
            type: "video"
          });
        }
        if (programMapTable.audio !== null) {
          pmt.tracks.push({
            timelineStartInfo: {
              baseMediaDecodeTime: 0
            },
            id: +programMapTable.audio,
            codec: "adts",
            type: "audio"
          });
        }
        self2.trigger("data", pmt);
      }
      segmentHadPmt = false;
      this.flushStreams_();
      this.trigger("done");
    };
  };
  _ElementaryStream.prototype = new stream();
  var m2ts = {
    PAT_PID: 0,
    MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH$1,
    TransportPacketStream: _TransportPacketStream,
    TransportParseStream: _TransportParseStream,
    ElementaryStream: _ElementaryStream,
    TimestampRolloverStream,
    CaptionStream: captionStream.CaptionStream,
    Cea608Stream: captionStream.Cea608Stream,
    Cea708Stream: captionStream.Cea708Stream,
    MetadataStream: metadataStream
  };
  for (var type2 in streamTypes) {
    if (streamTypes.hasOwnProperty(type2)) {
      m2ts[type2] = streamTypes[type2];
    }
  }
  var m2ts_1 = m2ts;
  var ONE_SECOND_IN_TS$2 = clock.ONE_SECOND_IN_TS;
  var _AdtsStream;
  var ADTS_SAMPLING_FREQUENCIES$1 = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
  _AdtsStream = function AdtsStream(handlePartialSegments) {
    var buffer, frameNum = 0;
    _AdtsStream.prototype.init.call(this);
    this.skipWarn_ = function(start2, end) {
      this.trigger("log", {
        level: "warn",
        message: "adts skiping bytes " + start2 + " to " + end + " in frame " + frameNum + " outside syncword"
      });
    };
    this.push = function(packet) {
      var i = 0, frameLength, protectionSkipBytes, oldBuffer, sampleCount, adtsFrameDuration;
      if (!handlePartialSegments) {
        frameNum = 0;
      }
      if (packet.type !== "audio") {
        return;
      }
      if (buffer && buffer.length) {
        oldBuffer = buffer;
        buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);
        buffer.set(oldBuffer);
        buffer.set(packet.data, oldBuffer.byteLength);
      } else {
        buffer = packet.data;
      }
      var skip;
      while (i + 7 < buffer.length) {
        if (buffer[i] !== 255 || (buffer[i + 1] & 246) !== 240) {
          if (typeof skip !== "number") {
            skip = i;
          }
          i++;
          continue;
        }
        if (typeof skip === "number") {
          this.skipWarn_(skip, i);
          skip = null;
        }
        protectionSkipBytes = (~buffer[i + 1] & 1) * 2;
        frameLength = (buffer[i + 3] & 3) << 11 | buffer[i + 4] << 3 | (buffer[i + 5] & 224) >> 5;
        sampleCount = ((buffer[i + 6] & 3) + 1) * 1024;
        adtsFrameDuration = sampleCount * ONE_SECOND_IN_TS$2 / ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 60) >>> 2];
        if (buffer.byteLength - i < frameLength) {
          break;
        }
        this.trigger("data", {
          pts: packet.pts + frameNum * adtsFrameDuration,
          dts: packet.dts + frameNum * adtsFrameDuration,
          sampleCount,
          audioobjecttype: (buffer[i + 2] >>> 6 & 3) + 1,
          channelcount: (buffer[i + 2] & 1) << 2 | (buffer[i + 3] & 192) >>> 6,
          samplerate: ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 60) >>> 2],
          samplingfrequencyindex: (buffer[i + 2] & 60) >>> 2,
          // assume ISO/IEC 14496-12 AudioSampleEntry default of 16
          samplesize: 16,
          // data is the frame without it's header
          data: buffer.subarray(i + 7 + protectionSkipBytes, i + frameLength)
        });
        frameNum++;
        i += frameLength;
      }
      if (typeof skip === "number") {
        this.skipWarn_(skip, i);
        skip = null;
      }
      buffer = buffer.subarray(i);
    };
    this.flush = function() {
      frameNum = 0;
      this.trigger("done");
    };
    this.reset = function() {
      buffer = void 0;
      this.trigger("reset");
    };
    this.endTimeline = function() {
      buffer = void 0;
      this.trigger("endedtimeline");
    };
  };
  _AdtsStream.prototype = new stream();
  var adts = _AdtsStream;
  var ExpGolomb2;
  ExpGolomb2 = function ExpGolomb3(workingData) {
    var workingBytesAvailable = workingData.byteLength, workingWord = 0, workingBitsAvailable = 0;
    this.length = function() {
      return 8 * workingBytesAvailable;
    };
    this.bitsAvailable = function() {
      return 8 * workingBytesAvailable + workingBitsAvailable;
    };
    this.loadWord = function() {
      var position = workingData.byteLength - workingBytesAvailable, workingBytes = new Uint8Array(4), availableBytes = Math.min(4, workingBytesAvailable);
      if (availableBytes === 0) {
        throw new Error("no bytes available");
      }
      workingBytes.set(workingData.subarray(position, position + availableBytes));
      workingWord = new DataView(workingBytes.buffer).getUint32(0);
      workingBitsAvailable = availableBytes * 8;
      workingBytesAvailable -= availableBytes;
    };
    this.skipBits = function(count) {
      var skipBytes;
      if (workingBitsAvailable > count) {
        workingWord <<= count;
        workingBitsAvailable -= count;
      } else {
        count -= workingBitsAvailable;
        skipBytes = Math.floor(count / 8);
        count -= skipBytes * 8;
        workingBytesAvailable -= skipBytes;
        this.loadWord();
        workingWord <<= count;
        workingBitsAvailable -= count;
      }
    };
    this.readBits = function(size) {
      var bits = Math.min(workingBitsAvailable, size), valu = workingWord >>> 32 - bits;
      workingBitsAvailable -= bits;
      if (workingBitsAvailable > 0) {
        workingWord <<= bits;
      } else if (workingBytesAvailable > 0) {
        this.loadWord();
      }
      bits = size - bits;
      if (bits > 0) {
        return valu << bits | this.readBits(bits);
      }
      return valu;
    };
    this.skipLeadingZeros = function() {
      var leadingZeroCount;
      for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {
        if ((workingWord & 2147483648 >>> leadingZeroCount) !== 0) {
          workingWord <<= leadingZeroCount;
          workingBitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      this.loadWord();
      return leadingZeroCount + this.skipLeadingZeros();
    };
    this.skipUnsignedExpGolomb = function() {
      this.skipBits(1 + this.skipLeadingZeros());
    };
    this.skipExpGolomb = function() {
      this.skipBits(1 + this.skipLeadingZeros());
    };
    this.readUnsignedExpGolomb = function() {
      var clz = this.skipLeadingZeros();
      return this.readBits(clz + 1) - 1;
    };
    this.readExpGolomb = function() {
      var valu = this.readUnsignedExpGolomb();
      if (1 & valu) {
        return 1 + valu >>> 1;
      }
      return -1 * (valu >>> 1);
    };
    this.readBoolean = function() {
      return this.readBits(1) === 1;
    };
    this.readUnsignedByte = function() {
      return this.readBits(8);
    };
    this.loadWord();
  };
  var expGolomb = ExpGolomb2;
  var _H264Stream, _NalByteStream;
  var PROFILES_WITH_OPTIONAL_SPS_DATA;
  _NalByteStream = function NalByteStream() {
    var syncPoint = 0, i, buffer;
    _NalByteStream.prototype.init.call(this);
    this.push = function(data) {
      var swapBuffer;
      if (!buffer) {
        buffer = data.data;
      } else {
        swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);
        swapBuffer.set(buffer);
        swapBuffer.set(data.data, buffer.byteLength);
        buffer = swapBuffer;
      }
      var len = buffer.byteLength;
      for (; syncPoint < len - 3; syncPoint++) {
        if (buffer[syncPoint + 2] === 1) {
          i = syncPoint + 5;
          break;
        }
      }
      while (i < len) {
        switch (buffer[i]) {
          case 0:
            if (buffer[i - 1] !== 0) {
              i += 2;
              break;
            } else if (buffer[i - 2] !== 0) {
              i++;
              break;
            }
            if (syncPoint + 3 !== i - 2) {
              this.trigger("data", buffer.subarray(syncPoint + 3, i - 2));
            }
            do {
              i++;
            } while (buffer[i] !== 1 && i < len);
            syncPoint = i - 2;
            i += 3;
            break;
          case 1:
            if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {
              i += 3;
              break;
            }
            this.trigger("data", buffer.subarray(syncPoint + 3, i - 2));
            syncPoint = i - 2;
            i += 3;
            break;
          default:
            i += 3;
            break;
        }
      }
      buffer = buffer.subarray(syncPoint);
      i -= syncPoint;
      syncPoint = 0;
    };
    this.reset = function() {
      buffer = null;
      syncPoint = 0;
      this.trigger("reset");
    };
    this.flush = function() {
      if (buffer && buffer.byteLength > 3) {
        this.trigger("data", buffer.subarray(syncPoint + 3));
      }
      buffer = null;
      syncPoint = 0;
      this.trigger("done");
    };
    this.endTimeline = function() {
      this.flush();
      this.trigger("endedtimeline");
    };
  };
  _NalByteStream.prototype = new stream();
  PROFILES_WITH_OPTIONAL_SPS_DATA = {
    100: true,
    110: true,
    122: true,
    244: true,
    44: true,
    83: true,
    86: true,
    118: true,
    128: true,
    // TODO: the three profiles below don't
    // appear to have sps data in the specificiation anymore?
    138: true,
    139: true,
    134: true
  };
  _H264Stream = function H264Stream2() {
    var nalByteStream = new _NalByteStream(), self2, trackId, currentPts, currentDts, discardEmulationPreventionBytes4, readSequenceParameterSet, skipScalingList;
    _H264Stream.prototype.init.call(this);
    self2 = this;
    this.push = function(packet) {
      if (packet.type !== "video") {
        return;
      }
      trackId = packet.trackId;
      currentPts = packet.pts;
      currentDts = packet.dts;
      nalByteStream.push(packet);
    };
    nalByteStream.on("data", function(data) {
      var event = {
        trackId,
        pts: currentPts,
        dts: currentDts,
        data,
        nalUnitTypeCode: data[0] & 31
      };
      switch (event.nalUnitTypeCode) {
        case 5:
          event.nalUnitType = "slice_layer_without_partitioning_rbsp_idr";
          break;
        case 6:
          event.nalUnitType = "sei_rbsp";
          event.escapedRBSP = discardEmulationPreventionBytes4(data.subarray(1));
          break;
        case 7:
          event.nalUnitType = "seq_parameter_set_rbsp";
          event.escapedRBSP = discardEmulationPreventionBytes4(data.subarray(1));
          event.config = readSequenceParameterSet(event.escapedRBSP);
          break;
        case 8:
          event.nalUnitType = "pic_parameter_set_rbsp";
          break;
        case 9:
          event.nalUnitType = "access_unit_delimiter_rbsp";
          break;
      }
      self2.trigger("data", event);
    });
    nalByteStream.on("done", function() {
      self2.trigger("done");
    });
    nalByteStream.on("partialdone", function() {
      self2.trigger("partialdone");
    });
    nalByteStream.on("reset", function() {
      self2.trigger("reset");
    });
    nalByteStream.on("endedtimeline", function() {
      self2.trigger("endedtimeline");
    });
    this.flush = function() {
      nalByteStream.flush();
    };
    this.partialFlush = function() {
      nalByteStream.partialFlush();
    };
    this.reset = function() {
      nalByteStream.reset();
    };
    this.endTimeline = function() {
      nalByteStream.endTimeline();
    };
    skipScalingList = function skipScalingList2(count, expGolombDecoder) {
      var lastScale = 8, nextScale = 8, j, deltaScale;
      for (j = 0; j < count; j++) {
        if (nextScale !== 0) {
          deltaScale = expGolombDecoder.readExpGolomb();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    };
    discardEmulationPreventionBytes4 = function discardEmulationPreventionBytes5(data) {
      var length = data.byteLength, emulationPreventionBytesPositions = [], i = 1, newLength, newData;
      while (i < length - 2) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
          emulationPreventionBytesPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }
      if (emulationPreventionBytesPositions.length === 0) {
        return data;
      }
      newLength = length - emulationPreventionBytesPositions.length;
      newData = new Uint8Array(newLength);
      var sourceIndex = 0;
      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === emulationPreventionBytesPositions[0]) {
          sourceIndex++;
          emulationPreventionBytesPositions.shift();
        }
        newData[i] = data[sourceIndex];
      }
      return newData;
    };
    readSequenceParameterSet = function readSequenceParameterSet2(data) {
      var frameCropLeftOffset = 0, frameCropRightOffset = 0, frameCropTopOffset = 0, frameCropBottomOffset = 0, expGolombDecoder, profileIdc, levelIdc, profileCompatibility, chromaFormatIdc, picOrderCntType, numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1, picHeightInMapUnitsMinus1, frameMbsOnlyFlag, scalingListCount, sarRatio = [1, 1], aspectRatioIdc, i;
      expGolombDecoder = new expGolomb(data);
      profileIdc = expGolombDecoder.readUnsignedByte();
      profileCompatibility = expGolombDecoder.readUnsignedByte();
      levelIdc = expGolombDecoder.readUnsignedByte();
      expGolombDecoder.skipUnsignedExpGolomb();
      if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {
        chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();
        if (chromaFormatIdc === 3) {
          expGolombDecoder.skipBits(1);
        }
        expGolombDecoder.skipUnsignedExpGolomb();
        expGolombDecoder.skipUnsignedExpGolomb();
        expGolombDecoder.skipBits(1);
        if (expGolombDecoder.readBoolean()) {
          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (i = 0; i < scalingListCount; i++) {
            if (expGolombDecoder.readBoolean()) {
              if (i < 6) {
                skipScalingList(16, expGolombDecoder);
              } else {
                skipScalingList(64, expGolombDecoder);
              }
            }
          }
        }
      }
      expGolombDecoder.skipUnsignedExpGolomb();
      picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();
      if (picOrderCntType === 0) {
        expGolombDecoder.readUnsignedExpGolomb();
      } else if (picOrderCntType === 1) {
        expGolombDecoder.skipBits(1);
        expGolombDecoder.skipExpGolomb();
        expGolombDecoder.skipExpGolomb();
        numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();
        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
          expGolombDecoder.skipExpGolomb();
        }
      }
      expGolombDecoder.skipUnsignedExpGolomb();
      expGolombDecoder.skipBits(1);
      picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();
      picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();
      frameMbsOnlyFlag = expGolombDecoder.readBits(1);
      if (frameMbsOnlyFlag === 0) {
        expGolombDecoder.skipBits(1);
      }
      expGolombDecoder.skipBits(1);
      if (expGolombDecoder.readBoolean()) {
        frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();
        frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();
        frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();
        frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();
      }
      if (expGolombDecoder.readBoolean()) {
        if (expGolombDecoder.readBoolean()) {
          aspectRatioIdc = expGolombDecoder.readUnsignedByte();
          switch (aspectRatioIdc) {
            case 1:
              sarRatio = [1, 1];
              break;
            case 2:
              sarRatio = [12, 11];
              break;
            case 3:
              sarRatio = [10, 11];
              break;
            case 4:
              sarRatio = [16, 11];
              break;
            case 5:
              sarRatio = [40, 33];
              break;
            case 6:
              sarRatio = [24, 11];
              break;
            case 7:
              sarRatio = [20, 11];
              break;
            case 8:
              sarRatio = [32, 11];
              break;
            case 9:
              sarRatio = [80, 33];
              break;
            case 10:
              sarRatio = [18, 11];
              break;
            case 11:
              sarRatio = [15, 11];
              break;
            case 12:
              sarRatio = [64, 33];
              break;
            case 13:
              sarRatio = [160, 99];
              break;
            case 14:
              sarRatio = [4, 3];
              break;
            case 15:
              sarRatio = [3, 2];
              break;
            case 16:
              sarRatio = [2, 1];
              break;
            case 255: {
              sarRatio = [expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte()];
              break;
            }
          }
          if (sarRatio) {
            sarRatio[0] / sarRatio[1];
          }
        }
      }
      return {
        profileIdc,
        levelIdc,
        profileCompatibility,
        width: (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2,
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2,
        // sar is sample aspect ratio
        sarRatio
      };
    };
  };
  _H264Stream.prototype = new stream();
  var h2642 = {
    H264Stream: _H264Stream,
    NalByteStream: _NalByteStream
  };
  var ADTS_SAMPLING_FREQUENCIES = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
  var parseId3TagSize = function parseId3TagSize2(header, byteIndex) {
    var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9], flags = header[byteIndex + 5], footerPresent = (flags & 16) >> 4;
    returnSize = returnSize >= 0 ? returnSize : 0;
    if (footerPresent) {
      return returnSize + 20;
    }
    return returnSize + 10;
  };
  var getId3Offset3 = function getId3Offset4(data, offset) {
    if (data.length - offset < 10 || data[offset] !== "I".charCodeAt(0) || data[offset + 1] !== "D".charCodeAt(0) || data[offset + 2] !== "3".charCodeAt(0)) {
      return offset;
    }
    offset += parseId3TagSize(data, offset);
    return getId3Offset4(data, offset);
  };
  var isLikelyAacData$1 = function isLikelyAacData2(data) {
    var offset = getId3Offset3(data, 0);
    return data.length >= offset + 2 && (data[offset] & 255) === 255 && (data[offset + 1] & 240) === 240 && // verify that the 2 layer bits are 0, aka this
    // is not mp3 data but aac data.
    (data[offset + 1] & 22) === 16;
  };
  var parseSyncSafeInteger = function parseSyncSafeInteger2(data) {
    return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
  };
  var percentEncode = function percentEncode2(bytes, start2, end) {
    var i, result = "";
    for (i = start2; i < end; i++) {
      result += "%" + ("00" + bytes[i].toString(16)).slice(-2);
    }
    return result;
  };
  var parseIso88591 = function parseIso885912(bytes, start2, end) {
    return unescape(percentEncode(bytes, start2, end));
  };
  var parseAdtsSize = function parseAdtsSize2(header, byteIndex) {
    var lowThree = (header[byteIndex + 5] & 224) >> 5, middle = header[byteIndex + 4] << 3, highTwo = header[byteIndex + 3] & 3 << 11;
    return highTwo | middle | lowThree;
  };
  var parseType$2 = function parseType2(header, byteIndex) {
    if (header[byteIndex] === "I".charCodeAt(0) && header[byteIndex + 1] === "D".charCodeAt(0) && header[byteIndex + 2] === "3".charCodeAt(0)) {
      return "timed-metadata";
    } else if (header[byteIndex] & true && (header[byteIndex + 1] & 240) === 240) {
      return "audio";
    }
    return null;
  };
  var parseSampleRate = function parseSampleRate2(packet) {
    var i = 0;
    while (i + 5 < packet.length) {
      if (packet[i] !== 255 || (packet[i + 1] & 246) !== 240) {
        i++;
        continue;
      }
      return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 60) >>> 2];
    }
    return null;
  };
  var parseAacTimestamp = function parseAacTimestamp2(packet) {
    var frameStart, frameSize, frame, frameHeader;
    frameStart = 10;
    if (packet[5] & 64) {
      frameStart += 4;
      frameStart += parseSyncSafeInteger(packet.subarray(10, 14));
    }
    do {
      frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));
      if (frameSize < 1) {
        return null;
      }
      frameHeader = String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3]);
      if (frameHeader === "PRIV") {
        frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);
        for (var i = 0; i < frame.byteLength; i++) {
          if (frame[i] === 0) {
            var owner = parseIso88591(frame, 0, i);
            if (owner === "com.apple.streaming.transportStreamTimestamp") {
              var d2 = frame.subarray(i + 1);
              var size = (d2[3] & 1) << 30 | d2[4] << 22 | d2[5] << 14 | d2[6] << 6 | d2[7] >>> 2;
              size *= 4;
              size += d2[7] & 3;
              return size;
            }
            break;
          }
        }
      }
      frameStart += 10;
      frameStart += frameSize;
    } while (frameStart < packet.byteLength);
    return null;
  };
  var utils2 = {
    isLikelyAacData: isLikelyAacData$1,
    parseId3TagSize,
    parseAdtsSize,
    parseType: parseType$2,
    parseSampleRate,
    parseAacTimestamp
  };
  var _AacStream;
  _AacStream = function AacStream() {
    var everything = new Uint8Array(), timeStamp = 0;
    _AacStream.prototype.init.call(this);
    this.setTimestamp = function(timestamp) {
      timeStamp = timestamp;
    };
    this.push = function(bytes) {
      var frameSize = 0, byteIndex = 0, bytesLeft, chunk, packet, tempLength;
      if (everything.length) {
        tempLength = everything.length;
        everything = new Uint8Array(bytes.byteLength + tempLength);
        everything.set(everything.subarray(0, tempLength));
        everything.set(bytes, tempLength);
      } else {
        everything = bytes;
      }
      while (everything.length - byteIndex >= 3) {
        if (everything[byteIndex] === "I".charCodeAt(0) && everything[byteIndex + 1] === "D".charCodeAt(0) && everything[byteIndex + 2] === "3".charCodeAt(0)) {
          if (everything.length - byteIndex < 10) {
            break;
          }
          frameSize = utils2.parseId3TagSize(everything, byteIndex);
          if (byteIndex + frameSize > everything.length) {
            break;
          }
          chunk = {
            type: "timed-metadata",
            data: everything.subarray(byteIndex, byteIndex + frameSize)
          };
          this.trigger("data", chunk);
          byteIndex += frameSize;
          continue;
        } else if ((everything[byteIndex] & 255) === 255 && (everything[byteIndex + 1] & 240) === 240) {
          if (everything.length - byteIndex < 7) {
            break;
          }
          frameSize = utils2.parseAdtsSize(everything, byteIndex);
          if (byteIndex + frameSize > everything.length) {
            break;
          }
          packet = {
            type: "audio",
            data: everything.subarray(byteIndex, byteIndex + frameSize),
            pts: timeStamp,
            dts: timeStamp
          };
          this.trigger("data", packet);
          byteIndex += frameSize;
          continue;
        }
        byteIndex++;
      }
      bytesLeft = everything.length - byteIndex;
      if (bytesLeft > 0) {
        everything = everything.subarray(byteIndex);
      } else {
        everything = new Uint8Array();
      }
    };
    this.reset = function() {
      everything = new Uint8Array();
      this.trigger("reset");
    };
    this.endTimeline = function() {
      everything = new Uint8Array();
      this.trigger("endedtimeline");
    };
  };
  _AacStream.prototype = new stream();
  var aac2 = _AacStream;
  var AUDIO_PROPERTIES = ["audioobjecttype", "channelcount", "samplerate", "samplingfrequencyindex", "samplesize"];
  var audioProperties = AUDIO_PROPERTIES;
  var VIDEO_PROPERTIES = ["width", "height", "profileIdc", "levelIdc", "profileCompatibility", "sarRatio"];
  var videoProperties = VIDEO_PROPERTIES;
  var H264Stream = h2642.H264Stream;
  var isLikelyAacData = utils2.isLikelyAacData;
  var ONE_SECOND_IN_TS$1 = clock.ONE_SECOND_IN_TS;
  var _VideoSegmentStream, _AudioSegmentStream, _Transmuxer, _CoalesceStream;
  var retriggerForStream = function retriggerForStream2(key, event) {
    event.stream = key;
    this.trigger("log", event);
  };
  var addPipelineLogRetriggers = function addPipelineLogRetriggers2(transmuxer2, pipeline) {
    var keys3 = Object.keys(pipeline);
    for (var i = 0; i < keys3.length; i++) {
      var key = keys3[i];
      if (key === "headOfPipeline" || !pipeline[key].on) {
        continue;
      }
      pipeline[key].on("log", retriggerForStream.bind(transmuxer2, key));
    }
  };
  var arrayEquals = function arrayEquals2(a, b) {
    var i;
    if (a.length !== b.length) {
      return false;
    }
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  };
  var generateSegmentTimingInfo = function generateSegmentTimingInfo2(baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {
    var ptsOffsetFromDts = startPts - startDts, decodeDuration = endDts - startDts, presentationDuration = endPts - startPts;
    return {
      start: {
        dts: baseMediaDecodeTime,
        pts: baseMediaDecodeTime + ptsOffsetFromDts
      },
      end: {
        dts: baseMediaDecodeTime + decodeDuration,
        pts: baseMediaDecodeTime + presentationDuration
      },
      prependedContentDuration,
      baseMediaDecodeTime
    };
  };
  _AudioSegmentStream = function AudioSegmentStream(track, options) {
    var adtsFrames = [], sequenceNumber, earliestAllowedDts = 0, audioAppendStartTs = 0, videoBaseMediaDecodeTime = Infinity;
    options = options || {};
    sequenceNumber = options.firstSequenceNumber || 0;
    _AudioSegmentStream.prototype.init.call(this);
    this.push = function(data) {
      trackDecodeInfo.collectDtsInfo(track, data);
      if (track) {
        audioProperties.forEach(function(prop) {
          track[prop] = data[prop];
        });
      }
      adtsFrames.push(data);
    };
    this.setEarliestDts = function(earliestDts) {
      earliestAllowedDts = earliestDts;
    };
    this.setVideoBaseMediaDecodeTime = function(baseMediaDecodeTime) {
      videoBaseMediaDecodeTime = baseMediaDecodeTime;
    };
    this.setAudioAppendStart = function(timestamp) {
      audioAppendStartTs = timestamp;
    };
    this.flush = function() {
      var frames, moof2, mdat2, boxes, frameDuration, segmentDuration, videoClockCyclesOfSilencePrefixed;
      if (adtsFrames.length === 0) {
        this.trigger("done", "AudioSegmentStream");
        return;
      }
      frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);
      track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);
      videoClockCyclesOfSilencePrefixed = audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime);
      track.samples = audioFrameUtils.generateSampleTable(frames);
      mdat2 = mp4Generator.mdat(audioFrameUtils.concatenateFrameData(frames));
      adtsFrames = [];
      moof2 = mp4Generator.moof(sequenceNumber, [track]);
      boxes = new Uint8Array(moof2.byteLength + mdat2.byteLength);
      sequenceNumber++;
      boxes.set(moof2);
      boxes.set(mdat2, moof2.byteLength);
      trackDecodeInfo.clearDtsInfo(track);
      frameDuration = Math.ceil(ONE_SECOND_IN_TS$1 * 1024 / track.samplerate);
      if (frames.length) {
        segmentDuration = frames.length * frameDuration;
        this.trigger("segmentTimingInfo", generateSegmentTimingInfo(
          // The audio track's baseMediaDecodeTime is in audio clock cycles, but the
          // frame info is in video clock cycles. Convert to match expectation of
          // listeners (that all timestamps will be based on video clock cycles).
          clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate),
          // frame times are already in video clock, as is segment duration
          frames[0].dts,
          frames[0].pts,
          frames[0].dts + segmentDuration,
          frames[0].pts + segmentDuration,
          videoClockCyclesOfSilencePrefixed || 0
        ));
        this.trigger("timingInfo", {
          start: frames[0].pts,
          end: frames[0].pts + segmentDuration
        });
      }
      this.trigger("data", {
        track,
        boxes
      });
      this.trigger("done", "AudioSegmentStream");
    };
    this.reset = function() {
      trackDecodeInfo.clearDtsInfo(track);
      adtsFrames = [];
      this.trigger("reset");
    };
  };
  _AudioSegmentStream.prototype = new stream();
  _VideoSegmentStream = function VideoSegmentStream(track, options) {
    var sequenceNumber, nalUnits = [], gopsToAlignWith = [], config, pps;
    options = options || {};
    sequenceNumber = options.firstSequenceNumber || 0;
    _VideoSegmentStream.prototype.init.call(this);
    delete track.minPTS;
    this.gopCache_ = [];
    this.push = function(nalUnit) {
      trackDecodeInfo.collectDtsInfo(track, nalUnit);
      if (nalUnit.nalUnitType === "seq_parameter_set_rbsp" && !config) {
        config = nalUnit.config;
        track.sps = [nalUnit.data];
        videoProperties.forEach(function(prop) {
          track[prop] = config[prop];
        }, this);
      }
      if (nalUnit.nalUnitType === "pic_parameter_set_rbsp" && !pps) {
        pps = nalUnit.data;
        track.pps = [nalUnit.data];
      }
      nalUnits.push(nalUnit);
    };
    this.flush = function() {
      var frames, gopForFusion, gops, moof2, mdat2, boxes, prependedContentDuration = 0, firstGop, lastGop;
      while (nalUnits.length) {
        if (nalUnits[0].nalUnitType === "access_unit_delimiter_rbsp") {
          break;
        }
        nalUnits.shift();
      }
      if (nalUnits.length === 0) {
        this.resetStream_();
        this.trigger("done", "VideoSegmentStream");
        return;
      }
      frames = frameUtils.groupNalsIntoFrames(nalUnits);
      gops = frameUtils.groupFramesIntoGops(frames);
      if (!gops[0][0].keyFrame) {
        gopForFusion = this.getGopForFusion_(nalUnits[0], track);
        if (gopForFusion) {
          prependedContentDuration = gopForFusion.duration;
          gops.unshift(gopForFusion);
          gops.byteLength += gopForFusion.byteLength;
          gops.nalCount += gopForFusion.nalCount;
          gops.pts = gopForFusion.pts;
          gops.dts = gopForFusion.dts;
          gops.duration += gopForFusion.duration;
        } else {
          gops = frameUtils.extendFirstKeyFrame(gops);
        }
      }
      if (gopsToAlignWith.length) {
        var alignedGops;
        if (options.alignGopsAtEnd) {
          alignedGops = this.alignGopsAtEnd_(gops);
        } else {
          alignedGops = this.alignGopsAtStart_(gops);
        }
        if (!alignedGops) {
          this.gopCache_.unshift({
            gop: gops.pop(),
            pps: track.pps,
            sps: track.sps
          });
          this.gopCache_.length = Math.min(6, this.gopCache_.length);
          nalUnits = [];
          this.resetStream_();
          this.trigger("done", "VideoSegmentStream");
          return;
        }
        trackDecodeInfo.clearDtsInfo(track);
        gops = alignedGops;
      }
      trackDecodeInfo.collectDtsInfo(track, gops);
      track.samples = frameUtils.generateSampleTable(gops);
      mdat2 = mp4Generator.mdat(frameUtils.concatenateNalData(gops));
      track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);
      this.trigger("processedGopsInfo", gops.map(function(gop) {
        return {
          pts: gop.pts,
          dts: gop.dts,
          byteLength: gop.byteLength
        };
      }));
      firstGop = gops[0];
      lastGop = gops[gops.length - 1];
      this.trigger("segmentTimingInfo", generateSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration));
      this.trigger("timingInfo", {
        start: gops[0].pts,
        end: gops[gops.length - 1].pts + gops[gops.length - 1].duration
      });
      this.gopCache_.unshift({
        gop: gops.pop(),
        pps: track.pps,
        sps: track.sps
      });
      this.gopCache_.length = Math.min(6, this.gopCache_.length);
      nalUnits = [];
      this.trigger("baseMediaDecodeTime", track.baseMediaDecodeTime);
      this.trigger("timelineStartInfo", track.timelineStartInfo);
      moof2 = mp4Generator.moof(sequenceNumber, [track]);
      boxes = new Uint8Array(moof2.byteLength + mdat2.byteLength);
      sequenceNumber++;
      boxes.set(moof2);
      boxes.set(mdat2, moof2.byteLength);
      this.trigger("data", {
        track,
        boxes
      });
      this.resetStream_();
      this.trigger("done", "VideoSegmentStream");
    };
    this.reset = function() {
      this.resetStream_();
      nalUnits = [];
      this.gopCache_.length = 0;
      gopsToAlignWith.length = 0;
      this.trigger("reset");
    };
    this.resetStream_ = function() {
      trackDecodeInfo.clearDtsInfo(track);
      config = void 0;
      pps = void 0;
    };
    this.getGopForFusion_ = function(nalUnit) {
      var halfSecond = 45e3, allowableOverlap = 1e4, nearestDistance = Infinity, dtsDistance, nearestGopObj, currentGop, currentGopObj, i;
      for (i = 0; i < this.gopCache_.length; i++) {
        currentGopObj = this.gopCache_[i];
        currentGop = currentGopObj.gop;
        if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {
          continue;
        }
        if (currentGop.dts < track.timelineStartInfo.dts) {
          continue;
        }
        dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration;
        if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) {
          if (!nearestGopObj || nearestDistance > dtsDistance) {
            nearestGopObj = currentGopObj;
            nearestDistance = dtsDistance;
          }
        }
      }
      if (nearestGopObj) {
        return nearestGopObj.gop;
      }
      return null;
    };
    this.alignGopsAtStart_ = function(gops) {
      var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration5, alignedGops;
      byteLength = gops.byteLength;
      nalCount = gops.nalCount;
      duration5 = gops.duration;
      alignIndex = gopIndex = 0;
      while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {
        align = gopsToAlignWith[alignIndex];
        gop = gops[gopIndex];
        if (align.pts === gop.pts) {
          break;
        }
        if (gop.pts > align.pts) {
          alignIndex++;
          continue;
        }
        gopIndex++;
        byteLength -= gop.byteLength;
        nalCount -= gop.nalCount;
        duration5 -= gop.duration;
      }
      if (gopIndex === 0) {
        return gops;
      }
      if (gopIndex === gops.length) {
        return null;
      }
      alignedGops = gops.slice(gopIndex);
      alignedGops.byteLength = byteLength;
      alignedGops.duration = duration5;
      alignedGops.nalCount = nalCount;
      alignedGops.pts = alignedGops[0].pts;
      alignedGops.dts = alignedGops[0].dts;
      return alignedGops;
    };
    this.alignGopsAtEnd_ = function(gops) {
      var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;
      alignIndex = gopsToAlignWith.length - 1;
      gopIndex = gops.length - 1;
      alignEndIndex = null;
      matchFound = false;
      while (alignIndex >= 0 && gopIndex >= 0) {
        align = gopsToAlignWith[alignIndex];
        gop = gops[gopIndex];
        if (align.pts === gop.pts) {
          matchFound = true;
          break;
        }
        if (align.pts > gop.pts) {
          alignIndex--;
          continue;
        }
        if (alignIndex === gopsToAlignWith.length - 1) {
          alignEndIndex = gopIndex;
        }
        gopIndex--;
      }
      if (!matchFound && alignEndIndex === null) {
        return null;
      }
      var trimIndex;
      if (matchFound) {
        trimIndex = gopIndex;
      } else {
        trimIndex = alignEndIndex;
      }
      if (trimIndex === 0) {
        return gops;
      }
      var alignedGops = gops.slice(trimIndex);
      var metadata = alignedGops.reduce(function(total, gop2) {
        total.byteLength += gop2.byteLength;
        total.duration += gop2.duration;
        total.nalCount += gop2.nalCount;
        return total;
      }, {
        byteLength: 0,
        duration: 0,
        nalCount: 0
      });
      alignedGops.byteLength = metadata.byteLength;
      alignedGops.duration = metadata.duration;
      alignedGops.nalCount = metadata.nalCount;
      alignedGops.pts = alignedGops[0].pts;
      alignedGops.dts = alignedGops[0].dts;
      return alignedGops;
    };
    this.alignGopsWith = function(newGopsToAlignWith) {
      gopsToAlignWith = newGopsToAlignWith;
    };
  };
  _VideoSegmentStream.prototype = new stream();
  _CoalesceStream = function CoalesceStream(options, metadataStream2) {
    this.numberOfTracks = 0;
    this.metadataStream = metadataStream2;
    options = options || {};
    if (typeof options.remux !== "undefined") {
      this.remuxTracks = !!options.remux;
    } else {
      this.remuxTracks = true;
    }
    if (typeof options.keepOriginalTimestamps === "boolean") {
      this.keepOriginalTimestamps = options.keepOriginalTimestamps;
    } else {
      this.keepOriginalTimestamps = false;
    }
    this.pendingTracks = [];
    this.videoTrack = null;
    this.pendingBoxes = [];
    this.pendingCaptions = [];
    this.pendingMetadata = [];
    this.pendingBytes = 0;
    this.emittedTracks = 0;
    _CoalesceStream.prototype.init.call(this);
    this.push = function(output) {
      if (output.text) {
        return this.pendingCaptions.push(output);
      }
      if (output.frames) {
        return this.pendingMetadata.push(output);
      }
      this.pendingTracks.push(output.track);
      this.pendingBytes += output.boxes.byteLength;
      if (output.track.type === "video") {
        this.videoTrack = output.track;
        this.pendingBoxes.push(output.boxes);
      }
      if (output.track.type === "audio") {
        this.audioTrack = output.track;
        this.pendingBoxes.unshift(output.boxes);
      }
    };
  };
  _CoalesceStream.prototype = new stream();
  _CoalesceStream.prototype.flush = function(flushSource) {
    var offset = 0, event = {
      captions: [],
      captionStreams: {},
      metadata: [],
      info: {}
    }, caption, id3, initSegment, timelineStartPts = 0, i;
    if (this.pendingTracks.length < this.numberOfTracks) {
      if (flushSource !== "VideoSegmentStream" && flushSource !== "AudioSegmentStream") {
        return;
      } else if (this.remuxTracks) {
        return;
      } else if (this.pendingTracks.length === 0) {
        this.emittedTracks++;
        if (this.emittedTracks >= this.numberOfTracks) {
          this.trigger("done");
          this.emittedTracks = 0;
        }
        return;
      }
    }
    if (this.videoTrack) {
      timelineStartPts = this.videoTrack.timelineStartInfo.pts;
      videoProperties.forEach(function(prop) {
        event.info[prop] = this.videoTrack[prop];
      }, this);
    } else if (this.audioTrack) {
      timelineStartPts = this.audioTrack.timelineStartInfo.pts;
      audioProperties.forEach(function(prop) {
        event.info[prop] = this.audioTrack[prop];
      }, this);
    }
    if (this.videoTrack || this.audioTrack) {
      if (this.pendingTracks.length === 1) {
        event.type = this.pendingTracks[0].type;
      } else {
        event.type = "combined";
      }
      this.emittedTracks += this.pendingTracks.length;
      initSegment = mp4Generator.initSegment(this.pendingTracks);
      event.initSegment = new Uint8Array(initSegment.byteLength);
      event.initSegment.set(initSegment);
      event.data = new Uint8Array(this.pendingBytes);
      for (i = 0; i < this.pendingBoxes.length; i++) {
        event.data.set(this.pendingBoxes[i], offset);
        offset += this.pendingBoxes[i].byteLength;
      }
      for (i = 0; i < this.pendingCaptions.length; i++) {
        caption = this.pendingCaptions[i];
        caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps);
        caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps);
        event.captionStreams[caption.stream] = true;
        event.captions.push(caption);
      }
      for (i = 0; i < this.pendingMetadata.length; i++) {
        id3 = this.pendingMetadata[i];
        id3.cueTime = clock.metadataTsToSeconds(id3.pts, timelineStartPts, this.keepOriginalTimestamps);
        event.metadata.push(id3);
      }
      event.metadata.dispatchType = this.metadataStream.dispatchType;
      this.pendingTracks.length = 0;
      this.videoTrack = null;
      this.pendingBoxes.length = 0;
      this.pendingCaptions.length = 0;
      this.pendingBytes = 0;
      this.pendingMetadata.length = 0;
      this.trigger("data", event);
      for (i = 0; i < event.captions.length; i++) {
        caption = event.captions[i];
        this.trigger("caption", caption);
      }
      for (i = 0; i < event.metadata.length; i++) {
        id3 = event.metadata[i];
        this.trigger("id3Frame", id3);
      }
    }
    if (this.emittedTracks >= this.numberOfTracks) {
      this.trigger("done");
      this.emittedTracks = 0;
    }
  };
  _CoalesceStream.prototype.setRemux = function(val) {
    this.remuxTracks = val;
  };
  _Transmuxer = function Transmuxer2(options) {
    var self2 = this, hasFlushed = true, videoTrack, audioTrack;
    _Transmuxer.prototype.init.call(this);
    options = options || {};
    this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;
    this.transmuxPipeline_ = {};
    this.setupAacPipeline = function() {
      var pipeline = {};
      this.transmuxPipeline_ = pipeline;
      pipeline.type = "aac";
      pipeline.metadataStream = new m2ts_1.MetadataStream();
      pipeline.aacStream = new aac2();
      pipeline.audioTimestampRolloverStream = new m2ts_1.TimestampRolloverStream("audio");
      pipeline.timedMetadataTimestampRolloverStream = new m2ts_1.TimestampRolloverStream("timed-metadata");
      pipeline.adtsStream = new adts();
      pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);
      pipeline.headOfPipeline = pipeline.aacStream;
      pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);
      pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);
      pipeline.metadataStream.on("timestamp", function(frame) {
        pipeline.aacStream.setTimestamp(frame.timeStamp);
      });
      pipeline.aacStream.on("data", function(data) {
        if (data.type !== "timed-metadata" && data.type !== "audio" || pipeline.audioSegmentStream) {
          return;
        }
        audioTrack = audioTrack || {
          timelineStartInfo: {
            baseMediaDecodeTime: self2.baseMediaDecodeTime
          },
          codec: "adts",
          type: "audio"
        };
        pipeline.coalesceStream.numberOfTracks++;
        pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options);
        pipeline.audioSegmentStream.on("log", self2.getLogTrigger_("audioSegmentStream"));
        pipeline.audioSegmentStream.on("timingInfo", self2.trigger.bind(self2, "audioTimingInfo"));
        pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);
        self2.trigger("trackinfo", {
          hasAudio: !!audioTrack,
          hasVideo: !!videoTrack
        });
      });
      pipeline.coalesceStream.on("data", this.trigger.bind(this, "data"));
      pipeline.coalesceStream.on("done", this.trigger.bind(this, "done"));
      addPipelineLogRetriggers(this, pipeline);
    };
    this.setupTsPipeline = function() {
      var pipeline = {};
      this.transmuxPipeline_ = pipeline;
      pipeline.type = "ts";
      pipeline.metadataStream = new m2ts_1.MetadataStream();
      pipeline.packetStream = new m2ts_1.TransportPacketStream();
      pipeline.parseStream = new m2ts_1.TransportParseStream();
      pipeline.elementaryStream = new m2ts_1.ElementaryStream();
      pipeline.timestampRolloverStream = new m2ts_1.TimestampRolloverStream();
      pipeline.adtsStream = new adts();
      pipeline.h264Stream = new H264Stream();
      pipeline.captionStream = new m2ts_1.CaptionStream(options);
      pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);
      pipeline.headOfPipeline = pipeline.packetStream;
      pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream);
      pipeline.timestampRolloverStream.pipe(pipeline.h264Stream);
      pipeline.timestampRolloverStream.pipe(pipeline.adtsStream);
      pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);
      pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);
      pipeline.elementaryStream.on("data", function(data) {
        var i;
        if (data.type === "metadata") {
          i = data.tracks.length;
          while (i--) {
            if (!videoTrack && data.tracks[i].type === "video") {
              videoTrack = data.tracks[i];
              videoTrack.timelineStartInfo.baseMediaDecodeTime = self2.baseMediaDecodeTime;
            } else if (!audioTrack && data.tracks[i].type === "audio") {
              audioTrack = data.tracks[i];
              audioTrack.timelineStartInfo.baseMediaDecodeTime = self2.baseMediaDecodeTime;
            }
          }
          if (videoTrack && !pipeline.videoSegmentStream) {
            pipeline.coalesceStream.numberOfTracks++;
            pipeline.videoSegmentStream = new _VideoSegmentStream(videoTrack, options);
            pipeline.videoSegmentStream.on("log", self2.getLogTrigger_("videoSegmentStream"));
            pipeline.videoSegmentStream.on("timelineStartInfo", function(timelineStartInfo) {
              if (audioTrack && !options.keepOriginalTimestamps) {
                audioTrack.timelineStartInfo = timelineStartInfo;
                pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self2.baseMediaDecodeTime);
              }
            });
            pipeline.videoSegmentStream.on("processedGopsInfo", self2.trigger.bind(self2, "gopInfo"));
            pipeline.videoSegmentStream.on("segmentTimingInfo", self2.trigger.bind(self2, "videoSegmentTimingInfo"));
            pipeline.videoSegmentStream.on("baseMediaDecodeTime", function(baseMediaDecodeTime) {
              if (audioTrack) {
                pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);
              }
            });
            pipeline.videoSegmentStream.on("timingInfo", self2.trigger.bind(self2, "videoTimingInfo"));
            pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);
          }
          if (audioTrack && !pipeline.audioSegmentStream) {
            pipeline.coalesceStream.numberOfTracks++;
            pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options);
            pipeline.audioSegmentStream.on("log", self2.getLogTrigger_("audioSegmentStream"));
            pipeline.audioSegmentStream.on("timingInfo", self2.trigger.bind(self2, "audioTimingInfo"));
            pipeline.audioSegmentStream.on("segmentTimingInfo", self2.trigger.bind(self2, "audioSegmentTimingInfo"));
            pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);
          }
          self2.trigger("trackinfo", {
            hasAudio: !!audioTrack,
            hasVideo: !!videoTrack
          });
        }
      });
      pipeline.coalesceStream.on("data", this.trigger.bind(this, "data"));
      pipeline.coalesceStream.on("id3Frame", function(id3Frame) {
        id3Frame.dispatchType = pipeline.metadataStream.dispatchType;
        self2.trigger("id3Frame", id3Frame);
      });
      pipeline.coalesceStream.on("caption", this.trigger.bind(this, "caption"));
      pipeline.coalesceStream.on("done", this.trigger.bind(this, "done"));
      addPipelineLogRetriggers(this, pipeline);
    };
    this.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {
      var pipeline = this.transmuxPipeline_;
      if (!options.keepOriginalTimestamps) {
        this.baseMediaDecodeTime = baseMediaDecodeTime;
      }
      if (audioTrack) {
        audioTrack.timelineStartInfo.dts = void 0;
        audioTrack.timelineStartInfo.pts = void 0;
        trackDecodeInfo.clearDtsInfo(audioTrack);
        if (pipeline.audioTimestampRolloverStream) {
          pipeline.audioTimestampRolloverStream.discontinuity();
        }
      }
      if (videoTrack) {
        if (pipeline.videoSegmentStream) {
          pipeline.videoSegmentStream.gopCache_ = [];
        }
        videoTrack.timelineStartInfo.dts = void 0;
        videoTrack.timelineStartInfo.pts = void 0;
        trackDecodeInfo.clearDtsInfo(videoTrack);
        pipeline.captionStream.reset();
      }
      if (pipeline.timestampRolloverStream) {
        pipeline.timestampRolloverStream.discontinuity();
      }
    };
    this.setAudioAppendStart = function(timestamp) {
      if (audioTrack) {
        this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);
      }
    };
    this.setRemux = function(val) {
      var pipeline = this.transmuxPipeline_;
      options.remux = val;
      if (pipeline && pipeline.coalesceStream) {
        pipeline.coalesceStream.setRemux(val);
      }
    };
    this.alignGopsWith = function(gopsToAlignWith) {
      if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {
        this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);
      }
    };
    this.getLogTrigger_ = function(key) {
      var self3 = this;
      return function(event) {
        event.stream = key;
        self3.trigger("log", event);
      };
    };
    this.push = function(data) {
      if (hasFlushed) {
        var isAac = isLikelyAacData(data);
        if (isAac && this.transmuxPipeline_.type !== "aac") {
          this.setupAacPipeline();
        } else if (!isAac && this.transmuxPipeline_.type !== "ts") {
          this.setupTsPipeline();
        }
        hasFlushed = false;
      }
      this.transmuxPipeline_.headOfPipeline.push(data);
    };
    this.flush = function() {
      hasFlushed = true;
      this.transmuxPipeline_.headOfPipeline.flush();
    };
    this.endTimeline = function() {
      this.transmuxPipeline_.headOfPipeline.endTimeline();
    };
    this.reset = function() {
      if (this.transmuxPipeline_.headOfPipeline) {
        this.transmuxPipeline_.headOfPipeline.reset();
      }
    };
    this.resetCaptions = function() {
      if (this.transmuxPipeline_.captionStream) {
        this.transmuxPipeline_.captionStream.reset();
      }
    };
  };
  _Transmuxer.prototype = new stream();
  var transmuxer = {
    Transmuxer: _Transmuxer,
    VideoSegmentStream: _VideoSegmentStream,
    AudioSegmentStream: _AudioSegmentStream,
    AUDIO_PROPERTIES: audioProperties,
    VIDEO_PROPERTIES: videoProperties,
    // exported for testing
    generateSegmentTimingInfo
  };
  var toUnsigned$3 = function toUnsigned2(value) {
    return value >>> 0;
  };
  var toHexString$1 = function toHexString3(value) {
    return ("00" + value.toString(16)).slice(-2);
  };
  var bin = {
    toUnsigned: toUnsigned$3,
    toHexString: toHexString$1
  };
  var parseType$1 = function parseType2(buffer) {
    var result = "";
    result += String.fromCharCode(buffer[0]);
    result += String.fromCharCode(buffer[1]);
    result += String.fromCharCode(buffer[2]);
    result += String.fromCharCode(buffer[3]);
    return result;
  };
  var parseType_1 = parseType$1;
  var toUnsigned$2 = bin.toUnsigned;
  var findBox4 = function findBox5(data, path) {
    var results = [], i, size, type3, end, subresults;
    if (!path.length) {
      return null;
    }
    for (i = 0; i < data.byteLength; ) {
      size = toUnsigned$2(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]);
      type3 = parseType_1(data.subarray(i + 4, i + 8));
      end = size > 1 ? i + size : data.byteLength;
      if (type3 === path[0]) {
        if (path.length === 1) {
          results.push(data.subarray(i + 8, end));
        } else {
          subresults = findBox5(data.subarray(i + 8, end), path.slice(1));
          if (subresults.length) {
            results = results.concat(subresults);
          }
        }
      }
      i = end;
    }
    return results;
  };
  var findBox_1 = findBox4;
  var toUnsigned$1 = bin.toUnsigned;
  var getUint64$1 = numbers.getUint64;
  var tfdt = function tfdt2(data) {
    var result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4))
    };
    if (result.version === 1) {
      result.baseMediaDecodeTime = getUint64$1(data.subarray(4));
    } else {
      result.baseMediaDecodeTime = toUnsigned$1(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]);
    }
    return result;
  };
  var parseTfdt = tfdt;
  var parseSampleFlags = function parseSampleFlags2(flags) {
    return {
      isLeading: (flags[0] & 12) >>> 2,
      dependsOn: flags[0] & 3,
      isDependedOn: (flags[1] & 192) >>> 6,
      hasRedundancy: (flags[1] & 48) >>> 4,
      paddingValue: (flags[1] & 14) >>> 1,
      isNonSyncSample: flags[1] & 1,
      degradationPriority: flags[2] << 8 | flags[3]
    };
  };
  var parseSampleFlags_1 = parseSampleFlags;
  var trun = function trun2(data) {
    var result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      samples: []
    }, view = new DataView(data.buffer, data.byteOffset, data.byteLength), dataOffsetPresent = result.flags[2] & 1, firstSampleFlagsPresent = result.flags[2] & 4, sampleDurationPresent = result.flags[1] & 1, sampleSizePresent = result.flags[1] & 2, sampleFlagsPresent = result.flags[1] & 4, sampleCompositionTimeOffsetPresent = result.flags[1] & 8, sampleCount = view.getUint32(4), offset = 8, sample;
    if (dataOffsetPresent) {
      result.dataOffset = view.getInt32(offset);
      offset += 4;
    }
    if (firstSampleFlagsPresent && sampleCount) {
      sample = {
        flags: parseSampleFlags_1(data.subarray(offset, offset + 4))
      };
      offset += 4;
      if (sampleDurationPresent) {
        sample.duration = view.getUint32(offset);
        offset += 4;
      }
      if (sampleSizePresent) {
        sample.size = view.getUint32(offset);
        offset += 4;
      }
      if (sampleCompositionTimeOffsetPresent) {
        if (result.version === 1) {
          sample.compositionTimeOffset = view.getInt32(offset);
        } else {
          sample.compositionTimeOffset = view.getUint32(offset);
        }
        offset += 4;
      }
      result.samples.push(sample);
      sampleCount--;
    }
    while (sampleCount--) {
      sample = {};
      if (sampleDurationPresent) {
        sample.duration = view.getUint32(offset);
        offset += 4;
      }
      if (sampleSizePresent) {
        sample.size = view.getUint32(offset);
        offset += 4;
      }
      if (sampleFlagsPresent) {
        sample.flags = parseSampleFlags_1(data.subarray(offset, offset + 4));
        offset += 4;
      }
      if (sampleCompositionTimeOffsetPresent) {
        if (result.version === 1) {
          sample.compositionTimeOffset = view.getInt32(offset);
        } else {
          sample.compositionTimeOffset = view.getUint32(offset);
        }
        offset += 4;
      }
      result.samples.push(sample);
    }
    return result;
  };
  var parseTrun = trun;
  var tfhd = function tfhd2(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      trackId: view.getUint32(4)
    }, baseDataOffsetPresent = result.flags[2] & 1, sampleDescriptionIndexPresent = result.flags[2] & 2, defaultSampleDurationPresent = result.flags[2] & 8, defaultSampleSizePresent = result.flags[2] & 16, defaultSampleFlagsPresent = result.flags[2] & 32, durationIsEmpty = result.flags[0] & 65536, defaultBaseIsMoof = result.flags[0] & 131072, i;
    i = 8;
    if (baseDataOffsetPresent) {
      i += 4;
      result.baseDataOffset = view.getUint32(12);
      i += 4;
    }
    if (sampleDescriptionIndexPresent) {
      result.sampleDescriptionIndex = view.getUint32(i);
      i += 4;
    }
    if (defaultSampleDurationPresent) {
      result.defaultSampleDuration = view.getUint32(i);
      i += 4;
    }
    if (defaultSampleSizePresent) {
      result.defaultSampleSize = view.getUint32(i);
      i += 4;
    }
    if (defaultSampleFlagsPresent) {
      result.defaultSampleFlags = view.getUint32(i);
    }
    if (durationIsEmpty) {
      result.durationIsEmpty = true;
    }
    if (!baseDataOffsetPresent && defaultBaseIsMoof) {
      result.baseDataOffsetIsMoof = true;
    }
    return result;
  };
  var parseTfhd = tfhd;
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var win;
  if (typeof window !== "undefined") {
    win = window;
  } else if (typeof commonjsGlobal !== "undefined") {
    win = commonjsGlobal;
  } else if (typeof self !== "undefined") {
    win = self;
  } else {
    win = {};
  }
  var window_1 = win;
  var discardEmulationPreventionBytes3 = captionPacketParser.discardEmulationPreventionBytes;
  var CaptionStream = captionStream.CaptionStream;
  var mapToSample = function mapToSample2(offset, samples) {
    var approximateOffset = offset;
    for (var i = 0; i < samples.length; i++) {
      var sample = samples[i];
      if (approximateOffset < sample.size) {
        return sample;
      }
      approximateOffset -= sample.size;
    }
    return null;
  };
  var findSeiNals = function findSeiNals2(avcStream, samples, trackId) {
    var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength), result = {
      logs: [],
      seiNals: []
    }, seiNal, i, length, lastMatchedSample;
    for (i = 0; i + 4 < avcStream.length; i += length) {
      length = avcView.getUint32(i);
      i += 4;
      if (length <= 0) {
        continue;
      }
      switch (avcStream[i] & 31) {
        case 6:
          var data = avcStream.subarray(i + 1, i + 1 + length);
          var matchingSample = mapToSample(i, samples);
          seiNal = {
            nalUnitType: "sei_rbsp",
            size: length,
            data,
            escapedRBSP: discardEmulationPreventionBytes3(data),
            trackId
          };
          if (matchingSample) {
            seiNal.pts = matchingSample.pts;
            seiNal.dts = matchingSample.dts;
            lastMatchedSample = matchingSample;
          } else if (lastMatchedSample) {
            seiNal.pts = lastMatchedSample.pts;
            seiNal.dts = lastMatchedSample.dts;
          } else {
            result.logs.push({
              level: "warn",
              message: "We've encountered a nal unit without data at " + i + " for trackId " + trackId + ". See mux.js#223."
            });
            break;
          }
          result.seiNals.push(seiNal);
          break;
      }
    }
    return result;
  };
  var parseSamples2 = function parseSamples3(truns, baseMediaDecodeTime, tfhd2) {
    var currentDts = baseMediaDecodeTime;
    var defaultSampleDuration = tfhd2.defaultSampleDuration || 0;
    var defaultSampleSize = tfhd2.defaultSampleSize || 0;
    var trackId = tfhd2.trackId;
    var allSamples = [];
    truns.forEach(function(trun2) {
      var trackRun = parseTrun(trun2);
      var samples = trackRun.samples;
      samples.forEach(function(sample) {
        if (sample.duration === void 0) {
          sample.duration = defaultSampleDuration;
        }
        if (sample.size === void 0) {
          sample.size = defaultSampleSize;
        }
        sample.trackId = trackId;
        sample.dts = currentDts;
        if (sample.compositionTimeOffset === void 0) {
          sample.compositionTimeOffset = 0;
        }
        if (typeof currentDts === "bigint") {
          sample.pts = currentDts + window_1.BigInt(sample.compositionTimeOffset);
          currentDts += window_1.BigInt(sample.duration);
        } else {
          sample.pts = currentDts + sample.compositionTimeOffset;
          currentDts += sample.duration;
        }
      });
      allSamples = allSamples.concat(samples);
    });
    return allSamples;
  };
  var parseCaptionNals = function parseCaptionNals2(segment, videoTrackId) {
    var trafs = findBox_1(segment, ["moof", "traf"]);
    var mdats = findBox_1(segment, ["mdat"]);
    var captionNals = {};
    var mdatTrafPairs = [];
    mdats.forEach(function(mdat2, index) {
      var matchingTraf = trafs[index];
      mdatTrafPairs.push({
        mdat: mdat2,
        traf: matchingTraf
      });
    });
    mdatTrafPairs.forEach(function(pair) {
      var mdat2 = pair.mdat;
      var traf2 = pair.traf;
      var tfhd2 = findBox_1(traf2, ["tfhd"]);
      var headerInfo = parseTfhd(tfhd2[0]);
      var trackId = headerInfo.trackId;
      var tfdt2 = findBox_1(traf2, ["tfdt"]);
      var baseMediaDecodeTime = tfdt2.length > 0 ? parseTfdt(tfdt2[0]).baseMediaDecodeTime : 0;
      var truns = findBox_1(traf2, ["trun"]);
      var samples;
      var result;
      if (videoTrackId === trackId && truns.length > 0) {
        samples = parseSamples2(truns, baseMediaDecodeTime, headerInfo);
        result = findSeiNals(mdat2, samples, trackId);
        if (!captionNals[trackId]) {
          captionNals[trackId] = {
            seiNals: [],
            logs: []
          };
        }
        captionNals[trackId].seiNals = captionNals[trackId].seiNals.concat(result.seiNals);
        captionNals[trackId].logs = captionNals[trackId].logs.concat(result.logs);
      }
    });
    return captionNals;
  };
  var parseEmbeddedCaptions = function parseEmbeddedCaptions2(segment, trackId, timescale3) {
    var captionNals;
    if (trackId === null) {
      return null;
    }
    captionNals = parseCaptionNals(segment, trackId);
    var trackNals = captionNals[trackId] || {};
    return {
      seiNals: trackNals.seiNals,
      logs: trackNals.logs,
      timescale: timescale3
    };
  };
  var CaptionParser = function CaptionParser2() {
    var isInitialized = false;
    var captionStream2;
    var segmentCache;
    var trackId;
    var timescale3;
    var parsedCaptions;
    var parsingPartial;
    this.isInitialized = function() {
      return isInitialized;
    };
    this.init = function(options) {
      captionStream2 = new CaptionStream();
      isInitialized = true;
      parsingPartial = options ? options.isPartial : false;
      captionStream2.on("data", function(event) {
        event.startTime = event.startPts / timescale3;
        event.endTime = event.endPts / timescale3;
        parsedCaptions.captions.push(event);
        parsedCaptions.captionStreams[event.stream] = true;
      });
      captionStream2.on("log", function(log2) {
        parsedCaptions.logs.push(log2);
      });
    };
    this.isNewInit = function(videoTrackIds, timescales) {
      if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === "object" && Object.keys(timescales).length === 0) {
        return false;
      }
      return trackId !== videoTrackIds[0] || timescale3 !== timescales[trackId];
    };
    this.parse = function(segment, videoTrackIds, timescales) {
      var parsedData;
      if (!this.isInitialized()) {
        return null;
      } else if (!videoTrackIds || !timescales) {
        return null;
      } else if (this.isNewInit(videoTrackIds, timescales)) {
        trackId = videoTrackIds[0];
        timescale3 = timescales[trackId];
      } else if (trackId === null || !timescale3) {
        segmentCache.push(segment);
        return null;
      }
      while (segmentCache.length > 0) {
        var cachedSegment = segmentCache.shift();
        this.parse(cachedSegment, videoTrackIds, timescales);
      }
      parsedData = parseEmbeddedCaptions(segment, trackId, timescale3);
      if (parsedData && parsedData.logs) {
        parsedCaptions.logs = parsedCaptions.logs.concat(parsedData.logs);
      }
      if (parsedData === null || !parsedData.seiNals) {
        if (parsedCaptions.logs.length) {
          return {
            logs: parsedCaptions.logs,
            captions: [],
            captionStreams: []
          };
        }
        return null;
      }
      this.pushNals(parsedData.seiNals);
      this.flushStream();
      return parsedCaptions;
    };
    this.pushNals = function(nals) {
      if (!this.isInitialized() || !nals || nals.length === 0) {
        return null;
      }
      nals.forEach(function(nal) {
        captionStream2.push(nal);
      });
    };
    this.flushStream = function() {
      if (!this.isInitialized()) {
        return null;
      }
      if (!parsingPartial) {
        captionStream2.flush();
      } else {
        captionStream2.partialFlush();
      }
    };
    this.clearParsedCaptions = function() {
      parsedCaptions.captions = [];
      parsedCaptions.captionStreams = {};
      parsedCaptions.logs = [];
    };
    this.resetCaptionStream = function() {
      if (!this.isInitialized()) {
        return null;
      }
      captionStream2.reset();
    };
    this.clearAllCaptions = function() {
      this.clearParsedCaptions();
      this.resetCaptionStream();
    };
    this.reset = function() {
      segmentCache = [];
      trackId = null;
      timescale3 = null;
      if (!parsedCaptions) {
        parsedCaptions = {
          captions: [],
          // CC1, CC2, CC3, CC4
          captionStreams: {},
          logs: []
        };
      } else {
        this.clearParsedCaptions();
      }
      this.resetCaptionStream();
    };
    this.reset();
  };
  var captionParser = CaptionParser;
  var toUnsigned = bin.toUnsigned;
  var toHexString2 = bin.toHexString;
  var getUint64 = numbers.getUint64;
  var timescale2, startTime, compositionStartTime, getVideoTrackIds, getTracks, getTimescaleFromMediaHeader;
  timescale2 = function timescale3(init) {
    var result = {}, traks = findBox_1(init, ["moov", "trak"]);
    return traks.reduce(function(result2, trak2) {
      var tkhd2, version5, index, id, mdhd2;
      tkhd2 = findBox_1(trak2, ["tkhd"])[0];
      if (!tkhd2) {
        return null;
      }
      version5 = tkhd2[0];
      index = version5 === 0 ? 12 : 20;
      id = toUnsigned(tkhd2[index] << 24 | tkhd2[index + 1] << 16 | tkhd2[index + 2] << 8 | tkhd2[index + 3]);
      mdhd2 = findBox_1(trak2, ["mdia", "mdhd"])[0];
      if (!mdhd2) {
        return null;
      }
      version5 = mdhd2[0];
      index = version5 === 0 ? 12 : 20;
      result2[id] = toUnsigned(mdhd2[index] << 24 | mdhd2[index + 1] << 16 | mdhd2[index + 2] << 8 | mdhd2[index + 3]);
      return result2;
    }, result);
  };
  startTime = function startTime2(timescale3, fragment) {
    var trafs;
    trafs = findBox_1(fragment, ["moof", "traf"]);
    var lowestTime = trafs.reduce(function(acc, traf2) {
      var tfhd2 = findBox_1(traf2, ["tfhd"])[0];
      var id = toUnsigned(tfhd2[4] << 24 | tfhd2[5] << 16 | tfhd2[6] << 8 | tfhd2[7]);
      var scale = timescale3[id] || 9e4;
      var tfdt2 = findBox_1(traf2, ["tfdt"])[0];
      var dv = new DataView(tfdt2.buffer, tfdt2.byteOffset, tfdt2.byteLength);
      var baseTime;
      if (tfdt2[0] === 1) {
        baseTime = getUint64(tfdt2.subarray(4, 12));
      } else {
        baseTime = dv.getUint32(4);
      }
      var seconds;
      if (typeof baseTime === "bigint") {
        seconds = baseTime / window_1.BigInt(scale);
      } else if (typeof baseTime === "number" && !isNaN(baseTime)) {
        seconds = baseTime / scale;
      }
      if (seconds < Number.MAX_SAFE_INTEGER) {
        seconds = Number(seconds);
      }
      if (seconds < acc) {
        acc = seconds;
      }
      return acc;
    }, Infinity);
    return typeof lowestTime === "bigint" || isFinite(lowestTime) ? lowestTime : 0;
  };
  compositionStartTime = function compositionStartTime2(timescales, fragment) {
    var trafBoxes = findBox_1(fragment, ["moof", "traf"]);
    var baseMediaDecodeTime = 0;
    var compositionTimeOffset = 0;
    var trackId;
    if (trafBoxes && trafBoxes.length) {
      var tfhd2 = findBox_1(trafBoxes[0], ["tfhd"])[0];
      var trun2 = findBox_1(trafBoxes[0], ["trun"])[0];
      var tfdt2 = findBox_1(trafBoxes[0], ["tfdt"])[0];
      if (tfhd2) {
        var parsedTfhd = parseTfhd(tfhd2);
        trackId = parsedTfhd.trackId;
      }
      if (tfdt2) {
        var parsedTfdt = parseTfdt(tfdt2);
        baseMediaDecodeTime = parsedTfdt.baseMediaDecodeTime;
      }
      if (trun2) {
        var parsedTrun = parseTrun(trun2);
        if (parsedTrun.samples && parsedTrun.samples.length) {
          compositionTimeOffset = parsedTrun.samples[0].compositionTimeOffset || 0;
        }
      }
    }
    var timescale3 = timescales[trackId] || 9e4;
    if (typeof baseMediaDecodeTime === "bigint") {
      compositionTimeOffset = window_1.BigInt(compositionTimeOffset);
      timescale3 = window_1.BigInt(timescale3);
    }
    var result = (baseMediaDecodeTime + compositionTimeOffset) / timescale3;
    if (typeof result === "bigint" && result < Number.MAX_SAFE_INTEGER) {
      result = Number(result);
    }
    return result;
  };
  getVideoTrackIds = function getVideoTrackIds2(init) {
    var traks = findBox_1(init, ["moov", "trak"]);
    var videoTrackIds = [];
    traks.forEach(function(trak2) {
      var hdlrs = findBox_1(trak2, ["mdia", "hdlr"]);
      var tkhds = findBox_1(trak2, ["tkhd"]);
      hdlrs.forEach(function(hdlr2, index) {
        var handlerType = parseType_1(hdlr2.subarray(8, 12));
        var tkhd2 = tkhds[index];
        var view;
        var version5;
        var trackId;
        if (handlerType === "vide") {
          view = new DataView(tkhd2.buffer, tkhd2.byteOffset, tkhd2.byteLength);
          version5 = view.getUint8(0);
          trackId = version5 === 0 ? view.getUint32(12) : view.getUint32(20);
          videoTrackIds.push(trackId);
        }
      });
    });
    return videoTrackIds;
  };
  getTimescaleFromMediaHeader = function getTimescaleFromMediaHeader2(mdhd2) {
    var version5 = mdhd2[0];
    var index = version5 === 0 ? 12 : 20;
    return toUnsigned(mdhd2[index] << 24 | mdhd2[index + 1] << 16 | mdhd2[index + 2] << 8 | mdhd2[index + 3]);
  };
  getTracks = function getTracks2(init) {
    var traks = findBox_1(init, ["moov", "trak"]);
    var tracks = [];
    traks.forEach(function(trak2) {
      var track = {};
      var tkhd2 = findBox_1(trak2, ["tkhd"])[0];
      var view, tkhdVersion;
      if (tkhd2) {
        view = new DataView(tkhd2.buffer, tkhd2.byteOffset, tkhd2.byteLength);
        tkhdVersion = view.getUint8(0);
        track.id = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);
      }
      var hdlr2 = findBox_1(trak2, ["mdia", "hdlr"])[0];
      if (hdlr2) {
        var type3 = parseType_1(hdlr2.subarray(8, 12));
        if (type3 === "vide") {
          track.type = "video";
        } else if (type3 === "soun") {
          track.type = "audio";
        } else {
          track.type = type3;
        }
      }
      var stsd2 = findBox_1(trak2, ["mdia", "minf", "stbl", "stsd"])[0];
      if (stsd2) {
        var sampleDescriptions = stsd2.subarray(8);
        track.codec = parseType_1(sampleDescriptions.subarray(4, 8));
        var codecBox = findBox_1(sampleDescriptions, [track.codec])[0];
        var codecConfig, codecConfigType;
        if (codecBox) {
          if (/^[asm]vc[1-9]$/i.test(track.codec)) {
            codecConfig = codecBox.subarray(78);
            codecConfigType = parseType_1(codecConfig.subarray(4, 8));
            if (codecConfigType === "avcC" && codecConfig.length > 11) {
              track.codec += ".";
              track.codec += toHexString2(codecConfig[9]);
              track.codec += toHexString2(codecConfig[10]);
              track.codec += toHexString2(codecConfig[11]);
            } else {
              track.codec = "avc1.4d400d";
            }
          } else if (/^mp4[a,v]$/i.test(track.codec)) {
            codecConfig = codecBox.subarray(28);
            codecConfigType = parseType_1(codecConfig.subarray(4, 8));
            if (codecConfigType === "esds" && codecConfig.length > 20 && codecConfig[19] !== 0) {
              track.codec += "." + toHexString2(codecConfig[19]);
              track.codec += "." + toHexString2(codecConfig[20] >>> 2 & 63).replace(/^0/, "");
            } else {
              track.codec = "mp4a.40.2";
            }
          } else {
            track.codec = track.codec.toLowerCase();
          }
        }
      }
      var mdhd2 = findBox_1(trak2, ["mdia", "mdhd"])[0];
      if (mdhd2) {
        track.timescale = getTimescaleFromMediaHeader(mdhd2);
      }
      tracks.push(track);
    });
    return tracks;
  };
  var probe$2 = {
    // export mp4 inspector's findBox and parseType for backwards compatibility
    findBox: findBox_1,
    parseType: parseType_1,
    timescale: timescale2,
    startTime,
    compositionStartTime,
    videoTrackIds: getVideoTrackIds,
    tracks: getTracks,
    getTimescaleFromMediaHeader
  };
  var parsePid = function parsePid2(packet) {
    var pid = packet[1] & 31;
    pid <<= 8;
    pid |= packet[2];
    return pid;
  };
  var parsePayloadUnitStartIndicator = function parsePayloadUnitStartIndicator2(packet) {
    return !!(packet[1] & 64);
  };
  var parseAdaptionField = function parseAdaptionField2(packet) {
    var offset = 0;
    if ((packet[3] & 48) >>> 4 > 1) {
      offset += packet[4] + 1;
    }
    return offset;
  };
  var parseType = function parseType2(packet, pmtPid) {
    var pid = parsePid(packet);
    if (pid === 0) {
      return "pat";
    } else if (pid === pmtPid) {
      return "pmt";
    } else if (pmtPid) {
      return "pes";
    }
    return null;
  };
  var parsePat = function parsePat2(packet) {
    var pusi = parsePayloadUnitStartIndicator(packet);
    var offset = 4 + parseAdaptionField(packet);
    if (pusi) {
      offset += packet[offset] + 1;
    }
    return (packet[offset + 10] & 31) << 8 | packet[offset + 11];
  };
  var parsePmt = function parsePmt2(packet) {
    var programMapTable = {};
    var pusi = parsePayloadUnitStartIndicator(packet);
    var payloadOffset = 4 + parseAdaptionField(packet);
    if (pusi) {
      payloadOffset += packet[payloadOffset] + 1;
    }
    if (!(packet[payloadOffset + 5] & 1)) {
      return;
    }
    var sectionLength, tableEnd, programInfoLength;
    sectionLength = (packet[payloadOffset + 1] & 15) << 8 | packet[payloadOffset + 2];
    tableEnd = 3 + sectionLength - 4;
    programInfoLength = (packet[payloadOffset + 10] & 15) << 8 | packet[payloadOffset + 11];
    var offset = 12 + programInfoLength;
    while (offset < tableEnd) {
      var i = payloadOffset + offset;
      programMapTable[(packet[i + 1] & 31) << 8 | packet[i + 2]] = packet[i];
      offset += ((packet[i + 3] & 15) << 8 | packet[i + 4]) + 5;
    }
    return programMapTable;
  };
  var parsePesType = function parsePesType2(packet, programMapTable) {
    var pid = parsePid(packet);
    var type3 = programMapTable[pid];
    switch (type3) {
      case streamTypes.H264_STREAM_TYPE:
        return "video";
      case streamTypes.ADTS_STREAM_TYPE:
        return "audio";
      case streamTypes.METADATA_STREAM_TYPE:
        return "timed-metadata";
      default:
        return null;
    }
  };
  var parsePesTime = function parsePesTime2(packet) {
    var pusi = parsePayloadUnitStartIndicator(packet);
    if (!pusi) {
      return null;
    }
    var offset = 4 + parseAdaptionField(packet);
    if (offset >= packet.byteLength) {
      return null;
    }
    var pes = null;
    var ptsDtsFlags;
    ptsDtsFlags = packet[offset + 7];
    if (ptsDtsFlags & 192) {
      pes = {};
      pes.pts = (packet[offset + 9] & 14) << 27 | (packet[offset + 10] & 255) << 20 | (packet[offset + 11] & 254) << 12 | (packet[offset + 12] & 255) << 5 | (packet[offset + 13] & 254) >>> 3;
      pes.pts *= 4;
      pes.pts += (packet[offset + 13] & 6) >>> 1;
      pes.dts = pes.pts;
      if (ptsDtsFlags & 64) {
        pes.dts = (packet[offset + 14] & 14) << 27 | (packet[offset + 15] & 255) << 20 | (packet[offset + 16] & 254) << 12 | (packet[offset + 17] & 255) << 5 | (packet[offset + 18] & 254) >>> 3;
        pes.dts *= 4;
        pes.dts += (packet[offset + 18] & 6) >>> 1;
      }
    }
    return pes;
  };
  var parseNalUnitType = function parseNalUnitType2(type3) {
    switch (type3) {
      case 5:
        return "slice_layer_without_partitioning_rbsp_idr";
      case 6:
        return "sei_rbsp";
      case 7:
        return "seq_parameter_set_rbsp";
      case 8:
        return "pic_parameter_set_rbsp";
      case 9:
        return "access_unit_delimiter_rbsp";
      default:
        return null;
    }
  };
  var videoPacketContainsKeyFrame = function videoPacketContainsKeyFrame2(packet) {
    var offset = 4 + parseAdaptionField(packet);
    var frameBuffer = packet.subarray(offset);
    var frameI = 0;
    var frameSyncPoint = 0;
    var foundKeyFrame = false;
    var nalType;
    for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {
      if (frameBuffer[frameSyncPoint + 2] === 1) {
        frameI = frameSyncPoint + 5;
        break;
      }
    }
    while (frameI < frameBuffer.byteLength) {
      switch (frameBuffer[frameI]) {
        case 0:
          if (frameBuffer[frameI - 1] !== 0) {
            frameI += 2;
            break;
          } else if (frameBuffer[frameI - 2] !== 0) {
            frameI++;
            break;
          }
          if (frameSyncPoint + 3 !== frameI - 2) {
            nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
            if (nalType === "slice_layer_without_partitioning_rbsp_idr") {
              foundKeyFrame = true;
            }
          }
          do {
            frameI++;
          } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);
          frameSyncPoint = frameI - 2;
          frameI += 3;
          break;
        case 1:
          if (frameBuffer[frameI - 1] !== 0 || frameBuffer[frameI - 2] !== 0) {
            frameI += 3;
            break;
          }
          nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
          if (nalType === "slice_layer_without_partitioning_rbsp_idr") {
            foundKeyFrame = true;
          }
          frameSyncPoint = frameI - 2;
          frameI += 3;
          break;
        default:
          frameI += 3;
          break;
      }
    }
    frameBuffer = frameBuffer.subarray(frameSyncPoint);
    frameI -= frameSyncPoint;
    frameSyncPoint = 0;
    if (frameBuffer && frameBuffer.byteLength > 3) {
      nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
      if (nalType === "slice_layer_without_partitioning_rbsp_idr") {
        foundKeyFrame = true;
      }
    }
    return foundKeyFrame;
  };
  var probe$12 = {
    parseType,
    parsePat,
    parsePmt,
    parsePayloadUnitStartIndicator,
    parsePesType,
    parsePesTime,
    videoPacketContainsKeyFrame
  };
  var handleRollover = timestampRolloverStream.handleRollover;
  var probe2 = {};
  probe2.ts = probe$12;
  probe2.aac = utils2;
  var ONE_SECOND_IN_TS2 = clock.ONE_SECOND_IN_TS;
  var MP2T_PACKET_LENGTH = 188, SYNC_BYTE = 71;
  var parsePsi_ = function parsePsi_2(bytes, pmt) {
    var startIndex = 0, endIndex = MP2T_PACKET_LENGTH, packet, type3;
    while (endIndex < bytes.byteLength) {
      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
        packet = bytes.subarray(startIndex, endIndex);
        type3 = probe2.ts.parseType(packet, pmt.pid);
        switch (type3) {
          case "pat":
            pmt.pid = probe2.ts.parsePat(packet);
            break;
          case "pmt":
            var table = probe2.ts.parsePmt(packet);
            pmt.table = pmt.table || {};
            Object.keys(table).forEach(function(key) {
              pmt.table[key] = table[key];
            });
            break;
        }
        startIndex += MP2T_PACKET_LENGTH;
        endIndex += MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex++;
      endIndex++;
    }
  };
  var parseAudioPes_ = function parseAudioPes_2(bytes, pmt, result) {
    var startIndex = 0, endIndex = MP2T_PACKET_LENGTH, packet, type3, pesType, pusi, parsed;
    var endLoop = false;
    while (endIndex <= bytes.byteLength) {
      if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {
        packet = bytes.subarray(startIndex, endIndex);
        type3 = probe2.ts.parseType(packet, pmt.pid);
        switch (type3) {
          case "pes":
            pesType = probe2.ts.parsePesType(packet, pmt.table);
            pusi = probe2.ts.parsePayloadUnitStartIndicator(packet);
            if (pesType === "audio" && pusi) {
              parsed = probe2.ts.parsePesTime(packet);
              if (parsed) {
                parsed.type = "audio";
                result.audio.push(parsed);
                endLoop = true;
              }
            }
            break;
        }
        if (endLoop) {
          break;
        }
        startIndex += MP2T_PACKET_LENGTH;
        endIndex += MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex++;
      endIndex++;
    }
    endIndex = bytes.byteLength;
    startIndex = endIndex - MP2T_PACKET_LENGTH;
    endLoop = false;
    while (startIndex >= 0) {
      if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {
        packet = bytes.subarray(startIndex, endIndex);
        type3 = probe2.ts.parseType(packet, pmt.pid);
        switch (type3) {
          case "pes":
            pesType = probe2.ts.parsePesType(packet, pmt.table);
            pusi = probe2.ts.parsePayloadUnitStartIndicator(packet);
            if (pesType === "audio" && pusi) {
              parsed = probe2.ts.parsePesTime(packet);
              if (parsed) {
                parsed.type = "audio";
                result.audio.push(parsed);
                endLoop = true;
              }
            }
            break;
        }
        if (endLoop) {
          break;
        }
        startIndex -= MP2T_PACKET_LENGTH;
        endIndex -= MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex--;
      endIndex--;
    }
  };
  var parseVideoPes_ = function parseVideoPes_2(bytes, pmt, result) {
    var startIndex = 0, endIndex = MP2T_PACKET_LENGTH, packet, type3, pesType, pusi, parsed, frame, i, pes;
    var endLoop = false;
    var currentFrame = {
      data: [],
      size: 0
    };
    while (endIndex < bytes.byteLength) {
      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
        packet = bytes.subarray(startIndex, endIndex);
        type3 = probe2.ts.parseType(packet, pmt.pid);
        switch (type3) {
          case "pes":
            pesType = probe2.ts.parsePesType(packet, pmt.table);
            pusi = probe2.ts.parsePayloadUnitStartIndicator(packet);
            if (pesType === "video") {
              if (pusi && !endLoop) {
                parsed = probe2.ts.parsePesTime(packet);
                if (parsed) {
                  parsed.type = "video";
                  result.video.push(parsed);
                  endLoop = true;
                }
              }
              if (!result.firstKeyFrame) {
                if (pusi) {
                  if (currentFrame.size !== 0) {
                    frame = new Uint8Array(currentFrame.size);
                    i = 0;
                    while (currentFrame.data.length) {
                      pes = currentFrame.data.shift();
                      frame.set(pes, i);
                      i += pes.byteLength;
                    }
                    if (probe2.ts.videoPacketContainsKeyFrame(frame)) {
                      var firstKeyFrame = probe2.ts.parsePesTime(frame);
                      if (firstKeyFrame) {
                        result.firstKeyFrame = firstKeyFrame;
                        result.firstKeyFrame.type = "video";
                      } else {
                        console.warn("Failed to extract PTS/DTS from PES at first keyframe. This could be an unusual TS segment, or else mux.js did not parse your TS segment correctly. If you know your TS segments do contain PTS/DTS on keyframes please file a bug report! You can try ffprobe to double check for yourself.");
                      }
                    }
                    currentFrame.size = 0;
                  }
                }
                currentFrame.data.push(packet);
                currentFrame.size += packet.byteLength;
              }
            }
            break;
        }
        if (endLoop && result.firstKeyFrame) {
          break;
        }
        startIndex += MP2T_PACKET_LENGTH;
        endIndex += MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex++;
      endIndex++;
    }
    endIndex = bytes.byteLength;
    startIndex = endIndex - MP2T_PACKET_LENGTH;
    endLoop = false;
    while (startIndex >= 0) {
      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
        packet = bytes.subarray(startIndex, endIndex);
        type3 = probe2.ts.parseType(packet, pmt.pid);
        switch (type3) {
          case "pes":
            pesType = probe2.ts.parsePesType(packet, pmt.table);
            pusi = probe2.ts.parsePayloadUnitStartIndicator(packet);
            if (pesType === "video" && pusi) {
              parsed = probe2.ts.parsePesTime(packet);
              if (parsed) {
                parsed.type = "video";
                result.video.push(parsed);
                endLoop = true;
              }
            }
            break;
        }
        if (endLoop) {
          break;
        }
        startIndex -= MP2T_PACKET_LENGTH;
        endIndex -= MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex--;
      endIndex--;
    }
  };
  var adjustTimestamp_ = function adjustTimestamp_2(segmentInfo, baseTimestamp) {
    if (segmentInfo.audio && segmentInfo.audio.length) {
      var audioBaseTimestamp = baseTimestamp;
      if (typeof audioBaseTimestamp === "undefined" || isNaN(audioBaseTimestamp)) {
        audioBaseTimestamp = segmentInfo.audio[0].dts;
      }
      segmentInfo.audio.forEach(function(info) {
        info.dts = handleRollover(info.dts, audioBaseTimestamp);
        info.pts = handleRollover(info.pts, audioBaseTimestamp);
        info.dtsTime = info.dts / ONE_SECOND_IN_TS2;
        info.ptsTime = info.pts / ONE_SECOND_IN_TS2;
      });
    }
    if (segmentInfo.video && segmentInfo.video.length) {
      var videoBaseTimestamp = baseTimestamp;
      if (typeof videoBaseTimestamp === "undefined" || isNaN(videoBaseTimestamp)) {
        videoBaseTimestamp = segmentInfo.video[0].dts;
      }
      segmentInfo.video.forEach(function(info) {
        info.dts = handleRollover(info.dts, videoBaseTimestamp);
        info.pts = handleRollover(info.pts, videoBaseTimestamp);
        info.dtsTime = info.dts / ONE_SECOND_IN_TS2;
        info.ptsTime = info.pts / ONE_SECOND_IN_TS2;
      });
      if (segmentInfo.firstKeyFrame) {
        var frame = segmentInfo.firstKeyFrame;
        frame.dts = handleRollover(frame.dts, videoBaseTimestamp);
        frame.pts = handleRollover(frame.pts, videoBaseTimestamp);
        frame.dtsTime = frame.dts / ONE_SECOND_IN_TS2;
        frame.ptsTime = frame.pts / ONE_SECOND_IN_TS2;
      }
    }
  };
  var inspectAac_ = function inspectAac_2(bytes) {
    var endLoop = false, audioCount = 0, sampleRate = null, timestamp = null, frameSize = 0, byteIndex = 0, packet;
    while (bytes.length - byteIndex >= 3) {
      var type3 = probe2.aac.parseType(bytes, byteIndex);
      switch (type3) {
        case "timed-metadata":
          if (bytes.length - byteIndex < 10) {
            endLoop = true;
            break;
          }
          frameSize = probe2.aac.parseId3TagSize(bytes, byteIndex);
          if (frameSize > bytes.length) {
            endLoop = true;
            break;
          }
          if (timestamp === null) {
            packet = bytes.subarray(byteIndex, byteIndex + frameSize);
            timestamp = probe2.aac.parseAacTimestamp(packet);
          }
          byteIndex += frameSize;
          break;
        case "audio":
          if (bytes.length - byteIndex < 7) {
            endLoop = true;
            break;
          }
          frameSize = probe2.aac.parseAdtsSize(bytes, byteIndex);
          if (frameSize > bytes.length) {
            endLoop = true;
            break;
          }
          if (sampleRate === null) {
            packet = bytes.subarray(byteIndex, byteIndex + frameSize);
            sampleRate = probe2.aac.parseSampleRate(packet);
          }
          audioCount++;
          byteIndex += frameSize;
          break;
        default:
          byteIndex++;
          break;
      }
      if (endLoop) {
        return null;
      }
    }
    if (sampleRate === null || timestamp === null) {
      return null;
    }
    var audioTimescale = ONE_SECOND_IN_TS2 / sampleRate;
    var result = {
      audio: [{
        type: "audio",
        dts: timestamp,
        pts: timestamp
      }, {
        type: "audio",
        dts: timestamp + audioCount * 1024 * audioTimescale,
        pts: timestamp + audioCount * 1024 * audioTimescale
      }]
    };
    return result;
  };
  var inspectTs_ = function inspectTs_2(bytes) {
    var pmt = {
      pid: null,
      table: null
    };
    var result = {};
    parsePsi_(bytes, pmt);
    for (var pid in pmt.table) {
      if (pmt.table.hasOwnProperty(pid)) {
        var type3 = pmt.table[pid];
        switch (type3) {
          case streamTypes.H264_STREAM_TYPE:
            result.video = [];
            parseVideoPes_(bytes, pmt, result);
            if (result.video.length === 0) {
              delete result.video;
            }
            break;
          case streamTypes.ADTS_STREAM_TYPE:
            result.audio = [];
            parseAudioPes_(bytes, pmt, result);
            if (result.audio.length === 0) {
              delete result.audio;
            }
            break;
        }
      }
    }
    return result;
  };
  var inspect = function inspect2(bytes, baseTimestamp) {
    var isAacData = probe2.aac.isLikelyAacData(bytes);
    var result;
    if (isAacData) {
      result = inspectAac_(bytes);
    } else {
      result = inspectTs_(bytes);
    }
    if (!result || !result.audio && !result.video) {
      return null;
    }
    adjustTimestamp_(result, baseTimestamp);
    return result;
  };
  var tsInspector = {
    inspect,
    parseAudioPes_
  };
  var wireTransmuxerEvents = function wireTransmuxerEvents2(self2, transmuxer2) {
    transmuxer2.on("data", function(segment) {
      var initArray = segment.initSegment;
      segment.initSegment = {
        data: initArray.buffer,
        byteOffset: initArray.byteOffset,
        byteLength: initArray.byteLength
      };
      var typedArray = segment.data;
      segment.data = typedArray.buffer;
      self2.postMessage({
        action: "data",
        segment,
        byteOffset: typedArray.byteOffset,
        byteLength: typedArray.byteLength
      }, [segment.data]);
    });
    transmuxer2.on("done", function(data) {
      self2.postMessage({
        action: "done"
      });
    });
    transmuxer2.on("gopInfo", function(gopInfo) {
      self2.postMessage({
        action: "gopInfo",
        gopInfo
      });
    });
    transmuxer2.on("videoSegmentTimingInfo", function(timingInfo) {
      var videoSegmentTimingInfo = {
        start: {
          decode: clock.videoTsToSeconds(timingInfo.start.dts),
          presentation: clock.videoTsToSeconds(timingInfo.start.pts)
        },
        end: {
          decode: clock.videoTsToSeconds(timingInfo.end.dts),
          presentation: clock.videoTsToSeconds(timingInfo.end.pts)
        },
        baseMediaDecodeTime: clock.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
      };
      if (timingInfo.prependedContentDuration) {
        videoSegmentTimingInfo.prependedContentDuration = clock.videoTsToSeconds(timingInfo.prependedContentDuration);
      }
      self2.postMessage({
        action: "videoSegmentTimingInfo",
        videoSegmentTimingInfo
      });
    });
    transmuxer2.on("audioSegmentTimingInfo", function(timingInfo) {
      var audioSegmentTimingInfo = {
        start: {
          decode: clock.videoTsToSeconds(timingInfo.start.dts),
          presentation: clock.videoTsToSeconds(timingInfo.start.pts)
        },
        end: {
          decode: clock.videoTsToSeconds(timingInfo.end.dts),
          presentation: clock.videoTsToSeconds(timingInfo.end.pts)
        },
        baseMediaDecodeTime: clock.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
      };
      if (timingInfo.prependedContentDuration) {
        audioSegmentTimingInfo.prependedContentDuration = clock.videoTsToSeconds(timingInfo.prependedContentDuration);
      }
      self2.postMessage({
        action: "audioSegmentTimingInfo",
        audioSegmentTimingInfo
      });
    });
    transmuxer2.on("id3Frame", function(id3Frame) {
      self2.postMessage({
        action: "id3Frame",
        id3Frame
      });
    });
    transmuxer2.on("caption", function(caption) {
      self2.postMessage({
        action: "caption",
        caption
      });
    });
    transmuxer2.on("trackinfo", function(trackInfo) {
      self2.postMessage({
        action: "trackinfo",
        trackInfo
      });
    });
    transmuxer2.on("audioTimingInfo", function(audioTimingInfo) {
      self2.postMessage({
        action: "audioTimingInfo",
        audioTimingInfo: {
          start: clock.videoTsToSeconds(audioTimingInfo.start),
          end: clock.videoTsToSeconds(audioTimingInfo.end)
        }
      });
    });
    transmuxer2.on("videoTimingInfo", function(videoTimingInfo) {
      self2.postMessage({
        action: "videoTimingInfo",
        videoTimingInfo: {
          start: clock.videoTsToSeconds(videoTimingInfo.start),
          end: clock.videoTsToSeconds(videoTimingInfo.end)
        }
      });
    });
    transmuxer2.on("log", function(log2) {
      self2.postMessage({
        action: "log",
        log: log2
      });
    });
  };
  var MessageHandlers = /* @__PURE__ */ function() {
    function MessageHandlers2(self2, options) {
      this.options = options || {};
      this.self = self2;
      this.init();
    }
    var _proto = MessageHandlers2.prototype;
    _proto.init = function init() {
      if (this.transmuxer) {
        this.transmuxer.dispose();
      }
      this.transmuxer = new transmuxer.Transmuxer(this.options);
      wireTransmuxerEvents(this.self, this.transmuxer);
    };
    _proto.pushMp4Captions = function pushMp4Captions(data) {
      if (!this.captionParser) {
        this.captionParser = new captionParser();
        this.captionParser.init();
      }
      var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
      var parsed = this.captionParser.parse(segment, data.trackIds, data.timescales);
      this.self.postMessage({
        action: "mp4Captions",
        captions: parsed && parsed.captions || [],
        logs: parsed && parsed.logs || [],
        data: segment.buffer
      }, [segment.buffer]);
    };
    _proto.probeMp4StartTime = function probeMp4StartTime(_ref) {
      var timescales = _ref.timescales, data = _ref.data;
      var startTime2 = probe$2.startTime(timescales, data);
      this.self.postMessage({
        action: "probeMp4StartTime",
        startTime: startTime2,
        data
      }, [data.buffer]);
    };
    _proto.probeMp4Tracks = function probeMp4Tracks(_ref2) {
      var data = _ref2.data;
      var tracks = probe$2.tracks(data);
      this.self.postMessage({
        action: "probeMp4Tracks",
        tracks,
        data
      }, [data.buffer]);
    };
    _proto.probeTs = function probeTs(_ref3) {
      var data = _ref3.data, baseStartTime = _ref3.baseStartTime;
      var tsStartTime = typeof baseStartTime === "number" && !isNaN(baseStartTime) ? baseStartTime * clock.ONE_SECOND_IN_TS : void 0;
      var timeInfo = tsInspector.inspect(data, tsStartTime);
      var result = null;
      if (timeInfo) {
        result = {
          // each type's time info comes back as an array of 2 times, start and end
          hasVideo: timeInfo.video && timeInfo.video.length === 2 || false,
          hasAudio: timeInfo.audio && timeInfo.audio.length === 2 || false
        };
        if (result.hasVideo) {
          result.videoStart = timeInfo.video[0].ptsTime;
        }
        if (result.hasAudio) {
          result.audioStart = timeInfo.audio[0].ptsTime;
        }
      }
      this.self.postMessage({
        action: "probeTs",
        result,
        data
      }, [data.buffer]);
    };
    _proto.clearAllMp4Captions = function clearAllMp4Captions() {
      if (this.captionParser) {
        this.captionParser.clearAllCaptions();
      }
    };
    _proto.clearParsedMp4Captions = function clearParsedMp4Captions() {
      if (this.captionParser) {
        this.captionParser.clearParsedCaptions();
      }
    };
    _proto.push = function push2(data) {
      var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
      this.transmuxer.push(segment);
    };
    _proto.reset = function reset3() {
      this.transmuxer.reset();
    };
    _proto.setTimestampOffset = function setTimestampOffset(data) {
      var timestampOffset2 = data.timestampOffset || 0;
      this.transmuxer.setBaseMediaDecodeTime(Math.round(clock.secondsToVideoTs(timestampOffset2)));
    };
    _proto.setAudioAppendStart = function setAudioAppendStart(data) {
      this.transmuxer.setAudioAppendStart(Math.ceil(clock.secondsToVideoTs(data.appendStart)));
    };
    _proto.setRemux = function setRemux(data) {
      this.transmuxer.setRemux(data.remux);
    };
    _proto.flush = function flush(data) {
      this.transmuxer.flush();
      self.postMessage({
        action: "done",
        type: "transmuxed"
      });
    };
    _proto.endTimeline = function endTimeline3() {
      this.transmuxer.endTimeline();
      self.postMessage({
        action: "endedtimeline",
        type: "transmuxed"
      });
    };
    _proto.alignGopsWith = function alignGopsWith(data) {
      this.transmuxer.alignGopsWith(data.gopsToAlignWith.slice());
    };
    return MessageHandlers2;
  }();
  self.onmessage = function(event) {
    if (event.data.action === "init" && event.data.options) {
      this.messageHandlers = new MessageHandlers(self, event.data.options);
      return;
    }
    if (!this.messageHandlers) {
      this.messageHandlers = new MessageHandlers(self);
    }
    if (event.data && event.data.action && event.data.action !== "init") {
      if (this.messageHandlers[event.data.action]) {
        this.messageHandlers[event.data.action](event.data);
      }
    }
  };
}));
var TransmuxWorker = factory(workerCode$1);
var handleData_ = function handleData_2(event, transmuxedData, callback2) {
  var _event$data$segment = event.data.segment, type2 = _event$data$segment.type, initSegment = _event$data$segment.initSegment, captions = _event$data$segment.captions, captionStreams = _event$data$segment.captionStreams, metadata = _event$data$segment.metadata, videoFrameDtsTime = _event$data$segment.videoFrameDtsTime, videoFramePtsTime = _event$data$segment.videoFramePtsTime;
  transmuxedData.buffer.push({
    captions,
    captionStreams,
    metadata
  });
  var boxes = event.data.segment.boxes || {
    data: event.data.segment.data
  };
  var result = {
    type: type2,
    // cast ArrayBuffer to TypedArray
    data: new Uint8Array(boxes.data, boxes.data.byteOffset, boxes.data.byteLength),
    initSegment: new Uint8Array(initSegment.data, initSegment.byteOffset, initSegment.byteLength)
  };
  if (typeof videoFrameDtsTime !== "undefined") {
    result.videoFrameDtsTime = videoFrameDtsTime;
  }
  if (typeof videoFramePtsTime !== "undefined") {
    result.videoFramePtsTime = videoFramePtsTime;
  }
  callback2(result);
};
var handleDone_ = function handleDone_2(_ref) {
  var transmuxedData = _ref.transmuxedData, callback2 = _ref.callback;
  transmuxedData.buffer = [];
  callback2(transmuxedData);
};
var handleGopInfo_ = function handleGopInfo_2(event, transmuxedData) {
  transmuxedData.gopInfo = event.data.gopInfo;
};
var processTransmux = function processTransmux2(options) {
  var transmuxer = options.transmuxer, bytes = options.bytes, audioAppendStart = options.audioAppendStart, gopsToAlignWith = options.gopsToAlignWith, remux = options.remux, onData = options.onData, onTrackInfo = options.onTrackInfo, onAudioTimingInfo = options.onAudioTimingInfo, onVideoTimingInfo = options.onVideoTimingInfo, onVideoSegmentTimingInfo = options.onVideoSegmentTimingInfo, onAudioSegmentTimingInfo = options.onAudioSegmentTimingInfo, onId3 = options.onId3, onCaptions = options.onCaptions, onDone = options.onDone, onEndedTimeline = options.onEndedTimeline, onTransmuxerLog = options.onTransmuxerLog, isEndOfTimeline = options.isEndOfTimeline;
  var transmuxedData = {
    buffer: []
  };
  var waitForEndedTimelineEvent = isEndOfTimeline;
  var handleMessage = function handleMessage2(event) {
    if (transmuxer.currentTransmux !== options) {
      return;
    }
    if (event.data.action === "data") {
      handleData_(event, transmuxedData, onData);
    }
    if (event.data.action === "trackinfo") {
      onTrackInfo(event.data.trackInfo);
    }
    if (event.data.action === "gopInfo") {
      handleGopInfo_(event, transmuxedData);
    }
    if (event.data.action === "audioTimingInfo") {
      onAudioTimingInfo(event.data.audioTimingInfo);
    }
    if (event.data.action === "videoTimingInfo") {
      onVideoTimingInfo(event.data.videoTimingInfo);
    }
    if (event.data.action === "videoSegmentTimingInfo") {
      onVideoSegmentTimingInfo(event.data.videoSegmentTimingInfo);
    }
    if (event.data.action === "audioSegmentTimingInfo") {
      onAudioSegmentTimingInfo(event.data.audioSegmentTimingInfo);
    }
    if (event.data.action === "id3Frame") {
      onId3([event.data.id3Frame], event.data.id3Frame.dispatchType);
    }
    if (event.data.action === "caption") {
      onCaptions(event.data.caption);
    }
    if (event.data.action === "endedtimeline") {
      waitForEndedTimelineEvent = false;
      onEndedTimeline();
    }
    if (event.data.action === "log") {
      onTransmuxerLog(event.data.log);
    }
    if (event.data.type !== "transmuxed") {
      return;
    }
    if (waitForEndedTimelineEvent) {
      return;
    }
    transmuxer.onmessage = null;
    handleDone_({
      transmuxedData,
      callback: onDone
    });
    dequeue(transmuxer);
  };
  transmuxer.onmessage = handleMessage;
  if (audioAppendStart) {
    transmuxer.postMessage({
      action: "setAudioAppendStart",
      appendStart: audioAppendStart
    });
  }
  if (Array.isArray(gopsToAlignWith)) {
    transmuxer.postMessage({
      action: "alignGopsWith",
      gopsToAlignWith
    });
  }
  if (typeof remux !== "undefined") {
    transmuxer.postMessage({
      action: "setRemux",
      remux
    });
  }
  if (bytes.byteLength) {
    var buffer = bytes instanceof ArrayBuffer ? bytes : bytes.buffer;
    var byteOffset = bytes instanceof ArrayBuffer ? 0 : bytes.byteOffset;
    transmuxer.postMessage({
      action: "push",
      // Send the typed-array of data as an ArrayBuffer so that
      // it can be sent as a "Transferable" and avoid the costly
      // memory copy
      data: buffer,
      // To recreate the original typed-array, we need information
      // about what portion of the ArrayBuffer it was a view into
      byteOffset,
      byteLength: bytes.byteLength
    }, [buffer]);
  }
  if (isEndOfTimeline) {
    transmuxer.postMessage({
      action: "endTimeline"
    });
  }
  transmuxer.postMessage({
    action: "flush"
  });
};
var dequeue = function dequeue2(transmuxer) {
  transmuxer.currentTransmux = null;
  if (transmuxer.transmuxQueue.length) {
    transmuxer.currentTransmux = transmuxer.transmuxQueue.shift();
    if (typeof transmuxer.currentTransmux === "function") {
      transmuxer.currentTransmux();
    } else {
      processTransmux(transmuxer.currentTransmux);
    }
  }
};
var processAction = function processAction2(transmuxer, action) {
  transmuxer.postMessage({
    action
  });
  dequeue(transmuxer);
};
var enqueueAction = function enqueueAction2(action, transmuxer) {
  if (!transmuxer.currentTransmux) {
    transmuxer.currentTransmux = action;
    processAction(transmuxer, action);
    return;
  }
  transmuxer.transmuxQueue.push(processAction.bind(null, transmuxer, action));
};
var reset = function reset2(transmuxer) {
  enqueueAction("reset", transmuxer);
};
var endTimeline = function endTimeline2(transmuxer) {
  enqueueAction("endTimeline", transmuxer);
};
var transmux = function transmux2(options) {
  if (!options.transmuxer.currentTransmux) {
    options.transmuxer.currentTransmux = options;
    processTransmux(options);
    return;
  }
  options.transmuxer.transmuxQueue.push(options);
};
var createTransmuxer = function createTransmuxer2(options) {
  var transmuxer = new TransmuxWorker();
  transmuxer.currentTransmux = null;
  transmuxer.transmuxQueue = [];
  var term = transmuxer.terminate;
  transmuxer.terminate = function() {
    transmuxer.currentTransmux = null;
    transmuxer.transmuxQueue.length = 0;
    return term.call(transmuxer);
  };
  transmuxer.postMessage({
    action: "init",
    options
  });
  return transmuxer;
};
var segmentTransmuxer = {
  reset,
  endTimeline,
  transmux,
  createTransmuxer
};
var workerCallback = function workerCallback2(options) {
  var transmuxer = options.transmuxer;
  var endAction = options.endAction || options.action;
  var callback2 = options.callback;
  var message = _extends2({}, options, {
    endAction: null,
    transmuxer: null,
    callback: null
  });
  var listenForEndEvent = function listenForEndEvent2(event) {
    if (event.data.action !== endAction) {
      return;
    }
    transmuxer.removeEventListener("message", listenForEndEvent2);
    if (event.data.data) {
      event.data.data = new Uint8Array(event.data.data, options.byteOffset || 0, options.byteLength || event.data.data.byteLength);
      if (options.data) {
        options.data = event.data.data;
      }
    }
    callback2(event.data);
  };
  transmuxer.addEventListener("message", listenForEndEvent);
  if (options.data) {
    var isArrayBuffer = options.data instanceof ArrayBuffer;
    message.byteOffset = isArrayBuffer ? 0 : options.data.byteOffset;
    message.byteLength = options.data.byteLength;
    var transfers = [isArrayBuffer ? options.data : options.data.buffer];
    transmuxer.postMessage(message, transfers);
  } else {
    transmuxer.postMessage(message);
  }
};
var REQUEST_ERRORS = {
  FAILURE: 2,
  TIMEOUT: -101,
  ABORTED: -102
};
var abortAll = function abortAll2(activeXhrs) {
  activeXhrs.forEach(function(xhr) {
    xhr.abort();
  });
};
var getRequestStats = function getRequestStats2(request) {
  return {
    bandwidth: request.bandwidth,
    bytesReceived: request.bytesReceived || 0,
    roundTripTime: request.roundTripTime || 0
  };
};
var getProgressStats = function getProgressStats2(progressEvent) {
  var request = progressEvent.target;
  var roundTripTime = Date.now() - request.requestTime;
  var stats = {
    bandwidth: Infinity,
    bytesReceived: 0,
    roundTripTime: roundTripTime || 0
  };
  stats.bytesReceived = progressEvent.loaded;
  stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8 * 1e3);
  return stats;
};
var handleErrors = function handleErrors2(error, request) {
  if (request.timedout) {
    return {
      status: request.status,
      message: "HLS request timed-out at URL: " + request.uri,
      code: REQUEST_ERRORS.TIMEOUT,
      xhr: request
    };
  }
  if (request.aborted) {
    return {
      status: request.status,
      message: "HLS request aborted at URL: " + request.uri,
      code: REQUEST_ERRORS.ABORTED,
      xhr: request
    };
  }
  if (error) {
    return {
      status: request.status,
      message: "HLS request errored at URL: " + request.uri,
      code: REQUEST_ERRORS.FAILURE,
      xhr: request
    };
  }
  if (request.responseType === "arraybuffer" && request.response.byteLength === 0) {
    return {
      status: request.status,
      message: "Empty HLS response at URL: " + request.uri,
      code: REQUEST_ERRORS.FAILURE,
      xhr: request
    };
  }
  return null;
};
var handleKeyResponse = function handleKeyResponse2(segment, objects, finishProcessingFn) {
  return function(error, request) {
    var response = request.response;
    var errorObj = handleErrors(error, request);
    if (errorObj) {
      return finishProcessingFn(errorObj, segment);
    }
    if (response.byteLength !== 16) {
      return finishProcessingFn({
        status: request.status,
        message: "Invalid HLS key at URL: " + request.uri,
        code: REQUEST_ERRORS.FAILURE,
        xhr: request
      }, segment);
    }
    var view = new DataView(response);
    var bytes = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);
    for (var i = 0; i < objects.length; i++) {
      objects[i].bytes = bytes;
    }
    return finishProcessingFn(null, segment);
  };
};
var parseInitSegment2 = function parseInitSegment3(segment, _callback) {
  var type2 = detectContainerForBytes(segment.map.bytes);
  if (type2 !== "mp4") {
    var uri = segment.map.resolvedUri || segment.map.uri;
    return _callback({
      internal: true,
      message: "Found unsupported " + (type2 || "unknown") + " container for initialization segment at URL: " + uri,
      code: REQUEST_ERRORS.FAILURE
    });
  }
  workerCallback({
    action: "probeMp4Tracks",
    data: segment.map.bytes,
    transmuxer: segment.transmuxer,
    callback: function callback2(_ref) {
      var tracks = _ref.tracks, data = _ref.data;
      segment.map.bytes = data;
      tracks.forEach(function(track) {
        segment.map.tracks = segment.map.tracks || {};
        if (segment.map.tracks[track.type]) {
          return;
        }
        segment.map.tracks[track.type] = track;
        if (typeof track.id === "number" && track.timescale) {
          segment.map.timescales = segment.map.timescales || {};
          segment.map.timescales[track.id] = track.timescale;
        }
      });
      return _callback(null);
    }
  });
};
var handleInitSegmentResponse = function handleInitSegmentResponse2(_ref2) {
  var segment = _ref2.segment, finishProcessingFn = _ref2.finishProcessingFn;
  return function(error, request) {
    var errorObj = handleErrors(error, request);
    if (errorObj) {
      return finishProcessingFn(errorObj, segment);
    }
    var bytes = new Uint8Array(request.response);
    if (segment.map.key) {
      segment.map.encryptedBytes = bytes;
      return finishProcessingFn(null, segment);
    }
    segment.map.bytes = bytes;
    parseInitSegment2(segment, function(parseError) {
      if (parseError) {
        parseError.xhr = request;
        parseError.status = request.status;
        return finishProcessingFn(parseError, segment);
      }
      finishProcessingFn(null, segment);
    });
  };
};
var handleSegmentResponse = function handleSegmentResponse2(_ref3) {
  var segment = _ref3.segment, finishProcessingFn = _ref3.finishProcessingFn, responseType = _ref3.responseType;
  return function(error, request) {
    var errorObj = handleErrors(error, request);
    if (errorObj) {
      return finishProcessingFn(errorObj, segment);
    }
    var newBytes = (
      // although responseText "should" exist, this guard serves to prevent an error being
      // thrown for two primary cases:
      // 1. the mime type override stops working, or is not implemented for a specific
      //    browser
      // 2. when using mock XHR libraries like sinon that do not allow the override behavior
      responseType === "arraybuffer" || !request.responseText ? request.response : stringToArrayBuffer(request.responseText.substring(segment.lastReachedChar || 0))
    );
    segment.stats = getRequestStats(request);
    if (segment.key) {
      segment.encryptedBytes = new Uint8Array(newBytes);
    } else {
      segment.bytes = new Uint8Array(newBytes);
    }
    return finishProcessingFn(null, segment);
  };
};
var transmuxAndNotify = function transmuxAndNotify2(_ref4) {
  var segment = _ref4.segment, bytes = _ref4.bytes, trackInfoFn = _ref4.trackInfoFn, timingInfoFn = _ref4.timingInfoFn, videoSegmentTimingInfoFn = _ref4.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref4.audioSegmentTimingInfoFn, id3Fn = _ref4.id3Fn, captionsFn = _ref4.captionsFn, isEndOfTimeline = _ref4.isEndOfTimeline, endedTimelineFn = _ref4.endedTimelineFn, dataFn = _ref4.dataFn, doneFn = _ref4.doneFn, onTransmuxerLog = _ref4.onTransmuxerLog;
  var fmp4Tracks = segment.map && segment.map.tracks || {};
  var isMuxed3 = Boolean(fmp4Tracks.audio && fmp4Tracks.video);
  var audioStartFn = timingInfoFn.bind(null, segment, "audio", "start");
  var audioEndFn = timingInfoFn.bind(null, segment, "audio", "end");
  var videoStartFn = timingInfoFn.bind(null, segment, "video", "start");
  var videoEndFn = timingInfoFn.bind(null, segment, "video", "end");
  var finish = function finish2() {
    return transmux({
      bytes,
      transmuxer: segment.transmuxer,
      audioAppendStart: segment.audioAppendStart,
      gopsToAlignWith: segment.gopsToAlignWith,
      remux: isMuxed3,
      onData: function onData(result) {
        result.type = result.type === "combined" ? "video" : result.type;
        dataFn(segment, result);
      },
      onTrackInfo: function onTrackInfo(trackInfo) {
        if (trackInfoFn) {
          if (isMuxed3) {
            trackInfo.isMuxed = true;
          }
          trackInfoFn(segment, trackInfo);
        }
      },
      onAudioTimingInfo: function onAudioTimingInfo(audioTimingInfo) {
        if (audioStartFn && typeof audioTimingInfo.start !== "undefined") {
          audioStartFn(audioTimingInfo.start);
          audioStartFn = null;
        }
        if (audioEndFn && typeof audioTimingInfo.end !== "undefined") {
          audioEndFn(audioTimingInfo.end);
        }
      },
      onVideoTimingInfo: function onVideoTimingInfo(videoTimingInfo) {
        if (videoStartFn && typeof videoTimingInfo.start !== "undefined") {
          videoStartFn(videoTimingInfo.start);
          videoStartFn = null;
        }
        if (videoEndFn && typeof videoTimingInfo.end !== "undefined") {
          videoEndFn(videoTimingInfo.end);
        }
      },
      onVideoSegmentTimingInfo: function onVideoSegmentTimingInfo(videoSegmentTimingInfo) {
        videoSegmentTimingInfoFn(videoSegmentTimingInfo);
      },
      onAudioSegmentTimingInfo: function onAudioSegmentTimingInfo(audioSegmentTimingInfo) {
        audioSegmentTimingInfoFn(audioSegmentTimingInfo);
      },
      onId3: function onId3(id3Frames, dispatchType) {
        id3Fn(segment, id3Frames, dispatchType);
      },
      onCaptions: function onCaptions(captions) {
        captionsFn(segment, [captions]);
      },
      isEndOfTimeline,
      onEndedTimeline: function onEndedTimeline() {
        endedTimelineFn();
      },
      onTransmuxerLog,
      onDone: function onDone(result) {
        if (!doneFn) {
          return;
        }
        result.type = result.type === "combined" ? "video" : result.type;
        doneFn(null, segment, result);
      }
    });
  };
  workerCallback({
    action: "probeTs",
    transmuxer: segment.transmuxer,
    data: bytes,
    baseStartTime: segment.baseStartTime,
    callback: function callback2(data) {
      segment.bytes = bytes = data.data;
      var probeResult = data.result;
      if (probeResult) {
        trackInfoFn(segment, {
          hasAudio: probeResult.hasAudio,
          hasVideo: probeResult.hasVideo,
          isMuxed: isMuxed3
        });
        trackInfoFn = null;
        if (probeResult.hasAudio && !isMuxed3) {
          audioStartFn(probeResult.audioStart);
        }
        if (probeResult.hasVideo) {
          videoStartFn(probeResult.videoStart);
        }
        audioStartFn = null;
        videoStartFn = null;
      }
      finish();
    }
  });
};
var handleSegmentBytes = function handleSegmentBytes2(_ref5) {
  var segment = _ref5.segment, bytes = _ref5.bytes, trackInfoFn = _ref5.trackInfoFn, timingInfoFn = _ref5.timingInfoFn, videoSegmentTimingInfoFn = _ref5.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref5.audioSegmentTimingInfoFn, id3Fn = _ref5.id3Fn, captionsFn = _ref5.captionsFn, isEndOfTimeline = _ref5.isEndOfTimeline, endedTimelineFn = _ref5.endedTimelineFn, dataFn = _ref5.dataFn, doneFn = _ref5.doneFn, onTransmuxerLog = _ref5.onTransmuxerLog;
  var bytesAsUint8Array = new Uint8Array(bytes);
  if (isLikelyFmp4MediaSegment(bytesAsUint8Array)) {
    segment.isFmp4 = true;
    var tracks = segment.map.tracks;
    var trackInfo = {
      isFmp4: true,
      hasVideo: !!tracks.video,
      hasAudio: !!tracks.audio
    };
    if (tracks.audio && tracks.audio.codec && tracks.audio.codec !== "enca") {
      trackInfo.audioCodec = tracks.audio.codec;
    }
    if (tracks.video && tracks.video.codec && tracks.video.codec !== "encv") {
      trackInfo.videoCodec = tracks.video.codec;
    }
    if (tracks.video && tracks.audio) {
      trackInfo.isMuxed = true;
    }
    trackInfoFn(segment, trackInfo);
    var finishLoading = function finishLoading2(captions) {
      dataFn(segment, {
        data: bytesAsUint8Array,
        type: trackInfo.hasAudio && !trackInfo.isMuxed ? "audio" : "video"
      });
      if (captions && captions.length) {
        captionsFn(segment, captions);
      }
      doneFn(null, segment, {});
    };
    workerCallback({
      action: "probeMp4StartTime",
      timescales: segment.map.timescales,
      data: bytesAsUint8Array,
      transmuxer: segment.transmuxer,
      callback: function callback2(_ref6) {
        var data = _ref6.data, startTime = _ref6.startTime;
        bytes = data.buffer;
        segment.bytes = bytesAsUint8Array = data;
        if (trackInfo.hasAudio && !trackInfo.isMuxed) {
          timingInfoFn(segment, "audio", "start", startTime);
        }
        if (trackInfo.hasVideo) {
          timingInfoFn(segment, "video", "start", startTime);
        }
        if (!tracks.video || !data.byteLength || !segment.transmuxer) {
          finishLoading();
          return;
        }
        workerCallback({
          action: "pushMp4Captions",
          endAction: "mp4Captions",
          transmuxer: segment.transmuxer,
          data: bytesAsUint8Array,
          timescales: segment.map.timescales,
          trackIds: [tracks.video.id],
          callback: function callback3(message) {
            bytes = message.data.buffer;
            segment.bytes = bytesAsUint8Array = message.data;
            message.logs.forEach(function(log2) {
              onTransmuxerLog(videojs.mergeOptions(log2, {
                stream: "mp4CaptionParser"
              }));
            });
            finishLoading(message.captions);
          }
        });
      }
    });
    return;
  }
  if (!segment.transmuxer) {
    doneFn(null, segment, {});
    return;
  }
  if (typeof segment.container === "undefined") {
    segment.container = detectContainerForBytes(bytesAsUint8Array);
  }
  if (segment.container !== "ts" && segment.container !== "aac") {
    trackInfoFn(segment, {
      hasAudio: false,
      hasVideo: false
    });
    doneFn(null, segment, {});
    return;
  }
  transmuxAndNotify({
    segment,
    bytes,
    trackInfoFn,
    timingInfoFn,
    videoSegmentTimingInfoFn,
    audioSegmentTimingInfoFn,
    id3Fn,
    captionsFn,
    isEndOfTimeline,
    endedTimelineFn,
    dataFn,
    doneFn,
    onTransmuxerLog
  });
};
var decrypt = function decrypt2(_ref7, callback2) {
  var id = _ref7.id, key = _ref7.key, encryptedBytes = _ref7.encryptedBytes, decryptionWorker = _ref7.decryptionWorker;
  var decryptionHandler = function decryptionHandler2(event) {
    if (event.data.source === id) {
      decryptionWorker.removeEventListener("message", decryptionHandler2);
      var decrypted = event.data.decrypted;
      callback2(new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength));
    }
  };
  decryptionWorker.addEventListener("message", decryptionHandler);
  var keyBytes;
  if (key.bytes.slice) {
    keyBytes = key.bytes.slice();
  } else {
    keyBytes = new Uint32Array(Array.prototype.slice.call(key.bytes));
  }
  decryptionWorker.postMessage(createTransferableMessage({
    source: id,
    encrypted: encryptedBytes,
    key: keyBytes,
    iv: key.iv
  }), [encryptedBytes.buffer, keyBytes.buffer]);
};
var decryptSegment = function decryptSegment2(_ref8) {
  var decryptionWorker = _ref8.decryptionWorker, segment = _ref8.segment, trackInfoFn = _ref8.trackInfoFn, timingInfoFn = _ref8.timingInfoFn, videoSegmentTimingInfoFn = _ref8.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref8.audioSegmentTimingInfoFn, id3Fn = _ref8.id3Fn, captionsFn = _ref8.captionsFn, isEndOfTimeline = _ref8.isEndOfTimeline, endedTimelineFn = _ref8.endedTimelineFn, dataFn = _ref8.dataFn, doneFn = _ref8.doneFn, onTransmuxerLog = _ref8.onTransmuxerLog;
  decrypt({
    id: segment.requestId,
    key: segment.key,
    encryptedBytes: segment.encryptedBytes,
    decryptionWorker
  }, function(decryptedBytes) {
    segment.bytes = decryptedBytes;
    handleSegmentBytes({
      segment,
      bytes: segment.bytes,
      trackInfoFn,
      timingInfoFn,
      videoSegmentTimingInfoFn,
      audioSegmentTimingInfoFn,
      id3Fn,
      captionsFn,
      isEndOfTimeline,
      endedTimelineFn,
      dataFn,
      doneFn,
      onTransmuxerLog
    });
  });
};
var waitForCompletion = function waitForCompletion2(_ref9) {
  var activeXhrs = _ref9.activeXhrs, decryptionWorker = _ref9.decryptionWorker, trackInfoFn = _ref9.trackInfoFn, timingInfoFn = _ref9.timingInfoFn, videoSegmentTimingInfoFn = _ref9.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref9.audioSegmentTimingInfoFn, id3Fn = _ref9.id3Fn, captionsFn = _ref9.captionsFn, isEndOfTimeline = _ref9.isEndOfTimeline, endedTimelineFn = _ref9.endedTimelineFn, dataFn = _ref9.dataFn, doneFn = _ref9.doneFn, onTransmuxerLog = _ref9.onTransmuxerLog;
  var count = 0;
  var didError = false;
  return function(error, segment) {
    if (didError) {
      return;
    }
    if (error) {
      didError = true;
      abortAll(activeXhrs);
      return doneFn(error, segment);
    }
    count += 1;
    if (count === activeXhrs.length) {
      var segmentFinish = function segmentFinish2() {
        if (segment.encryptedBytes) {
          return decryptSegment({
            decryptionWorker,
            segment,
            trackInfoFn,
            timingInfoFn,
            videoSegmentTimingInfoFn,
            audioSegmentTimingInfoFn,
            id3Fn,
            captionsFn,
            isEndOfTimeline,
            endedTimelineFn,
            dataFn,
            doneFn,
            onTransmuxerLog
          });
        }
        handleSegmentBytes({
          segment,
          bytes: segment.bytes,
          trackInfoFn,
          timingInfoFn,
          videoSegmentTimingInfoFn,
          audioSegmentTimingInfoFn,
          id3Fn,
          captionsFn,
          isEndOfTimeline,
          endedTimelineFn,
          dataFn,
          doneFn,
          onTransmuxerLog
        });
      };
      segment.endOfAllRequests = Date.now();
      if (segment.map && segment.map.encryptedBytes && !segment.map.bytes) {
        return decrypt({
          decryptionWorker,
          // add -init to the "id" to differentiate between segment
          // and init segment decryption, just in case they happen
          // at the same time at some point in the future.
          id: segment.requestId + "-init",
          encryptedBytes: segment.map.encryptedBytes,
          key: segment.map.key
        }, function(decryptedBytes) {
          segment.map.bytes = decryptedBytes;
          parseInitSegment2(segment, function(parseError) {
            if (parseError) {
              abortAll(activeXhrs);
              return doneFn(parseError, segment);
            }
            segmentFinish();
          });
        });
      }
      segmentFinish();
    }
  };
};
var handleLoadEnd = function handleLoadEnd2(_ref10) {
  var loadendState = _ref10.loadendState, abortFn = _ref10.abortFn;
  return function(event) {
    var request = event.target;
    if (request.aborted && abortFn && !loadendState.calledAbortFn) {
      abortFn();
      loadendState.calledAbortFn = true;
    }
  };
};
var handleProgress = function handleProgress2(_ref11) {
  var segment = _ref11.segment, progressFn = _ref11.progressFn;
  _ref11.trackInfoFn;
  _ref11.timingInfoFn;
  _ref11.videoSegmentTimingInfoFn;
  _ref11.audioSegmentTimingInfoFn;
  _ref11.id3Fn;
  _ref11.captionsFn;
  _ref11.isEndOfTimeline;
  _ref11.endedTimelineFn;
  _ref11.dataFn;
  return function(event) {
    var request = event.target;
    if (request.aborted) {
      return;
    }
    segment.stats = videojs.mergeOptions(segment.stats, getProgressStats(event));
    if (!segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived) {
      segment.stats.firstBytesReceivedAt = Date.now();
    }
    return progressFn(event, segment);
  };
};
var mediaSegmentRequest = function mediaSegmentRequest2(_ref12) {
  var xhr = _ref12.xhr, xhrOptions = _ref12.xhrOptions, decryptionWorker = _ref12.decryptionWorker, segment = _ref12.segment, abortFn = _ref12.abortFn, progressFn = _ref12.progressFn, trackInfoFn = _ref12.trackInfoFn, timingInfoFn = _ref12.timingInfoFn, videoSegmentTimingInfoFn = _ref12.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref12.audioSegmentTimingInfoFn, id3Fn = _ref12.id3Fn, captionsFn = _ref12.captionsFn, isEndOfTimeline = _ref12.isEndOfTimeline, endedTimelineFn = _ref12.endedTimelineFn, dataFn = _ref12.dataFn, doneFn = _ref12.doneFn, onTransmuxerLog = _ref12.onTransmuxerLog;
  var activeXhrs = [];
  var finishProcessingFn = waitForCompletion({
    activeXhrs,
    decryptionWorker,
    trackInfoFn,
    timingInfoFn,
    videoSegmentTimingInfoFn,
    audioSegmentTimingInfoFn,
    id3Fn,
    captionsFn,
    isEndOfTimeline,
    endedTimelineFn,
    dataFn,
    doneFn,
    onTransmuxerLog
  });
  if (segment.key && !segment.key.bytes) {
    var objects = [segment.key];
    if (segment.map && !segment.map.bytes && segment.map.key && segment.map.key.resolvedUri === segment.key.resolvedUri) {
      objects.push(segment.map.key);
    }
    var keyRequestOptions = videojs.mergeOptions(xhrOptions, {
      uri: segment.key.resolvedUri,
      responseType: "arraybuffer"
    });
    var keyRequestCallback = handleKeyResponse(segment, objects, finishProcessingFn);
    var keyXhr = xhr(keyRequestOptions, keyRequestCallback);
    activeXhrs.push(keyXhr);
  }
  if (segment.map && !segment.map.bytes) {
    var differentMapKey = segment.map.key && (!segment.key || segment.key.resolvedUri !== segment.map.key.resolvedUri);
    if (differentMapKey) {
      var mapKeyRequestOptions = videojs.mergeOptions(xhrOptions, {
        uri: segment.map.key.resolvedUri,
        responseType: "arraybuffer"
      });
      var mapKeyRequestCallback = handleKeyResponse(segment, [segment.map.key], finishProcessingFn);
      var mapKeyXhr = xhr(mapKeyRequestOptions, mapKeyRequestCallback);
      activeXhrs.push(mapKeyXhr);
    }
    var initSegmentOptions = videojs.mergeOptions(xhrOptions, {
      uri: segment.map.resolvedUri,
      responseType: "arraybuffer",
      headers: segmentXhrHeaders(segment.map)
    });
    var initSegmentRequestCallback = handleInitSegmentResponse({
      segment,
      finishProcessingFn
    });
    var initSegmentXhr = xhr(initSegmentOptions, initSegmentRequestCallback);
    activeXhrs.push(initSegmentXhr);
  }
  var segmentRequestOptions = videojs.mergeOptions(xhrOptions, {
    uri: segment.part && segment.part.resolvedUri || segment.resolvedUri,
    responseType: "arraybuffer",
    headers: segmentXhrHeaders(segment)
  });
  var segmentRequestCallback = handleSegmentResponse({
    segment,
    finishProcessingFn,
    responseType: segmentRequestOptions.responseType
  });
  var segmentXhr = xhr(segmentRequestOptions, segmentRequestCallback);
  segmentXhr.addEventListener("progress", handleProgress({
    segment,
    progressFn,
    trackInfoFn,
    timingInfoFn,
    videoSegmentTimingInfoFn,
    audioSegmentTimingInfoFn,
    id3Fn,
    captionsFn,
    isEndOfTimeline,
    endedTimelineFn,
    dataFn
  }));
  activeXhrs.push(segmentXhr);
  var loadendState = {};
  activeXhrs.forEach(function(activeXhr) {
    activeXhr.addEventListener("loadend", handleLoadEnd({
      loadendState,
      abortFn
    }));
  });
  return function() {
    return abortAll(activeXhrs);
  };
};
var logFn$1 = logger2("CodecUtils");
var getCodecs = function getCodecs2(media) {
  var mediaAttributes = media.attributes || {};
  if (mediaAttributes.CODECS) {
    return parseCodecs(mediaAttributes.CODECS);
  }
};
var isMaat = function isMaat2(master, media) {
  var mediaAttributes = media.attributes || {};
  return master && master.mediaGroups && master.mediaGroups.AUDIO && mediaAttributes.AUDIO && master.mediaGroups.AUDIO[mediaAttributes.AUDIO];
};
var isMuxed = function isMuxed2(master, media) {
  if (!isMaat(master, media)) {
    return true;
  }
  var mediaAttributes = media.attributes || {};
  var audioGroup = master.mediaGroups.AUDIO[mediaAttributes.AUDIO];
  for (var groupId in audioGroup) {
    if (!audioGroup[groupId].uri && !audioGroup[groupId].playlists) {
      return true;
    }
  }
  return false;
};
var unwrapCodecList = function unwrapCodecList2(codecList) {
  var codecs = {};
  codecList.forEach(function(_ref) {
    var mediaType = _ref.mediaType, type2 = _ref.type, details = _ref.details;
    codecs[mediaType] = codecs[mediaType] || [];
    codecs[mediaType].push(translateLegacyCodec("" + type2 + details));
  });
  Object.keys(codecs).forEach(function(mediaType) {
    if (codecs[mediaType].length > 1) {
      logFn$1("multiple " + mediaType + " codecs found as attributes: " + codecs[mediaType].join(", ") + ". Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.");
      codecs[mediaType] = null;
      return;
    }
    codecs[mediaType] = codecs[mediaType][0];
  });
  return codecs;
};
var codecCount = function codecCount2(codecObj) {
  var count = 0;
  if (codecObj.audio) {
    count++;
  }
  if (codecObj.video) {
    count++;
  }
  return count;
};
var codecsForPlaylist = function codecsForPlaylist2(master, media) {
  var mediaAttributes = media.attributes || {};
  var codecInfo = unwrapCodecList(getCodecs(media) || []);
  if (isMaat(master, media) && !codecInfo.audio) {
    if (!isMuxed(master, media)) {
      var defaultCodecs = unwrapCodecList(codecsFromDefault(master, mediaAttributes.AUDIO) || []);
      if (defaultCodecs.audio) {
        codecInfo.audio = defaultCodecs.audio;
      }
    }
  }
  return codecInfo;
};
var logFn = logger2("PlaylistSelector");
var representationToString = function representationToString2(representation) {
  if (!representation || !representation.playlist) {
    return;
  }
  var playlist = representation.playlist;
  return JSON.stringify({
    id: playlist.id,
    bandwidth: representation.bandwidth,
    width: representation.width,
    height: representation.height,
    codecs: playlist.attributes && playlist.attributes.CODECS || ""
  });
};
var safeGetComputedStyle = function safeGetComputedStyle2(el, property) {
  if (!el) {
    return "";
  }
  var result = import_window6.default.getComputedStyle(el);
  if (!result) {
    return "";
  }
  return result[property];
};
var stableSort = function stableSort2(array, sortFn) {
  var newArray = array.slice();
  array.sort(function(left, right) {
    var cmp = sortFn(left, right);
    if (cmp === 0) {
      return newArray.indexOf(left) - newArray.indexOf(right);
    }
    return cmp;
  });
};
var comparePlaylistBandwidth = function comparePlaylistBandwidth2(left, right) {
  var leftBandwidth;
  var rightBandwidth;
  if (left.attributes.BANDWIDTH) {
    leftBandwidth = left.attributes.BANDWIDTH;
  }
  leftBandwidth = leftBandwidth || import_window6.default.Number.MAX_VALUE;
  if (right.attributes.BANDWIDTH) {
    rightBandwidth = right.attributes.BANDWIDTH;
  }
  rightBandwidth = rightBandwidth || import_window6.default.Number.MAX_VALUE;
  return leftBandwidth - rightBandwidth;
};
var comparePlaylistResolution = function comparePlaylistResolution2(left, right) {
  var leftWidth;
  var rightWidth;
  if (left.attributes.RESOLUTION && left.attributes.RESOLUTION.width) {
    leftWidth = left.attributes.RESOLUTION.width;
  }
  leftWidth = leftWidth || import_window6.default.Number.MAX_VALUE;
  if (right.attributes.RESOLUTION && right.attributes.RESOLUTION.width) {
    rightWidth = right.attributes.RESOLUTION.width;
  }
  rightWidth = rightWidth || import_window6.default.Number.MAX_VALUE;
  if (leftWidth === rightWidth && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) {
    return left.attributes.BANDWIDTH - right.attributes.BANDWIDTH;
  }
  return leftWidth - rightWidth;
};
var simpleSelector = function simpleSelector2(master, playerBandwidth, playerWidth, playerHeight, limitRenditionByPlayerDimensions, masterPlaylistController) {
  if (!master) {
    return;
  }
  var options = {
    bandwidth: playerBandwidth,
    width: playerWidth,
    height: playerHeight,
    limitRenditionByPlayerDimensions
  };
  var playlists = master.playlists;
  if (Playlist.isAudioOnly(master)) {
    playlists = masterPlaylistController.getAudioTrackPlaylists_();
    options.audioOnly = true;
  }
  var sortedPlaylistReps = playlists.map(function(playlist) {
    var bandwidth2;
    var width2 = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width;
    var height2 = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;
    bandwidth2 = playlist.attributes && playlist.attributes.BANDWIDTH;
    bandwidth2 = bandwidth2 || import_window6.default.Number.MAX_VALUE;
    return {
      bandwidth: bandwidth2,
      width: width2,
      height: height2,
      playlist
    };
  });
  stableSort(sortedPlaylistReps, function(left, right) {
    return left.bandwidth - right.bandwidth;
  });
  sortedPlaylistReps = sortedPlaylistReps.filter(function(rep) {
    return !Playlist.isIncompatible(rep.playlist);
  });
  var enabledPlaylistReps = sortedPlaylistReps.filter(function(rep) {
    return Playlist.isEnabled(rep.playlist);
  });
  if (!enabledPlaylistReps.length) {
    enabledPlaylistReps = sortedPlaylistReps.filter(function(rep) {
      return !Playlist.isDisabled(rep.playlist);
    });
  }
  var bandwidthPlaylistReps = enabledPlaylistReps.filter(function(rep) {
    return rep.bandwidth * Config.BANDWIDTH_VARIANCE < playerBandwidth;
  });
  var highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1];
  var bandwidthBestRep = bandwidthPlaylistReps.filter(function(rep) {
    return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;
  })[0];
  if (limitRenditionByPlayerDimensions === false) {
    var _chosenRep = bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
    if (_chosenRep && _chosenRep.playlist) {
      var type2 = "sortedPlaylistReps";
      if (bandwidthBestRep) {
        type2 = "bandwidthBestRep";
      }
      if (enabledPlaylistReps[0]) {
        type2 = "enabledPlaylistReps";
      }
      logFn("choosing " + representationToString(_chosenRep) + " using " + type2 + " with options", options);
      return _chosenRep.playlist;
    }
    logFn("could not choose a playlist with options", options);
    return null;
  }
  var haveResolution = bandwidthPlaylistReps.filter(function(rep) {
    return rep.width && rep.height;
  });
  stableSort(haveResolution, function(left, right) {
    return left.width - right.width;
  });
  var resolutionBestRepList = haveResolution.filter(function(rep) {
    return rep.width === playerWidth && rep.height === playerHeight;
  });
  highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1];
  var resolutionBestRep = resolutionBestRepList.filter(function(rep) {
    return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;
  })[0];
  var resolutionPlusOneList;
  var resolutionPlusOneSmallest;
  var resolutionPlusOneRep;
  if (!resolutionBestRep) {
    resolutionPlusOneList = haveResolution.filter(function(rep) {
      return rep.width > playerWidth || rep.height > playerHeight;
    });
    resolutionPlusOneSmallest = resolutionPlusOneList.filter(function(rep) {
      return rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height;
    });
    highestRemainingBandwidthRep = resolutionPlusOneSmallest[resolutionPlusOneSmallest.length - 1];
    resolutionPlusOneRep = resolutionPlusOneSmallest.filter(function(rep) {
      return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;
    })[0];
  }
  var leastPixelDiffRep;
  if (masterPlaylistController.experimentalLeastPixelDiffSelector) {
    var leastPixelDiffList = haveResolution.map(function(rep) {
      rep.pixelDiff = Math.abs(rep.width - playerWidth) + Math.abs(rep.height - playerHeight);
      return rep;
    });
    stableSort(leastPixelDiffList, function(left, right) {
      if (left.pixelDiff === right.pixelDiff) {
        return right.bandwidth - left.bandwidth;
      }
      return left.pixelDiff - right.pixelDiff;
    });
    leastPixelDiffRep = leastPixelDiffList[0];
  }
  var chosenRep = leastPixelDiffRep || resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
  if (chosenRep && chosenRep.playlist) {
    var _type = "sortedPlaylistReps";
    if (leastPixelDiffRep) {
      _type = "leastPixelDiffRep";
    } else if (resolutionPlusOneRep) {
      _type = "resolutionPlusOneRep";
    } else if (resolutionBestRep) {
      _type = "resolutionBestRep";
    } else if (bandwidthBestRep) {
      _type = "bandwidthBestRep";
    } else if (enabledPlaylistReps[0]) {
      _type = "enabledPlaylistReps";
    }
    logFn("choosing " + representationToString(chosenRep) + " using " + _type + " with options", options);
    return chosenRep.playlist;
  }
  logFn("could not choose a playlist with options", options);
  return null;
};
var lastBandwidthSelector = function lastBandwidthSelector2() {
  var pixelRatio = this.useDevicePixelRatio ? import_window6.default.devicePixelRatio || 1 : 1;
  return simpleSelector(this.playlists.master, this.systemBandwidth, parseInt(safeGetComputedStyle(this.tech_.el(), "width"), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), "height"), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.masterPlaylistController_);
};
var movingAverageBandwidthSelector = function movingAverageBandwidthSelector2(decay) {
  var average = -1;
  var lastSystemBandwidth = -1;
  if (decay < 0 || decay > 1) {
    throw new Error("Moving average bandwidth decay must be between 0 and 1.");
  }
  return function() {
    var pixelRatio = this.useDevicePixelRatio ? import_window6.default.devicePixelRatio || 1 : 1;
    if (average < 0) {
      average = this.systemBandwidth;
      lastSystemBandwidth = this.systemBandwidth;
    }
    if (this.systemBandwidth > 0 && this.systemBandwidth !== lastSystemBandwidth) {
      average = decay * this.systemBandwidth + (1 - decay) * average;
      lastSystemBandwidth = this.systemBandwidth;
    }
    return simpleSelector(this.playlists.master, average, parseInt(safeGetComputedStyle(this.tech_.el(), "width"), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), "height"), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.masterPlaylistController_);
  };
};
var minRebufferMaxBandwidthSelector = function minRebufferMaxBandwidthSelector2(settings) {
  var master = settings.master, currentTime = settings.currentTime, bandwidth2 = settings.bandwidth, duration5 = settings.duration, segmentDuration = settings.segmentDuration, timeUntilRebuffer3 = settings.timeUntilRebuffer, currentTimeline = settings.currentTimeline, syncController = settings.syncController;
  var compatiblePlaylists = master.playlists.filter(function(playlist) {
    return !Playlist.isIncompatible(playlist);
  });
  var enabledPlaylists = compatiblePlaylists.filter(Playlist.isEnabled);
  if (!enabledPlaylists.length) {
    enabledPlaylists = compatiblePlaylists.filter(function(playlist) {
      return !Playlist.isDisabled(playlist);
    });
  }
  var bandwidthPlaylists = enabledPlaylists.filter(Playlist.hasAttribute.bind(null, "BANDWIDTH"));
  var rebufferingEstimates = bandwidthPlaylists.map(function(playlist) {
    var syncPoint = syncController.getSyncPoint(playlist, duration5, currentTimeline, currentTime);
    var numRequests = syncPoint ? 1 : 2;
    var requestTimeEstimate = Playlist.estimateSegmentRequestTime(segmentDuration, bandwidth2, playlist);
    var rebufferingImpact = requestTimeEstimate * numRequests - timeUntilRebuffer3;
    return {
      playlist,
      rebufferingImpact
    };
  });
  var noRebufferingPlaylists = rebufferingEstimates.filter(function(estimate) {
    return estimate.rebufferingImpact <= 0;
  });
  stableSort(noRebufferingPlaylists, function(a, b) {
    return comparePlaylistBandwidth(b.playlist, a.playlist);
  });
  if (noRebufferingPlaylists.length) {
    return noRebufferingPlaylists[0];
  }
  stableSort(rebufferingEstimates, function(a, b) {
    return a.rebufferingImpact - b.rebufferingImpact;
  });
  return rebufferingEstimates[0] || null;
};
var lowestBitrateCompatibleVariantSelector = function lowestBitrateCompatibleVariantSelector2() {
  var _this = this;
  var playlists = this.playlists.master.playlists.filter(Playlist.isEnabled);
  stableSort(playlists, function(a, b) {
    return comparePlaylistBandwidth(a, b);
  });
  var playlistsWithVideo = playlists.filter(function(playlist) {
    return !!codecsForPlaylist(_this.playlists.master, playlist).video;
  });
  return playlistsWithVideo[0] || null;
};
var concatSegments = function concatSegments2(segmentObj) {
  var offset = 0;
  var tempBuffer;
  if (segmentObj.bytes) {
    tempBuffer = new Uint8Array(segmentObj.bytes);
    segmentObj.segments.forEach(function(segment) {
      tempBuffer.set(segment, offset);
      offset += segment.byteLength;
    });
  }
  return tempBuffer;
};
var createCaptionsTrackIfNotExists = function createCaptionsTrackIfNotExists2(inbandTextTracks, tech, captionStream) {
  if (!inbandTextTracks[captionStream]) {
    tech.trigger({
      type: "usage",
      name: "vhs-608"
    });
    tech.trigger({
      type: "usage",
      name: "hls-608"
    });
    var instreamId = captionStream;
    if (/^cc708_/.test(captionStream)) {
      instreamId = "SERVICE" + captionStream.split("_")[1];
    }
    var track = tech.textTracks().getTrackById(instreamId);
    if (track) {
      inbandTextTracks[captionStream] = track;
    } else {
      var captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};
      var label = captionStream;
      var language = captionStream;
      var def = false;
      var captionService = captionServices[instreamId];
      if (captionService) {
        label = captionService.label;
        language = captionService.language;
        def = captionService["default"];
      }
      inbandTextTracks[captionStream] = tech.addRemoteTextTrack({
        kind: "captions",
        id: instreamId,
        // TODO: investigate why this doesn't seem to turn the caption on by default
        "default": def,
        label,
        language
      }, false).track;
    }
  }
};
var addCaptionData = function addCaptionData2(_ref) {
  var inbandTextTracks = _ref.inbandTextTracks, captionArray = _ref.captionArray, timestampOffset2 = _ref.timestampOffset;
  if (!captionArray) {
    return;
  }
  var Cue = import_window6.default.WebKitDataCue || import_window6.default.VTTCue;
  captionArray.forEach(function(caption) {
    var track = caption.stream;
    inbandTextTracks[track].addCue(new Cue(caption.startTime + timestampOffset2, caption.endTime + timestampOffset2, caption.text));
  });
};
var deprecateOldCue = function deprecateOldCue2(cue) {
  Object.defineProperties(cue.frame, {
    id: {
      get: function get7() {
        videojs.log.warn("cue.frame.id is deprecated. Use cue.value.key instead.");
        return cue.value.key;
      }
    },
    value: {
      get: function get7() {
        videojs.log.warn("cue.frame.value is deprecated. Use cue.value.data instead.");
        return cue.value.data;
      }
    },
    privateData: {
      get: function get7() {
        videojs.log.warn("cue.frame.privateData is deprecated. Use cue.value.data instead.");
        return cue.value.data;
      }
    }
  });
};
var addMetadata = function addMetadata2(_ref2) {
  var inbandTextTracks = _ref2.inbandTextTracks, metadataArray = _ref2.metadataArray, timestampOffset2 = _ref2.timestampOffset, videoDuration = _ref2.videoDuration;
  if (!metadataArray) {
    return;
  }
  var Cue = import_window6.default.WebKitDataCue || import_window6.default.VTTCue;
  var metadataTrack = inbandTextTracks.metadataTrack_;
  if (!metadataTrack) {
    return;
  }
  metadataArray.forEach(function(metadata) {
    var time = metadata.cueTime + timestampOffset2;
    if (typeof time !== "number" || import_window6.default.isNaN(time) || time < 0 || !(time < Infinity)) {
      return;
    }
    metadata.frames.forEach(function(frame) {
      var cue = new Cue(time, time, frame.value || frame.url || frame.data || "");
      cue.frame = frame;
      cue.value = frame;
      deprecateOldCue(cue);
      metadataTrack.addCue(cue);
    });
  });
  if (!metadataTrack.cues || !metadataTrack.cues.length) {
    return;
  }
  var cues = metadataTrack.cues;
  var cuesArray = [];
  for (var i = 0; i < cues.length; i++) {
    if (cues[i]) {
      cuesArray.push(cues[i]);
    }
  }
  var cuesGroupedByStartTime = cuesArray.reduce(function(obj, cue) {
    var timeSlot = obj[cue.startTime] || [];
    timeSlot.push(cue);
    obj[cue.startTime] = timeSlot;
    return obj;
  }, {});
  var sortedStartTimes = Object.keys(cuesGroupedByStartTime).sort(function(a, b) {
    return Number(a) - Number(b);
  });
  sortedStartTimes.forEach(function(startTime, idx) {
    var cueGroup = cuesGroupedByStartTime[startTime];
    var nextTime = Number(sortedStartTimes[idx + 1]) || videoDuration;
    cueGroup.forEach(function(cue) {
      cue.endTime = nextTime;
    });
  });
};
var createMetadataTrackIfNotExists = function createMetadataTrackIfNotExists2(inbandTextTracks, dispatchType, tech) {
  if (inbandTextTracks.metadataTrack_) {
    return;
  }
  inbandTextTracks.metadataTrack_ = tech.addRemoteTextTrack({
    kind: "metadata",
    label: "Timed Metadata"
  }, false).track;
  inbandTextTracks.metadataTrack_.inBandMetadataTrackDispatchType = dispatchType;
};
var removeCuesFromTrack = function removeCuesFromTrack2(start2, end, track) {
  var i;
  var cue;
  if (!track) {
    return;
  }
  if (!track.cues) {
    return;
  }
  i = track.cues.length;
  while (i--) {
    cue = track.cues[i];
    if (cue.startTime >= start2 && cue.endTime <= end) {
      track.removeCue(cue);
    }
  }
};
var removeDuplicateCuesFromTrack = function removeDuplicateCuesFromTrack2(track) {
  var cues = track.cues;
  if (!cues) {
    return;
  }
  for (var i = 0; i < cues.length; i++) {
    var duplicates = [];
    var occurrences = 0;
    for (var j = 0; j < cues.length; j++) {
      if (cues[i].startTime === cues[j].startTime && cues[i].endTime === cues[j].endTime && cues[i].text === cues[j].text) {
        occurrences++;
        if (occurrences > 1) {
          duplicates.push(cues[j]);
        }
      }
    }
    if (duplicates.length) {
      duplicates.forEach(function(dupe) {
        return track.removeCue(dupe);
      });
    }
  }
};
var gopsSafeToAlignWith = function gopsSafeToAlignWith2(buffer, currentTime, mapping) {
  if (typeof currentTime === "undefined" || currentTime === null || !buffer.length) {
    return [];
  }
  var currentTimePts = Math.ceil((currentTime - mapping + 3) * import_clock.ONE_SECOND_IN_TS);
  var i;
  for (i = 0; i < buffer.length; i++) {
    if (buffer[i].pts > currentTimePts) {
      break;
    }
  }
  return buffer.slice(i);
};
var updateGopBuffer = function updateGopBuffer2(buffer, gops, replace) {
  if (!gops.length) {
    return buffer;
  }
  if (replace) {
    return gops.slice();
  }
  var start2 = gops[0].pts;
  var i = 0;
  for (i; i < buffer.length; i++) {
    if (buffer[i].pts >= start2) {
      break;
    }
  }
  return buffer.slice(0, i).concat(gops);
};
var removeGopBuffer = function removeGopBuffer2(buffer, start2, end, mapping) {
  var startPts = Math.ceil((start2 - mapping) * import_clock.ONE_SECOND_IN_TS);
  var endPts = Math.ceil((end - mapping) * import_clock.ONE_SECOND_IN_TS);
  var updatedBuffer = buffer.slice();
  var i = buffer.length;
  while (i--) {
    if (buffer[i].pts <= endPts) {
      break;
    }
  }
  if (i === -1) {
    return updatedBuffer;
  }
  var j = i + 1;
  while (j--) {
    if (buffer[j].pts <= startPts) {
      break;
    }
  }
  j = Math.max(j, 0);
  updatedBuffer.splice(j, i - j + 1);
  return updatedBuffer;
};
var shallowEqual = function shallowEqual2(a, b) {
  if (!a && !b || !a && b || a && !b) {
    return false;
  }
  if (a === b) {
    return true;
  }
  var akeys = Object.keys(a).sort();
  var bkeys = Object.keys(b).sort();
  if (akeys.length !== bkeys.length) {
    return false;
  }
  for (var i = 0; i < akeys.length; i++) {
    var key = akeys[i];
    if (key !== bkeys[i]) {
      return false;
    }
    if (a[key] !== b[key]) {
      return false;
    }
  }
  return true;
};
var QUOTA_EXCEEDED_ERR = 22;
var getSyncSegmentCandidate = function getSyncSegmentCandidate2(currentTimeline, segments, targetTime) {
  segments = segments || [];
  var timelineSegments = [];
  var time = 0;
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (currentTimeline === segment.timeline) {
      timelineSegments.push(i);
      time += segment.duration;
      if (time > targetTime) {
        return i;
      }
    }
  }
  if (timelineSegments.length === 0) {
    return 0;
  }
  return timelineSegments[timelineSegments.length - 1];
};
var MIN_BACK_BUFFER = 1;
var CHECK_BUFFER_DELAY = 500;
var finite = function finite2(num) {
  return typeof num === "number" && isFinite(num);
};
var MIN_SEGMENT_DURATION_TO_SAVE_STATS = 1 / 60;
var illegalMediaSwitch = function illegalMediaSwitch2(loaderType, startingMedia, trackInfo) {
  if (loaderType !== "main" || !startingMedia || !trackInfo) {
    return null;
  }
  if (!trackInfo.hasAudio && !trackInfo.hasVideo) {
    return "Neither audio nor video found in segment.";
  }
  if (startingMedia.hasVideo && !trackInfo.hasVideo) {
    return "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest.";
  }
  if (!startingMedia.hasVideo && trackInfo.hasVideo) {
    return "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest.";
  }
  return null;
};
var safeBackBufferTrimTime = function safeBackBufferTrimTime2(seekable3, currentTime, targetDuration) {
  var trimTime = currentTime - Config.BACK_BUFFER_LENGTH;
  if (seekable3.length) {
    trimTime = Math.max(trimTime, seekable3.start(0));
  }
  var maxTrimTime = currentTime - targetDuration;
  return Math.min(maxTrimTime, trimTime);
};
var segmentInfoString = function segmentInfoString2(segmentInfo) {
  var startOfSegment = segmentInfo.startOfSegment, duration5 = segmentInfo.duration, segment = segmentInfo.segment, part = segmentInfo.part, _segmentInfo$playlist = segmentInfo.playlist, seq = _segmentInfo$playlist.mediaSequence, id = _segmentInfo$playlist.id, _segmentInfo$playlist2 = _segmentInfo$playlist.segments, segments = _segmentInfo$playlist2 === void 0 ? [] : _segmentInfo$playlist2, index = segmentInfo.mediaIndex, partIndex = segmentInfo.partIndex, timeline = segmentInfo.timeline;
  var segmentLen = segments.length - 1;
  var selection = "mediaIndex/partIndex increment";
  if (segmentInfo.getMediaInfoForTime) {
    selection = "getMediaInfoForTime (" + segmentInfo.getMediaInfoForTime + ")";
  } else if (segmentInfo.isSyncRequest) {
    selection = "getSyncSegmentCandidate (isSyncRequest)";
  }
  if (segmentInfo.independent) {
    selection += " with independent " + segmentInfo.independent;
  }
  var hasPartIndex = typeof partIndex === "number";
  var name = segmentInfo.segment.uri ? "segment" : "pre-segment";
  var zeroBasedPartCount = hasPartIndex ? getKnownPartCount({
    preloadSegment: segment
  }) - 1 : 0;
  return name + " [" + (seq + index) + "/" + (seq + segmentLen) + "]" + (hasPartIndex ? " part [" + partIndex + "/" + zeroBasedPartCount + "]" : "") + (" segment start/end [" + segment.start + " => " + segment.end + "]") + (hasPartIndex ? " part start/end [" + part.start + " => " + part.end + "]" : "") + (" startOfSegment [" + startOfSegment + "]") + (" duration [" + duration5 + "]") + (" timeline [" + timeline + "]") + (" selected by [" + selection + "]") + (" playlist [" + id + "]");
};
var timingInfoPropertyForMedia = function timingInfoPropertyForMedia2(mediaType) {
  return mediaType + "TimingInfo";
};
var timestampOffsetForSegment = function timestampOffsetForSegment2(_ref) {
  var segmentTimeline = _ref.segmentTimeline, currentTimeline = _ref.currentTimeline, startOfSegment = _ref.startOfSegment, buffered = _ref.buffered, overrideCheck = _ref.overrideCheck;
  if (!overrideCheck && segmentTimeline === currentTimeline) {
    return null;
  }
  if (segmentTimeline < currentTimeline) {
    return startOfSegment;
  }
  return buffered.length ? buffered.end(buffered.length - 1) : startOfSegment;
};
var shouldWaitForTimelineChange = function shouldWaitForTimelineChange2(_ref2) {
  var timelineChangeController = _ref2.timelineChangeController, currentTimeline = _ref2.currentTimeline, segmentTimeline = _ref2.segmentTimeline, loaderType = _ref2.loaderType, audioDisabled = _ref2.audioDisabled;
  if (currentTimeline === segmentTimeline) {
    return false;
  }
  if (loaderType === "audio") {
    var lastMainTimelineChange = timelineChangeController.lastTimelineChange({
      type: "main"
    });
    return !lastMainTimelineChange || lastMainTimelineChange.to !== segmentTimeline;
  }
  if (loaderType === "main" && audioDisabled) {
    var pendingAudioTimelineChange = timelineChangeController.pendingTimelineChange({
      type: "audio"
    });
    if (pendingAudioTimelineChange && pendingAudioTimelineChange.to === segmentTimeline) {
      return false;
    }
    return true;
  }
  return false;
};
var mediaDuration = function mediaDuration2(timingInfos) {
  var maxDuration = 0;
  ["video", "audio"].forEach(function(type2) {
    var typeTimingInfo = timingInfos[type2 + "TimingInfo"];
    if (!typeTimingInfo) {
      return;
    }
    var start2 = typeTimingInfo.start, end = typeTimingInfo.end;
    var duration5;
    if (typeof start2 === "bigint" || typeof end === "bigint") {
      duration5 = import_window6.default.BigInt(end) - import_window6.default.BigInt(start2);
    } else if (typeof start2 === "number" && typeof end === "number") {
      duration5 = end - start2;
    }
    if (typeof duration5 !== "undefined" && duration5 > maxDuration) {
      maxDuration = duration5;
    }
  });
  if (typeof maxDuration === "bigint" && maxDuration < Number.MAX_SAFE_INTEGER) {
    maxDuration = Number(maxDuration);
  }
  return maxDuration;
};
var segmentTooLong = function segmentTooLong2(_ref3) {
  var segmentDuration = _ref3.segmentDuration, maxDuration = _ref3.maxDuration;
  if (!segmentDuration) {
    return false;
  }
  return Math.round(segmentDuration) > maxDuration + TIME_FUDGE_FACTOR;
};
var getTroublesomeSegmentDurationMessage = function getTroublesomeSegmentDurationMessage2(segmentInfo, sourceType) {
  if (sourceType !== "hls") {
    return null;
  }
  var segmentDuration = mediaDuration({
    audioTimingInfo: segmentInfo.audioTimingInfo,
    videoTimingInfo: segmentInfo.videoTimingInfo
  });
  if (!segmentDuration) {
    return null;
  }
  var targetDuration = segmentInfo.playlist.targetDuration;
  var isSegmentWayTooLong = segmentTooLong({
    segmentDuration,
    maxDuration: targetDuration * 2
  });
  var isSegmentSlightlyTooLong = segmentTooLong({
    segmentDuration,
    maxDuration: targetDuration
  });
  var segmentTooLongMessage = "Segment with index " + segmentInfo.mediaIndex + " " + ("from playlist " + segmentInfo.playlist.id + " ") + ("has a duration of " + segmentDuration + " ") + ("when the reported duration is " + segmentInfo.duration + " ") + ("and the target duration is " + targetDuration + ". ") + "For HLS content, a duration in excess of the target duration may result in playback issues. See the HLS specification section on EXT-X-TARGETDURATION for more details: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1";
  if (isSegmentWayTooLong || isSegmentSlightlyTooLong) {
    return {
      severity: isSegmentWayTooLong ? "warn" : "info",
      message: segmentTooLongMessage
    };
  }
  return null;
};
var SegmentLoader = /* @__PURE__ */ function(_videojs$EventTarget) {
  _inheritsLoose(SegmentLoader2, _videojs$EventTarget);
  function SegmentLoader2(settings, options) {
    var _this;
    _this = _videojs$EventTarget.call(this) || this;
    if (!settings) {
      throw new TypeError("Initialization settings are required");
    }
    if (typeof settings.currentTime !== "function") {
      throw new TypeError("No currentTime getter specified");
    }
    if (!settings.mediaSource) {
      throw new TypeError("No MediaSource specified");
    }
    _this.bandwidth = settings.bandwidth;
    _this.throughput = {
      rate: 0,
      count: 0
    };
    _this.roundTrip = NaN;
    _this.resetStats_();
    _this.mediaIndex = null;
    _this.partIndex = null;
    _this.hasPlayed_ = settings.hasPlayed;
    _this.currentTime_ = settings.currentTime;
    _this.seekable_ = settings.seekable;
    _this.seeking_ = settings.seeking;
    _this.duration_ = settings.duration;
    _this.mediaSource_ = settings.mediaSource;
    _this.vhs_ = settings.vhs;
    _this.loaderType_ = settings.loaderType;
    _this.currentMediaInfo_ = void 0;
    _this.startingMediaInfo_ = void 0;
    _this.segmentMetadataTrack_ = settings.segmentMetadataTrack;
    _this.goalBufferLength_ = settings.goalBufferLength;
    _this.sourceType_ = settings.sourceType;
    _this.sourceUpdater_ = settings.sourceUpdater;
    _this.inbandTextTracks_ = settings.inbandTextTracks;
    _this.state_ = "INIT";
    _this.timelineChangeController_ = settings.timelineChangeController;
    _this.shouldSaveSegmentTimingInfo_ = true;
    _this.parse708captions_ = settings.parse708captions;
    _this.useDtsForTimestampOffset_ = settings.useDtsForTimestampOffset;
    _this.captionServices_ = settings.captionServices;
    _this.experimentalExactManifestTimings = settings.experimentalExactManifestTimings;
    _this.checkBufferTimeout_ = null;
    _this.error_ = void 0;
    _this.currentTimeline_ = -1;
    _this.pendingSegment_ = null;
    _this.xhrOptions_ = null;
    _this.pendingSegments_ = [];
    _this.audioDisabled_ = false;
    _this.isPendingTimestampOffset_ = false;
    _this.gopBuffer_ = [];
    _this.timeMapping_ = 0;
    _this.safeAppend_ = videojs.browser.IE_VERSION >= 11;
    _this.appendInitSegment_ = {
      audio: true,
      video: true
    };
    _this.playlistOfLastInitSegment_ = {
      audio: null,
      video: null
    };
    _this.callQueue_ = [];
    _this.loadQueue_ = [];
    _this.metadataQueue_ = {
      id3: [],
      caption: []
    };
    _this.waitingOnRemove_ = false;
    _this.quotaExceededErrorRetryTimeout_ = null;
    _this.activeInitSegmentId_ = null;
    _this.initSegments_ = {};
    _this.cacheEncryptionKeys_ = settings.cacheEncryptionKeys;
    _this.keyCache_ = {};
    _this.decrypter_ = settings.decrypter;
    _this.syncController_ = settings.syncController;
    _this.syncPoint_ = {
      segmentIndex: 0,
      time: 0
    };
    _this.transmuxer_ = _this.createTransmuxer_();
    _this.triggerSyncInfoUpdate_ = function() {
      return _this.trigger("syncinfoupdate");
    };
    _this.syncController_.on("syncinfoupdate", _this.triggerSyncInfoUpdate_);
    _this.mediaSource_.addEventListener("sourceopen", function() {
      if (!_this.isEndOfStream_()) {
        _this.ended_ = false;
      }
    });
    _this.fetchAtBuffer_ = false;
    _this.logger_ = logger2("SegmentLoader[" + _this.loaderType_ + "]");
    Object.defineProperty(_assertThisInitialized(_this), "state", {
      get: function get7() {
        return this.state_;
      },
      set: function set4(newState) {
        if (newState !== this.state_) {
          this.logger_(this.state_ + " -> " + newState);
          this.state_ = newState;
          this.trigger("statechange");
        }
      }
    });
    _this.sourceUpdater_.on("ready", function() {
      if (_this.hasEnoughInfoToAppend_()) {
        _this.processCallQueue_();
      }
    });
    if (_this.loaderType_ === "main") {
      _this.timelineChangeController_.on("pendingtimelinechange", function() {
        if (_this.hasEnoughInfoToAppend_()) {
          _this.processCallQueue_();
        }
      });
    }
    if (_this.loaderType_ === "audio") {
      _this.timelineChangeController_.on("timelinechange", function() {
        if (_this.hasEnoughInfoToLoad_()) {
          _this.processLoadQueue_();
        }
        if (_this.hasEnoughInfoToAppend_()) {
          _this.processCallQueue_();
        }
      });
    }
    return _this;
  }
  var _proto = SegmentLoader2.prototype;
  _proto.createTransmuxer_ = function createTransmuxer_() {
    return segmentTransmuxer.createTransmuxer({
      remux: false,
      alignGopsAtEnd: this.safeAppend_,
      keepOriginalTimestamps: true,
      parse708captions: this.parse708captions_,
      captionServices: this.captionServices_
    });
  };
  _proto.resetStats_ = function resetStats_() {
    this.mediaBytesTransferred = 0;
    this.mediaRequests = 0;
    this.mediaRequestsAborted = 0;
    this.mediaRequestsTimedout = 0;
    this.mediaRequestsErrored = 0;
    this.mediaTransferDuration = 0;
    this.mediaSecondsLoaded = 0;
    this.mediaAppends = 0;
  };
  _proto.dispose = function dispose() {
    this.trigger("dispose");
    this.state = "DISPOSED";
    this.pause();
    this.abort_();
    if (this.transmuxer_) {
      this.transmuxer_.terminate();
    }
    this.resetStats_();
    if (this.checkBufferTimeout_) {
      import_window6.default.clearTimeout(this.checkBufferTimeout_);
    }
    if (this.syncController_ && this.triggerSyncInfoUpdate_) {
      this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_);
    }
    this.off();
  };
  _proto.setAudio = function setAudio(enable) {
    this.audioDisabled_ = !enable;
    if (enable) {
      this.appendInitSegment_.audio = true;
    } else {
      this.sourceUpdater_.removeAudio(0, this.duration_());
    }
  };
  _proto.abort = function abort2() {
    if (this.state !== "WAITING") {
      if (this.pendingSegment_) {
        this.pendingSegment_ = null;
      }
      return;
    }
    this.abort_();
    this.state = "READY";
    if (!this.paused()) {
      this.monitorBuffer_();
    }
  };
  _proto.abort_ = function abort_() {
    if (this.pendingSegment_ && this.pendingSegment_.abortRequests) {
      this.pendingSegment_.abortRequests();
    }
    this.pendingSegment_ = null;
    this.callQueue_ = [];
    this.loadQueue_ = [];
    this.metadataQueue_.id3 = [];
    this.metadataQueue_.caption = [];
    this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_);
    this.waitingOnRemove_ = false;
    import_window6.default.clearTimeout(this.quotaExceededErrorRetryTimeout_);
    this.quotaExceededErrorRetryTimeout_ = null;
  };
  _proto.checkForAbort_ = function checkForAbort_(requestId) {
    if (this.state === "APPENDING" && !this.pendingSegment_) {
      this.state = "READY";
      return true;
    }
    if (!this.pendingSegment_ || this.pendingSegment_.requestId !== requestId) {
      return true;
    }
    return false;
  };
  _proto.error = function error(_error) {
    if (typeof _error !== "undefined") {
      this.logger_("error occurred:", _error);
      this.error_ = _error;
    }
    this.pendingSegment_ = null;
    return this.error_;
  };
  _proto.endOfStream = function endOfStream2() {
    this.ended_ = true;
    if (this.transmuxer_) {
      segmentTransmuxer.reset(this.transmuxer_);
    }
    this.gopBuffer_.length = 0;
    this.pause();
    this.trigger("ended");
  };
  _proto.buffered_ = function buffered_() {
    var trackInfo = this.getMediaInfo_();
    if (!this.sourceUpdater_ || !trackInfo) {
      return videojs.createTimeRanges();
    }
    if (this.loaderType_ === "main") {
      var hasAudio = trackInfo.hasAudio, hasVideo = trackInfo.hasVideo, isMuxed3 = trackInfo.isMuxed;
      if (hasVideo && hasAudio && !this.audioDisabled_ && !isMuxed3) {
        return this.sourceUpdater_.buffered();
      }
      if (hasVideo) {
        return this.sourceUpdater_.videoBuffered();
      }
    }
    return this.sourceUpdater_.audioBuffered();
  };
  _proto.initSegmentForMap = function initSegmentForMap(map, set4) {
    if (set4 === void 0) {
      set4 = false;
    }
    if (!map) {
      return null;
    }
    var id = initSegmentId(map);
    var storedMap = this.initSegments_[id];
    if (set4 && !storedMap && map.bytes) {
      this.initSegments_[id] = storedMap = {
        resolvedUri: map.resolvedUri,
        byterange: map.byterange,
        bytes: map.bytes,
        tracks: map.tracks,
        timescales: map.timescales
      };
    }
    return storedMap || map;
  };
  _proto.segmentKey = function segmentKey(key, set4) {
    if (set4 === void 0) {
      set4 = false;
    }
    if (!key) {
      return null;
    }
    var id = segmentKeyId(key);
    var storedKey = this.keyCache_[id];
    if (this.cacheEncryptionKeys_ && set4 && !storedKey && key.bytes) {
      this.keyCache_[id] = storedKey = {
        resolvedUri: key.resolvedUri,
        bytes: key.bytes
      };
    }
    var result = {
      resolvedUri: (storedKey || key).resolvedUri
    };
    if (storedKey) {
      result.bytes = storedKey.bytes;
    }
    return result;
  };
  _proto.couldBeginLoading_ = function couldBeginLoading_() {
    return this.playlist_ && !this.paused();
  };
  _proto.load = function load() {
    this.monitorBuffer_();
    if (!this.playlist_) {
      return;
    }
    if (this.state === "INIT" && this.couldBeginLoading_()) {
      return this.init_();
    }
    if (!this.couldBeginLoading_() || this.state !== "READY" && this.state !== "INIT") {
      return;
    }
    this.state = "READY";
  };
  _proto.init_ = function init_() {
    this.state = "READY";
    this.resetEverything();
    return this.monitorBuffer_();
  };
  _proto.playlist = function playlist(newPlaylist, options) {
    if (options === void 0) {
      options = {};
    }
    if (!newPlaylist) {
      return;
    }
    var oldPlaylist = this.playlist_;
    var segmentInfo = this.pendingSegment_;
    this.playlist_ = newPlaylist;
    this.xhrOptions_ = options;
    if (this.state === "INIT") {
      newPlaylist.syncInfo = {
        mediaSequence: newPlaylist.mediaSequence,
        time: 0
      };
      if (this.loaderType_ === "main") {
        this.syncController_.setDateTimeMappingForStart(newPlaylist);
      }
    }
    var oldId = null;
    if (oldPlaylist) {
      if (oldPlaylist.id) {
        oldId = oldPlaylist.id;
      } else if (oldPlaylist.uri) {
        oldId = oldPlaylist.uri;
      }
    }
    this.logger_("playlist update [" + oldId + " => " + (newPlaylist.id || newPlaylist.uri) + "]");
    this.trigger("syncinfoupdate");
    if (this.state === "INIT" && this.couldBeginLoading_()) {
      return this.init_();
    }
    if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {
      if (this.mediaIndex !== null) {
        if (!newPlaylist.endList) {
          this.resetLoader();
        } else {
          this.resyncLoader();
        }
      }
      this.currentMediaInfo_ = void 0;
      this.trigger("playlistupdate");
      return;
    }
    var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
    this.logger_("live window shift [" + mediaSequenceDiff + "]");
    if (this.mediaIndex !== null) {
      this.mediaIndex -= mediaSequenceDiff;
      if (this.mediaIndex < 0) {
        this.mediaIndex = null;
        this.partIndex = null;
      } else {
        var segment = this.playlist_.segments[this.mediaIndex];
        if (this.partIndex && (!segment.parts || !segment.parts.length || !segment.parts[this.partIndex])) {
          var mediaIndex = this.mediaIndex;
          this.logger_("currently processing part (index " + this.partIndex + ") no longer exists.");
          this.resetLoader();
          this.mediaIndex = mediaIndex;
        }
      }
    }
    if (segmentInfo) {
      segmentInfo.mediaIndex -= mediaSequenceDiff;
      if (segmentInfo.mediaIndex < 0) {
        segmentInfo.mediaIndex = null;
        segmentInfo.partIndex = null;
      } else {
        if (segmentInfo.mediaIndex >= 0) {
          segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex];
        }
        if (segmentInfo.partIndex >= 0 && segmentInfo.segment.parts) {
          segmentInfo.part = segmentInfo.segment.parts[segmentInfo.partIndex];
        }
      }
    }
    this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);
  };
  _proto.pause = function pause() {
    if (this.checkBufferTimeout_) {
      import_window6.default.clearTimeout(this.checkBufferTimeout_);
      this.checkBufferTimeout_ = null;
    }
  };
  _proto.paused = function paused() {
    return this.checkBufferTimeout_ === null;
  };
  _proto.resetEverything = function resetEverything(done) {
    this.ended_ = false;
    this.appendInitSegment_ = {
      audio: true,
      video: true
    };
    this.resetLoader();
    this.remove(0, Infinity, done);
    if (this.transmuxer_) {
      this.transmuxer_.postMessage({
        action: "clearAllMp4Captions"
      });
      this.transmuxer_.postMessage({
        action: "reset"
      });
    }
  };
  _proto.resetLoader = function resetLoader() {
    this.fetchAtBuffer_ = false;
    this.resyncLoader();
  };
  _proto.resyncLoader = function resyncLoader() {
    if (this.transmuxer_) {
      segmentTransmuxer.reset(this.transmuxer_);
    }
    this.mediaIndex = null;
    this.partIndex = null;
    this.syncPoint_ = null;
    this.isPendingTimestampOffset_ = false;
    this.callQueue_ = [];
    this.loadQueue_ = [];
    this.metadataQueue_.id3 = [];
    this.metadataQueue_.caption = [];
    this.abort();
    if (this.transmuxer_) {
      this.transmuxer_.postMessage({
        action: "clearParsedMp4Captions"
      });
    }
  };
  _proto.remove = function remove2(start2, end, done, force) {
    if (done === void 0) {
      done = function done2() {
      };
    }
    if (force === void 0) {
      force = false;
    }
    if (end === Infinity) {
      end = this.duration_();
    }
    if (end <= start2) {
      this.logger_("skipping remove because end ${end} is <= start ${start}");
      return;
    }
    if (!this.sourceUpdater_ || !this.getMediaInfo_()) {
      this.logger_("skipping remove because no source updater or starting media info");
      return;
    }
    var removesRemaining = 1;
    var removeFinished = function removeFinished2() {
      removesRemaining--;
      if (removesRemaining === 0) {
        done();
      }
    };
    if (force || !this.audioDisabled_) {
      removesRemaining++;
      this.sourceUpdater_.removeAudio(start2, end, removeFinished);
    }
    if (force || this.loaderType_ === "main") {
      this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start2, end, this.timeMapping_);
      removesRemaining++;
      this.sourceUpdater_.removeVideo(start2, end, removeFinished);
    }
    for (var track in this.inbandTextTracks_) {
      removeCuesFromTrack(start2, end, this.inbandTextTracks_[track]);
    }
    removeCuesFromTrack(start2, end, this.segmentMetadataTrack_);
    removeFinished();
  };
  _proto.monitorBuffer_ = function monitorBuffer_() {
    if (this.checkBufferTimeout_) {
      import_window6.default.clearTimeout(this.checkBufferTimeout_);
    }
    this.checkBufferTimeout_ = import_window6.default.setTimeout(this.monitorBufferTick_.bind(this), 1);
  };
  _proto.monitorBufferTick_ = function monitorBufferTick_() {
    if (this.state === "READY") {
      this.fillBuffer_();
    }
    if (this.checkBufferTimeout_) {
      import_window6.default.clearTimeout(this.checkBufferTimeout_);
    }
    this.checkBufferTimeout_ = import_window6.default.setTimeout(this.monitorBufferTick_.bind(this), CHECK_BUFFER_DELAY);
  };
  _proto.fillBuffer_ = function fillBuffer_() {
    if (this.sourceUpdater_.updating()) {
      return;
    }
    var segmentInfo = this.chooseNextRequest_();
    if (!segmentInfo) {
      return;
    }
    if (typeof segmentInfo.timestampOffset === "number") {
      this.isPendingTimestampOffset_ = false;
      this.timelineChangeController_.pendingTimelineChange({
        type: this.loaderType_,
        from: this.currentTimeline_,
        to: segmentInfo.timeline
      });
    }
    this.loadSegment_(segmentInfo);
  };
  _proto.isEndOfStream_ = function isEndOfStream_(mediaIndex, playlist, partIndex) {
    if (mediaIndex === void 0) {
      mediaIndex = this.mediaIndex;
    }
    if (playlist === void 0) {
      playlist = this.playlist_;
    }
    if (partIndex === void 0) {
      partIndex = this.partIndex;
    }
    if (!playlist || !this.mediaSource_) {
      return false;
    }
    var segment = typeof mediaIndex === "number" && playlist.segments[mediaIndex];
    var appendedLastSegment = mediaIndex + 1 === playlist.segments.length;
    var appendedLastPart = !segment || !segment.parts || partIndex + 1 === segment.parts.length;
    return playlist.endList && this.mediaSource_.readyState === "open" && appendedLastSegment && appendedLastPart;
  };
  _proto.chooseNextRequest_ = function chooseNextRequest_() {
    var buffered = this.buffered_();
    var bufferedEnd = lastBufferedEnd(buffered) || 0;
    var bufferedTime = timeAheadOf(buffered, this.currentTime_());
    var preloaded = !this.hasPlayed_() && bufferedTime >= 1;
    var haveEnoughBuffer = bufferedTime >= this.goalBufferLength_();
    var segments = this.playlist_.segments;
    if (!segments.length || preloaded || haveEnoughBuffer) {
      return null;
    }
    this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());
    var next = {
      partIndex: null,
      mediaIndex: null,
      startOfSegment: null,
      playlist: this.playlist_,
      isSyncRequest: Boolean(!this.syncPoint_)
    };
    if (next.isSyncRequest) {
      next.mediaIndex = getSyncSegmentCandidate(this.currentTimeline_, segments, bufferedEnd);
    } else if (this.mediaIndex !== null) {
      var segment = segments[this.mediaIndex];
      var partIndex = typeof this.partIndex === "number" ? this.partIndex : -1;
      next.startOfSegment = segment.end ? segment.end : bufferedEnd;
      if (segment.parts && segment.parts[partIndex + 1]) {
        next.mediaIndex = this.mediaIndex;
        next.partIndex = partIndex + 1;
      } else {
        next.mediaIndex = this.mediaIndex + 1;
      }
    } else {
      var _Playlist$getMediaInf = Playlist.getMediaInfoForTime({
        experimentalExactManifestTimings: this.experimentalExactManifestTimings,
        playlist: this.playlist_,
        currentTime: this.fetchAtBuffer_ ? bufferedEnd : this.currentTime_(),
        startingPartIndex: this.syncPoint_.partIndex,
        startingSegmentIndex: this.syncPoint_.segmentIndex,
        startTime: this.syncPoint_.time
      }), segmentIndex = _Playlist$getMediaInf.segmentIndex, startTime = _Playlist$getMediaInf.startTime, _partIndex = _Playlist$getMediaInf.partIndex;
      next.getMediaInfoForTime = this.fetchAtBuffer_ ? "bufferedEnd " + bufferedEnd : "currentTime " + this.currentTime_();
      next.mediaIndex = segmentIndex;
      next.startOfSegment = startTime;
      next.partIndex = _partIndex;
    }
    var nextSegment = segments[next.mediaIndex];
    var nextPart = nextSegment && typeof next.partIndex === "number" && nextSegment.parts && nextSegment.parts[next.partIndex];
    if (!nextSegment || typeof next.partIndex === "number" && !nextPart) {
      return null;
    }
    if (typeof next.partIndex !== "number" && nextSegment.parts) {
      next.partIndex = 0;
      nextPart = nextSegment.parts[0];
    }
    if (!bufferedTime && nextPart && !nextPart.independent) {
      if (next.partIndex === 0) {
        var lastSegment = segments[next.mediaIndex - 1];
        var lastSegmentLastPart = lastSegment.parts && lastSegment.parts.length && lastSegment.parts[lastSegment.parts.length - 1];
        if (lastSegmentLastPart && lastSegmentLastPart.independent) {
          next.mediaIndex -= 1;
          next.partIndex = lastSegment.parts.length - 1;
          next.independent = "previous segment";
        }
      } else if (nextSegment.parts[next.partIndex - 1].independent) {
        next.partIndex -= 1;
        next.independent = "previous part";
      }
    }
    var ended = this.mediaSource_ && this.mediaSource_.readyState === "ended";
    if (next.mediaIndex >= segments.length - 1 && ended && !this.seeking_()) {
      return null;
    }
    return this.generateSegmentInfo_(next);
  };
  _proto.generateSegmentInfo_ = function generateSegmentInfo_(options) {
    var independent = options.independent, playlist = options.playlist, mediaIndex = options.mediaIndex, startOfSegment = options.startOfSegment, isSyncRequest = options.isSyncRequest, partIndex = options.partIndex, forceTimestampOffset = options.forceTimestampOffset, getMediaInfoForTime3 = options.getMediaInfoForTime;
    var segment = playlist.segments[mediaIndex];
    var part = typeof partIndex === "number" && segment.parts[partIndex];
    var segmentInfo = {
      requestId: "segment-loader-" + Math.random(),
      // resolve the segment URL relative to the playlist
      uri: part && part.resolvedUri || segment.resolvedUri,
      // the segment's mediaIndex at the time it was requested
      mediaIndex,
      partIndex: part ? partIndex : null,
      // whether or not to update the SegmentLoader's state with this
      // segment's mediaIndex
      isSyncRequest,
      startOfSegment,
      // the segment's playlist
      playlist,
      // unencrypted bytes of the segment
      bytes: null,
      // when a key is defined for this segment, the encrypted bytes
      encryptedBytes: null,
      // The target timestampOffset for this segment when we append it
      // to the source buffer
      timestampOffset: null,
      // The timeline that the segment is in
      timeline: segment.timeline,
      // The expected duration of the segment in seconds
      duration: part && part.duration || segment.duration,
      // retain the segment in case the playlist updates while doing an async process
      segment,
      part,
      byteLength: 0,
      transmuxer: this.transmuxer_,
      // type of getMediaInfoForTime that was used to get this segment
      getMediaInfoForTime: getMediaInfoForTime3,
      independent
    };
    var overrideCheck = typeof forceTimestampOffset !== "undefined" ? forceTimestampOffset : this.isPendingTimestampOffset_;
    segmentInfo.timestampOffset = this.timestampOffsetForSegment_({
      segmentTimeline: segment.timeline,
      currentTimeline: this.currentTimeline_,
      startOfSegment,
      buffered: this.buffered_(),
      overrideCheck
    });
    var audioBufferedEnd = lastBufferedEnd(this.sourceUpdater_.audioBuffered());
    if (typeof audioBufferedEnd === "number") {
      segmentInfo.audioAppendStart = audioBufferedEnd - this.sourceUpdater_.audioTimestampOffset();
    }
    if (this.sourceUpdater_.videoBuffered().length) {
      segmentInfo.gopsToAlignWith = gopsSafeToAlignWith(
        this.gopBuffer_,
        // since the transmuxer is using the actual timing values, but the time is
        // adjusted by the timestmap offset, we must adjust the value here
        this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(),
        this.timeMapping_
      );
    }
    return segmentInfo;
  };
  _proto.timestampOffsetForSegment_ = function timestampOffsetForSegment_(options) {
    return timestampOffsetForSegment(options);
  };
  _proto.earlyAbortWhenNeeded_ = function earlyAbortWhenNeeded_(stats) {
    if (this.vhs_.tech_.paused() || // Don't abort if the current playlist is on the lowestEnabledRendition
    // TODO: Replace using timeout with a boolean indicating whether this playlist is
    //       the lowestEnabledRendition.
    !this.xhrOptions_.timeout || // Don't abort if we have no bandwidth information to estimate segment sizes
    !this.playlist_.attributes.BANDWIDTH) {
      return;
    }
    if (Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1e3) {
      return;
    }
    var currentTime = this.currentTime_();
    var measuredBandwidth = stats.bandwidth;
    var segmentDuration = this.pendingSegment_.duration;
    var requestTimeRemaining = Playlist.estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived);
    var timeUntilRebuffer$1 = timeUntilRebuffer(this.buffered_(), currentTime, this.vhs_.tech_.playbackRate()) - 1;
    if (requestTimeRemaining <= timeUntilRebuffer$1) {
      return;
    }
    var switchCandidate = minRebufferMaxBandwidthSelector({
      master: this.vhs_.playlists.master,
      currentTime,
      bandwidth: measuredBandwidth,
      duration: this.duration_(),
      segmentDuration,
      timeUntilRebuffer: timeUntilRebuffer$1,
      currentTimeline: this.currentTimeline_,
      syncController: this.syncController_
    });
    if (!switchCandidate) {
      return;
    }
    var rebufferingImpact = requestTimeRemaining - timeUntilRebuffer$1;
    var timeSavedBySwitching = rebufferingImpact - switchCandidate.rebufferingImpact;
    var minimumTimeSaving = 0.5;
    if (timeUntilRebuffer$1 <= TIME_FUDGE_FACTOR) {
      minimumTimeSaving = 1;
    }
    if (!switchCandidate.playlist || switchCandidate.playlist.uri === this.playlist_.uri || timeSavedBySwitching < minimumTimeSaving) {
      return;
    }
    this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * Config.BANDWIDTH_VARIANCE + 1;
    this.trigger("earlyabort");
  };
  _proto.handleAbort_ = function handleAbort_(segmentInfo) {
    this.logger_("Aborting " + segmentInfoString(segmentInfo));
    this.mediaRequestsAborted += 1;
  };
  _proto.handleProgress_ = function handleProgress_(event, simpleSegment) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    this.trigger("progress");
  };
  _proto.handleTrackInfo_ = function handleTrackInfo_(simpleSegment, trackInfo) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    if (this.checkForIllegalMediaSwitch(trackInfo)) {
      return;
    }
    trackInfo = trackInfo || {};
    if (!shallowEqual(this.currentMediaInfo_, trackInfo)) {
      this.appendInitSegment_ = {
        audio: true,
        video: true
      };
      this.startingMediaInfo_ = trackInfo;
      this.currentMediaInfo_ = trackInfo;
      this.logger_("trackinfo update", trackInfo);
      this.trigger("trackinfo");
    }
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    this.pendingSegment_.trackInfo = trackInfo;
    if (this.hasEnoughInfoToAppend_()) {
      this.processCallQueue_();
    }
  };
  _proto.handleTimingInfo_ = function handleTimingInfo_(simpleSegment, mediaType, timeType, time) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    var segmentInfo = this.pendingSegment_;
    var timingInfoProperty = timingInfoPropertyForMedia(mediaType);
    segmentInfo[timingInfoProperty] = segmentInfo[timingInfoProperty] || {};
    segmentInfo[timingInfoProperty][timeType] = time;
    this.logger_("timinginfo: " + mediaType + " - " + timeType + " - " + time);
    if (this.hasEnoughInfoToAppend_()) {
      this.processCallQueue_();
    }
  };
  _proto.handleCaptions_ = function handleCaptions_(simpleSegment, captionData) {
    var _this2 = this;
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    if (captionData.length === 0) {
      this.logger_("SegmentLoader received no captions from a caption event");
      return;
    }
    var segmentInfo = this.pendingSegment_;
    if (!segmentInfo.hasAppendedData_) {
      this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, simpleSegment, captionData));
      return;
    }
    var timestampOffset2 = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
    var captionTracks = {};
    captionData.forEach(function(caption) {
      captionTracks[caption.stream] = captionTracks[caption.stream] || {
        // Infinity, as any other value will be less than this
        startTime: Infinity,
        captions: [],
        // 0 as an other value will be more than this
        endTime: 0
      };
      var captionTrack = captionTracks[caption.stream];
      captionTrack.startTime = Math.min(captionTrack.startTime, caption.startTime + timestampOffset2);
      captionTrack.endTime = Math.max(captionTrack.endTime, caption.endTime + timestampOffset2);
      captionTrack.captions.push(caption);
    });
    Object.keys(captionTracks).forEach(function(trackName) {
      var _captionTracks$trackN = captionTracks[trackName], startTime = _captionTracks$trackN.startTime, endTime = _captionTracks$trackN.endTime, captions = _captionTracks$trackN.captions;
      var inbandTextTracks = _this2.inbandTextTracks_;
      _this2.logger_("adding cues from " + startTime + " -> " + endTime + " for " + trackName);
      createCaptionsTrackIfNotExists(inbandTextTracks, _this2.vhs_.tech_, trackName);
      removeCuesFromTrack(startTime, endTime, inbandTextTracks[trackName]);
      addCaptionData({
        captionArray: captions,
        inbandTextTracks,
        timestampOffset: timestampOffset2
      });
    });
    if (this.transmuxer_) {
      this.transmuxer_.postMessage({
        action: "clearParsedMp4Captions"
      });
    }
  };
  _proto.handleId3_ = function handleId3_(simpleSegment, id3Frames, dispatchType) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    var segmentInfo = this.pendingSegment_;
    if (!segmentInfo.hasAppendedData_) {
      this.metadataQueue_.id3.push(this.handleId3_.bind(this, simpleSegment, id3Frames, dispatchType));
      return;
    }
    var timestampOffset2 = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
    createMetadataTrackIfNotExists(this.inbandTextTracks_, dispatchType, this.vhs_.tech_);
    addMetadata({
      inbandTextTracks: this.inbandTextTracks_,
      metadataArray: id3Frames,
      timestampOffset: timestampOffset2,
      videoDuration: this.duration_()
    });
  };
  _proto.processMetadataQueue_ = function processMetadataQueue_() {
    this.metadataQueue_.id3.forEach(function(fn) {
      return fn();
    });
    this.metadataQueue_.caption.forEach(function(fn) {
      return fn();
    });
    this.metadataQueue_.id3 = [];
    this.metadataQueue_.caption = [];
  };
  _proto.processCallQueue_ = function processCallQueue_() {
    var callQueue = this.callQueue_;
    this.callQueue_ = [];
    callQueue.forEach(function(fun) {
      return fun();
    });
  };
  _proto.processLoadQueue_ = function processLoadQueue_() {
    var loadQueue = this.loadQueue_;
    this.loadQueue_ = [];
    loadQueue.forEach(function(fun) {
      return fun();
    });
  };
  _proto.hasEnoughInfoToLoad_ = function hasEnoughInfoToLoad_() {
    if (this.loaderType_ !== "audio") {
      return true;
    }
    var segmentInfo = this.pendingSegment_;
    if (!segmentInfo) {
      return false;
    }
    if (!this.getCurrentMediaInfo_()) {
      return true;
    }
    if (
      // Technically, instead of waiting to load a segment on timeline changes, a segment
      // can be requested and downloaded and only wait before it is transmuxed or parsed.
      // But in practice, there are a few reasons why it is better to wait until a loader
      // is ready to append that segment before requesting and downloading:
      //
      // 1. Because audio and main loaders cross discontinuities together, if this loader
      //    is waiting for the other to catch up, then instead of requesting another
      //    segment and using up more bandwidth, by not yet loading, more bandwidth is
      //    allotted to the loader currently behind.
      // 2. media-segment-request doesn't have to have logic to consider whether a segment
      // is ready to be processed or not, isolating the queueing behavior to the loader.
      // 3. The audio loader bases some of its segment properties on timing information
      //    provided by the main loader, meaning that, if the logic for waiting on
      //    processing was in media-segment-request, then it would also need to know how
      //    to re-generate the segment information after the main loader caught up.
      shouldWaitForTimelineChange({
        timelineChangeController: this.timelineChangeController_,
        currentTimeline: this.currentTimeline_,
        segmentTimeline: segmentInfo.timeline,
        loaderType: this.loaderType_,
        audioDisabled: this.audioDisabled_
      })
    ) {
      return false;
    }
    return true;
  };
  _proto.getCurrentMediaInfo_ = function getCurrentMediaInfo_(segmentInfo) {
    if (segmentInfo === void 0) {
      segmentInfo = this.pendingSegment_;
    }
    return segmentInfo && segmentInfo.trackInfo || this.currentMediaInfo_;
  };
  _proto.getMediaInfo_ = function getMediaInfo_(segmentInfo) {
    if (segmentInfo === void 0) {
      segmentInfo = this.pendingSegment_;
    }
    return this.getCurrentMediaInfo_(segmentInfo) || this.startingMediaInfo_;
  };
  _proto.hasEnoughInfoToAppend_ = function hasEnoughInfoToAppend_() {
    if (!this.sourceUpdater_.ready()) {
      return false;
    }
    if (this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_) {
      return false;
    }
    var segmentInfo = this.pendingSegment_;
    var trackInfo = this.getCurrentMediaInfo_();
    if (!segmentInfo || !trackInfo) {
      return false;
    }
    var hasAudio = trackInfo.hasAudio, hasVideo = trackInfo.hasVideo, isMuxed3 = trackInfo.isMuxed;
    if (hasVideo && !segmentInfo.videoTimingInfo) {
      return false;
    }
    if (hasAudio && !this.audioDisabled_ && !isMuxed3 && !segmentInfo.audioTimingInfo) {
      return false;
    }
    if (shouldWaitForTimelineChange({
      timelineChangeController: this.timelineChangeController_,
      currentTimeline: this.currentTimeline_,
      segmentTimeline: segmentInfo.timeline,
      loaderType: this.loaderType_,
      audioDisabled: this.audioDisabled_
    })) {
      return false;
    }
    return true;
  };
  _proto.handleData_ = function handleData_3(simpleSegment, result) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {
      this.callQueue_.push(this.handleData_.bind(this, simpleSegment, result));
      return;
    }
    var segmentInfo = this.pendingSegment_;
    this.setTimeMapping_(segmentInfo.timeline);
    this.updateMediaSecondsLoaded_(segmentInfo.part || segmentInfo.segment);
    if (this.mediaSource_.readyState === "closed") {
      return;
    }
    if (simpleSegment.map) {
      simpleSegment.map = this.initSegmentForMap(simpleSegment.map, true);
      segmentInfo.segment.map = simpleSegment.map;
    }
    if (simpleSegment.key) {
      this.segmentKey(simpleSegment.key, true);
    }
    segmentInfo.isFmp4 = simpleSegment.isFmp4;
    segmentInfo.timingInfo = segmentInfo.timingInfo || {};
    if (segmentInfo.isFmp4) {
      this.trigger("fmp4");
      segmentInfo.timingInfo.start = segmentInfo[timingInfoPropertyForMedia(result.type)].start;
    } else {
      var trackInfo = this.getCurrentMediaInfo_();
      var useVideoTimingInfo = this.loaderType_ === "main" && trackInfo && trackInfo.hasVideo;
      var firstVideoFrameTimeForData;
      if (useVideoTimingInfo) {
        firstVideoFrameTimeForData = segmentInfo.videoTimingInfo.start;
      }
      segmentInfo.timingInfo.start = this.trueSegmentStart_({
        currentStart: segmentInfo.timingInfo.start,
        playlist: segmentInfo.playlist,
        mediaIndex: segmentInfo.mediaIndex,
        currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),
        useVideoTimingInfo,
        firstVideoFrameTimeForData,
        videoTimingInfo: segmentInfo.videoTimingInfo,
        audioTimingInfo: segmentInfo.audioTimingInfo
      });
    }
    this.updateAppendInitSegmentStatus(segmentInfo, result.type);
    this.updateSourceBufferTimestampOffset_(segmentInfo);
    if (segmentInfo.isSyncRequest) {
      this.updateTimingInfoEnd_(segmentInfo);
      this.syncController_.saveSegmentTimingInfo({
        segmentInfo,
        shouldSaveTimelineMapping: this.loaderType_ === "main"
      });
      var next = this.chooseNextRequest_();
      if (next.mediaIndex !== segmentInfo.mediaIndex || next.partIndex !== segmentInfo.partIndex) {
        this.logger_("sync segment was incorrect, not appending");
        return;
      }
      this.logger_("sync segment was correct, appending");
    }
    segmentInfo.hasAppendedData_ = true;
    this.processMetadataQueue_();
    this.appendData_(segmentInfo, result);
  };
  _proto.updateAppendInitSegmentStatus = function updateAppendInitSegmentStatus(segmentInfo, type2) {
    if (this.loaderType_ === "main" && typeof segmentInfo.timestampOffset === "number" && // in the case that we're handling partial data, we don't want to append an init
    // segment for each chunk
    !segmentInfo.changedTimestampOffset) {
      this.appendInitSegment_ = {
        audio: true,
        video: true
      };
    }
    if (this.playlistOfLastInitSegment_[type2] !== segmentInfo.playlist) {
      this.appendInitSegment_[type2] = true;
    }
  };
  _proto.getInitSegmentAndUpdateState_ = function getInitSegmentAndUpdateState_(_ref4) {
    var type2 = _ref4.type, initSegment = _ref4.initSegment, map = _ref4.map, playlist = _ref4.playlist;
    if (map) {
      var id = initSegmentId(map);
      if (this.activeInitSegmentId_ === id) {
        return null;
      }
      initSegment = this.initSegmentForMap(map, true).bytes;
      this.activeInitSegmentId_ = id;
    }
    if (initSegment && this.appendInitSegment_[type2]) {
      this.playlistOfLastInitSegment_[type2] = playlist;
      this.appendInitSegment_[type2] = false;
      this.activeInitSegmentId_ = null;
      return initSegment;
    }
    return null;
  };
  _proto.handleQuotaExceededError_ = function handleQuotaExceededError_(_ref5, error) {
    var _this3 = this;
    var segmentInfo = _ref5.segmentInfo, type2 = _ref5.type, bytes = _ref5.bytes;
    var audioBuffered = this.sourceUpdater_.audioBuffered();
    var videoBuffered = this.sourceUpdater_.videoBuffered();
    if (audioBuffered.length > 1) {
      this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + timeRangesToArray(audioBuffered).join(", "));
    }
    if (videoBuffered.length > 1) {
      this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + timeRangesToArray(videoBuffered).join(", "));
    }
    var audioBufferStart = audioBuffered.length ? audioBuffered.start(0) : 0;
    var audioBufferEnd = audioBuffered.length ? audioBuffered.end(audioBuffered.length - 1) : 0;
    var videoBufferStart = videoBuffered.length ? videoBuffered.start(0) : 0;
    var videoBufferEnd = videoBuffered.length ? videoBuffered.end(videoBuffered.length - 1) : 0;
    if (audioBufferEnd - audioBufferStart <= MIN_BACK_BUFFER && videoBufferEnd - videoBufferStart <= MIN_BACK_BUFFER) {
      this.logger_("On QUOTA_EXCEEDED_ERR, single segment too large to append to buffer, triggering an error. " + ("Appended byte length: " + bytes.byteLength + ", ") + ("audio buffer: " + timeRangesToArray(audioBuffered).join(", ") + ", ") + ("video buffer: " + timeRangesToArray(videoBuffered).join(", ") + ", "));
      this.error({
        message: "Quota exceeded error with append of a single segment of content",
        excludeUntil: Infinity
      });
      this.trigger("error");
      return;
    }
    this.waitingOnRemove_ = true;
    this.callQueue_.push(this.appendToSourceBuffer_.bind(this, {
      segmentInfo,
      type: type2,
      bytes
    }));
    var currentTime = this.currentTime_();
    var timeToRemoveUntil = currentTime - MIN_BACK_BUFFER;
    this.logger_("On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to " + timeToRemoveUntil);
    this.remove(0, timeToRemoveUntil, function() {
      _this3.logger_("On QUOTA_EXCEEDED_ERR, retrying append in " + MIN_BACK_BUFFER + "s");
      _this3.waitingOnRemove_ = false;
      _this3.quotaExceededErrorRetryTimeout_ = import_window6.default.setTimeout(function() {
        _this3.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue");
        _this3.quotaExceededErrorRetryTimeout_ = null;
        _this3.processCallQueue_();
      }, MIN_BACK_BUFFER * 1e3);
    }, true);
  };
  _proto.handleAppendError_ = function handleAppendError_(_ref6, error) {
    var segmentInfo = _ref6.segmentInfo, type2 = _ref6.type, bytes = _ref6.bytes;
    if (!error) {
      return;
    }
    if (error.code === QUOTA_EXCEEDED_ERR) {
      this.handleQuotaExceededError_({
        segmentInfo,
        type: type2,
        bytes
      });
      return;
    }
    this.logger_("Received non QUOTA_EXCEEDED_ERR on append", error);
    this.error(type2 + " append of " + bytes.length + "b failed for segment " + ("#" + segmentInfo.mediaIndex + " in playlist " + segmentInfo.playlist.id));
    this.trigger("appenderror");
  };
  _proto.appendToSourceBuffer_ = function appendToSourceBuffer_(_ref7) {
    var segmentInfo = _ref7.segmentInfo, type2 = _ref7.type, initSegment = _ref7.initSegment, data = _ref7.data, bytes = _ref7.bytes;
    if (!bytes) {
      var segments = [data];
      var byteLength = data.byteLength;
      if (initSegment) {
        segments.unshift(initSegment);
        byteLength += initSegment.byteLength;
      }
      bytes = concatSegments({
        bytes: byteLength,
        segments
      });
    }
    this.sourceUpdater_.appendBuffer({
      segmentInfo,
      type: type2,
      bytes
    }, this.handleAppendError_.bind(this, {
      segmentInfo,
      type: type2,
      bytes
    }));
  };
  _proto.handleSegmentTimingInfo_ = function handleSegmentTimingInfo_(type2, requestId, segmentTimingInfo) {
    if (!this.pendingSegment_ || requestId !== this.pendingSegment_.requestId) {
      return;
    }
    var segment = this.pendingSegment_.segment;
    var timingInfoProperty = type2 + "TimingInfo";
    if (!segment[timingInfoProperty]) {
      segment[timingInfoProperty] = {};
    }
    segment[timingInfoProperty].transmuxerPrependedSeconds = segmentTimingInfo.prependedContentDuration || 0;
    segment[timingInfoProperty].transmuxedPresentationStart = segmentTimingInfo.start.presentation;
    segment[timingInfoProperty].transmuxedDecodeStart = segmentTimingInfo.start.decode;
    segment[timingInfoProperty].transmuxedPresentationEnd = segmentTimingInfo.end.presentation;
    segment[timingInfoProperty].transmuxedDecodeEnd = segmentTimingInfo.end.decode;
    segment[timingInfoProperty].baseMediaDecodeTime = segmentTimingInfo.baseMediaDecodeTime;
  };
  _proto.appendData_ = function appendData_(segmentInfo, result) {
    var type2 = result.type, data = result.data;
    if (!data || !data.byteLength) {
      return;
    }
    if (type2 === "audio" && this.audioDisabled_) {
      return;
    }
    var initSegment = this.getInitSegmentAndUpdateState_({
      type: type2,
      initSegment: result.initSegment,
      playlist: segmentInfo.playlist,
      map: segmentInfo.isFmp4 ? segmentInfo.segment.map : null
    });
    this.appendToSourceBuffer_({
      segmentInfo,
      type: type2,
      initSegment,
      data
    });
  };
  _proto.loadSegment_ = function loadSegment_(segmentInfo) {
    var _this4 = this;
    this.state = "WAITING";
    this.pendingSegment_ = segmentInfo;
    this.trimBackBuffer_(segmentInfo);
    if (typeof segmentInfo.timestampOffset === "number") {
      if (this.transmuxer_) {
        this.transmuxer_.postMessage({
          action: "clearAllMp4Captions"
        });
      }
    }
    if (!this.hasEnoughInfoToLoad_()) {
      this.loadQueue_.push(function() {
        var options = _extends2({}, segmentInfo, {
          forceTimestampOffset: true
        });
        _extends2(segmentInfo, _this4.generateSegmentInfo_(options));
        _this4.isPendingTimestampOffset_ = false;
        _this4.updateTransmuxerAndRequestSegment_(segmentInfo);
      });
      return;
    }
    this.updateTransmuxerAndRequestSegment_(segmentInfo);
  };
  _proto.updateTransmuxerAndRequestSegment_ = function updateTransmuxerAndRequestSegment_(segmentInfo) {
    var _this5 = this;
    if (this.shouldUpdateTransmuxerTimestampOffset_(segmentInfo.timestampOffset)) {
      this.gopBuffer_.length = 0;
      segmentInfo.gopsToAlignWith = [];
      this.timeMapping_ = 0;
      this.transmuxer_.postMessage({
        action: "reset"
      });
      this.transmuxer_.postMessage({
        action: "setTimestampOffset",
        timestampOffset: segmentInfo.timestampOffset
      });
    }
    var simpleSegment = this.createSimplifiedSegmentObj_(segmentInfo);
    var isEndOfStream = this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex);
    var isWalkingForward = this.mediaIndex !== null;
    var isDiscontinuity = segmentInfo.timeline !== this.currentTimeline_ && // currentTimeline starts at -1, so we shouldn't end the timeline switching to 0,
    // the first timeline
    segmentInfo.timeline > 0;
    var isEndOfTimeline = isEndOfStream || isWalkingForward && isDiscontinuity;
    this.logger_("Requesting " + segmentInfoString(segmentInfo));
    if (simpleSegment.map && !simpleSegment.map.bytes) {
      this.logger_("going to request init segment.");
      this.appendInitSegment_ = {
        video: true,
        audio: true
      };
    }
    segmentInfo.abortRequests = mediaSegmentRequest({
      xhr: this.vhs_.xhr,
      xhrOptions: this.xhrOptions_,
      decryptionWorker: this.decrypter_,
      segment: simpleSegment,
      abortFn: this.handleAbort_.bind(this, segmentInfo),
      progressFn: this.handleProgress_.bind(this),
      trackInfoFn: this.handleTrackInfo_.bind(this),
      timingInfoFn: this.handleTimingInfo_.bind(this),
      videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "video", segmentInfo.requestId),
      audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "audio", segmentInfo.requestId),
      captionsFn: this.handleCaptions_.bind(this),
      isEndOfTimeline,
      endedTimelineFn: function endedTimelineFn() {
        _this5.logger_("received endedtimeline callback");
      },
      id3Fn: this.handleId3_.bind(this),
      dataFn: this.handleData_.bind(this),
      doneFn: this.segmentRequestFinished_.bind(this),
      onTransmuxerLog: function onTransmuxerLog(_ref8) {
        var message = _ref8.message, level = _ref8.level, stream = _ref8.stream;
        _this5.logger_(segmentInfoString(segmentInfo) + " logged from transmuxer stream " + stream + " as a " + level + ": " + message);
      }
    });
  };
  _proto.trimBackBuffer_ = function trimBackBuffer_(segmentInfo) {
    var removeToTime = safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10);
    if (removeToTime > 0) {
      this.remove(0, removeToTime);
    }
  };
  _proto.createSimplifiedSegmentObj_ = function createSimplifiedSegmentObj_(segmentInfo) {
    var segment = segmentInfo.segment;
    var part = segmentInfo.part;
    var simpleSegment = {
      resolvedUri: part ? part.resolvedUri : segment.resolvedUri,
      byterange: part ? part.byterange : segment.byterange,
      requestId: segmentInfo.requestId,
      transmuxer: segmentInfo.transmuxer,
      audioAppendStart: segmentInfo.audioAppendStart,
      gopsToAlignWith: segmentInfo.gopsToAlignWith,
      part: segmentInfo.part
    };
    var previousSegment = segmentInfo.playlist.segments[segmentInfo.mediaIndex - 1];
    if (previousSegment && previousSegment.timeline === segment.timeline) {
      if (previousSegment.videoTimingInfo) {
        simpleSegment.baseStartTime = previousSegment.videoTimingInfo.transmuxedDecodeEnd;
      } else if (previousSegment.audioTimingInfo) {
        simpleSegment.baseStartTime = previousSegment.audioTimingInfo.transmuxedDecodeEnd;
      }
    }
    if (segment.key) {
      var iv = segment.key.iv || new Uint32Array([0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence]);
      simpleSegment.key = this.segmentKey(segment.key);
      simpleSegment.key.iv = iv;
    }
    if (segment.map) {
      simpleSegment.map = this.initSegmentForMap(segment.map);
    }
    return simpleSegment;
  };
  _proto.saveTransferStats_ = function saveTransferStats_(stats) {
    this.mediaRequests += 1;
    if (stats) {
      this.mediaBytesTransferred += stats.bytesReceived;
      this.mediaTransferDuration += stats.roundTripTime;
    }
  };
  _proto.saveBandwidthRelatedStats_ = function saveBandwidthRelatedStats_(duration5, stats) {
    this.pendingSegment_.byteLength = stats.bytesReceived;
    if (duration5 < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
      this.logger_("Ignoring segment's bandwidth because its duration of " + duration5 + (" is less than the min to record " + MIN_SEGMENT_DURATION_TO_SAVE_STATS));
      return;
    }
    this.bandwidth = stats.bandwidth;
    this.roundTrip = stats.roundTripTime;
  };
  _proto.handleTimeout_ = function handleTimeout_() {
    this.mediaRequestsTimedout += 1;
    this.bandwidth = 1;
    this.roundTrip = NaN;
    this.trigger("bandwidthupdate");
  };
  _proto.segmentRequestFinished_ = function segmentRequestFinished_(error, simpleSegment, result) {
    if (this.callQueue_.length) {
      this.callQueue_.push(this.segmentRequestFinished_.bind(this, error, simpleSegment, result));
      return;
    }
    this.saveTransferStats_(simpleSegment.stats);
    if (!this.pendingSegment_) {
      return;
    }
    if (simpleSegment.requestId !== this.pendingSegment_.requestId) {
      return;
    }
    if (error) {
      this.pendingSegment_ = null;
      this.state = "READY";
      if (error.code === REQUEST_ERRORS.ABORTED) {
        return;
      }
      this.pause();
      if (error.code === REQUEST_ERRORS.TIMEOUT) {
        this.handleTimeout_();
        return;
      }
      this.mediaRequestsErrored += 1;
      this.error(error);
      this.trigger("error");
      return;
    }
    var segmentInfo = this.pendingSegment_;
    this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);
    segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests;
    if (result.gopInfo) {
      this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, result.gopInfo, this.safeAppend_);
    }
    this.state = "APPENDING";
    this.trigger("appending");
    this.waitForAppendsToComplete_(segmentInfo);
  };
  _proto.setTimeMapping_ = function setTimeMapping_(timeline) {
    var timelineMapping = this.syncController_.mappingForTimeline(timeline);
    if (timelineMapping !== null) {
      this.timeMapping_ = timelineMapping;
    }
  };
  _proto.updateMediaSecondsLoaded_ = function updateMediaSecondsLoaded_(segment) {
    if (typeof segment.start === "number" && typeof segment.end === "number") {
      this.mediaSecondsLoaded += segment.end - segment.start;
    } else {
      this.mediaSecondsLoaded += segment.duration;
    }
  };
  _proto.shouldUpdateTransmuxerTimestampOffset_ = function shouldUpdateTransmuxerTimestampOffset_(timestampOffset2) {
    if (timestampOffset2 === null) {
      return false;
    }
    if (this.loaderType_ === "main" && timestampOffset2 !== this.sourceUpdater_.videoTimestampOffset()) {
      return true;
    }
    if (!this.audioDisabled_ && timestampOffset2 !== this.sourceUpdater_.audioTimestampOffset()) {
      return true;
    }
    return false;
  };
  _proto.trueSegmentStart_ = function trueSegmentStart_(_ref9) {
    var currentStart = _ref9.currentStart, playlist = _ref9.playlist, mediaIndex = _ref9.mediaIndex, firstVideoFrameTimeForData = _ref9.firstVideoFrameTimeForData, currentVideoTimestampOffset = _ref9.currentVideoTimestampOffset, useVideoTimingInfo = _ref9.useVideoTimingInfo, videoTimingInfo = _ref9.videoTimingInfo, audioTimingInfo = _ref9.audioTimingInfo;
    if (typeof currentStart !== "undefined") {
      return currentStart;
    }
    if (!useVideoTimingInfo) {
      return audioTimingInfo.start;
    }
    var previousSegment = playlist.segments[mediaIndex - 1];
    if (mediaIndex === 0 || !previousSegment || typeof previousSegment.start === "undefined" || previousSegment.end !== firstVideoFrameTimeForData + currentVideoTimestampOffset) {
      return firstVideoFrameTimeForData;
    }
    return videoTimingInfo.start;
  };
  _proto.waitForAppendsToComplete_ = function waitForAppendsToComplete_(segmentInfo) {
    var trackInfo = this.getCurrentMediaInfo_(segmentInfo);
    if (!trackInfo) {
      this.error({
        message: "No starting media returned, likely due to an unsupported media format.",
        blacklistDuration: Infinity
      });
      this.trigger("error");
      return;
    }
    var hasAudio = trackInfo.hasAudio, hasVideo = trackInfo.hasVideo, isMuxed3 = trackInfo.isMuxed;
    var waitForVideo = this.loaderType_ === "main" && hasVideo;
    var waitForAudio = !this.audioDisabled_ && hasAudio && !isMuxed3;
    segmentInfo.waitingOnAppends = 0;
    if (!segmentInfo.hasAppendedData_) {
      if (!segmentInfo.timingInfo && typeof segmentInfo.timestampOffset === "number") {
        this.isPendingTimestampOffset_ = true;
      }
      segmentInfo.timingInfo = {
        start: 0
      };
      segmentInfo.waitingOnAppends++;
      if (!this.isPendingTimestampOffset_) {
        this.updateSourceBufferTimestampOffset_(segmentInfo);
        this.processMetadataQueue_();
      }
      this.checkAppendsDone_(segmentInfo);
      return;
    }
    if (waitForVideo) {
      segmentInfo.waitingOnAppends++;
    }
    if (waitForAudio) {
      segmentInfo.waitingOnAppends++;
    }
    if (waitForVideo) {
      this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
    }
    if (waitForAudio) {
      this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
    }
  };
  _proto.checkAppendsDone_ = function checkAppendsDone_(segmentInfo) {
    if (this.checkForAbort_(segmentInfo.requestId)) {
      return;
    }
    segmentInfo.waitingOnAppends--;
    if (segmentInfo.waitingOnAppends === 0) {
      this.handleAppendsDone_();
    }
  };
  _proto.checkForIllegalMediaSwitch = function checkForIllegalMediaSwitch(trackInfo) {
    var illegalMediaSwitchError = illegalMediaSwitch(this.loaderType_, this.getCurrentMediaInfo_(), trackInfo);
    if (illegalMediaSwitchError) {
      this.error({
        message: illegalMediaSwitchError,
        blacklistDuration: Infinity
      });
      this.trigger("error");
      return true;
    }
    return false;
  };
  _proto.updateSourceBufferTimestampOffset_ = function updateSourceBufferTimestampOffset_(segmentInfo) {
    if (segmentInfo.timestampOffset === null || // we don't yet have the start for whatever media type (video or audio) has
    // priority, timing-wise, so we must wait
    typeof segmentInfo.timingInfo.start !== "number" || // already updated the timestamp offset for this segment
    segmentInfo.changedTimestampOffset || // the alt audio loader should not be responsible for setting the timestamp offset
    this.loaderType_ !== "main") {
      return;
    }
    var didChange = false;
    segmentInfo.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({
      videoTimingInfo: segmentInfo.segment.videoTimingInfo,
      audioTimingInfo: segmentInfo.segment.audioTimingInfo,
      timingInfo: segmentInfo.timingInfo
    });
    segmentInfo.changedTimestampOffset = true;
    if (segmentInfo.timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {
      this.sourceUpdater_.videoTimestampOffset(segmentInfo.timestampOffset);
      didChange = true;
    }
    if (segmentInfo.timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {
      this.sourceUpdater_.audioTimestampOffset(segmentInfo.timestampOffset);
      didChange = true;
    }
    if (didChange) {
      this.trigger("timestampoffset");
    }
  };
  _proto.getSegmentStartTimeForTimestampOffsetCalculation_ = function getSegmentStartTimeForTimestampOffsetCalculation_(_ref10) {
    var videoTimingInfo = _ref10.videoTimingInfo, audioTimingInfo = _ref10.audioTimingInfo, timingInfo = _ref10.timingInfo;
    if (!this.useDtsForTimestampOffset_) {
      return timingInfo.start;
    }
    if (videoTimingInfo && typeof videoTimingInfo.transmuxedDecodeStart === "number") {
      return videoTimingInfo.transmuxedDecodeStart;
    }
    if (audioTimingInfo && typeof audioTimingInfo.transmuxedDecodeStart === "number") {
      return audioTimingInfo.transmuxedDecodeStart;
    }
    return timingInfo.start;
  };
  _proto.updateTimingInfoEnd_ = function updateTimingInfoEnd_(segmentInfo) {
    segmentInfo.timingInfo = segmentInfo.timingInfo || {};
    var trackInfo = this.getMediaInfo_();
    var useVideoTimingInfo = this.loaderType_ === "main" && trackInfo && trackInfo.hasVideo;
    var prioritizedTimingInfo = useVideoTimingInfo && segmentInfo.videoTimingInfo ? segmentInfo.videoTimingInfo : segmentInfo.audioTimingInfo;
    if (!prioritizedTimingInfo) {
      return;
    }
    segmentInfo.timingInfo.end = typeof prioritizedTimingInfo.end === "number" ? (
      // End time may not exist in a case where we aren't parsing the full segment (one
      // current example is the case of fmp4), so use the rough duration to calculate an
      // end time.
      prioritizedTimingInfo.end
    ) : prioritizedTimingInfo.start + segmentInfo.duration;
  };
  _proto.handleAppendsDone_ = function handleAppendsDone_() {
    if (this.pendingSegment_) {
      this.trigger("appendsdone");
    }
    if (!this.pendingSegment_) {
      this.state = "READY";
      if (!this.paused()) {
        this.monitorBuffer_();
      }
      return;
    }
    var segmentInfo = this.pendingSegment_;
    this.updateTimingInfoEnd_(segmentInfo);
    if (this.shouldSaveSegmentTimingInfo_) {
      this.syncController_.saveSegmentTimingInfo({
        segmentInfo,
        shouldSaveTimelineMapping: this.loaderType_ === "main"
      });
    }
    var segmentDurationMessage = getTroublesomeSegmentDurationMessage(segmentInfo, this.sourceType_);
    if (segmentDurationMessage) {
      if (segmentDurationMessage.severity === "warn") {
        videojs.log.warn(segmentDurationMessage.message);
      } else {
        this.logger_(segmentDurationMessage.message);
      }
    }
    this.recordThroughput_(segmentInfo);
    this.pendingSegment_ = null;
    this.state = "READY";
    if (segmentInfo.isSyncRequest) {
      this.trigger("syncinfoupdate");
      if (!segmentInfo.hasAppendedData_) {
        this.logger_("Throwing away un-appended sync request " + segmentInfoString(segmentInfo));
        return;
      }
    }
    this.logger_("Appended " + segmentInfoString(segmentInfo));
    this.addSegmentMetadataCue_(segmentInfo);
    this.fetchAtBuffer_ = true;
    if (this.currentTimeline_ !== segmentInfo.timeline) {
      this.timelineChangeController_.lastTimelineChange({
        type: this.loaderType_,
        from: this.currentTimeline_,
        to: segmentInfo.timeline
      });
      if (this.loaderType_ === "main" && !this.audioDisabled_) {
        this.timelineChangeController_.lastTimelineChange({
          type: "audio",
          from: this.currentTimeline_,
          to: segmentInfo.timeline
        });
      }
    }
    this.currentTimeline_ = segmentInfo.timeline;
    this.trigger("syncinfoupdate");
    var segment = segmentInfo.segment;
    var part = segmentInfo.part;
    var badSegmentGuess = segment.end && this.currentTime_() - segment.end > segmentInfo.playlist.targetDuration * 3;
    var badPartGuess = part && part.end && this.currentTime_() - part.end > segmentInfo.playlist.partTargetDuration * 3;
    if (badSegmentGuess || badPartGuess) {
      this.logger_("bad " + (badSegmentGuess ? "segment" : "part") + " " + segmentInfoString(segmentInfo));
      this.resetEverything();
      return;
    }
    var isWalkingForward = this.mediaIndex !== null;
    if (isWalkingForward) {
      this.trigger("bandwidthupdate");
    }
    this.trigger("progress");
    this.mediaIndex = segmentInfo.mediaIndex;
    this.partIndex = segmentInfo.partIndex;
    if (this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex)) {
      this.endOfStream();
    }
    this.trigger("appended");
    if (segmentInfo.hasAppendedData_) {
      this.mediaAppends++;
    }
    if (!this.paused()) {
      this.monitorBuffer_();
    }
  };
  _proto.recordThroughput_ = function recordThroughput_(segmentInfo) {
    if (segmentInfo.duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
      this.logger_("Ignoring segment's throughput because its duration of " + segmentInfo.duration + (" is less than the min to record " + MIN_SEGMENT_DURATION_TO_SAVE_STATS));
      return;
    }
    var rate = this.throughput.rate;
    var segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1;
    var segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8 * 1e3);
    this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;
  };
  _proto.addSegmentMetadataCue_ = function addSegmentMetadataCue_(segmentInfo) {
    if (!this.segmentMetadataTrack_) {
      return;
    }
    var segment = segmentInfo.segment;
    var start2 = segment.start;
    var end = segment.end;
    if (!finite(start2) || !finite(end)) {
      return;
    }
    removeCuesFromTrack(start2, end, this.segmentMetadataTrack_);
    var Cue = import_window6.default.WebKitDataCue || import_window6.default.VTTCue;
    var value = {
      custom: segment.custom,
      dateTimeObject: segment.dateTimeObject,
      dateTimeString: segment.dateTimeString,
      bandwidth: segmentInfo.playlist.attributes.BANDWIDTH,
      resolution: segmentInfo.playlist.attributes.RESOLUTION,
      codecs: segmentInfo.playlist.attributes.CODECS,
      byteLength: segmentInfo.byteLength,
      uri: segmentInfo.uri,
      timeline: segmentInfo.timeline,
      playlist: segmentInfo.playlist.id,
      start: start2,
      end
    };
    var data = JSON.stringify(value);
    var cue = new Cue(start2, end, data);
    cue.value = value;
    this.segmentMetadataTrack_.addCue(cue);
  };
  return SegmentLoader2;
}(videojs.EventTarget);
function noop3() {
}
var toTitleCase2 = function toTitleCase3(string) {
  if (typeof string !== "string") {
    return string;
  }
  return string.replace(/./, function(w) {
    return w.toUpperCase();
  });
};
var bufferTypes = ["video", "audio"];
var _updating = function updating(type2, sourceUpdater) {
  var sourceBuffer = sourceUpdater[type2 + "Buffer"];
  return sourceBuffer && sourceBuffer.updating || sourceUpdater.queuePending[type2];
};
var nextQueueIndexOfType = function nextQueueIndexOfType2(type2, queue) {
  for (var i = 0; i < queue.length; i++) {
    var queueEntry = queue[i];
    if (queueEntry.type === "mediaSource") {
      return null;
    }
    if (queueEntry.type === type2) {
      return i;
    }
  }
  return null;
};
var shiftQueue = function shiftQueue2(type2, sourceUpdater) {
  if (sourceUpdater.queue.length === 0) {
    return;
  }
  var queueIndex = 0;
  var queueEntry = sourceUpdater.queue[queueIndex];
  if (queueEntry.type === "mediaSource") {
    if (!sourceUpdater.updating() && sourceUpdater.mediaSource.readyState !== "closed") {
      sourceUpdater.queue.shift();
      queueEntry.action(sourceUpdater);
      if (queueEntry.doneFn) {
        queueEntry.doneFn();
      }
      shiftQueue2("audio", sourceUpdater);
      shiftQueue2("video", sourceUpdater);
    }
    return;
  }
  if (type2 === "mediaSource") {
    return;
  }
  if (!sourceUpdater.ready() || sourceUpdater.mediaSource.readyState === "closed" || _updating(type2, sourceUpdater)) {
    return;
  }
  if (queueEntry.type !== type2) {
    queueIndex = nextQueueIndexOfType(type2, sourceUpdater.queue);
    if (queueIndex === null) {
      return;
    }
    queueEntry = sourceUpdater.queue[queueIndex];
  }
  sourceUpdater.queue.splice(queueIndex, 1);
  sourceUpdater.queuePending[type2] = queueEntry;
  queueEntry.action(type2, sourceUpdater);
  if (!queueEntry.doneFn) {
    sourceUpdater.queuePending[type2] = null;
    shiftQueue2(type2, sourceUpdater);
    return;
  }
};
var cleanupBuffer = function cleanupBuffer2(type2, sourceUpdater) {
  var buffer = sourceUpdater[type2 + "Buffer"];
  var titleType = toTitleCase2(type2);
  if (!buffer) {
    return;
  }
  buffer.removeEventListener("updateend", sourceUpdater["on" + titleType + "UpdateEnd_"]);
  buffer.removeEventListener("error", sourceUpdater["on" + titleType + "Error_"]);
  sourceUpdater.codecs[type2] = null;
  sourceUpdater[type2 + "Buffer"] = null;
};
var inSourceBuffers = function inSourceBuffers2(mediaSource, sourceBuffer) {
  return mediaSource && sourceBuffer && Array.prototype.indexOf.call(mediaSource.sourceBuffers, sourceBuffer) !== -1;
};
var actions = {
  appendBuffer: function appendBuffer(bytes, segmentInfo, onError2) {
    return function(type2, sourceUpdater) {
      var sourceBuffer = sourceUpdater[type2 + "Buffer"];
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_("Appending segment " + segmentInfo.mediaIndex + "'s " + bytes.length + " bytes to " + type2 + "Buffer");
      try {
        sourceBuffer.appendBuffer(bytes);
      } catch (e) {
        sourceUpdater.logger_("Error with code " + e.code + " " + (e.code === QUOTA_EXCEEDED_ERR ? "(QUOTA_EXCEEDED_ERR) " : "") + ("when appending segment " + segmentInfo.mediaIndex + " to " + type2 + "Buffer"));
        sourceUpdater.queuePending[type2] = null;
        onError2(e);
      }
    };
  },
  remove: function remove(start2, end) {
    return function(type2, sourceUpdater) {
      var sourceBuffer = sourceUpdater[type2 + "Buffer"];
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_("Removing " + start2 + " to " + end + " from " + type2 + "Buffer");
      try {
        sourceBuffer.remove(start2, end);
      } catch (e) {
        sourceUpdater.logger_("Remove " + start2 + " to " + end + " from " + type2 + "Buffer failed");
      }
    };
  },
  timestampOffset: function timestampOffset(offset) {
    return function(type2, sourceUpdater) {
      var sourceBuffer = sourceUpdater[type2 + "Buffer"];
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_("Setting " + type2 + "timestampOffset to " + offset);
      sourceBuffer.timestampOffset = offset;
    };
  },
  callback: function callback(_callback) {
    return function(type2, sourceUpdater) {
      _callback();
    };
  },
  endOfStream: function endOfStream(error) {
    return function(sourceUpdater) {
      if (sourceUpdater.mediaSource.readyState !== "open") {
        return;
      }
      sourceUpdater.logger_("Calling mediaSource endOfStream(" + (error || "") + ")");
      try {
        sourceUpdater.mediaSource.endOfStream(error);
      } catch (e) {
        videojs.log.warn("Failed to call media source endOfStream", e);
      }
    };
  },
  duration: function duration4(_duration) {
    return function(sourceUpdater) {
      sourceUpdater.logger_("Setting mediaSource duration to " + _duration);
      try {
        sourceUpdater.mediaSource.duration = _duration;
      } catch (e) {
        videojs.log.warn("Failed to set media source duration", e);
      }
    };
  },
  abort: function abort() {
    return function(type2, sourceUpdater) {
      if (sourceUpdater.mediaSource.readyState !== "open") {
        return;
      }
      var sourceBuffer = sourceUpdater[type2 + "Buffer"];
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_("calling abort on " + type2 + "Buffer");
      try {
        sourceBuffer.abort();
      } catch (e) {
        videojs.log.warn("Failed to abort on " + type2 + "Buffer", e);
      }
    };
  },
  addSourceBuffer: function addSourceBuffer(type2, codec) {
    return function(sourceUpdater) {
      var titleType = toTitleCase2(type2);
      var mime = getMimeForCodec(codec);
      sourceUpdater.logger_("Adding " + type2 + "Buffer with codec " + codec + " to mediaSource");
      var sourceBuffer = sourceUpdater.mediaSource.addSourceBuffer(mime);
      sourceBuffer.addEventListener("updateend", sourceUpdater["on" + titleType + "UpdateEnd_"]);
      sourceBuffer.addEventListener("error", sourceUpdater["on" + titleType + "Error_"]);
      sourceUpdater.codecs[type2] = codec;
      sourceUpdater[type2 + "Buffer"] = sourceBuffer;
    };
  },
  removeSourceBuffer: function removeSourceBuffer(type2) {
    return function(sourceUpdater) {
      var sourceBuffer = sourceUpdater[type2 + "Buffer"];
      cleanupBuffer(type2, sourceUpdater);
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_("Removing " + type2 + "Buffer with codec " + sourceUpdater.codecs[type2] + " from mediaSource");
      try {
        sourceUpdater.mediaSource.removeSourceBuffer(sourceBuffer);
      } catch (e) {
        videojs.log.warn("Failed to removeSourceBuffer " + type2 + "Buffer", e);
      }
    };
  },
  changeType: function changeType(codec) {
    return function(type2, sourceUpdater) {
      var sourceBuffer = sourceUpdater[type2 + "Buffer"];
      var mime = getMimeForCodec(codec);
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      if (sourceUpdater.codecs[type2] === codec) {
        return;
      }
      sourceUpdater.logger_("changing " + type2 + "Buffer codec from " + sourceUpdater.codecs[type2] + " to " + codec);
      sourceBuffer.changeType(mime);
      sourceUpdater.codecs[type2] = codec;
    };
  }
};
var pushQueue = function pushQueue2(_ref) {
  var type2 = _ref.type, sourceUpdater = _ref.sourceUpdater, action = _ref.action, doneFn = _ref.doneFn, name = _ref.name;
  sourceUpdater.queue.push({
    type: type2,
    action,
    doneFn,
    name
  });
  shiftQueue(type2, sourceUpdater);
};
var onUpdateend = function onUpdateend2(type2, sourceUpdater) {
  return function(e) {
    if (sourceUpdater.queuePending[type2]) {
      var doneFn = sourceUpdater.queuePending[type2].doneFn;
      sourceUpdater.queuePending[type2] = null;
      if (doneFn) {
        doneFn(sourceUpdater[type2 + "Error_"]);
      }
    }
    shiftQueue(type2, sourceUpdater);
  };
};
var SourceUpdater = /* @__PURE__ */ function(_videojs$EventTarget) {
  _inheritsLoose(SourceUpdater2, _videojs$EventTarget);
  function SourceUpdater2(mediaSource) {
    var _this;
    _this = _videojs$EventTarget.call(this) || this;
    _this.mediaSource = mediaSource;
    _this.sourceopenListener_ = function() {
      return shiftQueue("mediaSource", _assertThisInitialized(_this));
    };
    _this.mediaSource.addEventListener("sourceopen", _this.sourceopenListener_);
    _this.logger_ = logger2("SourceUpdater");
    _this.audioTimestampOffset_ = 0;
    _this.videoTimestampOffset_ = 0;
    _this.queue = [];
    _this.queuePending = {
      audio: null,
      video: null
    };
    _this.delayedAudioAppendQueue_ = [];
    _this.videoAppendQueued_ = false;
    _this.codecs = {};
    _this.onVideoUpdateEnd_ = onUpdateend("video", _assertThisInitialized(_this));
    _this.onAudioUpdateEnd_ = onUpdateend("audio", _assertThisInitialized(_this));
    _this.onVideoError_ = function(e) {
      _this.videoError_ = e;
    };
    _this.onAudioError_ = function(e) {
      _this.audioError_ = e;
    };
    _this.createdSourceBuffers_ = false;
    _this.initializedEme_ = false;
    _this.triggeredReady_ = false;
    return _this;
  }
  var _proto = SourceUpdater2.prototype;
  _proto.initializedEme = function initializedEme() {
    this.initializedEme_ = true;
    this.triggerReady();
  };
  _proto.hasCreatedSourceBuffers = function hasCreatedSourceBuffers() {
    return this.createdSourceBuffers_;
  };
  _proto.hasInitializedAnyEme = function hasInitializedAnyEme() {
    return this.initializedEme_;
  };
  _proto.ready = function ready() {
    return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();
  };
  _proto.createSourceBuffers = function createSourceBuffers(codecs) {
    if (this.hasCreatedSourceBuffers()) {
      return;
    }
    this.addOrChangeSourceBuffers(codecs);
    this.createdSourceBuffers_ = true;
    this.trigger("createdsourcebuffers");
    this.triggerReady();
  };
  _proto.triggerReady = function triggerReady() {
    if (this.ready() && !this.triggeredReady_) {
      this.triggeredReady_ = true;
      this.trigger("ready");
    }
  };
  _proto.addSourceBuffer = function addSourceBuffer2(type2, codec) {
    pushQueue({
      type: "mediaSource",
      sourceUpdater: this,
      action: actions.addSourceBuffer(type2, codec),
      name: "addSourceBuffer"
    });
  };
  _proto.abort = function abort2(type2) {
    pushQueue({
      type: type2,
      sourceUpdater: this,
      action: actions.abort(type2),
      name: "abort"
    });
  };
  _proto.removeSourceBuffer = function removeSourceBuffer2(type2) {
    if (!this.canRemoveSourceBuffer()) {
      videojs.log.error("removeSourceBuffer is not supported!");
      return;
    }
    pushQueue({
      type: "mediaSource",
      sourceUpdater: this,
      action: actions.removeSourceBuffer(type2),
      name: "removeSourceBuffer"
    });
  };
  _proto.canRemoveSourceBuffer = function canRemoveSourceBuffer() {
    return !videojs.browser.IE_VERSION && !videojs.browser.IS_FIREFOX && import_window6.default.MediaSource && import_window6.default.MediaSource.prototype && typeof import_window6.default.MediaSource.prototype.removeSourceBuffer === "function";
  };
  SourceUpdater2.canChangeType = function canChangeType() {
    return import_window6.default.SourceBuffer && import_window6.default.SourceBuffer.prototype && typeof import_window6.default.SourceBuffer.prototype.changeType === "function";
  };
  _proto.canChangeType = function canChangeType() {
    return this.constructor.canChangeType();
  };
  _proto.changeType = function changeType2(type2, codec) {
    if (!this.canChangeType()) {
      videojs.log.error("changeType is not supported!");
      return;
    }
    pushQueue({
      type: type2,
      sourceUpdater: this,
      action: actions.changeType(codec),
      name: "changeType"
    });
  };
  _proto.addOrChangeSourceBuffers = function addOrChangeSourceBuffers(codecs) {
    var _this2 = this;
    if (!codecs || typeof codecs !== "object" || Object.keys(codecs).length === 0) {
      throw new Error("Cannot addOrChangeSourceBuffers to undefined codecs");
    }
    Object.keys(codecs).forEach(function(type2) {
      var codec = codecs[type2];
      if (!_this2.hasCreatedSourceBuffers()) {
        return _this2.addSourceBuffer(type2, codec);
      }
      if (_this2.canChangeType()) {
        _this2.changeType(type2, codec);
      }
    });
  };
  _proto.appendBuffer = function appendBuffer2(options, doneFn) {
    var _this3 = this;
    var segmentInfo = options.segmentInfo, type2 = options.type, bytes = options.bytes;
    this.processedAppend_ = true;
    if (type2 === "audio" && this.videoBuffer && !this.videoAppendQueued_) {
      this.delayedAudioAppendQueue_.push([options, doneFn]);
      this.logger_("delayed audio append of " + bytes.length + " until video append");
      return;
    }
    var onError2 = doneFn;
    pushQueue({
      type: type2,
      sourceUpdater: this,
      action: actions.appendBuffer(bytes, segmentInfo || {
        mediaIndex: -1
      }, onError2),
      doneFn,
      name: "appendBuffer"
    });
    if (type2 === "video") {
      this.videoAppendQueued_ = true;
      if (!this.delayedAudioAppendQueue_.length) {
        return;
      }
      var queue = this.delayedAudioAppendQueue_.slice();
      this.logger_("queuing delayed audio " + queue.length + " appendBuffers");
      this.delayedAudioAppendQueue_.length = 0;
      queue.forEach(function(que) {
        _this3.appendBuffer.apply(_this3, que);
      });
    }
  };
  _proto.audioBuffered = function audioBuffered() {
    if (!inSourceBuffers(this.mediaSource, this.audioBuffer)) {
      return videojs.createTimeRange();
    }
    return this.audioBuffer.buffered ? this.audioBuffer.buffered : videojs.createTimeRange();
  };
  _proto.videoBuffered = function videoBuffered() {
    if (!inSourceBuffers(this.mediaSource, this.videoBuffer)) {
      return videojs.createTimeRange();
    }
    return this.videoBuffer.buffered ? this.videoBuffer.buffered : videojs.createTimeRange();
  };
  _proto.buffered = function buffered() {
    var video = inSourceBuffers(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null;
    var audio = inSourceBuffers(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;
    if (audio && !video) {
      return this.audioBuffered();
    }
    if (video && !audio) {
      return this.videoBuffered();
    }
    return bufferIntersection(this.audioBuffered(), this.videoBuffered());
  };
  _proto.setDuration = function setDuration(duration5, doneFn) {
    if (doneFn === void 0) {
      doneFn = noop3;
    }
    pushQueue({
      type: "mediaSource",
      sourceUpdater: this,
      action: actions.duration(duration5),
      name: "duration",
      doneFn
    });
  };
  _proto.endOfStream = function endOfStream2(error, doneFn) {
    if (error === void 0) {
      error = null;
    }
    if (doneFn === void 0) {
      doneFn = noop3;
    }
    if (typeof error !== "string") {
      error = void 0;
    }
    pushQueue({
      type: "mediaSource",
      sourceUpdater: this,
      action: actions.endOfStream(error),
      name: "endOfStream",
      doneFn
    });
  };
  _proto.removeAudio = function removeAudio(start2, end, done) {
    if (done === void 0) {
      done = noop3;
    }
    if (!this.audioBuffered().length || this.audioBuffered().end(0) === 0) {
      done();
      return;
    }
    pushQueue({
      type: "audio",
      sourceUpdater: this,
      action: actions.remove(start2, end),
      doneFn: done,
      name: "remove"
    });
  };
  _proto.removeVideo = function removeVideo(start2, end, done) {
    if (done === void 0) {
      done = noop3;
    }
    if (!this.videoBuffered().length || this.videoBuffered().end(0) === 0) {
      done();
      return;
    }
    pushQueue({
      type: "video",
      sourceUpdater: this,
      action: actions.remove(start2, end),
      doneFn: done,
      name: "remove"
    });
  };
  _proto.updating = function updating2() {
    if (_updating("audio", this) || _updating("video", this)) {
      return true;
    }
    return false;
  };
  _proto.audioTimestampOffset = function audioTimestampOffset(offset) {
    if (typeof offset !== "undefined" && this.audioBuffer && // no point in updating if it's the same
    this.audioTimestampOffset_ !== offset) {
      pushQueue({
        type: "audio",
        sourceUpdater: this,
        action: actions.timestampOffset(offset),
        name: "timestampOffset"
      });
      this.audioTimestampOffset_ = offset;
    }
    return this.audioTimestampOffset_;
  };
  _proto.videoTimestampOffset = function videoTimestampOffset(offset) {
    if (typeof offset !== "undefined" && this.videoBuffer && // no point in updating if it's the same
    this.videoTimestampOffset !== offset) {
      pushQueue({
        type: "video",
        sourceUpdater: this,
        action: actions.timestampOffset(offset),
        name: "timestampOffset"
      });
      this.videoTimestampOffset_ = offset;
    }
    return this.videoTimestampOffset_;
  };
  _proto.audioQueueCallback = function audioQueueCallback(callback2) {
    if (!this.audioBuffer) {
      return;
    }
    pushQueue({
      type: "audio",
      sourceUpdater: this,
      action: actions.callback(callback2),
      name: "callback"
    });
  };
  _proto.videoQueueCallback = function videoQueueCallback(callback2) {
    if (!this.videoBuffer) {
      return;
    }
    pushQueue({
      type: "video",
      sourceUpdater: this,
      action: actions.callback(callback2),
      name: "callback"
    });
  };
  _proto.dispose = function dispose() {
    var _this4 = this;
    this.trigger("dispose");
    bufferTypes.forEach(function(type2) {
      _this4.abort(type2);
      if (_this4.canRemoveSourceBuffer()) {
        _this4.removeSourceBuffer(type2);
      } else {
        _this4[type2 + "QueueCallback"](function() {
          return cleanupBuffer(type2, _this4);
        });
      }
    });
    this.videoAppendQueued_ = false;
    this.delayedAudioAppendQueue_.length = 0;
    if (this.sourceopenListener_) {
      this.mediaSource.removeEventListener("sourceopen", this.sourceopenListener_);
    }
    this.off();
  };
  return SourceUpdater2;
}(videojs.EventTarget);
var uint8ToUtf8 = function uint8ToUtf82(uintArray) {
  return decodeURIComponent(escape(String.fromCharCode.apply(null, uintArray)));
};
var VTT_LINE_TERMINATORS = new Uint8Array("\n\n".split("").map(function(_char3) {
  return _char3.charCodeAt(0);
}));
var VTTSegmentLoader = /* @__PURE__ */ function(_SegmentLoader) {
  _inheritsLoose(VTTSegmentLoader2, _SegmentLoader);
  function VTTSegmentLoader2(settings, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _SegmentLoader.call(this, settings, options) || this;
    _this.mediaSource_ = null;
    _this.subtitlesTrack_ = null;
    _this.loaderType_ = "subtitle";
    _this.featuresNativeTextTracks_ = settings.featuresNativeTextTracks;
    _this.shouldSaveSegmentTimingInfo_ = false;
    return _this;
  }
  var _proto = VTTSegmentLoader2.prototype;
  _proto.createTransmuxer_ = function createTransmuxer_() {
    return null;
  };
  _proto.buffered_ = function buffered_() {
    if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length) {
      return videojs.createTimeRanges();
    }
    var cues = this.subtitlesTrack_.cues;
    var start2 = cues[0].startTime;
    var end = cues[cues.length - 1].startTime;
    return videojs.createTimeRanges([[start2, end]]);
  };
  _proto.initSegmentForMap = function initSegmentForMap(map, set4) {
    if (set4 === void 0) {
      set4 = false;
    }
    if (!map) {
      return null;
    }
    var id = initSegmentId(map);
    var storedMap = this.initSegments_[id];
    if (set4 && !storedMap && map.bytes) {
      var combinedByteLength = VTT_LINE_TERMINATORS.byteLength + map.bytes.byteLength;
      var combinedSegment = new Uint8Array(combinedByteLength);
      combinedSegment.set(map.bytes);
      combinedSegment.set(VTT_LINE_TERMINATORS, map.bytes.byteLength);
      this.initSegments_[id] = storedMap = {
        resolvedUri: map.resolvedUri,
        byterange: map.byterange,
        bytes: combinedSegment
      };
    }
    return storedMap || map;
  };
  _proto.couldBeginLoading_ = function couldBeginLoading_() {
    return this.playlist_ && this.subtitlesTrack_ && !this.paused();
  };
  _proto.init_ = function init_() {
    this.state = "READY";
    this.resetEverything();
    return this.monitorBuffer_();
  };
  _proto.track = function track(_track) {
    if (typeof _track === "undefined") {
      return this.subtitlesTrack_;
    }
    this.subtitlesTrack_ = _track;
    if (this.state === "INIT" && this.couldBeginLoading_()) {
      this.init_();
    }
    return this.subtitlesTrack_;
  };
  _proto.remove = function remove2(start2, end) {
    removeCuesFromTrack(start2, end, this.subtitlesTrack_);
  };
  _proto.fillBuffer_ = function fillBuffer_() {
    var _this2 = this;
    var segmentInfo = this.chooseNextRequest_();
    if (!segmentInfo) {
      return;
    }
    if (this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline) === null) {
      var checkTimestampOffset = function checkTimestampOffset2() {
        _this2.state = "READY";
        if (!_this2.paused()) {
          _this2.monitorBuffer_();
        }
      };
      this.syncController_.one("timestampoffset", checkTimestampOffset);
      this.state = "WAITING_ON_TIMELINE";
      return;
    }
    this.loadSegment_(segmentInfo);
  };
  _proto.timestampOffsetForSegment_ = function timestampOffsetForSegment_() {
    return null;
  };
  _proto.chooseNextRequest_ = function chooseNextRequest_() {
    return this.skipEmptySegments_(_SegmentLoader.prototype.chooseNextRequest_.call(this));
  };
  _proto.skipEmptySegments_ = function skipEmptySegments_(segmentInfo) {
    while (segmentInfo && segmentInfo.segment.empty) {
      if (segmentInfo.mediaIndex + 1 >= segmentInfo.playlist.segments.length) {
        segmentInfo = null;
        break;
      }
      segmentInfo = this.generateSegmentInfo_({
        playlist: segmentInfo.playlist,
        mediaIndex: segmentInfo.mediaIndex + 1,
        startOfSegment: segmentInfo.startOfSegment + segmentInfo.duration,
        isSyncRequest: segmentInfo.isSyncRequest
      });
    }
    return segmentInfo;
  };
  _proto.stopForError = function stopForError(error) {
    this.error(error);
    this.state = "READY";
    this.pause();
    this.trigger("error");
  };
  _proto.segmentRequestFinished_ = function segmentRequestFinished_(error, simpleSegment, result) {
    var _this3 = this;
    if (!this.subtitlesTrack_) {
      this.state = "READY";
      return;
    }
    this.saveTransferStats_(simpleSegment.stats);
    if (!this.pendingSegment_) {
      this.state = "READY";
      this.mediaRequestsAborted += 1;
      return;
    }
    if (error) {
      if (error.code === REQUEST_ERRORS.TIMEOUT) {
        this.handleTimeout_();
      }
      if (error.code === REQUEST_ERRORS.ABORTED) {
        this.mediaRequestsAborted += 1;
      } else {
        this.mediaRequestsErrored += 1;
      }
      this.stopForError(error);
      return;
    }
    var segmentInfo = this.pendingSegment_;
    this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);
    if (simpleSegment.key) {
      this.segmentKey(simpleSegment.key, true);
    }
    this.state = "APPENDING";
    this.trigger("appending");
    var segment = segmentInfo.segment;
    if (segment.map) {
      segment.map.bytes = simpleSegment.map.bytes;
    }
    segmentInfo.bytes = simpleSegment.bytes;
    if (typeof import_window6.default.WebVTT !== "function" && this.subtitlesTrack_ && this.subtitlesTrack_.tech_) {
      var loadHandler;
      var errorHandler = function errorHandler2() {
        _this3.subtitlesTrack_.tech_.off("vttjsloaded", loadHandler);
        _this3.stopForError({
          message: "Error loading vtt.js"
        });
        return;
      };
      loadHandler = function loadHandler2() {
        _this3.subtitlesTrack_.tech_.off("vttjserror", errorHandler);
        _this3.segmentRequestFinished_(error, simpleSegment, result);
      };
      this.state = "WAITING_ON_VTTJS";
      this.subtitlesTrack_.tech_.one("vttjsloaded", loadHandler);
      this.subtitlesTrack_.tech_.one("vttjserror", errorHandler);
      return;
    }
    segment.requested = true;
    try {
      this.parseVTTCues_(segmentInfo);
    } catch (e) {
      this.stopForError({
        message: e.message
      });
      return;
    }
    this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_);
    if (segmentInfo.cues.length) {
      segmentInfo.timingInfo = {
        start: segmentInfo.cues[0].startTime,
        end: segmentInfo.cues[segmentInfo.cues.length - 1].endTime
      };
    } else {
      segmentInfo.timingInfo = {
        start: segmentInfo.startOfSegment,
        end: segmentInfo.startOfSegment + segmentInfo.duration
      };
    }
    if (segmentInfo.isSyncRequest) {
      this.trigger("syncinfoupdate");
      this.pendingSegment_ = null;
      this.state = "READY";
      return;
    }
    segmentInfo.byteLength = segmentInfo.bytes.byteLength;
    this.mediaSecondsLoaded += segment.duration;
    segmentInfo.cues.forEach(function(cue) {
      _this3.subtitlesTrack_.addCue(_this3.featuresNativeTextTracks_ ? new import_window6.default.VTTCue(cue.startTime, cue.endTime, cue.text) : cue);
    });
    removeDuplicateCuesFromTrack(this.subtitlesTrack_);
    this.handleAppendsDone_();
  };
  _proto.handleData_ = function handleData_3() {
  };
  _proto.updateTimingInfoEnd_ = function updateTimingInfoEnd_() {
  };
  _proto.parseVTTCues_ = function parseVTTCues_(segmentInfo) {
    var decoder2;
    var decodeBytesToString = false;
    if (typeof import_window6.default.TextDecoder === "function") {
      decoder2 = new import_window6.default.TextDecoder("utf8");
    } else {
      decoder2 = import_window6.default.WebVTT.StringDecoder();
      decodeBytesToString = true;
    }
    var parser6 = new import_window6.default.WebVTT.Parser(import_window6.default, import_window6.default.vttjs, decoder2);
    segmentInfo.cues = [];
    segmentInfo.timestampmap = {
      MPEGTS: 0,
      LOCAL: 0
    };
    parser6.oncue = segmentInfo.cues.push.bind(segmentInfo.cues);
    parser6.ontimestampmap = function(map) {
      segmentInfo.timestampmap = map;
    };
    parser6.onparsingerror = function(error) {
      videojs.log.warn("Error encountered when parsing cues: " + error.message);
    };
    if (segmentInfo.segment.map) {
      var mapData = segmentInfo.segment.map.bytes;
      if (decodeBytesToString) {
        mapData = uint8ToUtf8(mapData);
      }
      parser6.parse(mapData);
    }
    var segmentData = segmentInfo.bytes;
    if (decodeBytesToString) {
      segmentData = uint8ToUtf8(segmentData);
    }
    parser6.parse(segmentData);
    parser6.flush();
  };
  _proto.updateTimeMapping_ = function updateTimeMapping_(segmentInfo, mappingObj, playlist) {
    var segment = segmentInfo.segment;
    if (!mappingObj) {
      return;
    }
    if (!segmentInfo.cues.length) {
      segment.empty = true;
      return;
    }
    var timestampmap = segmentInfo.timestampmap;
    var diff = timestampmap.MPEGTS / import_clock.ONE_SECOND_IN_TS - timestampmap.LOCAL + mappingObj.mapping;
    segmentInfo.cues.forEach(function(cue) {
      cue.startTime += diff;
      cue.endTime += diff;
    });
    if (!playlist.syncInfo) {
      var firstStart = segmentInfo.cues[0].startTime;
      var lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;
      playlist.syncInfo = {
        mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,
        time: Math.min(firstStart, lastStart - segment.duration)
      };
    }
  };
  return VTTSegmentLoader2;
}(SegmentLoader);
var findAdCue = function findAdCue2(track, mediaTime) {
  var cues = track.cues;
  for (var i = 0; i < cues.length; i++) {
    var cue = cues[i];
    if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) {
      return cue;
    }
  }
  return null;
};
var updateAdCues = function updateAdCues2(media, track, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  if (!media.segments) {
    return;
  }
  var mediaTime = offset;
  var cue;
  for (var i = 0; i < media.segments.length; i++) {
    var segment = media.segments[i];
    if (!cue) {
      cue = findAdCue(track, mediaTime + segment.duration / 2);
    }
    if (cue) {
      if ("cueIn" in segment) {
        cue.endTime = mediaTime;
        cue.adEndTime = mediaTime;
        mediaTime += segment.duration;
        cue = null;
        continue;
      }
      if (mediaTime < cue.endTime) {
        mediaTime += segment.duration;
        continue;
      }
      cue.endTime += segment.duration;
    } else {
      if ("cueOut" in segment) {
        cue = new import_window6.default.VTTCue(mediaTime, mediaTime + segment.duration, segment.cueOut);
        cue.adStartTime = mediaTime;
        cue.adEndTime = mediaTime + parseFloat(segment.cueOut);
        track.addCue(cue);
      }
      if ("cueOutCont" in segment) {
        var _segment$cueOutCont$s = segment.cueOutCont.split("/").map(parseFloat), adOffset = _segment$cueOutCont$s[0], adTotal = _segment$cueOutCont$s[1];
        cue = new import_window6.default.VTTCue(mediaTime, mediaTime + segment.duration, "");
        cue.adStartTime = mediaTime - adOffset;
        cue.adEndTime = cue.adStartTime + adTotal;
        track.addCue(cue);
      }
    }
    mediaTime += segment.duration;
  }
};
var MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC = 86400;
var syncPointStrategies = [
  // Stategy "VOD": Handle the VOD-case where the sync-point is *always*
  //                the equivalence display-time 0 === segment-index 0
  {
    name: "VOD",
    run: function run(syncController, playlist, duration5, currentTimeline, currentTime) {
      if (duration5 !== Infinity) {
        var syncPoint = {
          time: 0,
          segmentIndex: 0,
          partIndex: null
        };
        return syncPoint;
      }
      return null;
    }
  },
  // Stategy "ProgramDateTime": We have a program-date-time tag in this playlist
  {
    name: "ProgramDateTime",
    run: function run2(syncController, playlist, duration5, currentTimeline, currentTime) {
      if (!Object.keys(syncController.timelineToDatetimeMappings).length) {
        return null;
      }
      var syncPoint = null;
      var lastDistance = null;
      var partsAndSegments = getPartsAndSegments(playlist);
      currentTime = currentTime || 0;
      for (var i = 0; i < partsAndSegments.length; i++) {
        var index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);
        var partAndSegment = partsAndSegments[index];
        var segment = partAndSegment.segment;
        var datetimeMapping = syncController.timelineToDatetimeMappings[segment.timeline];
        if (!datetimeMapping || !segment.dateTimeObject) {
          continue;
        }
        var segmentTime = segment.dateTimeObject.getTime() / 1e3;
        var start2 = segmentTime + datetimeMapping;
        if (segment.parts && typeof partAndSegment.partIndex === "number") {
          for (var z = 0; z < partAndSegment.partIndex; z++) {
            start2 += segment.parts[z].duration;
          }
        }
        var distance = Math.abs(currentTime - start2);
        if (lastDistance !== null && (distance === 0 || lastDistance < distance)) {
          break;
        }
        lastDistance = distance;
        syncPoint = {
          time: start2,
          segmentIndex: partAndSegment.segmentIndex,
          partIndex: partAndSegment.partIndex
        };
      }
      return syncPoint;
    }
  },
  // Stategy "Segment": We have a known time mapping for a timeline and a
  //                    segment in the current timeline with timing data
  {
    name: "Segment",
    run: function run3(syncController, playlist, duration5, currentTimeline, currentTime) {
      var syncPoint = null;
      var lastDistance = null;
      currentTime = currentTime || 0;
      var partsAndSegments = getPartsAndSegments(playlist);
      for (var i = 0; i < partsAndSegments.length; i++) {
        var index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);
        var partAndSegment = partsAndSegments[index];
        var segment = partAndSegment.segment;
        var start2 = partAndSegment.part && partAndSegment.part.start || segment && segment.start;
        if (segment.timeline === currentTimeline && typeof start2 !== "undefined") {
          var distance = Math.abs(currentTime - start2);
          if (lastDistance !== null && lastDistance < distance) {
            break;
          }
          if (!syncPoint || lastDistance === null || lastDistance >= distance) {
            lastDistance = distance;
            syncPoint = {
              time: start2,
              segmentIndex: partAndSegment.segmentIndex,
              partIndex: partAndSegment.partIndex
            };
          }
        }
      }
      return syncPoint;
    }
  },
  // Stategy "Discontinuity": We have a discontinuity with a known
  //                          display-time
  {
    name: "Discontinuity",
    run: function run4(syncController, playlist, duration5, currentTimeline, currentTime) {
      var syncPoint = null;
      currentTime = currentTime || 0;
      if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {
        var lastDistance = null;
        for (var i = 0; i < playlist.discontinuityStarts.length; i++) {
          var segmentIndex = playlist.discontinuityStarts[i];
          var discontinuity = playlist.discontinuitySequence + i + 1;
          var discontinuitySync = syncController.discontinuities[discontinuity];
          if (discontinuitySync) {
            var distance = Math.abs(currentTime - discontinuitySync.time);
            if (lastDistance !== null && lastDistance < distance) {
              break;
            }
            if (!syncPoint || lastDistance === null || lastDistance >= distance) {
              lastDistance = distance;
              syncPoint = {
                time: discontinuitySync.time,
                segmentIndex,
                partIndex: null
              };
            }
          }
        }
      }
      return syncPoint;
    }
  },
  // Stategy "Playlist": We have a playlist with a known mapping of
  //                     segment index to display time
  {
    name: "Playlist",
    run: function run5(syncController, playlist, duration5, currentTimeline, currentTime) {
      if (playlist.syncInfo) {
        var syncPoint = {
          time: playlist.syncInfo.time,
          segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence,
          partIndex: null
        };
        return syncPoint;
      }
      return null;
    }
  }
];
var SyncController = /* @__PURE__ */ function(_videojs$EventTarget) {
  _inheritsLoose(SyncController2, _videojs$EventTarget);
  function SyncController2(options) {
    var _this;
    _this = _videojs$EventTarget.call(this) || this;
    _this.timelines = [];
    _this.discontinuities = [];
    _this.timelineToDatetimeMappings = {};
    _this.logger_ = logger2("SyncController");
    return _this;
  }
  var _proto = SyncController2.prototype;
  _proto.getSyncPoint = function getSyncPoint(playlist, duration5, currentTimeline, currentTime) {
    var syncPoints = this.runStrategies_(playlist, duration5, currentTimeline, currentTime);
    if (!syncPoints.length) {
      return null;
    }
    return this.selectSyncPoint_(syncPoints, {
      key: "time",
      value: currentTime
    });
  };
  _proto.getExpiredTime = function getExpiredTime(playlist, duration5) {
    if (!playlist || !playlist.segments) {
      return null;
    }
    var syncPoints = this.runStrategies_(playlist, duration5, playlist.discontinuitySequence, 0);
    if (!syncPoints.length) {
      return null;
    }
    var syncPoint = this.selectSyncPoint_(syncPoints, {
      key: "segmentIndex",
      value: 0
    });
    if (syncPoint.segmentIndex > 0) {
      syncPoint.time *= -1;
    }
    return Math.abs(syncPoint.time + sumDurations({
      defaultDuration: playlist.targetDuration,
      durationList: playlist.segments,
      startIndex: syncPoint.segmentIndex,
      endIndex: 0
    }));
  };
  _proto.runStrategies_ = function runStrategies_(playlist, duration5, currentTimeline, currentTime) {
    var syncPoints = [];
    for (var i = 0; i < syncPointStrategies.length; i++) {
      var strategy = syncPointStrategies[i];
      var syncPoint = strategy.run(this, playlist, duration5, currentTimeline, currentTime);
      if (syncPoint) {
        syncPoint.strategy = strategy.name;
        syncPoints.push({
          strategy: strategy.name,
          syncPoint
        });
      }
    }
    return syncPoints;
  };
  _proto.selectSyncPoint_ = function selectSyncPoint_(syncPoints, target) {
    var bestSyncPoint = syncPoints[0].syncPoint;
    var bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value);
    var bestStrategy = syncPoints[0].strategy;
    for (var i = 1; i < syncPoints.length; i++) {
      var newDistance = Math.abs(syncPoints[i].syncPoint[target.key] - target.value);
      if (newDistance < bestDistance) {
        bestDistance = newDistance;
        bestSyncPoint = syncPoints[i].syncPoint;
        bestStrategy = syncPoints[i].strategy;
      }
    }
    this.logger_("syncPoint for [" + target.key + ": " + target.value + "] chosen with strategy" + (" [" + bestStrategy + "]: [time:" + bestSyncPoint.time + ",") + (" segmentIndex:" + bestSyncPoint.segmentIndex) + (typeof bestSyncPoint.partIndex === "number" ? ",partIndex:" + bestSyncPoint.partIndex : "") + "]");
    return bestSyncPoint;
  };
  _proto.saveExpiredSegmentInfo = function saveExpiredSegmentInfo(oldPlaylist, newPlaylist) {
    var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
    if (mediaSequenceDiff > MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC) {
      videojs.log.warn("Not saving expired segment info. Media sequence gap " + mediaSequenceDiff + " is too large.");
      return;
    }
    for (var i = mediaSequenceDiff - 1; i >= 0; i--) {
      var lastRemovedSegment = oldPlaylist.segments[i];
      if (lastRemovedSegment && typeof lastRemovedSegment.start !== "undefined") {
        newPlaylist.syncInfo = {
          mediaSequence: oldPlaylist.mediaSequence + i,
          time: lastRemovedSegment.start
        };
        this.logger_("playlist refresh sync: [time:" + newPlaylist.syncInfo.time + "," + (" mediaSequence: " + newPlaylist.syncInfo.mediaSequence + "]"));
        this.trigger("syncinfoupdate");
        break;
      }
    }
  };
  _proto.setDateTimeMappingForStart = function setDateTimeMappingForStart(playlist) {
    this.timelineToDatetimeMappings = {};
    if (playlist.segments && playlist.segments.length && playlist.segments[0].dateTimeObject) {
      var firstSegment = playlist.segments[0];
      var playlistTimestamp = firstSegment.dateTimeObject.getTime() / 1e3;
      this.timelineToDatetimeMappings[firstSegment.timeline] = -playlistTimestamp;
    }
  };
  _proto.saveSegmentTimingInfo = function saveSegmentTimingInfo(_ref) {
    var segmentInfo = _ref.segmentInfo, shouldSaveTimelineMapping = _ref.shouldSaveTimelineMapping;
    var didCalculateSegmentTimeMapping = this.calculateSegmentTimeMapping_(segmentInfo, segmentInfo.timingInfo, shouldSaveTimelineMapping);
    var segment = segmentInfo.segment;
    if (didCalculateSegmentTimeMapping) {
      this.saveDiscontinuitySyncInfo_(segmentInfo);
      if (!segmentInfo.playlist.syncInfo) {
        segmentInfo.playlist.syncInfo = {
          mediaSequence: segmentInfo.playlist.mediaSequence + segmentInfo.mediaIndex,
          time: segment.start
        };
      }
    }
    var dateTime = segment.dateTimeObject;
    if (segment.discontinuity && shouldSaveTimelineMapping && dateTime) {
      this.timelineToDatetimeMappings[segment.timeline] = -(dateTime.getTime() / 1e3);
    }
  };
  _proto.timestampOffsetForTimeline = function timestampOffsetForTimeline(timeline) {
    if (typeof this.timelines[timeline] === "undefined") {
      return null;
    }
    return this.timelines[timeline].time;
  };
  _proto.mappingForTimeline = function mappingForTimeline(timeline) {
    if (typeof this.timelines[timeline] === "undefined") {
      return null;
    }
    return this.timelines[timeline].mapping;
  };
  _proto.calculateSegmentTimeMapping_ = function calculateSegmentTimeMapping_(segmentInfo, timingInfo, shouldSaveTimelineMapping) {
    var segment = segmentInfo.segment;
    var part = segmentInfo.part;
    var mappingObj = this.timelines[segmentInfo.timeline];
    var start2;
    var end;
    if (typeof segmentInfo.timestampOffset === "number") {
      mappingObj = {
        time: segmentInfo.startOfSegment,
        mapping: segmentInfo.startOfSegment - timingInfo.start
      };
      if (shouldSaveTimelineMapping) {
        this.timelines[segmentInfo.timeline] = mappingObj;
        this.trigger("timestampoffset");
        this.logger_("time mapping for timeline " + segmentInfo.timeline + ": " + ("[time: " + mappingObj.time + "] [mapping: " + mappingObj.mapping + "]"));
      }
      start2 = segmentInfo.startOfSegment;
      end = timingInfo.end + mappingObj.mapping;
    } else if (mappingObj) {
      start2 = timingInfo.start + mappingObj.mapping;
      end = timingInfo.end + mappingObj.mapping;
    } else {
      return false;
    }
    if (part) {
      part.start = start2;
      part.end = end;
    }
    if (!segment.start || start2 < segment.start) {
      segment.start = start2;
    }
    segment.end = end;
    return true;
  };
  _proto.saveDiscontinuitySyncInfo_ = function saveDiscontinuitySyncInfo_(segmentInfo) {
    var playlist = segmentInfo.playlist;
    var segment = segmentInfo.segment;
    if (segment.discontinuity) {
      this.discontinuities[segment.timeline] = {
        time: segment.start,
        accuracy: 0
      };
    } else if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {
      for (var i = 0; i < playlist.discontinuityStarts.length; i++) {
        var segmentIndex = playlist.discontinuityStarts[i];
        var discontinuity = playlist.discontinuitySequence + i + 1;
        var mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex;
        var accuracy = Math.abs(mediaIndexDiff);
        if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {
          var time = void 0;
          if (mediaIndexDiff < 0) {
            time = segment.start - sumDurations({
              defaultDuration: playlist.targetDuration,
              durationList: playlist.segments,
              startIndex: segmentInfo.mediaIndex,
              endIndex: segmentIndex
            });
          } else {
            time = segment.end + sumDurations({
              defaultDuration: playlist.targetDuration,
              durationList: playlist.segments,
              startIndex: segmentInfo.mediaIndex + 1,
              endIndex: segmentIndex
            });
          }
          this.discontinuities[discontinuity] = {
            time,
            accuracy
          };
        }
      }
    }
  };
  _proto.dispose = function dispose() {
    this.trigger("dispose");
    this.off();
  };
  return SyncController2;
}(videojs.EventTarget);
var TimelineChangeController = /* @__PURE__ */ function(_videojs$EventTarget) {
  _inheritsLoose(TimelineChangeController2, _videojs$EventTarget);
  function TimelineChangeController2() {
    var _this;
    _this = _videojs$EventTarget.call(this) || this;
    _this.pendingTimelineChanges_ = {};
    _this.lastTimelineChanges_ = {};
    return _this;
  }
  var _proto = TimelineChangeController2.prototype;
  _proto.clearPendingTimelineChange = function clearPendingTimelineChange(type2) {
    this.pendingTimelineChanges_[type2] = null;
    this.trigger("pendingtimelinechange");
  };
  _proto.pendingTimelineChange = function pendingTimelineChange(_ref) {
    var type2 = _ref.type, from3 = _ref.from, to = _ref.to;
    if (typeof from3 === "number" && typeof to === "number") {
      this.pendingTimelineChanges_[type2] = {
        type: type2,
        from: from3,
        to
      };
      this.trigger("pendingtimelinechange");
    }
    return this.pendingTimelineChanges_[type2];
  };
  _proto.lastTimelineChange = function lastTimelineChange(_ref2) {
    var type2 = _ref2.type, from3 = _ref2.from, to = _ref2.to;
    if (typeof from3 === "number" && typeof to === "number") {
      this.lastTimelineChanges_[type2] = {
        type: type2,
        from: from3,
        to
      };
      delete this.pendingTimelineChanges_[type2];
      this.trigger("timelinechange");
    }
    return this.lastTimelineChanges_[type2];
  };
  _proto.dispose = function dispose() {
    this.trigger("dispose");
    this.pendingTimelineChanges_ = {};
    this.lastTimelineChanges_ = {};
    this.off();
  };
  return TimelineChangeController2;
}(videojs.EventTarget);
var workerCode = transform(getWorkerString(function() {
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function createCommonjsModule(fn, basedir, module) {
    return module = {
      path: basedir,
      exports: {},
      require: function require2(path, base) {
        return commonjsRequire(path, base === void 0 || base === null ? module.path : base);
      }
    }, fn(module, module.exports), module.exports;
  }
  function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
  }
  var createClass = createCommonjsModule(function(module) {
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    module.exports = _createClass;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  });
  var setPrototypeOf = createCommonjsModule(function(module) {
    function _setPrototypeOf2(o, p) {
      module.exports = _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      module.exports["default"] = module.exports, module.exports.__esModule = true;
      return _setPrototypeOf2(o, p);
    }
    module.exports = _setPrototypeOf2;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  });
  var inheritsLoose = createCommonjsModule(function(module) {
    function _inheritsLoose4(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      setPrototypeOf(subClass, superClass);
    }
    module.exports = _inheritsLoose4;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  });
  var Stream2 = /* @__PURE__ */ function() {
    function Stream3() {
      this.listeners = {};
    }
    var _proto = Stream3.prototype;
    _proto.on = function on3(type2, listener) {
      if (!this.listeners[type2]) {
        this.listeners[type2] = [];
      }
      this.listeners[type2].push(listener);
    };
    _proto.off = function off2(type2, listener) {
      if (!this.listeners[type2]) {
        return false;
      }
      var index = this.listeners[type2].indexOf(listener);
      this.listeners[type2] = this.listeners[type2].slice(0);
      this.listeners[type2].splice(index, 1);
      return index > -1;
    };
    _proto.trigger = function trigger2(type2) {
      var callbacks = this.listeners[type2];
      if (!callbacks) {
        return;
      }
      if (arguments.length === 2) {
        var length = callbacks.length;
        for (var i = 0; i < length; ++i) {
          callbacks[i].call(this, arguments[1]);
        }
      } else {
        var args = Array.prototype.slice.call(arguments, 1);
        var _length = callbacks.length;
        for (var _i = 0; _i < _length; ++_i) {
          callbacks[_i].apply(this, args);
        }
      }
    };
    _proto.dispose = function dispose() {
      this.listeners = {};
    };
    _proto.pipe = function pipe(destination) {
      this.on("data", function(data) {
        destination.push(data);
      });
    };
    return Stream3;
  }();
  function unpad(padded) {
    return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
  }
  var precompute = function precompute2() {
    var tables = [[[], [], [], [], []], [[], [], [], [], []]];
    var encTable = tables[0];
    var decTable = tables[1];
    var sbox = encTable[4];
    var sboxInv = decTable[4];
    var i;
    var x;
    var xInv;
    var d2 = [];
    var th = [];
    var x2;
    var x4;
    var x8;
    var s;
    var tEnc;
    var tDec;
    for (i = 0; i < 256; i++) {
      th[(d2[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
    }
    for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
      s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
      s = s >> 8 ^ s & 255 ^ 99;
      sbox[x] = s;
      sboxInv[s] = x;
      x8 = d2[x4 = d2[x2 = d2[x]]];
      tDec = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
      tEnc = d2[s] * 257 ^ s * 16843008;
      for (i = 0; i < 4; i++) {
        encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
        decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
      }
    }
    for (i = 0; i < 5; i++) {
      encTable[i] = encTable[i].slice(0);
      decTable[i] = decTable[i].slice(0);
    }
    return tables;
  };
  var aesTables = null;
  var AES = /* @__PURE__ */ function() {
    function AES2(key) {
      if (!aesTables) {
        aesTables = precompute();
      }
      this._tables = [[aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice()], [aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice()]];
      var i;
      var j;
      var tmp;
      var sbox = this._tables[0][4];
      var decTable = this._tables[1];
      var keyLen = key.length;
      var rcon = 1;
      if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
        throw new Error("Invalid aes key size");
      }
      var encKey = key.slice(0);
      var decKey = [];
      this._key = [encKey, decKey];
      for (i = keyLen; i < 4 * keyLen + 28; i++) {
        tmp = encKey[i - 1];
        if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
          tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
          if (i % keyLen === 0) {
            tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
            rcon = rcon << 1 ^ (rcon >> 7) * 283;
          }
        }
        encKey[i] = encKey[i - keyLen] ^ tmp;
      }
      for (j = 0; i; j++, i--) {
        tmp = encKey[j & 3 ? i : i - 4];
        if (i <= 4 || j < 4) {
          decKey[j] = tmp;
        } else {
          decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
        }
      }
    }
    var _proto = AES2.prototype;
    _proto.decrypt = function decrypt4(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {
      var key = this._key[1];
      var a = encrypted0 ^ key[0];
      var b = encrypted3 ^ key[1];
      var c = encrypted2 ^ key[2];
      var d2 = encrypted1 ^ key[3];
      var a2;
      var b2;
      var c2;
      var nInnerRounds = key.length / 4 - 2;
      var i;
      var kIndex = 4;
      var table = this._tables[1];
      var table0 = table[0];
      var table1 = table[1];
      var table2 = table[2];
      var table3 = table[3];
      var sbox = table[4];
      for (i = 0; i < nInnerRounds; i++) {
        a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d2 & 255] ^ key[kIndex];
        b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d2 >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];
        c2 = table0[c >>> 24] ^ table1[d2 >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];
        d2 = table0[d2 >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];
        kIndex += 4;
        a = a2;
        b = b2;
        c = c2;
      }
      for (i = 0; i < 4; i++) {
        out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d2 & 255] ^ key[kIndex++];
        a2 = a;
        a = b;
        b = c;
        c = d2;
        d2 = a2;
      }
    };
    return AES2;
  }();
  var AsyncStream = /* @__PURE__ */ function(_Stream) {
    inheritsLoose(AsyncStream2, _Stream);
    function AsyncStream2() {
      var _this;
      _this = _Stream.call(this, Stream2) || this;
      _this.jobs = [];
      _this.delay = 1;
      _this.timeout_ = null;
      return _this;
    }
    var _proto = AsyncStream2.prototype;
    _proto.processJob_ = function processJob_() {
      this.jobs.shift()();
      if (this.jobs.length) {
        this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);
      } else {
        this.timeout_ = null;
      }
    };
    _proto.push = function push2(job) {
      this.jobs.push(job);
      if (!this.timeout_) {
        this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);
      }
    };
    return AsyncStream2;
  }(Stream2);
  var ntoh = function ntoh2(word) {
    return word << 24 | (word & 65280) << 8 | (word & 16711680) >> 8 | word >>> 24;
  };
  var decrypt3 = function decrypt4(encrypted, key, initVector) {
    var encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);
    var decipher = new AES(Array.prototype.slice.call(key));
    var decrypted = new Uint8Array(encrypted.byteLength);
    var decrypted32 = new Int32Array(decrypted.buffer);
    var init0;
    var init1;
    var init2;
    var init3;
    var encrypted0;
    var encrypted1;
    var encrypted2;
    var encrypted3;
    var wordIx;
    init0 = initVector[0];
    init1 = initVector[1];
    init2 = initVector[2];
    init3 = initVector[3];
    for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {
      encrypted0 = ntoh(encrypted32[wordIx]);
      encrypted1 = ntoh(encrypted32[wordIx + 1]);
      encrypted2 = ntoh(encrypted32[wordIx + 2]);
      encrypted3 = ntoh(encrypted32[wordIx + 3]);
      decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx);
      decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);
      decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);
      decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);
      decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3);
      init0 = encrypted0;
      init1 = encrypted1;
      init2 = encrypted2;
      init3 = encrypted3;
    }
    return decrypted;
  };
  var Decrypter3 = /* @__PURE__ */ function() {
    function Decrypter4(encrypted, key, initVector, done) {
      var step = Decrypter4.STEP;
      var encrypted32 = new Int32Array(encrypted.buffer);
      var decrypted = new Uint8Array(encrypted.byteLength);
      var i = 0;
      this.asyncStream_ = new AsyncStream();
      this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));
      for (i = step; i < encrypted32.length; i += step) {
        initVector = new Uint32Array([ntoh(encrypted32[i - 4]), ntoh(encrypted32[i - 3]), ntoh(encrypted32[i - 2]), ntoh(encrypted32[i - 1])]);
        this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));
      }
      this.asyncStream_.push(function() {
        done(null, unpad(decrypted));
      });
    }
    var _proto = Decrypter4.prototype;
    _proto.decryptChunk_ = function decryptChunk_(encrypted, key, initVector, decrypted) {
      return function() {
        var bytes = decrypt3(encrypted, key, initVector);
        decrypted.set(bytes, encrypted.byteOffset);
      };
    };
    createClass(Decrypter4, null, [{
      key: "STEP",
      get: function get7() {
        return 32e3;
      }
    }]);
    return Decrypter4;
  }();
  var win;
  if (typeof window !== "undefined") {
    win = window;
  } else if (typeof commonjsGlobal !== "undefined") {
    win = commonjsGlobal;
  } else if (typeof self !== "undefined") {
    win = self;
  } else {
    win = {};
  }
  var window_1 = win;
  var isArrayBufferView3 = function isArrayBufferView4(obj) {
    if (ArrayBuffer.isView === "function") {
      return ArrayBuffer.isView(obj);
    }
    return obj && obj.buffer instanceof ArrayBuffer;
  };
  var BigInt2 = window_1.BigInt || Number;
  [BigInt2("0x1"), BigInt2("0x100"), BigInt2("0x10000"), BigInt2("0x1000000"), BigInt2("0x100000000"), BigInt2("0x10000000000"), BigInt2("0x1000000000000"), BigInt2("0x100000000000000"), BigInt2("0x10000000000000000")];
  var createTransferableMessage3 = function createTransferableMessage4(message) {
    var transferable = {};
    Object.keys(message).forEach(function(key) {
      var value = message[key];
      if (isArrayBufferView3(value)) {
        transferable[key] = {
          bytes: value.buffer,
          byteOffset: value.byteOffset,
          byteLength: value.byteLength
        };
      } else {
        transferable[key] = value;
      }
    });
    return transferable;
  };
  self.onmessage = function(event) {
    var data = event.data;
    var encrypted = new Uint8Array(data.encrypted.bytes, data.encrypted.byteOffset, data.encrypted.byteLength);
    var key = new Uint32Array(data.key.bytes, data.key.byteOffset, data.key.byteLength / 4);
    var iv = new Uint32Array(data.iv.bytes, data.iv.byteOffset, data.iv.byteLength / 4);
    new Decrypter3(encrypted, key, iv, function(err, bytes) {
      self.postMessage(createTransferableMessage3({
        source: data.source,
        decrypted: bytes
      }), [bytes.buffer]);
    });
  };
}));
var Decrypter2 = factory(workerCode);
var audioTrackKind_ = function audioTrackKind_2(properties) {
  var kind = properties["default"] ? "main" : "alternative";
  if (properties.characteristics && properties.characteristics.indexOf("public.accessibility.describes-video") >= 0) {
    kind = "main-desc";
  }
  return kind;
};
var stopLoaders = function stopLoaders2(segmentLoader, mediaType) {
  segmentLoader.abort();
  segmentLoader.pause();
  if (mediaType && mediaType.activePlaylistLoader) {
    mediaType.activePlaylistLoader.pause();
    mediaType.activePlaylistLoader = null;
  }
};
var startLoaders = function startLoaders2(playlistLoader, mediaType) {
  mediaType.activePlaylistLoader = playlistLoader;
  playlistLoader.load();
};
var onGroupChanged = function onGroupChanged2(type2, settings) {
  return function() {
    var _settings$segmentLoad = settings.segmentLoaders, segmentLoader = _settings$segmentLoad[type2], mainSegmentLoader = _settings$segmentLoad.main, mediaType = settings.mediaTypes[type2];
    var activeTrack2 = mediaType.activeTrack();
    var activeGroup3 = mediaType.getActiveGroup();
    var previousActiveLoader = mediaType.activePlaylistLoader;
    var lastGroup = mediaType.lastGroup_;
    if (activeGroup3 && lastGroup && activeGroup3.id === lastGroup.id) {
      return;
    }
    mediaType.lastGroup_ = activeGroup3;
    mediaType.lastTrack_ = activeTrack2;
    stopLoaders(segmentLoader, mediaType);
    if (!activeGroup3 || activeGroup3.isMasterPlaylist) {
      return;
    }
    if (!activeGroup3.playlistLoader) {
      if (previousActiveLoader) {
        mainSegmentLoader.resetEverything();
      }
      return;
    }
    segmentLoader.resyncLoader();
    startLoaders(activeGroup3.playlistLoader, mediaType);
  };
};
var onGroupChanging = function onGroupChanging2(type2, settings) {
  return function() {
    var segmentLoader = settings.segmentLoaders[type2], mediaType = settings.mediaTypes[type2];
    mediaType.lastGroup_ = null;
    segmentLoader.abort();
    segmentLoader.pause();
  };
};
var onTrackChanged = function onTrackChanged2(type2, settings) {
  return function() {
    var masterPlaylistLoader = settings.masterPlaylistLoader, _settings$segmentLoad2 = settings.segmentLoaders, segmentLoader = _settings$segmentLoad2[type2], mainSegmentLoader = _settings$segmentLoad2.main, mediaType = settings.mediaTypes[type2];
    var activeTrack2 = mediaType.activeTrack();
    var activeGroup3 = mediaType.getActiveGroup();
    var previousActiveLoader = mediaType.activePlaylistLoader;
    var lastTrack = mediaType.lastTrack_;
    if (lastTrack && activeTrack2 && lastTrack.id === activeTrack2.id) {
      return;
    }
    mediaType.lastGroup_ = activeGroup3;
    mediaType.lastTrack_ = activeTrack2;
    stopLoaders(segmentLoader, mediaType);
    if (!activeGroup3) {
      return;
    }
    if (activeGroup3.isMasterPlaylist) {
      if (!activeTrack2 || !lastTrack || activeTrack2.id === lastTrack.id) {
        return;
      }
      var mpc = settings.vhs.masterPlaylistController_;
      var newPlaylist = mpc.selectPlaylist();
      if (mpc.media() === newPlaylist) {
        return;
      }
      mediaType.logger_("track change. Switching master audio from " + lastTrack.id + " to " + activeTrack2.id);
      masterPlaylistLoader.pause();
      mainSegmentLoader.resetEverything();
      mpc.fastQualityChange_(newPlaylist);
      return;
    }
    if (type2 === "AUDIO") {
      if (!activeGroup3.playlistLoader) {
        mainSegmentLoader.setAudio(true);
        mainSegmentLoader.resetEverything();
        return;
      }
      segmentLoader.setAudio(true);
      mainSegmentLoader.setAudio(false);
    }
    if (previousActiveLoader === activeGroup3.playlistLoader) {
      startLoaders(activeGroup3.playlistLoader, mediaType);
      return;
    }
    if (segmentLoader.track) {
      segmentLoader.track(activeTrack2);
    }
    segmentLoader.resetEverything();
    startLoaders(activeGroup3.playlistLoader, mediaType);
  };
};
var onError = {
  /**
   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters
   * an error.
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Error handler. Logs warning (or error if the playlist is blacklisted) to
   *         console and switches back to default audio track.
   * @function onError.AUDIO
   */
  AUDIO: function AUDIO(type2, settings) {
    return function() {
      var segmentLoader = settings.segmentLoaders[type2], mediaType = settings.mediaTypes[type2], blacklistCurrentPlaylist = settings.blacklistCurrentPlaylist;
      stopLoaders(segmentLoader, mediaType);
      var activeTrack2 = mediaType.activeTrack();
      var activeGroup3 = mediaType.activeGroup();
      var id = (activeGroup3.filter(function(group) {
        return group["default"];
      })[0] || activeGroup3[0]).id;
      var defaultTrack = mediaType.tracks[id];
      if (activeTrack2 === defaultTrack) {
        blacklistCurrentPlaylist({
          message: "Problem encountered loading the default audio track."
        });
        return;
      }
      videojs.log.warn("Problem encountered loading the alternate audio track.Switching back to default.");
      for (var trackId in mediaType.tracks) {
        mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;
      }
      mediaType.onTrackChanged();
    };
  },
  /**
   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters
   * an error.
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Error handler. Logs warning to console and disables the active subtitle track
   * @function onError.SUBTITLES
   */
  SUBTITLES: function SUBTITLES(type2, settings) {
    return function() {
      var segmentLoader = settings.segmentLoaders[type2], mediaType = settings.mediaTypes[type2];
      videojs.log.warn("Problem encountered loading the subtitle track.Disabling subtitle track.");
      stopLoaders(segmentLoader, mediaType);
      var track = mediaType.activeTrack();
      if (track) {
        track.mode = "disabled";
      }
      mediaType.onTrackChanged();
    };
  }
};
var setupListeners = {
  /**
   * Setup event listeners for audio playlist loader
   *
   * @param {string} type
   *        MediaGroup type
   * @param {PlaylistLoader|null} playlistLoader
   *        PlaylistLoader to register listeners on
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function setupListeners.AUDIO
   */
  AUDIO: function AUDIO2(type2, playlistLoader, settings) {
    if (!playlistLoader) {
      return;
    }
    var tech = settings.tech, requestOptions = settings.requestOptions, segmentLoader = settings.segmentLoaders[type2];
    playlistLoader.on("loadedmetadata", function() {
      var media = playlistLoader.media();
      segmentLoader.playlist(media, requestOptions);
      if (!tech.paused() || media.endList && tech.preload() !== "none") {
        segmentLoader.load();
      }
    });
    playlistLoader.on("loadedplaylist", function() {
      segmentLoader.playlist(playlistLoader.media(), requestOptions);
      if (!tech.paused()) {
        segmentLoader.load();
      }
    });
    playlistLoader.on("error", onError[type2](type2, settings));
  },
  /**
   * Setup event listeners for subtitle playlist loader
   *
   * @param {string} type
   *        MediaGroup type
   * @param {PlaylistLoader|null} playlistLoader
   *        PlaylistLoader to register listeners on
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function setupListeners.SUBTITLES
   */
  SUBTITLES: function SUBTITLES2(type2, playlistLoader, settings) {
    var tech = settings.tech, requestOptions = settings.requestOptions, segmentLoader = settings.segmentLoaders[type2], mediaType = settings.mediaTypes[type2];
    playlistLoader.on("loadedmetadata", function() {
      var media = playlistLoader.media();
      segmentLoader.playlist(media, requestOptions);
      segmentLoader.track(mediaType.activeTrack());
      if (!tech.paused() || media.endList && tech.preload() !== "none") {
        segmentLoader.load();
      }
    });
    playlistLoader.on("loadedplaylist", function() {
      segmentLoader.playlist(playlistLoader.media(), requestOptions);
      if (!tech.paused()) {
        segmentLoader.load();
      }
    });
    playlistLoader.on("error", onError[type2](type2, settings));
  }
};
var initialize = {
  /**
   * Setup PlaylistLoaders and AudioTracks for the audio groups
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize.AUDIO
   */
  "AUDIO": function AUDIO3(type2, settings) {
    var vhs = settings.vhs, sourceType = settings.sourceType, segmentLoader = settings.segmentLoaders[type2], requestOptions = settings.requestOptions, mediaGroups = settings.master.mediaGroups, _settings$mediaTypes$ = settings.mediaTypes[type2], groups = _settings$mediaTypes$.groups, tracks = _settings$mediaTypes$.tracks, logger_ = _settings$mediaTypes$.logger_, masterPlaylistLoader = settings.masterPlaylistLoader;
    var audioOnlyMaster = isAudioOnly(masterPlaylistLoader.master);
    if (!mediaGroups[type2] || Object.keys(mediaGroups[type2]).length === 0) {
      mediaGroups[type2] = {
        main: {
          "default": {
            "default": true
          }
        }
      };
      if (audioOnlyMaster) {
        mediaGroups[type2].main["default"].playlists = masterPlaylistLoader.master.playlists;
      }
    }
    for (var groupId in mediaGroups[type2]) {
      if (!groups[groupId]) {
        groups[groupId] = [];
      }
      for (var variantLabel in mediaGroups[type2][groupId]) {
        var properties = mediaGroups[type2][groupId][variantLabel];
        var playlistLoader = void 0;
        if (audioOnlyMaster) {
          logger_("AUDIO group '" + groupId + "' label '" + variantLabel + "' is a master playlist");
          properties.isMasterPlaylist = true;
          playlistLoader = null;
        } else if (sourceType === "vhs-json" && properties.playlists) {
          playlistLoader = new PlaylistLoader2(properties.playlists[0], vhs, requestOptions);
        } else if (properties.resolvedUri) {
          playlistLoader = new PlaylistLoader2(properties.resolvedUri, vhs, requestOptions);
        } else if (properties.playlists && sourceType === "dash") {
          playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, masterPlaylistLoader);
        } else {
          playlistLoader = null;
        }
        properties = videojs.mergeOptions({
          id: variantLabel,
          playlistLoader
        }, properties);
        setupListeners[type2](type2, properties.playlistLoader, settings);
        groups[groupId].push(properties);
        if (typeof tracks[variantLabel] === "undefined") {
          var track = new videojs.AudioTrack({
            id: variantLabel,
            kind: audioTrackKind_(properties),
            enabled: false,
            language: properties.language,
            "default": properties["default"],
            label: variantLabel
          });
          tracks[variantLabel] = track;
        }
      }
    }
    segmentLoader.on("error", onError[type2](type2, settings));
  },
  /**
   * Setup PlaylistLoaders and TextTracks for the subtitle groups
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize.SUBTITLES
   */
  "SUBTITLES": function SUBTITLES3(type2, settings) {
    var tech = settings.tech, vhs = settings.vhs, sourceType = settings.sourceType, segmentLoader = settings.segmentLoaders[type2], requestOptions = settings.requestOptions, mediaGroups = settings.master.mediaGroups, _settings$mediaTypes$2 = settings.mediaTypes[type2], groups = _settings$mediaTypes$2.groups, tracks = _settings$mediaTypes$2.tracks, masterPlaylistLoader = settings.masterPlaylistLoader;
    for (var groupId in mediaGroups[type2]) {
      if (!groups[groupId]) {
        groups[groupId] = [];
      }
      for (var variantLabel in mediaGroups[type2][groupId]) {
        if (mediaGroups[type2][groupId][variantLabel].forced) {
          continue;
        }
        var properties = mediaGroups[type2][groupId][variantLabel];
        var playlistLoader = void 0;
        if (sourceType === "hls") {
          playlistLoader = new PlaylistLoader2(properties.resolvedUri, vhs, requestOptions);
        } else if (sourceType === "dash") {
          var playlists = properties.playlists.filter(function(p) {
            return p.excludeUntil !== Infinity;
          });
          if (!playlists.length) {
            return;
          }
          playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, masterPlaylistLoader);
        } else if (sourceType === "vhs-json") {
          playlistLoader = new PlaylistLoader2(
            // if the vhs-json object included the media playlist, use the media playlist
            // as provided, otherwise use the resolved URI to load the playlist
            properties.playlists ? properties.playlists[0] : properties.resolvedUri,
            vhs,
            requestOptions
          );
        }
        properties = videojs.mergeOptions({
          id: variantLabel,
          playlistLoader
        }, properties);
        setupListeners[type2](type2, properties.playlistLoader, settings);
        groups[groupId].push(properties);
        if (typeof tracks[variantLabel] === "undefined") {
          var track = tech.addRemoteTextTrack({
            id: variantLabel,
            kind: "subtitles",
            "default": properties["default"] && properties.autoselect,
            language: properties.language,
            label: variantLabel
          }, false).track;
          tracks[variantLabel] = track;
        }
      }
    }
    segmentLoader.on("error", onError[type2](type2, settings));
  },
  /**
   * Setup TextTracks for the closed-caption groups
   *
   * @param {String} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize['CLOSED-CAPTIONS']
   */
  "CLOSED-CAPTIONS": function CLOSEDCAPTIONS(type2, settings) {
    var tech = settings.tech, mediaGroups = settings.master.mediaGroups, _settings$mediaTypes$3 = settings.mediaTypes[type2], groups = _settings$mediaTypes$3.groups, tracks = _settings$mediaTypes$3.tracks;
    for (var groupId in mediaGroups[type2]) {
      if (!groups[groupId]) {
        groups[groupId] = [];
      }
      for (var variantLabel in mediaGroups[type2][groupId]) {
        var properties = mediaGroups[type2][groupId][variantLabel];
        if (!/^(?:CC|SERVICE)/.test(properties.instreamId)) {
          continue;
        }
        var captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};
        var newProps = {
          label: variantLabel,
          language: properties.language,
          instreamId: properties.instreamId,
          "default": properties["default"] && properties.autoselect
        };
        if (captionServices[newProps.instreamId]) {
          newProps = videojs.mergeOptions(newProps, captionServices[newProps.instreamId]);
        }
        if (newProps["default"] === void 0) {
          delete newProps["default"];
        }
        groups[groupId].push(videojs.mergeOptions({
          id: variantLabel
        }, properties));
        if (typeof tracks[variantLabel] === "undefined") {
          var track = tech.addRemoteTextTrack({
            id: newProps.instreamId,
            kind: "captions",
            "default": newProps["default"],
            language: newProps.language,
            label: newProps.label
          }, false).track;
          tracks[variantLabel] = track;
        }
      }
    }
  }
};
var groupMatch = function groupMatch2(list, media) {
  for (var i = 0; i < list.length; i++) {
    if (playlistMatch(media, list[i])) {
      return true;
    }
    if (list[i].playlists && groupMatch2(list[i].playlists, media)) {
      return true;
    }
  }
  return false;
};
var activeGroup = function activeGroup2(type2, settings) {
  return function(track) {
    var masterPlaylistLoader = settings.masterPlaylistLoader, groups = settings.mediaTypes[type2].groups;
    var media = masterPlaylistLoader.media();
    if (!media) {
      return null;
    }
    var variants = null;
    if (media.attributes[type2]) {
      variants = groups[media.attributes[type2]];
    }
    var groupKeys = Object.keys(groups);
    if (!variants) {
      if (type2 === "AUDIO" && groupKeys.length > 1 && isAudioOnly(settings.master)) {
        for (var i = 0; i < groupKeys.length; i++) {
          var groupPropertyList = groups[groupKeys[i]];
          if (groupMatch(groupPropertyList, media)) {
            variants = groupPropertyList;
            break;
          }
        }
      } else if (groups.main) {
        variants = groups.main;
      } else if (groupKeys.length === 1) {
        variants = groups[groupKeys[0]];
      }
    }
    if (typeof track === "undefined") {
      return variants;
    }
    if (track === null || !variants) {
      return null;
    }
    return variants.filter(function(props) {
      return props.id === track.id;
    })[0] || null;
  };
};
var activeTrack = {
  /**
   * Returns a function used to get the active track of type provided
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Function that returns the active media track for the provided type. Returns
   *         null if no track is active
   * @function activeTrack.AUDIO
   */
  AUDIO: function AUDIO4(type2, settings) {
    return function() {
      var tracks = settings.mediaTypes[type2].tracks;
      for (var id in tracks) {
        if (tracks[id].enabled) {
          return tracks[id];
        }
      }
      return null;
    };
  },
  /**
   * Returns a function used to get the active track of type provided
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Function that returns the active media track for the provided type. Returns
   *         null if no track is active
   * @function activeTrack.SUBTITLES
   */
  SUBTITLES: function SUBTITLES4(type2, settings) {
    return function() {
      var tracks = settings.mediaTypes[type2].tracks;
      for (var id in tracks) {
        if (tracks[id].mode === "showing" || tracks[id].mode === "hidden") {
          return tracks[id];
        }
      }
      return null;
    };
  }
};
var getActiveGroup = function getActiveGroup2(type2, _ref) {
  var mediaTypes2 = _ref.mediaTypes;
  return function() {
    var activeTrack_ = mediaTypes2[type2].activeTrack();
    if (!activeTrack_) {
      return null;
    }
    return mediaTypes2[type2].activeGroup(activeTrack_);
  };
};
var setupMediaGroups = function setupMediaGroups2(settings) {
  ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(function(type2) {
    initialize[type2](type2, settings);
  });
  var mediaTypes2 = settings.mediaTypes, masterPlaylistLoader = settings.masterPlaylistLoader, tech = settings.tech, vhs = settings.vhs, _settings$segmentLoad3 = settings.segmentLoaders, audioSegmentLoader = _settings$segmentLoad3["AUDIO"], mainSegmentLoader = _settings$segmentLoad3.main;
  ["AUDIO", "SUBTITLES"].forEach(function(type2) {
    mediaTypes2[type2].activeGroup = activeGroup(type2, settings);
    mediaTypes2[type2].activeTrack = activeTrack[type2](type2, settings);
    mediaTypes2[type2].onGroupChanged = onGroupChanged(type2, settings);
    mediaTypes2[type2].onGroupChanging = onGroupChanging(type2, settings);
    mediaTypes2[type2].onTrackChanged = onTrackChanged(type2, settings);
    mediaTypes2[type2].getActiveGroup = getActiveGroup(type2, settings);
  });
  var audioGroup = mediaTypes2.AUDIO.activeGroup();
  if (audioGroup) {
    var groupId = (audioGroup.filter(function(group) {
      return group["default"];
    })[0] || audioGroup[0]).id;
    mediaTypes2.AUDIO.tracks[groupId].enabled = true;
    mediaTypes2.AUDIO.onGroupChanged();
    mediaTypes2.AUDIO.onTrackChanged();
    var activeAudioGroup = mediaTypes2.AUDIO.getActiveGroup();
    if (!activeAudioGroup.playlistLoader) {
      mainSegmentLoader.setAudio(true);
    } else {
      mainSegmentLoader.setAudio(false);
      audioSegmentLoader.setAudio(true);
    }
  }
  masterPlaylistLoader.on("mediachange", function() {
    ["AUDIO", "SUBTITLES"].forEach(function(type2) {
      return mediaTypes2[type2].onGroupChanged();
    });
  });
  masterPlaylistLoader.on("mediachanging", function() {
    ["AUDIO", "SUBTITLES"].forEach(function(type2) {
      return mediaTypes2[type2].onGroupChanging();
    });
  });
  var onAudioTrackChanged = function onAudioTrackChanged2() {
    mediaTypes2.AUDIO.onTrackChanged();
    tech.trigger({
      type: "usage",
      name: "vhs-audio-change"
    });
    tech.trigger({
      type: "usage",
      name: "hls-audio-change"
    });
  };
  tech.audioTracks().addEventListener("change", onAudioTrackChanged);
  tech.remoteTextTracks().addEventListener("change", mediaTypes2.SUBTITLES.onTrackChanged);
  vhs.on("dispose", function() {
    tech.audioTracks().removeEventListener("change", onAudioTrackChanged);
    tech.remoteTextTracks().removeEventListener("change", mediaTypes2.SUBTITLES.onTrackChanged);
  });
  tech.clearTracks("audio");
  for (var id in mediaTypes2.AUDIO.tracks) {
    tech.audioTracks().addTrack(mediaTypes2.AUDIO.tracks[id]);
  }
};
var createMediaTypes = function createMediaTypes2() {
  var mediaTypes2 = {};
  ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(function(type2) {
    mediaTypes2[type2] = {
      groups: {},
      tracks: {},
      activePlaylistLoader: null,
      activeGroup: noop3,
      activeTrack: noop3,
      getActiveGroup: noop3,
      onGroupChanged: noop3,
      onTrackChanged: noop3,
      lastTrack_: null,
      logger_: logger2("MediaGroups[" + type2 + "]")
    };
  });
  return mediaTypes2;
};
var ABORT_EARLY_BLACKLIST_SECONDS = 60 * 2;
var Vhs$1;
var loaderStats = ["mediaRequests", "mediaRequestsAborted", "mediaRequestsTimedout", "mediaRequestsErrored", "mediaTransferDuration", "mediaBytesTransferred", "mediaAppends"];
var sumLoaderStat = function sumLoaderStat2(stat) {
  return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];
};
var shouldSwitchToMedia = function shouldSwitchToMedia2(_ref) {
  var currentPlaylist = _ref.currentPlaylist, buffered = _ref.buffered, currentTime = _ref.currentTime, nextPlaylist = _ref.nextPlaylist, bufferLowWaterLine = _ref.bufferLowWaterLine, bufferHighWaterLine = _ref.bufferHighWaterLine, duration5 = _ref.duration, experimentalBufferBasedABR = _ref.experimentalBufferBasedABR, log2 = _ref.log;
  if (!nextPlaylist) {
    videojs.log.warn("We received no playlist to switch to. Please check your stream.");
    return false;
  }
  var sharedLogLine = "allowing switch " + (currentPlaylist && currentPlaylist.id || "null") + " -> " + nextPlaylist.id;
  if (!currentPlaylist) {
    log2(sharedLogLine + " as current playlist is not set");
    return true;
  }
  if (nextPlaylist.id === currentPlaylist.id) {
    return false;
  }
  var isBuffered = Boolean(findRange(buffered, currentTime).length);
  if (!currentPlaylist.endList) {
    if (!isBuffered && typeof currentPlaylist.partTargetDuration === "number") {
      log2("not " + sharedLogLine + " as current playlist is live llhls, but currentTime isn't in buffered.");
      return false;
    }
    log2(sharedLogLine + " as current playlist is live");
    return true;
  }
  var forwardBuffer = timeAheadOf(buffered, currentTime);
  var maxBufferLowWaterLine = experimentalBufferBasedABR ? Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : Config.MAX_BUFFER_LOW_WATER_LINE;
  if (duration5 < maxBufferLowWaterLine) {
    log2(sharedLogLine + " as duration < max low water line (" + duration5 + " < " + maxBufferLowWaterLine + ")");
    return true;
  }
  var nextBandwidth = nextPlaylist.attributes.BANDWIDTH;
  var currBandwidth = currentPlaylist.attributes.BANDWIDTH;
  if (nextBandwidth < currBandwidth && (!experimentalBufferBasedABR || forwardBuffer < bufferHighWaterLine)) {
    var logLine = sharedLogLine + " as next bandwidth < current bandwidth (" + nextBandwidth + " < " + currBandwidth + ")";
    if (experimentalBufferBasedABR) {
      logLine += " and forwardBuffer < bufferHighWaterLine (" + forwardBuffer + " < " + bufferHighWaterLine + ")";
    }
    log2(logLine);
    return true;
  }
  if ((!experimentalBufferBasedABR || nextBandwidth > currBandwidth) && forwardBuffer >= bufferLowWaterLine) {
    var _logLine = sharedLogLine + " as forwardBuffer >= bufferLowWaterLine (" + forwardBuffer + " >= " + bufferLowWaterLine + ")";
    if (experimentalBufferBasedABR) {
      _logLine += " and next bandwidth > current bandwidth (" + nextBandwidth + " > " + currBandwidth + ")";
    }
    log2(_logLine);
    return true;
  }
  log2("not " + sharedLogLine + " as no switching criteria met");
  return false;
};
var MasterPlaylistController = /* @__PURE__ */ function(_videojs$EventTarget) {
  _inheritsLoose(MasterPlaylistController2, _videojs$EventTarget);
  function MasterPlaylistController2(options) {
    var _this;
    _this = _videojs$EventTarget.call(this) || this;
    var src = options.src, handleManifestRedirects = options.handleManifestRedirects, withCredentials = options.withCredentials, tech = options.tech, bandwidth2 = options.bandwidth, externVhs = options.externVhs, useCueTags = options.useCueTags, blacklistDuration = options.blacklistDuration, enableLowInitialPlaylist = options.enableLowInitialPlaylist, sourceType = options.sourceType, cacheEncryptionKeys = options.cacheEncryptionKeys, experimentalBufferBasedABR = options.experimentalBufferBasedABR, experimentalLeastPixelDiffSelector = options.experimentalLeastPixelDiffSelector, captionServices = options.captionServices;
    if (!src) {
      throw new Error("A non-empty playlist URL or JSON manifest string is required");
    }
    var maxPlaylistRetries = options.maxPlaylistRetries;
    if (maxPlaylistRetries === null || typeof maxPlaylistRetries === "undefined") {
      maxPlaylistRetries = Infinity;
    }
    Vhs$1 = externVhs;
    _this.experimentalBufferBasedABR = Boolean(experimentalBufferBasedABR);
    _this.experimentalLeastPixelDiffSelector = Boolean(experimentalLeastPixelDiffSelector);
    _this.withCredentials = withCredentials;
    _this.tech_ = tech;
    _this.vhs_ = tech.vhs;
    _this.sourceType_ = sourceType;
    _this.useCueTags_ = useCueTags;
    _this.blacklistDuration = blacklistDuration;
    _this.maxPlaylistRetries = maxPlaylistRetries;
    _this.enableLowInitialPlaylist = enableLowInitialPlaylist;
    if (_this.useCueTags_) {
      _this.cueTagsTrack_ = _this.tech_.addTextTrack("metadata", "ad-cues");
      _this.cueTagsTrack_.inBandMetadataTrackDispatchType = "";
    }
    _this.requestOptions_ = {
      withCredentials,
      handleManifestRedirects,
      maxPlaylistRetries,
      timeout: null
    };
    _this.on("error", _this.pauseLoading);
    _this.mediaTypes_ = createMediaTypes();
    _this.mediaSource = new import_window6.default.MediaSource();
    _this.handleDurationChange_ = _this.handleDurationChange_.bind(_assertThisInitialized(_this));
    _this.handleSourceOpen_ = _this.handleSourceOpen_.bind(_assertThisInitialized(_this));
    _this.handleSourceEnded_ = _this.handleSourceEnded_.bind(_assertThisInitialized(_this));
    _this.mediaSource.addEventListener("durationchange", _this.handleDurationChange_);
    _this.mediaSource.addEventListener("sourceopen", _this.handleSourceOpen_);
    _this.mediaSource.addEventListener("sourceended", _this.handleSourceEnded_);
    _this.seekable_ = videojs.createTimeRanges();
    _this.hasPlayed_ = false;
    _this.syncController_ = new SyncController(options);
    _this.segmentMetadataTrack_ = tech.addRemoteTextTrack({
      kind: "metadata",
      label: "segment-metadata"
    }, false).track;
    _this.decrypter_ = new Decrypter2();
    _this.sourceUpdater_ = new SourceUpdater(_this.mediaSource);
    _this.inbandTextTracks_ = {};
    _this.timelineChangeController_ = new TimelineChangeController();
    var segmentLoaderSettings = {
      vhs: _this.vhs_,
      parse708captions: options.parse708captions,
      useDtsForTimestampOffset: options.useDtsForTimestampOffset,
      captionServices,
      mediaSource: _this.mediaSource,
      currentTime: _this.tech_.currentTime.bind(_this.tech_),
      seekable: function seekable3() {
        return _this.seekable();
      },
      seeking: function seeking() {
        return _this.tech_.seeking();
      },
      duration: function duration5() {
        return _this.duration();
      },
      hasPlayed: function hasPlayed() {
        return _this.hasPlayed_;
      },
      goalBufferLength: function goalBufferLength() {
        return _this.goalBufferLength();
      },
      bandwidth: bandwidth2,
      syncController: _this.syncController_,
      decrypter: _this.decrypter_,
      sourceType: _this.sourceType_,
      inbandTextTracks: _this.inbandTextTracks_,
      cacheEncryptionKeys,
      sourceUpdater: _this.sourceUpdater_,
      timelineChangeController: _this.timelineChangeController_,
      experimentalExactManifestTimings: options.experimentalExactManifestTimings
    };
    _this.masterPlaylistLoader_ = _this.sourceType_ === "dash" ? new DashPlaylistLoader(src, _this.vhs_, _this.requestOptions_) : new PlaylistLoader2(src, _this.vhs_, _this.requestOptions_);
    _this.setupMasterPlaylistLoaderListeners_();
    _this.mainSegmentLoader_ = new SegmentLoader(videojs.mergeOptions(segmentLoaderSettings, {
      segmentMetadataTrack: _this.segmentMetadataTrack_,
      loaderType: "main"
    }), options);
    _this.audioSegmentLoader_ = new SegmentLoader(videojs.mergeOptions(segmentLoaderSettings, {
      loaderType: "audio"
    }), options);
    _this.subtitleSegmentLoader_ = new VTTSegmentLoader(videojs.mergeOptions(segmentLoaderSettings, {
      loaderType: "vtt",
      featuresNativeTextTracks: _this.tech_.featuresNativeTextTracks
    }), options);
    _this.setupSegmentLoaderListeners_();
    if (_this.experimentalBufferBasedABR) {
      _this.masterPlaylistLoader_.one("loadedplaylist", function() {
        return _this.startABRTimer_();
      });
      _this.tech_.on("pause", function() {
        return _this.stopABRTimer_();
      });
      _this.tech_.on("play", function() {
        return _this.startABRTimer_();
      });
    }
    loaderStats.forEach(function(stat) {
      _this[stat + "_"] = sumLoaderStat.bind(_assertThisInitialized(_this), stat);
    });
    _this.logger_ = logger2("MPC");
    _this.triggeredFmp4Usage = false;
    if (_this.tech_.preload() === "none") {
      _this.loadOnPlay_ = function() {
        _this.loadOnPlay_ = null;
        _this.masterPlaylistLoader_.load();
      };
      _this.tech_.one("play", _this.loadOnPlay_);
    } else {
      _this.masterPlaylistLoader_.load();
    }
    _this.timeToLoadedData__ = -1;
    _this.mainAppendsToLoadedData__ = -1;
    _this.audioAppendsToLoadedData__ = -1;
    var event = _this.tech_.preload() === "none" ? "play" : "loadstart";
    _this.tech_.one(event, function() {
      var timeToLoadedDataStart = Date.now();
      _this.tech_.one("loadeddata", function() {
        _this.timeToLoadedData__ = Date.now() - timeToLoadedDataStart;
        _this.mainAppendsToLoadedData__ = _this.mainSegmentLoader_.mediaAppends;
        _this.audioAppendsToLoadedData__ = _this.audioSegmentLoader_.mediaAppends;
      });
    });
    return _this;
  }
  var _proto = MasterPlaylistController2.prototype;
  _proto.mainAppendsToLoadedData_ = function mainAppendsToLoadedData_() {
    return this.mainAppendsToLoadedData__;
  };
  _proto.audioAppendsToLoadedData_ = function audioAppendsToLoadedData_() {
    return this.audioAppendsToLoadedData__;
  };
  _proto.appendsToLoadedData_ = function appendsToLoadedData_() {
    var main = this.mainAppendsToLoadedData_();
    var audio = this.audioAppendsToLoadedData_();
    if (main === -1 || audio === -1) {
      return -1;
    }
    return main + audio;
  };
  _proto.timeToLoadedData_ = function timeToLoadedData_() {
    return this.timeToLoadedData__;
  };
  _proto.checkABR_ = function checkABR_() {
    var nextPlaylist = this.selectPlaylist();
    if (nextPlaylist && this.shouldSwitchToMedia_(nextPlaylist)) {
      this.switchMedia_(nextPlaylist, "abr");
    }
  };
  _proto.switchMedia_ = function switchMedia_(playlist, cause, delay) {
    var oldMedia = this.media();
    var oldId = oldMedia && (oldMedia.id || oldMedia.uri);
    var newId = playlist.id || playlist.uri;
    if (oldId && oldId !== newId) {
      this.logger_("switch media " + oldId + " -> " + newId + " from " + cause);
      this.tech_.trigger({
        type: "usage",
        name: "vhs-rendition-change-" + cause
      });
    }
    this.masterPlaylistLoader_.media(playlist, delay);
  };
  _proto.startABRTimer_ = function startABRTimer_() {
    var _this2 = this;
    this.stopABRTimer_();
    this.abrTimer_ = import_window6.default.setInterval(function() {
      return _this2.checkABR_();
    }, 250);
  };
  _proto.stopABRTimer_ = function stopABRTimer_() {
    if (this.tech_.scrubbing && this.tech_.scrubbing()) {
      return;
    }
    import_window6.default.clearInterval(this.abrTimer_);
    this.abrTimer_ = null;
  };
  _proto.getAudioTrackPlaylists_ = function getAudioTrackPlaylists_() {
    var master = this.master();
    var defaultPlaylists = master && master.playlists || [];
    if (!master || !master.mediaGroups || !master.mediaGroups.AUDIO) {
      return defaultPlaylists;
    }
    var AUDIO5 = master.mediaGroups.AUDIO;
    var groupKeys = Object.keys(AUDIO5);
    var track;
    if (Object.keys(this.mediaTypes_.AUDIO.groups).length) {
      track = this.mediaTypes_.AUDIO.activeTrack();
    } else {
      var defaultGroup = AUDIO5.main || groupKeys.length && AUDIO5[groupKeys[0]];
      for (var label in defaultGroup) {
        if (defaultGroup[label]["default"]) {
          track = {
            label
          };
          break;
        }
      }
    }
    if (!track) {
      return defaultPlaylists;
    }
    var playlists = [];
    for (var group in AUDIO5) {
      if (AUDIO5[group][track.label]) {
        var properties = AUDIO5[group][track.label];
        if (properties.playlists && properties.playlists.length) {
          playlists.push.apply(playlists, properties.playlists);
        } else if (properties.uri) {
          playlists.push(properties);
        } else if (master.playlists.length) {
          for (var i = 0; i < master.playlists.length; i++) {
            var playlist = master.playlists[i];
            if (playlist.attributes && playlist.attributes.AUDIO && playlist.attributes.AUDIO === group) {
              playlists.push(playlist);
            }
          }
        }
      }
    }
    if (!playlists.length) {
      return defaultPlaylists;
    }
    return playlists;
  };
  _proto.setupMasterPlaylistLoaderListeners_ = function setupMasterPlaylistLoaderListeners_() {
    var _this3 = this;
    this.masterPlaylistLoader_.on("loadedmetadata", function() {
      var media = _this3.masterPlaylistLoader_.media();
      var requestTimeout = media.targetDuration * 1.5 * 1e3;
      if (isLowestEnabledRendition(_this3.masterPlaylistLoader_.master, _this3.masterPlaylistLoader_.media())) {
        _this3.requestOptions_.timeout = 0;
      } else {
        _this3.requestOptions_.timeout = requestTimeout;
      }
      if (media.endList && _this3.tech_.preload() !== "none") {
        _this3.mainSegmentLoader_.playlist(media, _this3.requestOptions_);
        _this3.mainSegmentLoader_.load();
      }
      setupMediaGroups({
        sourceType: _this3.sourceType_,
        segmentLoaders: {
          AUDIO: _this3.audioSegmentLoader_,
          SUBTITLES: _this3.subtitleSegmentLoader_,
          main: _this3.mainSegmentLoader_
        },
        tech: _this3.tech_,
        requestOptions: _this3.requestOptions_,
        masterPlaylistLoader: _this3.masterPlaylistLoader_,
        vhs: _this3.vhs_,
        master: _this3.master(),
        mediaTypes: _this3.mediaTypes_,
        blacklistCurrentPlaylist: _this3.blacklistCurrentPlaylist.bind(_this3)
      });
      _this3.triggerPresenceUsage_(_this3.master(), media);
      _this3.setupFirstPlay();
      if (!_this3.mediaTypes_.AUDIO.activePlaylistLoader || _this3.mediaTypes_.AUDIO.activePlaylistLoader.media()) {
        _this3.trigger("selectedinitialmedia");
      } else {
        _this3.mediaTypes_.AUDIO.activePlaylistLoader.one("loadedmetadata", function() {
          _this3.trigger("selectedinitialmedia");
        });
      }
    });
    this.masterPlaylistLoader_.on("loadedplaylist", function() {
      if (_this3.loadOnPlay_) {
        _this3.tech_.off("play", _this3.loadOnPlay_);
      }
      var updatedPlaylist = _this3.masterPlaylistLoader_.media();
      if (!updatedPlaylist) {
        _this3.excludeUnsupportedVariants_();
        var selectedMedia;
        if (_this3.enableLowInitialPlaylist) {
          selectedMedia = _this3.selectInitialPlaylist();
        }
        if (!selectedMedia) {
          selectedMedia = _this3.selectPlaylist();
        }
        if (!selectedMedia || !_this3.shouldSwitchToMedia_(selectedMedia)) {
          return;
        }
        _this3.initialMedia_ = selectedMedia;
        _this3.switchMedia_(_this3.initialMedia_, "initial");
        var haveJsonSource = _this3.sourceType_ === "vhs-json" && _this3.initialMedia_.segments;
        if (!haveJsonSource) {
          return;
        }
        updatedPlaylist = _this3.initialMedia_;
      }
      _this3.handleUpdatedMediaPlaylist(updatedPlaylist);
    });
    this.masterPlaylistLoader_.on("error", function() {
      _this3.blacklistCurrentPlaylist(_this3.masterPlaylistLoader_.error);
    });
    this.masterPlaylistLoader_.on("mediachanging", function() {
      _this3.mainSegmentLoader_.abort();
      _this3.mainSegmentLoader_.pause();
    });
    this.masterPlaylistLoader_.on("mediachange", function() {
      var media = _this3.masterPlaylistLoader_.media();
      var requestTimeout = media.targetDuration * 1.5 * 1e3;
      if (isLowestEnabledRendition(_this3.masterPlaylistLoader_.master, _this3.masterPlaylistLoader_.media())) {
        _this3.requestOptions_.timeout = 0;
      } else {
        _this3.requestOptions_.timeout = requestTimeout;
      }
      _this3.mainSegmentLoader_.playlist(media, _this3.requestOptions_);
      _this3.mainSegmentLoader_.load();
      _this3.tech_.trigger({
        type: "mediachange",
        bubbles: true
      });
    });
    this.masterPlaylistLoader_.on("playlistunchanged", function() {
      var updatedPlaylist = _this3.masterPlaylistLoader_.media();
      if (updatedPlaylist.lastExcludeReason_ === "playlist-unchanged") {
        return;
      }
      var playlistOutdated = _this3.stuckAtPlaylistEnd_(updatedPlaylist);
      if (playlistOutdated) {
        _this3.blacklistCurrentPlaylist({
          message: "Playlist no longer updating.",
          reason: "playlist-unchanged"
        });
        _this3.tech_.trigger("playliststuck");
      }
    });
    this.masterPlaylistLoader_.on("renditiondisabled", function() {
      _this3.tech_.trigger({
        type: "usage",
        name: "vhs-rendition-disabled"
      });
      _this3.tech_.trigger({
        type: "usage",
        name: "hls-rendition-disabled"
      });
    });
    this.masterPlaylistLoader_.on("renditionenabled", function() {
      _this3.tech_.trigger({
        type: "usage",
        name: "vhs-rendition-enabled"
      });
      _this3.tech_.trigger({
        type: "usage",
        name: "hls-rendition-enabled"
      });
    });
  };
  _proto.handleUpdatedMediaPlaylist = function handleUpdatedMediaPlaylist(updatedPlaylist) {
    if (this.useCueTags_) {
      this.updateAdCues_(updatedPlaylist);
    }
    this.mainSegmentLoader_.playlist(updatedPlaylist, this.requestOptions_);
    this.updateDuration(!updatedPlaylist.endList);
    if (!this.tech_.paused()) {
      this.mainSegmentLoader_.load();
      if (this.audioSegmentLoader_) {
        this.audioSegmentLoader_.load();
      }
    }
  };
  _proto.triggerPresenceUsage_ = function triggerPresenceUsage_(master, media) {
    var mediaGroups = master.mediaGroups || {};
    var defaultDemuxed = true;
    var audioGroupKeys = Object.keys(mediaGroups.AUDIO);
    for (var mediaGroup in mediaGroups.AUDIO) {
      for (var label in mediaGroups.AUDIO[mediaGroup]) {
        var properties = mediaGroups.AUDIO[mediaGroup][label];
        if (!properties.uri) {
          defaultDemuxed = false;
        }
      }
    }
    if (defaultDemuxed) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-demuxed"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-demuxed"
      });
    }
    if (Object.keys(mediaGroups.SUBTITLES).length) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-webvtt"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-webvtt"
      });
    }
    if (Vhs$1.Playlist.isAes(media)) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-aes"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-aes"
      });
    }
    if (audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-alternate-audio"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-alternate-audio"
      });
    }
    if (this.useCueTags_) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-playlist-cue-tags"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-playlist-cue-tags"
      });
    }
  };
  _proto.shouldSwitchToMedia_ = function shouldSwitchToMedia_(nextPlaylist) {
    var currentPlaylist = this.masterPlaylistLoader_.media() || this.masterPlaylistLoader_.pendingMedia_;
    var currentTime = this.tech_.currentTime();
    var bufferLowWaterLine = this.bufferLowWaterLine();
    var bufferHighWaterLine = this.bufferHighWaterLine();
    var buffered = this.tech_.buffered();
    return shouldSwitchToMedia({
      buffered,
      currentTime,
      currentPlaylist,
      nextPlaylist,
      bufferLowWaterLine,
      bufferHighWaterLine,
      duration: this.duration(),
      experimentalBufferBasedABR: this.experimentalBufferBasedABR,
      log: this.logger_
    });
  };
  _proto.setupSegmentLoaderListeners_ = function setupSegmentLoaderListeners_() {
    var _this4 = this;
    if (!this.experimentalBufferBasedABR) {
      this.mainSegmentLoader_.on("bandwidthupdate", function() {
        var nextPlaylist = _this4.selectPlaylist();
        if (_this4.shouldSwitchToMedia_(nextPlaylist)) {
          _this4.switchMedia_(nextPlaylist, "bandwidthupdate");
        }
        _this4.tech_.trigger("bandwidthupdate");
      });
      this.mainSegmentLoader_.on("progress", function() {
        _this4.trigger("progress");
      });
    }
    this.mainSegmentLoader_.on("error", function() {
      _this4.blacklistCurrentPlaylist(_this4.mainSegmentLoader_.error());
    });
    this.mainSegmentLoader_.on("appenderror", function() {
      _this4.error = _this4.mainSegmentLoader_.error_;
      _this4.trigger("error");
    });
    this.mainSegmentLoader_.on("syncinfoupdate", function() {
      _this4.onSyncInfoUpdate_();
    });
    this.mainSegmentLoader_.on("timestampoffset", function() {
      _this4.tech_.trigger({
        type: "usage",
        name: "vhs-timestamp-offset"
      });
      _this4.tech_.trigger({
        type: "usage",
        name: "hls-timestamp-offset"
      });
    });
    this.audioSegmentLoader_.on("syncinfoupdate", function() {
      _this4.onSyncInfoUpdate_();
    });
    this.audioSegmentLoader_.on("appenderror", function() {
      _this4.error = _this4.audioSegmentLoader_.error_;
      _this4.trigger("error");
    });
    this.mainSegmentLoader_.on("ended", function() {
      _this4.logger_("main segment loader ended");
      _this4.onEndOfStream();
    });
    this.mainSegmentLoader_.on("earlyabort", function(event) {
      if (_this4.experimentalBufferBasedABR) {
        return;
      }
      _this4.delegateLoaders_("all", ["abort"]);
      _this4.blacklistCurrentPlaylist({
        message: "Aborted early because there isn't enough bandwidth to complete the request without rebuffering."
      }, ABORT_EARLY_BLACKLIST_SECONDS);
    });
    var updateCodecs = function updateCodecs2() {
      if (!_this4.sourceUpdater_.hasCreatedSourceBuffers()) {
        return _this4.tryToCreateSourceBuffers_();
      }
      var codecs = _this4.getCodecsOrExclude_();
      if (!codecs) {
        return;
      }
      _this4.sourceUpdater_.addOrChangeSourceBuffers(codecs);
    };
    this.mainSegmentLoader_.on("trackinfo", updateCodecs);
    this.audioSegmentLoader_.on("trackinfo", updateCodecs);
    this.mainSegmentLoader_.on("fmp4", function() {
      if (!_this4.triggeredFmp4Usage) {
        _this4.tech_.trigger({
          type: "usage",
          name: "vhs-fmp4"
        });
        _this4.tech_.trigger({
          type: "usage",
          name: "hls-fmp4"
        });
        _this4.triggeredFmp4Usage = true;
      }
    });
    this.audioSegmentLoader_.on("fmp4", function() {
      if (!_this4.triggeredFmp4Usage) {
        _this4.tech_.trigger({
          type: "usage",
          name: "vhs-fmp4"
        });
        _this4.tech_.trigger({
          type: "usage",
          name: "hls-fmp4"
        });
        _this4.triggeredFmp4Usage = true;
      }
    });
    this.audioSegmentLoader_.on("ended", function() {
      _this4.logger_("audioSegmentLoader ended");
      _this4.onEndOfStream();
    });
  };
  _proto.mediaSecondsLoaded_ = function mediaSecondsLoaded_() {
    return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);
  };
  _proto.load = function load() {
    this.mainSegmentLoader_.load();
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      this.audioSegmentLoader_.load();
    }
    if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {
      this.subtitleSegmentLoader_.load();
    }
  };
  _proto.smoothQualityChange_ = function smoothQualityChange_(media) {
    if (media === void 0) {
      media = this.selectPlaylist();
    }
    this.fastQualityChange_(media);
  };
  _proto.fastQualityChange_ = function fastQualityChange_(media) {
    var _this5 = this;
    if (media === void 0) {
      media = this.selectPlaylist();
    }
    if (media === this.masterPlaylistLoader_.media()) {
      this.logger_("skipping fastQualityChange because new media is same as old");
      return;
    }
    this.switchMedia_(media, "fast-quality");
    this.mainSegmentLoader_.resetEverything(function() {
      if (videojs.browser.IE_VERSION || videojs.browser.IS_EDGE) {
        _this5.tech_.setCurrentTime(_this5.tech_.currentTime() + 0.04);
      } else {
        _this5.tech_.setCurrentTime(_this5.tech_.currentTime());
      }
    });
  };
  _proto.play = function play() {
    if (this.setupFirstPlay()) {
      return;
    }
    if (this.tech_.ended()) {
      this.tech_.setCurrentTime(0);
    }
    if (this.hasPlayed_) {
      this.load();
    }
    var seekable3 = this.tech_.seekable();
    if (this.tech_.duration() === Infinity) {
      if (this.tech_.currentTime() < seekable3.start(0)) {
        return this.tech_.setCurrentTime(seekable3.end(seekable3.length - 1));
      }
    }
  };
  _proto.setupFirstPlay = function setupFirstPlay() {
    var _this6 = this;
    var media = this.masterPlaylistLoader_.media();
    if (!media || this.tech_.paused() || this.hasPlayed_) {
      return false;
    }
    if (!media.endList) {
      var seekable3 = this.seekable();
      if (!seekable3.length) {
        return false;
      }
      if (videojs.browser.IE_VERSION && this.tech_.readyState() === 0) {
        this.tech_.one("loadedmetadata", function() {
          _this6.trigger("firstplay");
          _this6.tech_.setCurrentTime(seekable3.end(0));
          _this6.hasPlayed_ = true;
        });
        return false;
      }
      this.trigger("firstplay");
      this.tech_.setCurrentTime(seekable3.end(0));
    }
    this.hasPlayed_ = true;
    this.load();
    return true;
  };
  _proto.handleSourceOpen_ = function handleSourceOpen_() {
    this.tryToCreateSourceBuffers_();
    if (this.tech_.autoplay()) {
      var playPromise = this.tech_.play();
      if (typeof playPromise !== "undefined" && typeof playPromise.then === "function") {
        playPromise.then(null, function(e) {
        });
      }
    }
    this.trigger("sourceopen");
  };
  _proto.handleSourceEnded_ = function handleSourceEnded_() {
    if (!this.inbandTextTracks_.metadataTrack_) {
      return;
    }
    var cues = this.inbandTextTracks_.metadataTrack_.cues;
    if (!cues || !cues.length) {
      return;
    }
    var duration5 = this.duration();
    cues[cues.length - 1].endTime = isNaN(duration5) || Math.abs(duration5) === Infinity ? Number.MAX_VALUE : duration5;
  };
  _proto.handleDurationChange_ = function handleDurationChange_() {
    this.tech_.trigger("durationchange");
  };
  _proto.onEndOfStream = function onEndOfStream() {
    var isEndOfStream = this.mainSegmentLoader_.ended_;
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      var mainMediaInfo = this.mainSegmentLoader_.getCurrentMediaInfo_();
      if (!mainMediaInfo || mainMediaInfo.hasVideo) {
        isEndOfStream = isEndOfStream && this.audioSegmentLoader_.ended_;
      } else {
        isEndOfStream = this.audioSegmentLoader_.ended_;
      }
    }
    if (!isEndOfStream) {
      return;
    }
    this.stopABRTimer_();
    this.sourceUpdater_.endOfStream();
  };
  _proto.stuckAtPlaylistEnd_ = function stuckAtPlaylistEnd_(playlist) {
    var seekable3 = this.seekable();
    if (!seekable3.length) {
      return false;
    }
    var expired = this.syncController_.getExpiredTime(playlist, this.duration());
    if (expired === null) {
      return false;
    }
    var absolutePlaylistEnd = Vhs$1.Playlist.playlistEnd(playlist, expired);
    var currentTime = this.tech_.currentTime();
    var buffered = this.tech_.buffered();
    if (!buffered.length) {
      return absolutePlaylistEnd - currentTime <= SAFE_TIME_DELTA;
    }
    var bufferedEnd = buffered.end(buffered.length - 1);
    return bufferedEnd - currentTime <= SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= SAFE_TIME_DELTA;
  };
  _proto.blacklistCurrentPlaylist = function blacklistCurrentPlaylist(error, blacklistDuration) {
    if (error === void 0) {
      error = {};
    }
    var currentPlaylist = error.playlist || this.masterPlaylistLoader_.media();
    blacklistDuration = blacklistDuration || error.blacklistDuration || this.blacklistDuration;
    if (!currentPlaylist) {
      this.error = error;
      if (this.mediaSource.readyState !== "open") {
        this.trigger("error");
      } else {
        this.sourceUpdater_.endOfStream("network");
      }
      return;
    }
    currentPlaylist.playlistErrors_++;
    var playlists = this.masterPlaylistLoader_.master.playlists;
    var enabledPlaylists = playlists.filter(isEnabled);
    var isFinalRendition = enabledPlaylists.length === 1 && enabledPlaylists[0] === currentPlaylist;
    if (playlists.length === 1 && blacklistDuration !== Infinity) {
      videojs.log.warn("Problem encountered with playlist " + currentPlaylist.id + ". Trying again since it is the only playlist.");
      this.tech_.trigger("retryplaylist");
      return this.masterPlaylistLoader_.load(isFinalRendition);
    }
    if (isFinalRendition) {
      var reincluded = false;
      playlists.forEach(function(playlist) {
        if (playlist === currentPlaylist) {
          return;
        }
        var excludeUntil2 = playlist.excludeUntil;
        if (typeof excludeUntil2 !== "undefined" && excludeUntil2 !== Infinity) {
          reincluded = true;
          delete playlist.excludeUntil;
        }
      });
      if (reincluded) {
        videojs.log.warn("Removing other playlists from the exclusion list because the last rendition is about to be excluded.");
        this.tech_.trigger("retryplaylist");
      }
    }
    var excludeUntil;
    if (currentPlaylist.playlistErrors_ > this.maxPlaylistRetries) {
      excludeUntil = Infinity;
    } else {
      excludeUntil = Date.now() + blacklistDuration * 1e3;
    }
    currentPlaylist.excludeUntil = excludeUntil;
    if (error.reason) {
      currentPlaylist.lastExcludeReason_ = error.reason;
    }
    this.tech_.trigger("blacklistplaylist");
    this.tech_.trigger({
      type: "usage",
      name: "vhs-rendition-blacklisted"
    });
    this.tech_.trigger({
      type: "usage",
      name: "hls-rendition-blacklisted"
    });
    var nextPlaylist = this.selectPlaylist();
    if (!nextPlaylist) {
      this.error = "Playback cannot continue. No available working or supported playlists.";
      this.trigger("error");
      return;
    }
    var logFn2 = error.internal ? this.logger_ : videojs.log.warn;
    var errorMessage = error.message ? " " + error.message : "";
    logFn2((error.internal ? "Internal problem" : "Problem") + " encountered with playlist " + currentPlaylist.id + "." + (errorMessage + " Switching to playlist " + nextPlaylist.id + "."));
    if (nextPlaylist.attributes.AUDIO !== currentPlaylist.attributes.AUDIO) {
      this.delegateLoaders_("audio", ["abort", "pause"]);
    }
    if (nextPlaylist.attributes.SUBTITLES !== currentPlaylist.attributes.SUBTITLES) {
      this.delegateLoaders_("subtitle", ["abort", "pause"]);
    }
    this.delegateLoaders_("main", ["abort", "pause"]);
    var delayDuration = nextPlaylist.targetDuration / 2 * 1e3 || 5 * 1e3;
    var shouldDelay = typeof nextPlaylist.lastRequest === "number" && Date.now() - nextPlaylist.lastRequest <= delayDuration;
    return this.switchMedia_(nextPlaylist, "exclude", isFinalRendition || shouldDelay);
  };
  _proto.pauseLoading = function pauseLoading() {
    this.delegateLoaders_("all", ["abort", "pause"]);
    this.stopABRTimer_();
  };
  _proto.delegateLoaders_ = function delegateLoaders_(filter, fnNames) {
    var _this7 = this;
    var loaders = [];
    var dontFilterPlaylist = filter === "all";
    if (dontFilterPlaylist || filter === "main") {
      loaders.push(this.masterPlaylistLoader_);
    }
    var mediaTypes2 = [];
    if (dontFilterPlaylist || filter === "audio") {
      mediaTypes2.push("AUDIO");
    }
    if (dontFilterPlaylist || filter === "subtitle") {
      mediaTypes2.push("CLOSED-CAPTIONS");
      mediaTypes2.push("SUBTITLES");
    }
    mediaTypes2.forEach(function(mediaType) {
      var loader = _this7.mediaTypes_[mediaType] && _this7.mediaTypes_[mediaType].activePlaylistLoader;
      if (loader) {
        loaders.push(loader);
      }
    });
    ["main", "audio", "subtitle"].forEach(function(name) {
      var loader = _this7[name + "SegmentLoader_"];
      if (loader && (filter === name || filter === "all")) {
        loaders.push(loader);
      }
    });
    loaders.forEach(function(loader) {
      return fnNames.forEach(function(fnName) {
        if (typeof loader[fnName] === "function") {
          loader[fnName]();
        }
      });
    });
  };
  _proto.setCurrentTime = function setCurrentTime(currentTime) {
    var buffered = findRange(this.tech_.buffered(), currentTime);
    if (!(this.masterPlaylistLoader_ && this.masterPlaylistLoader_.media())) {
      return 0;
    }
    if (!this.masterPlaylistLoader_.media().segments) {
      return 0;
    }
    if (buffered && buffered.length) {
      return currentTime;
    }
    this.mainSegmentLoader_.resetEverything();
    this.mainSegmentLoader_.abort();
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      this.audioSegmentLoader_.resetEverything();
      this.audioSegmentLoader_.abort();
    }
    if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {
      this.subtitleSegmentLoader_.resetEverything();
      this.subtitleSegmentLoader_.abort();
    }
    this.load();
  };
  _proto.duration = function duration5() {
    if (!this.masterPlaylistLoader_) {
      return 0;
    }
    var media = this.masterPlaylistLoader_.media();
    if (!media) {
      return 0;
    }
    if (!media.endList) {
      return Infinity;
    }
    if (this.mediaSource) {
      return this.mediaSource.duration;
    }
    return Vhs$1.Playlist.duration(media);
  };
  _proto.seekable = function seekable3() {
    return this.seekable_;
  };
  _proto.onSyncInfoUpdate_ = function onSyncInfoUpdate_() {
    var audioSeekable;
    if (!this.masterPlaylistLoader_) {
      return;
    }
    var media = this.masterPlaylistLoader_.media();
    if (!media) {
      return;
    }
    var expired = this.syncController_.getExpiredTime(media, this.duration());
    if (expired === null) {
      return;
    }
    var master = this.masterPlaylistLoader_.master;
    var mainSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(master, media));
    if (mainSeekable.length === 0) {
      return;
    }
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      media = this.mediaTypes_.AUDIO.activePlaylistLoader.media();
      expired = this.syncController_.getExpiredTime(media, this.duration());
      if (expired === null) {
        return;
      }
      audioSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(master, media));
      if (audioSeekable.length === 0) {
        return;
      }
    }
    var oldEnd;
    var oldStart;
    if (this.seekable_ && this.seekable_.length) {
      oldEnd = this.seekable_.end(0);
      oldStart = this.seekable_.start(0);
    }
    if (!audioSeekable) {
      this.seekable_ = mainSeekable;
    } else if (audioSeekable.start(0) > mainSeekable.end(0) || mainSeekable.start(0) > audioSeekable.end(0)) {
      this.seekable_ = mainSeekable;
    } else {
      this.seekable_ = videojs.createTimeRanges([[audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)]]);
    }
    if (this.seekable_ && this.seekable_.length) {
      if (this.seekable_.end(0) === oldEnd && this.seekable_.start(0) === oldStart) {
        return;
      }
    }
    this.logger_("seekable updated [" + printableRange(this.seekable_) + "]");
    this.tech_.trigger("seekablechanged");
  };
  _proto.updateDuration = function updateDuration(isLive) {
    if (this.updateDuration_) {
      this.mediaSource.removeEventListener("sourceopen", this.updateDuration_);
      this.updateDuration_ = null;
    }
    if (this.mediaSource.readyState !== "open") {
      this.updateDuration_ = this.updateDuration.bind(this, isLive);
      this.mediaSource.addEventListener("sourceopen", this.updateDuration_);
      return;
    }
    if (isLive) {
      var seekable3 = this.seekable();
      if (!seekable3.length) {
        return;
      }
      if (isNaN(this.mediaSource.duration) || this.mediaSource.duration < seekable3.end(seekable3.length - 1)) {
        this.sourceUpdater_.setDuration(seekable3.end(seekable3.length - 1));
      }
      return;
    }
    var buffered = this.tech_.buffered();
    var duration5 = Vhs$1.Playlist.duration(this.masterPlaylistLoader_.media());
    if (buffered.length > 0) {
      duration5 = Math.max(duration5, buffered.end(buffered.length - 1));
    }
    if (this.mediaSource.duration !== duration5) {
      this.sourceUpdater_.setDuration(duration5);
    }
  };
  _proto.dispose = function dispose() {
    var _this8 = this;
    this.trigger("dispose");
    this.decrypter_.terminate();
    this.masterPlaylistLoader_.dispose();
    this.mainSegmentLoader_.dispose();
    if (this.loadOnPlay_) {
      this.tech_.off("play", this.loadOnPlay_);
    }
    ["AUDIO", "SUBTITLES"].forEach(function(type2) {
      var groups = _this8.mediaTypes_[type2].groups;
      for (var id in groups) {
        groups[id].forEach(function(group) {
          if (group.playlistLoader) {
            group.playlistLoader.dispose();
          }
        });
      }
    });
    this.audioSegmentLoader_.dispose();
    this.subtitleSegmentLoader_.dispose();
    this.sourceUpdater_.dispose();
    this.timelineChangeController_.dispose();
    this.stopABRTimer_();
    if (this.updateDuration_) {
      this.mediaSource.removeEventListener("sourceopen", this.updateDuration_);
    }
    this.mediaSource.removeEventListener("durationchange", this.handleDurationChange_);
    this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_);
    this.mediaSource.removeEventListener("sourceended", this.handleSourceEnded_);
    this.off();
  };
  _proto.master = function master() {
    return this.masterPlaylistLoader_.master;
  };
  _proto.media = function media() {
    return this.masterPlaylistLoader_.media() || this.initialMedia_;
  };
  _proto.areMediaTypesKnown_ = function areMediaTypesKnown_() {
    var usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
    var hasMainMediaInfo = !!this.mainSegmentLoader_.getCurrentMediaInfo_();
    var hasAudioMediaInfo = !usingAudioLoader ? true : !!this.audioSegmentLoader_.getCurrentMediaInfo_();
    if (!hasMainMediaInfo || !hasAudioMediaInfo) {
      return false;
    }
    return true;
  };
  _proto.getCodecsOrExclude_ = function getCodecsOrExclude_() {
    var _this9 = this;
    var media = {
      main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},
      audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {}
    };
    media.video = media.main;
    var playlistCodecs = codecsForPlaylist(this.master(), this.media());
    var codecs = {};
    var usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
    if (media.main.hasVideo) {
      codecs.video = playlistCodecs.video || media.main.videoCodec || DEFAULT_VIDEO_CODEC;
    }
    if (media.main.isMuxed) {
      codecs.video += "," + (playlistCodecs.audio || media.main.audioCodec || DEFAULT_AUDIO_CODEC);
    }
    if (media.main.hasAudio && !media.main.isMuxed || media.audio.hasAudio || usingAudioLoader) {
      codecs.audio = playlistCodecs.audio || media.main.audioCodec || media.audio.audioCodec || DEFAULT_AUDIO_CODEC;
      media.audio.isFmp4 = media.main.hasAudio && !media.main.isMuxed ? media.main.isFmp4 : media.audio.isFmp4;
    }
    if (!codecs.audio && !codecs.video) {
      this.blacklistCurrentPlaylist({
        playlist: this.media(),
        message: "Could not determine codecs for playlist.",
        blacklistDuration: Infinity
      });
      return;
    }
    var supportFunction = function supportFunction2(isFmp4, codec) {
      return isFmp4 ? browserSupportsCodec(codec) : muxerSupportsCodec(codec);
    };
    var unsupportedCodecs = {};
    var unsupportedAudio;
    ["video", "audio"].forEach(function(type2) {
      if (codecs.hasOwnProperty(type2) && !supportFunction(media[type2].isFmp4, codecs[type2])) {
        var supporter = media[type2].isFmp4 ? "browser" : "muxer";
        unsupportedCodecs[supporter] = unsupportedCodecs[supporter] || [];
        unsupportedCodecs[supporter].push(codecs[type2]);
        if (type2 === "audio") {
          unsupportedAudio = supporter;
        }
      }
    });
    if (usingAudioLoader && unsupportedAudio && this.media().attributes.AUDIO) {
      var audioGroup = this.media().attributes.AUDIO;
      this.master().playlists.forEach(function(variant) {
        var variantAudioGroup = variant.attributes && variant.attributes.AUDIO;
        if (variantAudioGroup === audioGroup && variant !== _this9.media()) {
          variant.excludeUntil = Infinity;
        }
      });
      this.logger_("excluding audio group " + audioGroup + " as " + unsupportedAudio + ' does not support codec(s): "' + codecs.audio + '"');
    }
    if (Object.keys(unsupportedCodecs).length) {
      var message = Object.keys(unsupportedCodecs).reduce(function(acc, supporter) {
        if (acc) {
          acc += ", ";
        }
        acc += supporter + ' does not support codec(s): "' + unsupportedCodecs[supporter].join(",") + '"';
        return acc;
      }, "") + ".";
      this.blacklistCurrentPlaylist({
        playlist: this.media(),
        internal: true,
        message,
        blacklistDuration: Infinity
      });
      return;
    }
    if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {
      var switchMessages = [];
      ["video", "audio"].forEach(function(type2) {
        var newCodec = (parseCodecs(_this9.sourceUpdater_.codecs[type2] || "")[0] || {}).type;
        var oldCodec = (parseCodecs(codecs[type2] || "")[0] || {}).type;
        if (newCodec && oldCodec && newCodec.toLowerCase() !== oldCodec.toLowerCase()) {
          switchMessages.push('"' + _this9.sourceUpdater_.codecs[type2] + '" -> "' + codecs[type2] + '"');
        }
      });
      if (switchMessages.length) {
        this.blacklistCurrentPlaylist({
          playlist: this.media(),
          message: "Codec switching not supported: " + switchMessages.join(", ") + ".",
          blacklistDuration: Infinity,
          internal: true
        });
        return;
      }
    }
    return codecs;
  };
  _proto.tryToCreateSourceBuffers_ = function tryToCreateSourceBuffers_() {
    if (this.mediaSource.readyState !== "open" || this.sourceUpdater_.hasCreatedSourceBuffers()) {
      return;
    }
    if (!this.areMediaTypesKnown_()) {
      return;
    }
    var codecs = this.getCodecsOrExclude_();
    if (!codecs) {
      return;
    }
    this.sourceUpdater_.createSourceBuffers(codecs);
    var codecString = [codecs.video, codecs.audio].filter(Boolean).join(",");
    this.excludeIncompatibleVariants_(codecString);
  };
  _proto.excludeUnsupportedVariants_ = function excludeUnsupportedVariants_() {
    var _this10 = this;
    var playlists = this.master().playlists;
    var ids = [];
    Object.keys(playlists).forEach(function(key) {
      var variant = playlists[key];
      if (ids.indexOf(variant.id) !== -1) {
        return;
      }
      ids.push(variant.id);
      var codecs = codecsForPlaylist(_this10.master, variant);
      var unsupported = [];
      if (codecs.audio && !muxerSupportsCodec(codecs.audio) && !browserSupportsCodec(codecs.audio)) {
        unsupported.push("audio codec " + codecs.audio);
      }
      if (codecs.video && !muxerSupportsCodec(codecs.video) && !browserSupportsCodec(codecs.video)) {
        unsupported.push("video codec " + codecs.video);
      }
      if (codecs.text && codecs.text === "stpp.ttml.im1t") {
        unsupported.push("text codec " + codecs.text);
      }
      if (unsupported.length) {
        variant.excludeUntil = Infinity;
        _this10.logger_("excluding " + variant.id + " for unsupported: " + unsupported.join(", "));
      }
    });
  };
  _proto.excludeIncompatibleVariants_ = function excludeIncompatibleVariants_(codecString) {
    var _this11 = this;
    var ids = [];
    var playlists = this.master().playlists;
    var codecs = unwrapCodecList(parseCodecs(codecString));
    var codecCount_ = codecCount(codecs);
    var videoDetails = codecs.video && parseCodecs(codecs.video)[0] || null;
    var audioDetails = codecs.audio && parseCodecs(codecs.audio)[0] || null;
    Object.keys(playlists).forEach(function(key) {
      var variant = playlists[key];
      if (ids.indexOf(variant.id) !== -1 || variant.excludeUntil === Infinity) {
        return;
      }
      ids.push(variant.id);
      var blacklistReasons = [];
      var variantCodecs = codecsForPlaylist(_this11.masterPlaylistLoader_.master, variant);
      var variantCodecCount = codecCount(variantCodecs);
      if (!variantCodecs.audio && !variantCodecs.video) {
        return;
      }
      if (variantCodecCount !== codecCount_) {
        blacklistReasons.push('codec count "' + variantCodecCount + '" !== "' + codecCount_ + '"');
      }
      if (!_this11.sourceUpdater_.canChangeType()) {
        var variantVideoDetails = variantCodecs.video && parseCodecs(variantCodecs.video)[0] || null;
        var variantAudioDetails = variantCodecs.audio && parseCodecs(variantCodecs.audio)[0] || null;
        if (variantVideoDetails && videoDetails && variantVideoDetails.type.toLowerCase() !== videoDetails.type.toLowerCase()) {
          blacklistReasons.push('video codec "' + variantVideoDetails.type + '" !== "' + videoDetails.type + '"');
        }
        if (variantAudioDetails && audioDetails && variantAudioDetails.type.toLowerCase() !== audioDetails.type.toLowerCase()) {
          blacklistReasons.push('audio codec "' + variantAudioDetails.type + '" !== "' + audioDetails.type + '"');
        }
      }
      if (blacklistReasons.length) {
        variant.excludeUntil = Infinity;
        _this11.logger_("blacklisting " + variant.id + ": " + blacklistReasons.join(" && "));
      }
    });
  };
  _proto.updateAdCues_ = function updateAdCues_(media) {
    var offset = 0;
    var seekable3 = this.seekable();
    if (seekable3.length) {
      offset = seekable3.start(0);
    }
    updateAdCues(media, this.cueTagsTrack_, offset);
  };
  _proto.goalBufferLength = function goalBufferLength() {
    var currentTime = this.tech_.currentTime();
    var initial = Config.GOAL_BUFFER_LENGTH;
    var rate = Config.GOAL_BUFFER_LENGTH_RATE;
    var max = Math.max(initial, Config.MAX_GOAL_BUFFER_LENGTH);
    return Math.min(initial + currentTime * rate, max);
  };
  _proto.bufferLowWaterLine = function bufferLowWaterLine() {
    var currentTime = this.tech_.currentTime();
    var initial = Config.BUFFER_LOW_WATER_LINE;
    var rate = Config.BUFFER_LOW_WATER_LINE_RATE;
    var max = Math.max(initial, Config.MAX_BUFFER_LOW_WATER_LINE);
    var newMax = Math.max(initial, Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);
    return Math.min(initial + currentTime * rate, this.experimentalBufferBasedABR ? newMax : max);
  };
  _proto.bufferHighWaterLine = function bufferHighWaterLine() {
    return Config.BUFFER_HIGH_WATER_LINE;
  };
  return MasterPlaylistController2;
}(videojs.EventTarget);
var enableFunction = function enableFunction2(loader, playlistID, changePlaylistFn) {
  return function(enable) {
    var playlist = loader.master.playlists[playlistID];
    var incompatible = isIncompatible(playlist);
    var currentlyEnabled = isEnabled(playlist);
    if (typeof enable === "undefined") {
      return currentlyEnabled;
    }
    if (enable) {
      delete playlist.disabled;
    } else {
      playlist.disabled = true;
    }
    if (enable !== currentlyEnabled && !incompatible) {
      changePlaylistFn();
      if (enable) {
        loader.trigger("renditionenabled");
      } else {
        loader.trigger("renditiondisabled");
      }
    }
    return enable;
  };
};
var Representation = function Representation2(vhsHandler, playlist, id) {
  var mpc = vhsHandler.masterPlaylistController_, smoothQualityChange = vhsHandler.options_.smoothQualityChange;
  var changeType2 = smoothQualityChange ? "smooth" : "fast";
  var qualityChangeFunction = mpc[changeType2 + "QualityChange_"].bind(mpc);
  if (playlist.attributes) {
    var resolution = playlist.attributes.RESOLUTION;
    this.width = resolution && resolution.width;
    this.height = resolution && resolution.height;
    this.bandwidth = playlist.attributes.BANDWIDTH;
  }
  this.codecs = codecsForPlaylist(mpc.master(), playlist);
  this.playlist = playlist;
  this.id = id;
  this.enabled = enableFunction(vhsHandler.playlists, playlist.id, qualityChangeFunction);
};
var renditionSelectionMixin = function renditionSelectionMixin2(vhsHandler) {
  vhsHandler.representations = function() {
    var master = vhsHandler.masterPlaylistController_.master();
    var playlists = isAudioOnly(master) ? vhsHandler.masterPlaylistController_.getAudioTrackPlaylists_() : master.playlists;
    if (!playlists) {
      return [];
    }
    return playlists.filter(function(media) {
      return !isIncompatible(media);
    }).map(function(e, i) {
      return new Representation(vhsHandler, e, e.id);
    });
  };
};
var timerCancelEvents = ["seeking", "seeked", "pause", "playing", "error"];
var PlaybackWatcher = /* @__PURE__ */ function() {
  function PlaybackWatcher2(options) {
    var _this = this;
    this.masterPlaylistController_ = options.masterPlaylistController;
    this.tech_ = options.tech;
    this.seekable = options.seekable;
    this.allowSeeksWithinUnsafeLiveWindow = options.allowSeeksWithinUnsafeLiveWindow;
    this.liveRangeSafeTimeDelta = options.liveRangeSafeTimeDelta;
    this.media = options.media;
    this.consecutiveUpdates = 0;
    this.lastRecordedTime = null;
    this.timer_ = null;
    this.checkCurrentTimeTimeout_ = null;
    this.logger_ = logger2("PlaybackWatcher");
    this.logger_("initialize");
    var playHandler = function playHandler2() {
      return _this.monitorCurrentTime_();
    };
    var canPlayHandler = function canPlayHandler2() {
      return _this.monitorCurrentTime_();
    };
    var waitingHandler = function waitingHandler2() {
      return _this.techWaiting_();
    };
    var cancelTimerHandler = function cancelTimerHandler2() {
      return _this.cancelTimer_();
    };
    var mpc = this.masterPlaylistController_;
    var loaderTypes = ["main", "subtitle", "audio"];
    var loaderChecks = {};
    loaderTypes.forEach(function(type2) {
      loaderChecks[type2] = {
        reset: function reset3() {
          return _this.resetSegmentDownloads_(type2);
        },
        updateend: function updateend() {
          return _this.checkSegmentDownloads_(type2);
        }
      };
      mpc[type2 + "SegmentLoader_"].on("appendsdone", loaderChecks[type2].updateend);
      mpc[type2 + "SegmentLoader_"].on("playlistupdate", loaderChecks[type2].reset);
      _this.tech_.on(["seeked", "seeking"], loaderChecks[type2].reset);
    });
    var setSeekingHandlers = function setSeekingHandlers2(fn) {
      ["main", "audio"].forEach(function(type2) {
        mpc[type2 + "SegmentLoader_"][fn]("appended", _this.seekingAppendCheck_);
      });
    };
    this.seekingAppendCheck_ = function() {
      if (_this.fixesBadSeeks_()) {
        _this.consecutiveUpdates = 0;
        _this.lastRecordedTime = _this.tech_.currentTime();
        setSeekingHandlers("off");
      }
    };
    this.clearSeekingAppendCheck_ = function() {
      return setSeekingHandlers("off");
    };
    this.watchForBadSeeking_ = function() {
      _this.clearSeekingAppendCheck_();
      setSeekingHandlers("on");
    };
    this.tech_.on("seeked", this.clearSeekingAppendCheck_);
    this.tech_.on("seeking", this.watchForBadSeeking_);
    this.tech_.on("waiting", waitingHandler);
    this.tech_.on(timerCancelEvents, cancelTimerHandler);
    this.tech_.on("canplay", canPlayHandler);
    this.tech_.one("play", playHandler);
    this.dispose = function() {
      _this.clearSeekingAppendCheck_();
      _this.logger_("dispose");
      _this.tech_.off("waiting", waitingHandler);
      _this.tech_.off(timerCancelEvents, cancelTimerHandler);
      _this.tech_.off("canplay", canPlayHandler);
      _this.tech_.off("play", playHandler);
      _this.tech_.off("seeking", _this.watchForBadSeeking_);
      _this.tech_.off("seeked", _this.clearSeekingAppendCheck_);
      loaderTypes.forEach(function(type2) {
        mpc[type2 + "SegmentLoader_"].off("appendsdone", loaderChecks[type2].updateend);
        mpc[type2 + "SegmentLoader_"].off("playlistupdate", loaderChecks[type2].reset);
        _this.tech_.off(["seeked", "seeking"], loaderChecks[type2].reset);
      });
      if (_this.checkCurrentTimeTimeout_) {
        import_window6.default.clearTimeout(_this.checkCurrentTimeTimeout_);
      }
      _this.cancelTimer_();
    };
  }
  var _proto = PlaybackWatcher2.prototype;
  _proto.monitorCurrentTime_ = function monitorCurrentTime_() {
    this.checkCurrentTime_();
    if (this.checkCurrentTimeTimeout_) {
      import_window6.default.clearTimeout(this.checkCurrentTimeTimeout_);
    }
    this.checkCurrentTimeTimeout_ = import_window6.default.setTimeout(this.monitorCurrentTime_.bind(this), 250);
  };
  _proto.resetSegmentDownloads_ = function resetSegmentDownloads_(type2) {
    var loader = this.masterPlaylistController_[type2 + "SegmentLoader_"];
    if (this[type2 + "StalledDownloads_"] > 0) {
      this.logger_("resetting possible stalled download count for " + type2 + " loader");
    }
    this[type2 + "StalledDownloads_"] = 0;
    this[type2 + "Buffered_"] = loader.buffered_();
  };
  _proto.checkSegmentDownloads_ = function checkSegmentDownloads_(type2) {
    var mpc = this.masterPlaylistController_;
    var loader = mpc[type2 + "SegmentLoader_"];
    var buffered = loader.buffered_();
    var isBufferedDifferent = isRangeDifferent(this[type2 + "Buffered_"], buffered);
    this[type2 + "Buffered_"] = buffered;
    if (isBufferedDifferent) {
      this.resetSegmentDownloads_(type2);
      return;
    }
    this[type2 + "StalledDownloads_"]++;
    this.logger_("found #" + this[type2 + "StalledDownloads_"] + " " + type2 + " appends that did not increase buffer (possible stalled download)", {
      playlistId: loader.playlist_ && loader.playlist_.id,
      buffered: timeRangesToArray(buffered)
    });
    if (this[type2 + "StalledDownloads_"] < 10) {
      return;
    }
    this.logger_(type2 + " loader stalled download exclusion");
    this.resetSegmentDownloads_(type2);
    this.tech_.trigger({
      type: "usage",
      name: "vhs-" + type2 + "-download-exclusion"
    });
    if (type2 === "subtitle") {
      return;
    }
    mpc.blacklistCurrentPlaylist({
      message: "Excessive " + type2 + " segment downloading detected."
    }, Infinity);
  };
  _proto.checkCurrentTime_ = function checkCurrentTime_() {
    if (this.tech_.paused() || this.tech_.seeking()) {
      return;
    }
    var currentTime = this.tech_.currentTime();
    var buffered = this.tech_.buffered();
    if (this.lastRecordedTime === currentTime && (!buffered.length || currentTime + SAFE_TIME_DELTA >= buffered.end(buffered.length - 1))) {
      return this.techWaiting_();
    }
    if (this.consecutiveUpdates >= 5 && currentTime === this.lastRecordedTime) {
      this.consecutiveUpdates++;
      this.waiting_();
    } else if (currentTime === this.lastRecordedTime) {
      this.consecutiveUpdates++;
    } else {
      this.consecutiveUpdates = 0;
      this.lastRecordedTime = currentTime;
    }
  };
  _proto.cancelTimer_ = function cancelTimer_() {
    this.consecutiveUpdates = 0;
    if (this.timer_) {
      this.logger_("cancelTimer_");
      clearTimeout(this.timer_);
    }
    this.timer_ = null;
  };
  _proto.fixesBadSeeks_ = function fixesBadSeeks_() {
    var seeking = this.tech_.seeking();
    if (!seeking) {
      return false;
    }
    var seekable3 = this.seekable();
    var currentTime = this.tech_.currentTime();
    var isAfterSeekableRange = this.afterSeekableWindow_(seekable3, currentTime, this.media(), this.allowSeeksWithinUnsafeLiveWindow);
    var seekTo;
    if (isAfterSeekableRange) {
      var seekableEnd = seekable3.end(seekable3.length - 1);
      seekTo = seekableEnd;
    }
    if (this.beforeSeekableWindow_(seekable3, currentTime)) {
      var seekableStart = seekable3.start(0);
      seekTo = seekableStart + // if the playlist is too short and the seekable range is an exact time (can
      // happen in live with a 3 segment playlist), then don't use a time delta
      (seekableStart === seekable3.end(0) ? 0 : SAFE_TIME_DELTA);
    }
    if (typeof seekTo !== "undefined") {
      this.logger_("Trying to seek outside of seekable at time " + currentTime + " with " + ("seekable range " + printableRange(seekable3) + ". Seeking to ") + (seekTo + "."));
      this.tech_.setCurrentTime(seekTo);
      return true;
    }
    var sourceUpdater = this.masterPlaylistController_.sourceUpdater_;
    var buffered = this.tech_.buffered();
    var audioBuffered = sourceUpdater.audioBuffer ? sourceUpdater.audioBuffered() : null;
    var videoBuffered = sourceUpdater.videoBuffer ? sourceUpdater.videoBuffered() : null;
    var media = this.media();
    var minAppendedDuration = media.partTargetDuration ? media.partTargetDuration : (media.targetDuration - TIME_FUDGE_FACTOR) * 2;
    var bufferedToCheck = [audioBuffered, videoBuffered];
    for (var i = 0; i < bufferedToCheck.length; i++) {
      if (!bufferedToCheck[i]) {
        continue;
      }
      var timeAhead = timeAheadOf(bufferedToCheck[i], currentTime);
      if (timeAhead < minAppendedDuration) {
        return false;
      }
    }
    var nextRange = findNextRange(buffered, currentTime);
    if (nextRange.length === 0) {
      return false;
    }
    seekTo = nextRange.start(0) + SAFE_TIME_DELTA;
    this.logger_("Buffered region starts (" + nextRange.start(0) + ") " + (" just beyond seek point (" + currentTime + "). Seeking to " + seekTo + "."));
    this.tech_.setCurrentTime(seekTo);
    return true;
  };
  _proto.waiting_ = function waiting_() {
    if (this.techWaiting_()) {
      return;
    }
    var currentTime = this.tech_.currentTime();
    var buffered = this.tech_.buffered();
    var currentRange = findRange(buffered, currentTime);
    if (currentRange.length && currentTime + 3 <= currentRange.end(0)) {
      this.cancelTimer_();
      this.tech_.setCurrentTime(currentTime);
      this.logger_("Stopped at " + currentTime + " while inside a buffered region " + ("[" + currentRange.start(0) + " -> " + currentRange.end(0) + "]. Attempting to resume ") + "playback by seeking to the current time.");
      this.tech_.trigger({
        type: "usage",
        name: "vhs-unknown-waiting"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-unknown-waiting"
      });
      return;
    }
  };
  _proto.techWaiting_ = function techWaiting_() {
    var seekable3 = this.seekable();
    var currentTime = this.tech_.currentTime();
    if (this.tech_.seeking() || this.timer_ !== null) {
      return true;
    }
    if (this.beforeSeekableWindow_(seekable3, currentTime)) {
      var livePoint = seekable3.end(seekable3.length - 1);
      this.logger_("Fell out of live window at time " + currentTime + ". Seeking to " + ("live point (seekable end) " + livePoint));
      this.cancelTimer_();
      this.tech_.setCurrentTime(livePoint);
      this.tech_.trigger({
        type: "usage",
        name: "vhs-live-resync"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-live-resync"
      });
      return true;
    }
    var sourceUpdater = this.tech_.vhs.masterPlaylistController_.sourceUpdater_;
    var buffered = this.tech_.buffered();
    var videoUnderflow = this.videoUnderflow_({
      audioBuffered: sourceUpdater.audioBuffered(),
      videoBuffered: sourceUpdater.videoBuffered(),
      currentTime
    });
    if (videoUnderflow) {
      this.cancelTimer_();
      this.tech_.setCurrentTime(currentTime);
      this.tech_.trigger({
        type: "usage",
        name: "vhs-video-underflow"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-video-underflow"
      });
      return true;
    }
    var nextRange = findNextRange(buffered, currentTime);
    if (nextRange.length > 0) {
      var difference = nextRange.start(0) - currentTime;
      this.logger_("Stopped at " + currentTime + ", setting timer for " + difference + ", seeking " + ("to " + nextRange.start(0)));
      this.cancelTimer_();
      this.timer_ = setTimeout(this.skipTheGap_.bind(this), difference * 1e3, currentTime);
      return true;
    }
    return false;
  };
  _proto.afterSeekableWindow_ = function afterSeekableWindow_(seekable3, currentTime, playlist, allowSeeksWithinUnsafeLiveWindow) {
    if (allowSeeksWithinUnsafeLiveWindow === void 0) {
      allowSeeksWithinUnsafeLiveWindow = false;
    }
    if (!seekable3.length) {
      return false;
    }
    var allowedEnd = seekable3.end(seekable3.length - 1) + SAFE_TIME_DELTA;
    var isLive = !playlist.endList;
    if (isLive && allowSeeksWithinUnsafeLiveWindow) {
      allowedEnd = seekable3.end(seekable3.length - 1) + playlist.targetDuration * 3;
    }
    if (currentTime > allowedEnd) {
      return true;
    }
    return false;
  };
  _proto.beforeSeekableWindow_ = function beforeSeekableWindow_(seekable3, currentTime) {
    if (seekable3.length && // can't fall before 0 and 0 seekable start identifies VOD stream
    seekable3.start(0) > 0 && currentTime < seekable3.start(0) - this.liveRangeSafeTimeDelta) {
      return true;
    }
    return false;
  };
  _proto.videoUnderflow_ = function videoUnderflow_(_ref) {
    var videoBuffered = _ref.videoBuffered, audioBuffered = _ref.audioBuffered, currentTime = _ref.currentTime;
    if (!videoBuffered) {
      return;
    }
    var gap;
    if (videoBuffered.length && audioBuffered.length) {
      var lastVideoRange = findRange(videoBuffered, currentTime - 3);
      var videoRange = findRange(videoBuffered, currentTime);
      var audioRange = findRange(audioBuffered, currentTime);
      if (audioRange.length && !videoRange.length && lastVideoRange.length) {
        gap = {
          start: lastVideoRange.end(0),
          end: audioRange.end(0)
        };
      }
    } else {
      var nextRange = findNextRange(videoBuffered, currentTime);
      if (!nextRange.length) {
        gap = this.gapFromVideoUnderflow_(videoBuffered, currentTime);
      }
    }
    if (gap) {
      this.logger_("Encountered a gap in video from " + gap.start + " to " + gap.end + ". " + ("Seeking to current time " + currentTime));
      return true;
    }
    return false;
  };
  _proto.skipTheGap_ = function skipTheGap_(scheduledCurrentTime) {
    var buffered = this.tech_.buffered();
    var currentTime = this.tech_.currentTime();
    var nextRange = findNextRange(buffered, currentTime);
    this.cancelTimer_();
    if (nextRange.length === 0 || currentTime !== scheduledCurrentTime) {
      return;
    }
    this.logger_("skipTheGap_:", "currentTime:", currentTime, "scheduled currentTime:", scheduledCurrentTime, "nextRange start:", nextRange.start(0));
    this.tech_.setCurrentTime(nextRange.start(0) + TIME_FUDGE_FACTOR);
    this.tech_.trigger({
      type: "usage",
      name: "vhs-gap-skip"
    });
    this.tech_.trigger({
      type: "usage",
      name: "hls-gap-skip"
    });
  };
  _proto.gapFromVideoUnderflow_ = function gapFromVideoUnderflow_(buffered, currentTime) {
    var gaps = findGaps(buffered);
    for (var i = 0; i < gaps.length; i++) {
      var start2 = gaps.start(i);
      var end = gaps.end(i);
      if (currentTime - start2 < 4 && currentTime - start2 > 2) {
        return {
          start: start2,
          end
        };
      }
    }
    return null;
  };
  return PlaybackWatcher2;
}();
var defaultOptions = {
  errorInterval: 30,
  getSource: function getSource(next) {
    var tech = this.tech({
      IWillNotUseThisInPlugins: true
    });
    var sourceObj = tech.currentSource_ || this.currentSource();
    return next(sourceObj);
  }
};
var initPlugin = function initPlugin2(player, options) {
  var lastCalled = 0;
  var seekTo = 0;
  var localOptions = videojs.mergeOptions(defaultOptions, options);
  player.ready(function() {
    player.trigger({
      type: "usage",
      name: "vhs-error-reload-initialized"
    });
    player.trigger({
      type: "usage",
      name: "hls-error-reload-initialized"
    });
  });
  var loadedMetadataHandler = function loadedMetadataHandler2() {
    if (seekTo) {
      player.currentTime(seekTo);
    }
  };
  var setSource2 = function setSource3(sourceObj) {
    if (sourceObj === null || sourceObj === void 0) {
      return;
    }
    seekTo = player.duration() !== Infinity && player.currentTime() || 0;
    player.one("loadedmetadata", loadedMetadataHandler);
    player.src(sourceObj);
    player.trigger({
      type: "usage",
      name: "vhs-error-reload"
    });
    player.trigger({
      type: "usage",
      name: "hls-error-reload"
    });
    player.play();
  };
  var errorHandler = function errorHandler2() {
    if (Date.now() - lastCalled < localOptions.errorInterval * 1e3) {
      player.trigger({
        type: "usage",
        name: "vhs-error-reload-canceled"
      });
      player.trigger({
        type: "usage",
        name: "hls-error-reload-canceled"
      });
      return;
    }
    if (!localOptions.getSource || typeof localOptions.getSource !== "function") {
      videojs.log.error("ERROR: reloadSourceOnError - The option getSource must be a function!");
      return;
    }
    lastCalled = Date.now();
    return localOptions.getSource.call(player, setSource2);
  };
  var cleanupEvents = function cleanupEvents2() {
    player.off("loadedmetadata", loadedMetadataHandler);
    player.off("error", errorHandler);
    player.off("dispose", cleanupEvents2);
  };
  var reinitPlugin = function reinitPlugin2(newOptions) {
    cleanupEvents();
    initPlugin2(player, newOptions);
  };
  player.on("error", errorHandler);
  player.on("dispose", cleanupEvents);
  player.reloadSourceOnError = reinitPlugin;
};
var reloadSourceOnError = function reloadSourceOnError2(options) {
  initPlugin(this, options);
};
var version$4 = "2.14.3";
var version$3 = "6.0.1";
var version$2 = "0.21.1";
var version$1 = "4.7.1";
var version = "3.1.3";
var Vhs = {
  PlaylistLoader: PlaylistLoader2,
  Playlist,
  utils,
  STANDARD_PLAYLIST_SELECTOR: lastBandwidthSelector,
  INITIAL_PLAYLIST_SELECTOR: lowestBitrateCompatibleVariantSelector,
  lastBandwidthSelector,
  movingAverageBandwidthSelector,
  comparePlaylistBandwidth,
  comparePlaylistResolution,
  xhr: xhrFactory()
};
Object.keys(Config).forEach(function(prop) {
  Object.defineProperty(Vhs, prop, {
    get: function get7() {
      videojs.log.warn("using Vhs." + prop + " is UNSAFE be sure you know what you are doing");
      return Config[prop];
    },
    set: function set4(value) {
      videojs.log.warn("using Vhs." + prop + " is UNSAFE be sure you know what you are doing");
      if (typeof value !== "number" || value < 0) {
        videojs.log.warn("value of Vhs." + prop + " must be greater than or equal to 0");
        return;
      }
      Config[prop] = value;
    }
  });
});
var LOCAL_STORAGE_KEY = "videojs-vhs";
var handleVhsMediaChange = function handleVhsMediaChange2(qualityLevels3, playlistLoader) {
  var newPlaylist = playlistLoader.media();
  var selectedIndex = -1;
  for (var i = 0; i < qualityLevels3.length; i++) {
    if (qualityLevels3[i].id === newPlaylist.id) {
      selectedIndex = i;
      break;
    }
  }
  qualityLevels3.selectedIndex_ = selectedIndex;
  qualityLevels3.trigger({
    selectedIndex,
    type: "change"
  });
};
var handleVhsLoadedMetadata = function handleVhsLoadedMetadata2(qualityLevels3, vhs) {
  vhs.representations().forEach(function(rep) {
    qualityLevels3.addQualityLevel(rep);
  });
  handleVhsMediaChange(qualityLevels3, vhs.playlists);
};
Vhs.canPlaySource = function() {
  return videojs.log.warn("HLS is no longer a tech. Please remove it from your player's techOrder.");
};
var emeKeySystems = function emeKeySystems2(keySystemOptions, mainPlaylist, audioPlaylist) {
  if (!keySystemOptions) {
    return keySystemOptions;
  }
  var codecs = {};
  if (mainPlaylist && mainPlaylist.attributes && mainPlaylist.attributes.CODECS) {
    codecs = unwrapCodecList(parseCodecs(mainPlaylist.attributes.CODECS));
  }
  if (audioPlaylist && audioPlaylist.attributes && audioPlaylist.attributes.CODECS) {
    codecs.audio = audioPlaylist.attributes.CODECS;
  }
  var videoContentType = getMimeForCodec(codecs.video);
  var audioContentType = getMimeForCodec(codecs.audio);
  var keySystemContentTypes = {};
  for (var keySystem in keySystemOptions) {
    keySystemContentTypes[keySystem] = {};
    if (audioContentType) {
      keySystemContentTypes[keySystem].audioContentType = audioContentType;
    }
    if (videoContentType) {
      keySystemContentTypes[keySystem].videoContentType = videoContentType;
    }
    if (mainPlaylist.contentProtection && mainPlaylist.contentProtection[keySystem] && mainPlaylist.contentProtection[keySystem].pssh) {
      keySystemContentTypes[keySystem].pssh = mainPlaylist.contentProtection[keySystem].pssh;
    }
    if (typeof keySystemOptions[keySystem] === "string") {
      keySystemContentTypes[keySystem].url = keySystemOptions[keySystem];
    }
  }
  return videojs.mergeOptions(keySystemOptions, keySystemContentTypes);
};
var getAllPsshKeySystemsOptions = function getAllPsshKeySystemsOptions2(playlists, keySystems) {
  return playlists.reduce(function(keySystemsArr, playlist) {
    if (!playlist.contentProtection) {
      return keySystemsArr;
    }
    var keySystemsOptions = keySystems.reduce(function(keySystemsObj, keySystem) {
      var keySystemOptions = playlist.contentProtection[keySystem];
      if (keySystemOptions && keySystemOptions.pssh) {
        keySystemsObj[keySystem] = {
          pssh: keySystemOptions.pssh
        };
      }
      return keySystemsObj;
    }, {});
    if (Object.keys(keySystemsOptions).length) {
      keySystemsArr.push(keySystemsOptions);
    }
    return keySystemsArr;
  }, []);
};
var waitForKeySessionCreation = function waitForKeySessionCreation2(_ref) {
  var player = _ref.player, sourceKeySystems = _ref.sourceKeySystems, audioMedia = _ref.audioMedia, mainPlaylists = _ref.mainPlaylists;
  if (!player.eme.initializeMediaKeys) {
    return Promise.resolve();
  }
  var playlists = audioMedia ? mainPlaylists.concat([audioMedia]) : mainPlaylists;
  var keySystemsOptionsArr = getAllPsshKeySystemsOptions(playlists, Object.keys(sourceKeySystems));
  var initializationFinishedPromises = [];
  var keySessionCreatedPromises = [];
  keySystemsOptionsArr.forEach(function(keySystemsOptions) {
    keySessionCreatedPromises.push(new Promise(function(resolve, reject) {
      player.tech_.one("keysessioncreated", resolve);
    }));
    initializationFinishedPromises.push(new Promise(function(resolve, reject) {
      player.eme.initializeMediaKeys({
        keySystems: keySystemsOptions
      }, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    }));
  });
  return Promise.race([
    // If a session was previously created, these will all finish resolving without
    // creating a new session, otherwise it will take until the end of all license
    // requests, which is why the key session check is used (to make setup much faster).
    Promise.all(initializationFinishedPromises),
    // Once a single session is created, the browser knows DRM will be used.
    Promise.race(keySessionCreatedPromises)
  ]);
};
var setupEmeOptions = function setupEmeOptions2(_ref2) {
  var player = _ref2.player, sourceKeySystems = _ref2.sourceKeySystems, media = _ref2.media, audioMedia = _ref2.audioMedia;
  var sourceOptions = emeKeySystems(sourceKeySystems, media, audioMedia);
  if (!sourceOptions) {
    return false;
  }
  player.currentSource().keySystems = sourceOptions;
  if (sourceOptions && !player.eme) {
    videojs.log.warn("DRM encrypted source cannot be decrypted without a DRM plugin");
    return false;
  }
  return true;
};
var getVhsLocalStorage = function getVhsLocalStorage2() {
  if (!import_window6.default.localStorage) {
    return null;
  }
  var storedObject = import_window6.default.localStorage.getItem(LOCAL_STORAGE_KEY);
  if (!storedObject) {
    return null;
  }
  try {
    return JSON.parse(storedObject);
  } catch (e) {
    return null;
  }
};
var updateVhsLocalStorage = function updateVhsLocalStorage2(options) {
  if (!import_window6.default.localStorage) {
    return false;
  }
  var objectToStore = getVhsLocalStorage();
  objectToStore = objectToStore ? videojs.mergeOptions(objectToStore, options) : options;
  try {
    import_window6.default.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(objectToStore));
  } catch (e) {
    return false;
  }
  return objectToStore;
};
var expandDataUri = function expandDataUri2(dataUri) {
  if (dataUri.toLowerCase().indexOf("data:application/vnd.videojs.vhs+json,") === 0) {
    return JSON.parse(dataUri.substring(dataUri.indexOf(",") + 1));
  }
  return dataUri;
};
Vhs.supportsNativeHls = function() {
  if (!import_document.default || !import_document.default.createElement) {
    return false;
  }
  var video = import_document.default.createElement("video");
  if (!videojs.getTech("Html5").isSupported()) {
    return false;
  }
  var canPlay = [
    // Apple santioned
    "application/vnd.apple.mpegurl",
    // Apple sanctioned for backwards compatibility
    "audio/mpegurl",
    // Very common
    "audio/x-mpegurl",
    // Very common
    "application/x-mpegurl",
    // Included for completeness
    "video/x-mpegurl",
    "video/mpegurl",
    "application/mpegurl"
  ];
  return canPlay.some(function(canItPlay) {
    return /maybe|probably/i.test(video.canPlayType(canItPlay));
  });
}();
Vhs.supportsNativeDash = function() {
  if (!import_document.default || !import_document.default.createElement || !videojs.getTech("Html5").isSupported()) {
    return false;
  }
  return /maybe|probably/i.test(import_document.default.createElement("video").canPlayType("application/dash+xml"));
}();
Vhs.supportsTypeNatively = function(type2) {
  if (type2 === "hls") {
    return Vhs.supportsNativeHls;
  }
  if (type2 === "dash") {
    return Vhs.supportsNativeDash;
  }
  return false;
};
Vhs.isSupported = function() {
  return videojs.log.warn("HLS is no longer a tech. Please remove it from your player's techOrder.");
};
var Component = videojs.getComponent("Component");
var VhsHandler = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(VhsHandler2, _Component);
  function VhsHandler2(source, tech, options) {
    var _this;
    _this = _Component.call(this, tech, videojs.mergeOptions(options.hls, options.vhs)) || this;
    if (options.hls && Object.keys(options.hls).length) {
      videojs.log.warn("Using hls options is deprecated. Please rename `hls` to `vhs` in your options object.");
    }
    if (typeof options.initialBandwidth === "number") {
      _this.options_.bandwidth = options.initialBandwidth;
    }
    _this.logger_ = logger2("VhsHandler");
    if (tech.options_ && tech.options_.playerId) {
      var _player = videojs(tech.options_.playerId);
      if (!_player.hasOwnProperty("hls")) {
        Object.defineProperty(_player, "hls", {
          get: function get7() {
            videojs.log.warn("player.hls is deprecated. Use player.tech().vhs instead.");
            tech.trigger({
              type: "usage",
              name: "hls-player-access"
            });
            return _assertThisInitialized(_this);
          },
          configurable: true
        });
      }
      if (!_player.hasOwnProperty("vhs")) {
        Object.defineProperty(_player, "vhs", {
          get: function get7() {
            videojs.log.warn("player.vhs is deprecated. Use player.tech().vhs instead.");
            tech.trigger({
              type: "usage",
              name: "vhs-player-access"
            });
            return _assertThisInitialized(_this);
          },
          configurable: true
        });
      }
      if (!_player.hasOwnProperty("dash")) {
        Object.defineProperty(_player, "dash", {
          get: function get7() {
            videojs.log.warn("player.dash is deprecated. Use player.tech().vhs instead.");
            return _assertThisInitialized(_this);
          },
          configurable: true
        });
      }
      _this.player_ = _player;
    }
    _this.tech_ = tech;
    _this.source_ = source;
    _this.stats = {};
    _this.ignoreNextSeekingEvent_ = false;
    _this.setOptions_();
    if (_this.options_.overrideNative && tech.overrideNativeAudioTracks && tech.overrideNativeVideoTracks) {
      tech.overrideNativeAudioTracks(true);
      tech.overrideNativeVideoTracks(true);
    } else if (_this.options_.overrideNative && (tech.featuresNativeVideoTracks || tech.featuresNativeAudioTracks)) {
      throw new Error("Overriding native HLS requires emulated tracks. See https://git.io/vMpjB");
    }
    _this.on(import_document.default, ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"], function(event) {
      var fullscreenElement = import_document.default.fullscreenElement || import_document.default.webkitFullscreenElement || import_document.default.mozFullScreenElement || import_document.default.msFullscreenElement;
      if (fullscreenElement && fullscreenElement.contains(_this.tech_.el())) {
        _this.masterPlaylistController_.fastQualityChange_();
      } else {
        _this.masterPlaylistController_.checkABR_();
      }
    });
    _this.on(_this.tech_, "seeking", function() {
      if (this.ignoreNextSeekingEvent_) {
        this.ignoreNextSeekingEvent_ = false;
        return;
      }
      this.setCurrentTime(this.tech_.currentTime());
    });
    _this.on(_this.tech_, "error", function() {
      if (this.tech_.error() && this.masterPlaylistController_) {
        this.masterPlaylistController_.pauseLoading();
      }
    });
    _this.on(_this.tech_, "play", _this.play);
    return _this;
  }
  var _proto = VhsHandler2.prototype;
  _proto.setOptions_ = function setOptions_() {
    var _this2 = this;
    this.options_.withCredentials = this.options_.withCredentials || false;
    this.options_.handleManifestRedirects = this.options_.handleManifestRedirects === false ? false : true;
    this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions === false ? false : true;
    this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || false;
    this.options_.smoothQualityChange = this.options_.smoothQualityChange || false;
    this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage !== "undefined" ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || false;
    this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || false;
    this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || false;
    this.options_.customTagParsers = this.options_.customTagParsers || [];
    this.options_.customTagMappers = this.options_.customTagMappers || [];
    this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || false;
    if (typeof this.options_.blacklistDuration !== "number") {
      this.options_.blacklistDuration = 5 * 60;
    }
    if (typeof this.options_.bandwidth !== "number") {
      if (this.options_.useBandwidthFromLocalStorage) {
        var storedObject = getVhsLocalStorage();
        if (storedObject && storedObject.bandwidth) {
          this.options_.bandwidth = storedObject.bandwidth;
          this.tech_.trigger({
            type: "usage",
            name: "vhs-bandwidth-from-local-storage"
          });
          this.tech_.trigger({
            type: "usage",
            name: "hls-bandwidth-from-local-storage"
          });
        }
        if (storedObject && storedObject.throughput) {
          this.options_.throughput = storedObject.throughput;
          this.tech_.trigger({
            type: "usage",
            name: "vhs-throughput-from-local-storage"
          });
          this.tech_.trigger({
            type: "usage",
            name: "hls-throughput-from-local-storage"
          });
        }
      }
    }
    if (typeof this.options_.bandwidth !== "number") {
      this.options_.bandwidth = Config.INITIAL_BANDWIDTH;
    }
    this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Config.INITIAL_BANDWIDTH;
    ["withCredentials", "useDevicePixelRatio", "limitRenditionByPlayerDimensions", "bandwidth", "smoothQualityChange", "customTagParsers", "customTagMappers", "handleManifestRedirects", "cacheEncryptionKeys", "playlistSelector", "initialPlaylistSelector", "experimentalBufferBasedABR", "liveRangeSafeTimeDelta", "experimentalLLHLS", "useNetworkInformationApi", "useDtsForTimestampOffset", "experimentalExactManifestTimings", "experimentalLeastPixelDiffSelector"].forEach(function(option) {
      if (typeof _this2.source_[option] !== "undefined") {
        _this2.options_[option] = _this2.source_[option];
      }
    });
    this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions;
    this.useDevicePixelRatio = this.options_.useDevicePixelRatio;
  };
  _proto.src = function src(_src, type2) {
    var _this3 = this;
    if (!_src) {
      return;
    }
    this.setOptions_();
    this.options_.src = expandDataUri(this.source_.src);
    this.options_.tech = this.tech_;
    this.options_.externVhs = Vhs;
    this.options_.sourceType = simpleTypeFromSourceType(type2);
    this.options_.seekTo = function(time) {
      _this3.tech_.setCurrentTime(time);
    };
    if (this.options_.smoothQualityChange) {
      videojs.log.warn("smoothQualityChange is deprecated and will be removed in the next major version");
    }
    this.masterPlaylistController_ = new MasterPlaylistController(this.options_);
    var playbackWatcherOptions = videojs.mergeOptions({
      liveRangeSafeTimeDelta: SAFE_TIME_DELTA
    }, this.options_, {
      seekable: function seekable3() {
        return _this3.seekable();
      },
      media: function media() {
        return _this3.masterPlaylistController_.media();
      },
      masterPlaylistController: this.masterPlaylistController_
    });
    this.playbackWatcher_ = new PlaybackWatcher(playbackWatcherOptions);
    this.masterPlaylistController_.on("error", function() {
      var player = videojs.players[_this3.tech_.options_.playerId];
      var error = _this3.masterPlaylistController_.error;
      if (typeof error === "object" && !error.code) {
        error.code = 3;
      } else if (typeof error === "string") {
        error = {
          message: error,
          code: 3
        };
      }
      player.error(error);
    });
    var defaultSelector = this.options_.experimentalBufferBasedABR ? Vhs.movingAverageBandwidthSelector(0.55) : Vhs.STANDARD_PLAYLIST_SELECTOR;
    this.masterPlaylistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : defaultSelector.bind(this);
    this.masterPlaylistController_.selectInitialPlaylist = Vhs.INITIAL_PLAYLIST_SELECTOR.bind(this);
    this.playlists = this.masterPlaylistController_.masterPlaylistLoader_;
    this.mediaSource = this.masterPlaylistController_.mediaSource;
    Object.defineProperties(this, {
      selectPlaylist: {
        get: function get7() {
          return this.masterPlaylistController_.selectPlaylist;
        },
        set: function set4(selectPlaylist) {
          this.masterPlaylistController_.selectPlaylist = selectPlaylist.bind(this);
        }
      },
      throughput: {
        get: function get7() {
          return this.masterPlaylistController_.mainSegmentLoader_.throughput.rate;
        },
        set: function set4(throughput) {
          this.masterPlaylistController_.mainSegmentLoader_.throughput.rate = throughput;
          this.masterPlaylistController_.mainSegmentLoader_.throughput.count = 1;
        }
      },
      bandwidth: {
        get: function get7() {
          var playerBandwidthEst = this.masterPlaylistController_.mainSegmentLoader_.bandwidth;
          var networkInformation = import_window6.default.navigator.connection || import_window6.default.navigator.mozConnection || import_window6.default.navigator.webkitConnection;
          var tenMbpsAsBitsPerSecond = 1e7;
          if (this.options_.useNetworkInformationApi && networkInformation) {
            var networkInfoBandwidthEstBitsPerSec = networkInformation.downlink * 1e3 * 1e3;
            if (networkInfoBandwidthEstBitsPerSec >= tenMbpsAsBitsPerSecond && playerBandwidthEst >= tenMbpsAsBitsPerSecond) {
              playerBandwidthEst = Math.max(playerBandwidthEst, networkInfoBandwidthEstBitsPerSec);
            } else {
              playerBandwidthEst = networkInfoBandwidthEstBitsPerSec;
            }
          }
          return playerBandwidthEst;
        },
        set: function set4(bandwidth2) {
          this.masterPlaylistController_.mainSegmentLoader_.bandwidth = bandwidth2;
          this.masterPlaylistController_.mainSegmentLoader_.throughput = {
            rate: 0,
            count: 0
          };
        }
      },
      /**
       * `systemBandwidth` is a combination of two serial processes bit-rates. The first
       * is the network bitrate provided by `bandwidth` and the second is the bitrate of
       * the entire process after that - decryption, transmuxing, and appending - provided
       * by `throughput`.
       *
       * Since the two process are serial, the overall system bandwidth is given by:
       *   sysBandwidth = 1 / (1 / bandwidth + 1 / throughput)
       */
      systemBandwidth: {
        get: function get7() {
          var invBandwidth = 1 / (this.bandwidth || 1);
          var invThroughput;
          if (this.throughput > 0) {
            invThroughput = 1 / this.throughput;
          } else {
            invThroughput = 0;
          }
          var systemBitrate = Math.floor(1 / (invBandwidth + invThroughput));
          return systemBitrate;
        },
        set: function set4() {
          videojs.log.error('The "systemBandwidth" property is read-only');
        }
      }
    });
    if (this.options_.bandwidth) {
      this.bandwidth = this.options_.bandwidth;
    }
    if (this.options_.throughput) {
      this.throughput = this.options_.throughput;
    }
    Object.defineProperties(this.stats, {
      bandwidth: {
        get: function get7() {
          return _this3.bandwidth || 0;
        },
        enumerable: true
      },
      mediaRequests: {
        get: function get7() {
          return _this3.masterPlaylistController_.mediaRequests_() || 0;
        },
        enumerable: true
      },
      mediaRequestsAborted: {
        get: function get7() {
          return _this3.masterPlaylistController_.mediaRequestsAborted_() || 0;
        },
        enumerable: true
      },
      mediaRequestsTimedout: {
        get: function get7() {
          return _this3.masterPlaylistController_.mediaRequestsTimedout_() || 0;
        },
        enumerable: true
      },
      mediaRequestsErrored: {
        get: function get7() {
          return _this3.masterPlaylistController_.mediaRequestsErrored_() || 0;
        },
        enumerable: true
      },
      mediaTransferDuration: {
        get: function get7() {
          return _this3.masterPlaylistController_.mediaTransferDuration_() || 0;
        },
        enumerable: true
      },
      mediaBytesTransferred: {
        get: function get7() {
          return _this3.masterPlaylistController_.mediaBytesTransferred_() || 0;
        },
        enumerable: true
      },
      mediaSecondsLoaded: {
        get: function get7() {
          return _this3.masterPlaylistController_.mediaSecondsLoaded_() || 0;
        },
        enumerable: true
      },
      mediaAppends: {
        get: function get7() {
          return _this3.masterPlaylistController_.mediaAppends_() || 0;
        },
        enumerable: true
      },
      mainAppendsToLoadedData: {
        get: function get7() {
          return _this3.masterPlaylistController_.mainAppendsToLoadedData_() || 0;
        },
        enumerable: true
      },
      audioAppendsToLoadedData: {
        get: function get7() {
          return _this3.masterPlaylistController_.audioAppendsToLoadedData_() || 0;
        },
        enumerable: true
      },
      appendsToLoadedData: {
        get: function get7() {
          return _this3.masterPlaylistController_.appendsToLoadedData_() || 0;
        },
        enumerable: true
      },
      timeToLoadedData: {
        get: function get7() {
          return _this3.masterPlaylistController_.timeToLoadedData_() || 0;
        },
        enumerable: true
      },
      buffered: {
        get: function get7() {
          return timeRangesToArray(_this3.tech_.buffered());
        },
        enumerable: true
      },
      currentTime: {
        get: function get7() {
          return _this3.tech_.currentTime();
        },
        enumerable: true
      },
      currentSource: {
        get: function get7() {
          return _this3.tech_.currentSource_;
        },
        enumerable: true
      },
      currentTech: {
        get: function get7() {
          return _this3.tech_.name_;
        },
        enumerable: true
      },
      duration: {
        get: function get7() {
          return _this3.tech_.duration();
        },
        enumerable: true
      },
      master: {
        get: function get7() {
          return _this3.playlists.master;
        },
        enumerable: true
      },
      playerDimensions: {
        get: function get7() {
          return _this3.tech_.currentDimensions();
        },
        enumerable: true
      },
      seekable: {
        get: function get7() {
          return timeRangesToArray(_this3.tech_.seekable());
        },
        enumerable: true
      },
      timestamp: {
        get: function get7() {
          return Date.now();
        },
        enumerable: true
      },
      videoPlaybackQuality: {
        get: function get7() {
          return _this3.tech_.getVideoPlaybackQuality();
        },
        enumerable: true
      }
    });
    this.tech_.one("canplay", this.masterPlaylistController_.setupFirstPlay.bind(this.masterPlaylistController_));
    this.tech_.on("bandwidthupdate", function() {
      if (_this3.options_.useBandwidthFromLocalStorage) {
        updateVhsLocalStorage({
          bandwidth: _this3.bandwidth,
          throughput: Math.round(_this3.throughput)
        });
      }
    });
    this.masterPlaylistController_.on("selectedinitialmedia", function() {
      renditionSelectionMixin(_this3);
    });
    this.masterPlaylistController_.sourceUpdater_.on("createdsourcebuffers", function() {
      _this3.setupEme_();
    });
    this.on(this.masterPlaylistController_, "progress", function() {
      this.tech_.trigger("progress");
    });
    this.on(this.masterPlaylistController_, "firstplay", function() {
      this.ignoreNextSeekingEvent_ = true;
    });
    this.setupQualityLevels_();
    if (!this.tech_.el()) {
      return;
    }
    this.mediaSourceUrl_ = import_window6.default.URL.createObjectURL(this.masterPlaylistController_.mediaSource);
    this.tech_.src(this.mediaSourceUrl_);
  };
  _proto.createKeySessions_ = function createKeySessions_() {
    var _this4 = this;
    var audioPlaylistLoader = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader;
    this.logger_("waiting for EME key session creation");
    waitForKeySessionCreation({
      player: this.player_,
      sourceKeySystems: this.source_.keySystems,
      audioMedia: audioPlaylistLoader && audioPlaylistLoader.media(),
      mainPlaylists: this.playlists.master.playlists
    }).then(function() {
      _this4.logger_("created EME key session");
      _this4.masterPlaylistController_.sourceUpdater_.initializedEme();
    })["catch"](function(err) {
      _this4.logger_("error while creating EME key session", err);
      _this4.player_.error({
        message: "Failed to initialize media keys for EME",
        code: 3
      });
    });
  };
  _proto.handleWaitingForKey_ = function handleWaitingForKey_() {
    this.logger_("waitingforkey fired, attempting to create any new key sessions");
    this.createKeySessions_();
  };
  _proto.setupEme_ = function setupEme_() {
    var _this5 = this;
    var audioPlaylistLoader = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader;
    var didSetupEmeOptions = setupEmeOptions({
      player: this.player_,
      sourceKeySystems: this.source_.keySystems,
      media: this.playlists.media(),
      audioMedia: audioPlaylistLoader && audioPlaylistLoader.media()
    });
    this.player_.tech_.on("keystatuschange", function(e) {
      if (e.status !== "output-restricted") {
        return;
      }
      var masterPlaylist = _this5.masterPlaylistController_.master();
      if (!masterPlaylist || !masterPlaylist.playlists) {
        return;
      }
      var excludedHDPlaylists = [];
      masterPlaylist.playlists.forEach(function(playlist) {
        if (playlist && playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height >= 720) {
          if (!playlist.excludeUntil || playlist.excludeUntil < Infinity) {
            playlist.excludeUntil = Infinity;
            excludedHDPlaylists.push(playlist);
          }
        }
      });
      if (excludedHDPlaylists.length) {
        var _videojs$log;
        (_videojs$log = videojs.log).warn.apply(_videojs$log, ['DRM keystatus changed to "output-restricted." Removing the following HD playlists that will most likely fail to play and clearing the buffer. This may be due to HDCP restrictions on the stream and the capabilities of the current device.'].concat(excludedHDPlaylists));
        _this5.masterPlaylistController_.fastQualityChange_();
      }
    });
    this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this);
    this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_);
    if (videojs.browser.IE_VERSION === 11 || !didSetupEmeOptions) {
      this.masterPlaylistController_.sourceUpdater_.initializedEme();
      return;
    }
    this.createKeySessions_();
  };
  _proto.setupQualityLevels_ = function setupQualityLevels_() {
    var _this6 = this;
    var player = videojs.players[this.tech_.options_.playerId];
    if (!player || !player.qualityLevels || this.qualityLevels_) {
      return;
    }
    this.qualityLevels_ = player.qualityLevels();
    this.masterPlaylistController_.on("selectedinitialmedia", function() {
      handleVhsLoadedMetadata(_this6.qualityLevels_, _this6);
    });
    this.playlists.on("mediachange", function() {
      handleVhsMediaChange(_this6.qualityLevels_, _this6.playlists);
    });
  };
  VhsHandler2.version = function version$52() {
    return {
      "@videojs/http-streaming": version$4,
      "mux.js": version$3,
      "mpd-parser": version$2,
      "m3u8-parser": version$1,
      "aes-decrypter": version
    };
  };
  _proto.version = function version5() {
    return this.constructor.version();
  };
  _proto.canChangeType = function canChangeType() {
    return SourceUpdater.canChangeType();
  };
  _proto.play = function play() {
    this.masterPlaylistController_.play();
  };
  _proto.setCurrentTime = function setCurrentTime(currentTime) {
    this.masterPlaylistController_.setCurrentTime(currentTime);
  };
  _proto.duration = function duration5() {
    return this.masterPlaylistController_.duration();
  };
  _proto.seekable = function seekable3() {
    return this.masterPlaylistController_.seekable();
  };
  _proto.dispose = function dispose() {
    if (this.playbackWatcher_) {
      this.playbackWatcher_.dispose();
    }
    if (this.masterPlaylistController_) {
      this.masterPlaylistController_.dispose();
    }
    if (this.qualityLevels_) {
      this.qualityLevels_.dispose();
    }
    if (this.player_) {
      delete this.player_.vhs;
      delete this.player_.dash;
      delete this.player_.hls;
    }
    if (this.tech_ && this.tech_.vhs) {
      delete this.tech_.vhs;
    }
    if (this.tech_) {
      delete this.tech_.hls;
    }
    if (this.mediaSourceUrl_ && import_window6.default.URL.revokeObjectURL) {
      import_window6.default.URL.revokeObjectURL(this.mediaSourceUrl_);
      this.mediaSourceUrl_ = null;
    }
    if (this.tech_) {
      this.tech_.off("waitingforkey", this.handleWaitingForKey_);
    }
    _Component.prototype.dispose.call(this);
  };
  _proto.convertToProgramTime = function convertToProgramTime(time, callback2) {
    return getProgramTime({
      playlist: this.masterPlaylistController_.media(),
      time,
      callback: callback2
    });
  };
  _proto.seekToProgramTime = function seekToProgramTime$1(programTime, callback2, pauseAfterSeek, retryCount) {
    if (pauseAfterSeek === void 0) {
      pauseAfterSeek = true;
    }
    if (retryCount === void 0) {
      retryCount = 2;
    }
    return seekToProgramTime({
      programTime,
      playlist: this.masterPlaylistController_.media(),
      retryCount,
      pauseAfterSeek,
      seekTo: this.options_.seekTo,
      tech: this.options_.tech,
      callback: callback2
    });
  };
  return VhsHandler2;
}(Component);
var VhsSourceHandler = {
  name: "videojs-http-streaming",
  VERSION: version$4,
  canHandleSource: function canHandleSource(srcObj, options) {
    if (options === void 0) {
      options = {};
    }
    var localOptions = videojs.mergeOptions(videojs.options, options);
    return VhsSourceHandler.canPlayType(srcObj.type, localOptions);
  },
  handleSource: function handleSource(source, tech, options) {
    if (options === void 0) {
      options = {};
    }
    var localOptions = videojs.mergeOptions(videojs.options, options);
    tech.vhs = new VhsHandler(source, tech, localOptions);
    if (!videojs.hasOwnProperty("hls")) {
      Object.defineProperty(tech, "hls", {
        get: function get7() {
          videojs.log.warn("player.tech().hls is deprecated. Use player.tech().vhs instead.");
          return tech.vhs;
        },
        configurable: true
      });
    }
    tech.vhs.xhr = xhrFactory();
    tech.vhs.src(source.src, source.type);
    return tech.vhs;
  },
  canPlayType: function canPlayType2(type2, options) {
    if (options === void 0) {
      options = {};
    }
    var _videojs$mergeOptions = videojs.mergeOptions(videojs.options, options), _videojs$mergeOptions2 = _videojs$mergeOptions.vhs;
    _videojs$mergeOptions2 = _videojs$mergeOptions2 === void 0 ? {} : _videojs$mergeOptions2;
    var _videojs$mergeOptions3 = _videojs$mergeOptions2.overrideNative, overrideNative = _videojs$mergeOptions3 === void 0 ? !videojs.browser.IS_ANY_SAFARI : _videojs$mergeOptions3, _videojs$mergeOptions4 = _videojs$mergeOptions.hls;
    _videojs$mergeOptions4 = _videojs$mergeOptions4 === void 0 ? {} : _videojs$mergeOptions4;
    var _videojs$mergeOptions5 = _videojs$mergeOptions4.overrideNative, legacyOverrideNative = _videojs$mergeOptions5 === void 0 ? false : _videojs$mergeOptions5;
    var supportedType = simpleTypeFromSourceType(type2);
    var canUseMsePlayback = supportedType && (!Vhs.supportsTypeNatively(supportedType) || legacyOverrideNative || overrideNative);
    return canUseMsePlayback ? "maybe" : "";
  }
};
var supportsNativeMediaSources = function supportsNativeMediaSources2() {
  return browserSupportsCodec("avc1.4d400d,mp4a.40.2");
};
if (supportsNativeMediaSources()) {
  videojs.getTech("Html5").registerSourceHandler(VhsSourceHandler, 0);
}
videojs.VhsHandler = VhsHandler;
Object.defineProperty(videojs, "HlsHandler", {
  get: function get4() {
    videojs.log.warn("videojs.HlsHandler is deprecated. Use videojs.VhsHandler instead.");
    return VhsHandler;
  },
  configurable: true
});
videojs.VhsSourceHandler = VhsSourceHandler;
Object.defineProperty(videojs, "HlsSourceHandler", {
  get: function get5() {
    videojs.log.warn("videojs.HlsSourceHandler is deprecated. Use videojs.VhsSourceHandler instead.");
    return VhsSourceHandler;
  },
  configurable: true
});
videojs.Vhs = Vhs;
Object.defineProperty(videojs, "Hls", {
  get: function get6() {
    videojs.log.warn("videojs.Hls is deprecated. Use videojs.Vhs instead.");
    return Vhs;
  },
  configurable: true
});
if (!videojs.use) {
  videojs.registerComponent("Hls", Vhs);
  videojs.registerComponent("Vhs", Vhs);
}
videojs.options.vhs = videojs.options.vhs || {};
videojs.options.hls = videojs.options.hls || {};
if (!videojs.getPlugin || !videojs.getPlugin("reloadSourceOnError")) {
  registerPlugin3 = videojs.registerPlugin || videojs.plugin;
  registerPlugin3("reloadSourceOnError", reloadSourceOnError);
}
var registerPlugin3;
var video_es_default = videojs;

// node_modules/.pnpm/@yangkghjh+videojs-aspect-ratio-panel@0.0.1/node_modules/@yangkghjh/videojs-aspect-ratio-panel/dist/videojs-aspect-ratio-panel.es.js
function _inheritsLoose2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _assertThisInitialized2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var version2 = "0.0.1";
var MenuButton2 = video_es_default.getComponent("MenuButton");
var ResizerButton = /* @__PURE__ */ function(_MenuButton) {
  _inheritsLoose2(ResizerButton2, _MenuButton);
  function ResizerButton2(player, options) {
    var _this;
    _this = _MenuButton.call(this, player, {
      name: "ResizerButton"
    }) || this;
    MenuButton2.apply(_assertThisInitialized2(_this), arguments);
    _this.controlText(player.localize("Aspect Ratio"));
    return _this;
  }
  var _proto = ResizerButton2.prototype;
  _proto.createEl = function createEl2() {
    return video_es_default.dom.createEl("div", {
      className: "vjs-menu-button vjs-menu-button-popup vjs-control vjs-button"
    });
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return MenuButton2.prototype.buildCSSClass.call(this) + " vjs-icon-cog";
  };
  _proto.update = function update() {
    return MenuButton2.prototype.update.call(this);
  };
  _proto.handleClick = function handleClick() {
    this.player().getChild("ResizerPanel").toggleClass("vjs-hidden");
  };
  return ResizerButton2;
}(MenuButton2);
var Component2 = video_es_default.getComponent("Component");
var ResizerPanel = /* @__PURE__ */ function(_Component) {
  _inheritsLoose2(ResizerPanel2, _Component);
  function ResizerPanel2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    Component2.apply(_assertThisInitialized2(_this), arguments);
    _this.aspectRadio = "origin";
    _this.percent = 100;
    _this.radioWidth = 1;
    _this.radioHeight = 1;
    _this.currentHeight = _this.player().currentHeight();
    _this.currentWidth = _this.player().currentWidth();
    var el = _this.el();
    el.childNodes[1].childNodes[1].onclick = function() {
      _this.toggleClass("vjs-hidden");
    };
    window.addEventListener("resize", function() {
      if (_this.currentHeight != _this.player().currentHeight() || _this.currentWidth != _this.player().currentWidth()) {
        _this.currentHeight = _this.player().currentHeight();
        _this.currentWidth = _this.player().currentWidth();
        _this.resize();
      }
    });
    el.onmouseup = function() {
      el.onmousemove = null;
    };
    var scroll = el.childNodes[1].childNodes[5].childNodes[1].childNodes[3];
    _this.setScrollFunc(el, scroll, function(data) {
      _this.setPercent(data);
    });
    _this.player().on("play", function() {
      _this.resize();
    });
    var radiosDiv = el.childNodes[1].childNodes[5].childNodes[3].childNodes;
    var radios = [radiosDiv[1], radiosDiv[5], radiosDiv[9], radiosDiv[13]];
    var prev = "origin";
    for (var i = 0; i < radios.length; i++) {
      radios[i].onchange = function(event) {
        if (event.target.value !== prev) {
          prev = event.target.value;
          _this.setAspectRadio(event.target.value);
        }
      };
    }
    var resetDiv = el.childNodes[1].childNodes[5].childNodes[5].childNodes[1];
    resetDiv.onclick = function(event) {
      radios[0].checked = true;
      _this.reset();
    };
    return _this;
  }
  var _proto = ResizerPanel2.prototype;
  _proto.setAspectRadio = function setAspectRadio(radio) {
    switch (radio) {
      case "origin":
        this.aspectRadio = "origin";
        break;
      case "fill":
        this.aspectRadio = "fill";
        break;
      case "16:9":
        this.aspectRadio = "16:9";
        this.radioWidth = 16;
        this.radioHeight = 9;
        break;
      case "4:3":
        this.aspectRadio = "4:3";
        this.radioWidth = 4;
        this.radioHeight = 3;
        break;
    }
    this.resize();
  };
  _proto.setPercent = function setPercent(percent) {
    this.percent = percent;
    this.resize();
  };
  _proto.reset = function reset3() {
    this.player().tech_.el().style.objectFit = "contain";
    this.aspectRadio = "origin";
    this.percent = 100;
    var scroll = this.el().childNodes[1].childNodes[5].childNodes[1].childNodes[3];
    scroll.childNodes[1].style.left = "255px";
    scroll.childNodes[3].style.width = "255px";
    this.resize();
  };
  _proto.resize = function resize() {
    if (this.aspectRadio != "origin") {
      this.player().tech_.el().style.objectFit = "fill";
    } else {
      this.player().tech_.el().style.objectFit = "contain";
    }
    if (this.aspectRadio == "origin" || this.aspectRadio == "fill") {
      var _w = this.currentWidth * (100 - this.percent) / 100 / 2;
      var _h = this.currentHeight * (100 - this.percent) / 100 / 2;
      this.setPadding(_w, _h);
      return;
    }
    var playerRadio = this.currentWidth / this.currentHeight;
    var width2 = this.currentWidth;
    var height2 = width2 * this.radioHeight / this.radioWidth;
    if (playerRadio > this.radioWidth / this.radioHeight) {
      height2 = this.currentHeight;
      width2 = height2 * this.radioWidth / this.radioHeight;
    }
    var w = (this.currentWidth - width2 * this.percent / 100) / 2;
    var h = (this.currentHeight - height2 * this.percent / 100) / 2;
    this.setPadding(w, h);
  };
  _proto.setPadding = function setPadding(w, h) {
    if (w < 0) {
      w = 0;
    }
    this.player().tech_.el().style.paddingLeft = w + "px";
    this.player().tech_.el().style.paddingRight = w + "px";
    if (h < 0) {
      h = 0;
    }
    this.player().tech_.el().style.paddingTop = h + "px";
    this.player().tech_.el().style.paddingBottom = h + "px";
  };
  _proto.setScrollFunc = function setScrollFunc(scrollDiv, scrollDom, callback2) {
    var bar = scrollDom.childNodes[1];
    var mask = scrollDom.childNodes[3];
    var barleft = 0;
    bar.onmousedown = function(e) {
      var event = e || window.event;
      var leftVal = event.clientX - this.offsetLeft;
      var that = this;
      scrollDiv.onmousemove = function(e2) {
        var event2 = e2 || window.event;
        barleft = event2.clientX - leftVal;
        if (barleft < 0) barleft = 0;
        else if (barleft > 255) barleft = 255;
        mask.style.width = barleft + "px";
        that.style.left = barleft + "px";
        callback2(parseInt(barleft / 255 * 100));
        window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();
      };
    };
  };
  _proto.createEl = function createEl2() {
    return video_es_default.dom.createEl("div", {
      className: "vjs-resizer-modal vjs-hidden",
      innerHTML: '\n        <div class="vjs-resizer-modal-content">\n        <span class="vjs-resizer-modal-close">&times;</span>\n          <div class="vjs-resizer-modal-title">Aspect Ratio</div>\n          <div class="vjs-resizer-wrap">\n            <div class="vjs-resizer-size">\n              <span class="size-title">Size</span>\n              <div class="size-scroll" id="size-scroll">\n                <div class="size-scroll-bar"></div>\n                <div class="size-scroll-mask"></div>\n              </div>\n            </div>\n            <div class="radios">\n              Ratio\n              <input type="radio" name="radio" id="origin" value="origin" checked >\n              <label for="origin">Default</label>\n              <input type="radio" name="radio" id="4:3" value="4:3">\n              <label for="4:3">4:3</label>\n              <input type="radio" name="radio" id="16:9" value="16:9">\n              <label for="16:9">16:9</label>\n              <input type="radio" name="radio" id="fill" value="fill">\n              <label for="fill">Full</label>\n            </div>\n            <ul style="clear:both">\n                <li id="vjs-resizer-reset">Reset</li>\n            </ul>\n          </div>\n        </div>\n        '
    });
  };
  return ResizerPanel2;
}(Component2);
var Plugin2 = video_es_default.getPlugin("plugin");
var defaults3 = {};
var AspectRatioPanel = /* @__PURE__ */ function(_Plugin) {
  _inheritsLoose2(AspectRatioPanel2, _Plugin);
  function AspectRatioPanel2(player, options) {
    var _this;
    _this = _Plugin.call(this, player) || this;
    _this.options = video_es_default.mergeOptions(defaults3, options);
    _this.player.ready(function() {
      _this.player.addClass("vjs-aspect-ratio-panel");
      if (player.techName_ != "Html5") {
        return false;
      }
      player.on(["loadedmetadata"], function(e) {
        if (player.aspect_ratio_initialized == "undefined" || player.aspect_ratio_initialized == true) ;
        else {
          player.aspect_ratio_initialized = true;
          var controlBar = player.controlBar;
          var fullscreenToggle = controlBar.getChild("fullscreenToggle").el();
          controlBar.el().insertBefore(controlBar.addChild("ResizerButton").el(), fullscreenToggle);
          player.addChild("ResizerPanel");
        }
      });
    });
    video_es_default.registerComponent("ResizerButton", ResizerButton);
    video_es_default.registerComponent("ResizerPanel", ResizerPanel);
    return _this;
  }
  return AspectRatioPanel2;
}(Plugin2);
AspectRatioPanel.defaultState = {};
AspectRatioPanel.VERSION = version2;
video_es_default.registerPlugin("aspectRatioPanel", AspectRatioPanel);

// node_modules/.pnpm/videojs-contrib-quality-levels@2.2.0_video.js@7.20.3/node_modules/videojs-contrib-quality-levels/dist/videojs-contrib-quality-levels.es.js
function _inheritsLoose3(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _assertThisInitialized3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var QualityLevel = (
  /**
   * Creates a QualityLevel
   *
   * @param {Representation|Object} representation The representation of the quality level
   * @param {string}   representation.id        Unique id of the QualityLevel
   * @param {number=}  representation.width     Resolution width of the QualityLevel
   * @param {number=}  representation.height    Resolution height of the QualityLevel
   * @param {number}   representation.bandwidth Bitrate of the QualityLevel
   * @param {number=}  representation.frameRate Frame-rate of the QualityLevel
   * @param {Function} representation.enabled   Callback to enable/disable QualityLevel
   */
  function QualityLevel2(representation) {
    var level = this;
    level.id = representation.id;
    level.label = level.id;
    level.width = representation.width;
    level.height = representation.height;
    level.bitrate = representation.bandwidth;
    level.frameRate = representation.frameRate;
    level.enabled_ = representation.enabled;
    Object.defineProperty(level, "enabled", {
      /**
       * Get whether the QualityLevel is enabled.
       *
       * @return {boolean} True if the QualityLevel is enabled.
       */
      get: function get7() {
        return level.enabled_();
      },
      /**
       * Enable or disable the QualityLevel.
       *
       * @param {boolean} enable true to enable QualityLevel, false to disable.
       */
      set: function set4(enable) {
        level.enabled_(enable);
      }
    });
    return level;
  }
);
var QualityLevelList = /* @__PURE__ */ function(_videojs$EventTarget) {
  _inheritsLoose3(QualityLevelList2, _videojs$EventTarget);
  function QualityLevelList2() {
    var _this;
    _this = _videojs$EventTarget.call(this) || this;
    var list = _assertThisInitialized3(_assertThisInitialized3(_this));
    list.levels_ = [];
    list.selectedIndex_ = -1;
    Object.defineProperty(list, "selectedIndex", {
      get: function get7() {
        return list.selectedIndex_;
      }
    });
    Object.defineProperty(list, "length", {
      get: function get7() {
        return list.levels_.length;
      }
    });
    return list || _assertThisInitialized3(_this);
  }
  var _proto = QualityLevelList2.prototype;
  _proto.addQualityLevel = function addQualityLevel(representation) {
    var qualityLevel = this.getQualityLevelById(representation.id);
    if (qualityLevel) {
      return qualityLevel;
    }
    var index = this.levels_.length;
    qualityLevel = new QualityLevel(representation);
    if (!("" + index in this)) {
      Object.defineProperty(this, index, {
        get: function get7() {
          return this.levels_[index];
        }
      });
    }
    this.levels_.push(qualityLevel);
    this.trigger({
      qualityLevel,
      type: "addqualitylevel"
    });
    return qualityLevel;
  };
  _proto.removeQualityLevel = function removeQualityLevel(qualityLevel) {
    var removed = null;
    for (var i = 0, l = this.length; i < l; i++) {
      if (this[i] === qualityLevel) {
        removed = this.levels_.splice(i, 1)[0];
        if (this.selectedIndex_ === i) {
          this.selectedIndex_ = -1;
        } else if (this.selectedIndex_ > i) {
          this.selectedIndex_--;
        }
        break;
      }
    }
    if (removed) {
      this.trigger({
        qualityLevel,
        type: "removequalitylevel"
      });
    }
    return removed;
  };
  _proto.getQualityLevelById = function getQualityLevelById(id) {
    for (var i = 0, l = this.length; i < l; i++) {
      var level = this[i];
      if (level.id === id) {
        return level;
      }
    }
    return null;
  };
  _proto.dispose = function dispose() {
    this.selectedIndex_ = -1;
    this.levels_.length = 0;
  };
  return QualityLevelList2;
}(video_es_default.EventTarget);
QualityLevelList.prototype.allowedEvents_ = {
  change: "change",
  addqualitylevel: "addqualitylevel",
  removequalitylevel: "removequalitylevel"
};
for (event in QualityLevelList.prototype.allowedEvents_) {
  QualityLevelList.prototype["on" + event] = null;
}
var event;
var version3 = "2.2.0";
var registerPlugin = video_es_default.registerPlugin || video_es_default.plugin;
var initPlugin3 = function initPlugin4(player, options) {
  var originalPluginFn = player.qualityLevels;
  var qualityLevelList = new QualityLevelList();
  var disposeHandler = function disposeHandler2() {
    qualityLevelList.dispose();
    player.qualityLevels = originalPluginFn;
    player.off("dispose", disposeHandler2);
  };
  player.on("dispose", disposeHandler);
  player.qualityLevels = function() {
    return qualityLevelList;
  };
  player.qualityLevels.VERSION = version3;
  return qualityLevelList;
};
var qualityLevels = function qualityLevels2(options) {
  return initPlugin3(this, video_es_default.mergeOptions({}, options));
};
registerPlugin("qualityLevels", qualityLevels);
qualityLevels.VERSION = version3;

// node_modules/.pnpm/videojs-hls-quality-selector@1.1.4/node_modules/videojs-hls-quality-selector/dist/videojs-hls-quality-selector.es.js
var version4 = "1.1.4";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var asyncGenerator = function() {
  function AwaitValue(value) {
    this.value = value;
  }
  function AsyncGenerator(gen) {
    var front, back;
    function send(key, arg) {
      return new Promise(function(resolve, reject) {
        var request = {
          key,
          arg,
          resolve,
          reject,
          next: null
        };
        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }
    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;
        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function(arg2) {
            resume("next", arg2);
          }, function(arg2) {
            resume("throw", arg2);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }
    function settle(type2, value) {
      switch (type2) {
        case "return":
          front.resolve({
            value,
            done: true
          });
          break;
        case "throw":
          front.reject(value);
          break;
        default:
          front.resolve({
            value,
            done: false
          });
          break;
      }
      front = front.next;
      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }
    this._invoke = send;
    if (typeof gen.return !== "function") {
      this.return = void 0;
    }
  }
  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  AsyncGenerator.prototype.next = function(arg) {
    return this._invoke("next", arg);
  };
  AsyncGenerator.prototype.throw = function(arg) {
    return this._invoke("throw", arg);
  };
  AsyncGenerator.prototype.return = function(arg) {
    return this._invoke("return", arg);
  };
  return {
    wrap: function(fn) {
      return function() {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function(value) {
      return new AwaitValue(value);
    }
  };
}();
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var inherits = function(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};
var possibleConstructorReturn = function(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
};
var VideoJsButtonClass = video_es_default.getComponent("MenuButton");
var VideoJsMenuClass = video_es_default.getComponent("Menu");
var VideoJsComponent = video_es_default.getComponent("Component");
var Dom2 = video_es_default.dom;
function toTitleCase4(string) {
  if (typeof string !== "string") {
    return string;
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}
var ConcreteButton = function(_VideoJsButtonClass) {
  inherits(ConcreteButton2, _VideoJsButtonClass);
  function ConcreteButton2(player) {
    classCallCheck(this, ConcreteButton2);
    return possibleConstructorReturn(this, _VideoJsButtonClass.call(this, player, {
      title: player.localize("Quality"),
      name: "QualityButton"
    }));
  }
  ConcreteButton2.prototype.createItems = function createItems() {
    return [];
  };
  ConcreteButton2.prototype.createMenu = function createMenu() {
    var menu = new VideoJsMenuClass(this.player_, {
      menuButton: this
    });
    this.hideThreshold_ = 0;
    if (this.options_.title) {
      var titleEl = Dom2.createEl("li", {
        className: "vjs-menu-title",
        innerHTML: toTitleCase4(this.options_.title),
        tabIndex: -1
      });
      var titleComponent = new VideoJsComponent(this.player_, {
        el: titleEl
      });
      this.hideThreshold_ += 1;
      menu.addItem(titleComponent);
    }
    this.items = this.createItems();
    if (this.items) {
      for (var i = 0; i < this.items.length; i++) {
        menu.addItem(this.items[i]);
      }
    }
    return menu;
  };
  return ConcreteButton2;
}(VideoJsButtonClass);
var VideoJsMenuItemClass = video_es_default.getComponent("MenuItem");
var ConcreteMenuItem = function(_VideoJsMenuItemClass) {
  inherits(ConcreteMenuItem2, _VideoJsMenuItemClass);
  function ConcreteMenuItem2(player, item, qualityButton, plugin) {
    classCallCheck(this, ConcreteMenuItem2);
    var _this = possibleConstructorReturn(this, _VideoJsMenuItemClass.call(this, player, {
      label: item.label,
      selectable: true,
      selected: item.selected || false
    }));
    _this.item = item;
    _this.qualityButton = qualityButton;
    _this.plugin = plugin;
    return _this;
  }
  ConcreteMenuItem2.prototype.handleClick = function handleClick() {
    for (var i = 0; i < this.qualityButton.items.length; ++i) {
      this.qualityButton.items[i].selected(false);
    }
    this.plugin.setQuality(this.item.value);
    this.selected(true);
  };
  return ConcreteMenuItem2;
}(VideoJsMenuItemClass);
var defaults4 = {};
var registerPlugin2 = video_es_default.registerPlugin || video_es_default.plugin;
var HlsQualitySelectorPlugin = function() {
  function HlsQualitySelectorPlugin2(player, options) {
    classCallCheck(this, HlsQualitySelectorPlugin2);
    this.player = player;
    this.config = options;
    if (this.player.qualityLevels && this.getHls()) {
      this.createQualityButton();
      this.bindPlayerEvents();
    }
  }
  HlsQualitySelectorPlugin2.prototype.getHls = function getHls() {
    return this.player.tech({
      IWillNotUseThisInPlugins: true
    }).hls;
  };
  HlsQualitySelectorPlugin2.prototype.bindPlayerEvents = function bindPlayerEvents() {
    this.player.qualityLevels().on("addqualitylevel", this.onAddQualityLevel.bind(this));
  };
  HlsQualitySelectorPlugin2.prototype.createQualityButton = function createQualityButton() {
    var player = this.player;
    this._qualityButton = new ConcreteButton(player);
    var placementIndex = player.controlBar.children().length - 2;
    var concreteButtonInstance = player.controlBar.addChild(this._qualityButton, {
      componentClass: "qualitySelector"
    }, this.config.placementIndex || placementIndex);
    concreteButtonInstance.addClass("vjs-quality-selector");
    if (!this.config.displayCurrentQuality) {
      var icon = " " + (this.config.vjsIconClass || "vjs-icon-hd");
      concreteButtonInstance.menuButton_.$(".vjs-icon-placeholder").className += icon;
    } else {
      this.setButtonInnerText("auto");
    }
    concreteButtonInstance.removeClass("vjs-hidden");
  };
  HlsQualitySelectorPlugin2.prototype.setButtonInnerText = function setButtonInnerText(text) {
    this._qualityButton.menuButton_.$(".vjs-icon-placeholder").innerHTML = text;
  };
  HlsQualitySelectorPlugin2.prototype.getQualityMenuItem = function getQualityMenuItem(item) {
    var player = this.player;
    return new ConcreteMenuItem(player, item, this._qualityButton, this);
  };
  HlsQualitySelectorPlugin2.prototype.onAddQualityLevel = function onAddQualityLevel() {
    var _this = this;
    var player = this.player;
    var qualityList = player.qualityLevels();
    var levels = qualityList.levels_ || [];
    var levelItems = [];
    var _loop = function _loop2(i2) {
      if (!levelItems.filter(function(_existingItem) {
        return _existingItem.item && _existingItem.item.value === levels[i2].height;
      }).length) {
        var levelItem = _this.getQualityMenuItem.call(_this, {
          label: levels[i2].height + "p",
          value: levels[i2].height
        });
        levelItems.push(levelItem);
      }
    };
    for (var i = 0; i < levels.length; ++i) {
      _loop(i);
    }
    levelItems.sort(function(current, next) {
      if ((typeof current === "undefined" ? "undefined" : _typeof(current)) !== "object" || (typeof next === "undefined" ? "undefined" : _typeof(next)) !== "object") {
        return -1;
      }
      if (current.item.value < next.item.value) {
        return -1;
      }
      if (current.item.value > next.item.value) {
        return 1;
      }
      return 0;
    });
    levelItems.push(this.getQualityMenuItem.call(this, {
      label: player.localize("Auto"),
      value: "auto",
      selected: true
    }));
    if (this._qualityButton) {
      this._qualityButton.createItems = function() {
        return levelItems;
      };
      this._qualityButton.update();
    }
  };
  HlsQualitySelectorPlugin2.prototype.setQuality = function setQuality(height2) {
    var qualityList = this.player.qualityLevels();
    this._currentQuality = height2;
    if (this.config.displayCurrentQuality) {
      this.setButtonInnerText(height2 === "auto" ? height2 : height2 + "p");
    }
    for (var i = 0; i < qualityList.length; ++i) {
      var quality = qualityList[i];
      quality.enabled = quality.height === height2 || height2 === "auto";
    }
    this._qualityButton.unpressButton();
  };
  HlsQualitySelectorPlugin2.prototype.getCurrentQuality = function getCurrentQuality() {
    return this._currentQuality || "auto";
  };
  return HlsQualitySelectorPlugin2;
}();
var onPlayerReady = function onPlayerReady2(player, options) {
  player.addClass("vjs-hls-quality-selector");
  player.hlsQualitySelector = new HlsQualitySelectorPlugin(player, options);
};
var hlsQualitySelector = function hlsQualitySelector2(options) {
  var _this2 = this;
  this.ready(function() {
    onPlayerReady(_this2, video_es_default.mergeOptions(defaults4, options));
  });
};
registerPlugin2("hlsQualitySelector", hlsQualitySelector);
hlsQualitySelector.VERSION = version4;

// src/app/player/components/vjs-player/vjs-player.component.ts
var _c02 = ["target"];
var VjsPlayerComponent = class _VjsPlayerComponent {
  /**
   * Instantiate Video.js on component init
   */
  ngOnInit() {
    this.player = video_es_default(this.target.nativeElement, __spreadProps(__spreadValues({}, this.options), {
      autoplay: true
    }), function onPlayerReady3() {
      this.volume(100);
    });
    this.player.hlsQualitySelector({
      displayCurrentQuality: true
    });
    this.player["aspectRatioPanel"]();
  }
  /**
   * Replaces the url source of the player with the changed source url
   * @param changes contains changed channel object
   */
  ngOnChanges(changes) {
    if (changes.options.previousValue) {
      this.player.src(changes.options.currentValue.sources[0]);
    }
  }
  /**
   * Removes the players HTML reference on destroy
   */
  ngOnDestroy() {
    if (this.player) {
      this.player.dispose();
    }
  }
  static {
    this.\u0275fac = function VjsPlayerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _VjsPlayerComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _VjsPlayerComponent, selectors: [["app-vjs-player"]], viewQuery: function VjsPlayerComponent_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c02, 7);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.target = _t.first);
      }
    }, inputs: { options: "options" }, standalone: true, features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature], decls: 3, vars: 0, consts: [["target", ""], ["controls", "", "muted", "", "playsinline", "", "preload", "none", "data-setup", '{"liveui": true, "muted": false}', 1, "video-js"]], template: function VjsPlayerComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275element(0, "video", 1, 0);
        \u0275\u0275text(2, "\n");
      }
    }, styles: ["/* src/app/player/components/vjs-player/vjs-player.component.scss */\n.video-js {\n  position: relative !important;\n  width: 100% !important;\n  height: calc(100vh - 65px);\n}\n.hide-captions .vjs-texttrack-settings,\n.hide-captions .vjs-text-track-display,\n.hide-captions .vjs-subs-caps-button {\n  display: none;\n}\n@media only screen and (max-width: 599px) {\n  .video-js {\n    height: calc(50vh - 65px) !important;\n  }\n}\n"], encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(VjsPlayerComponent, { className: "VjsPlayerComponent" });
})();

export {
  HtmlVideoPlayerComponent,
  VjsPlayerComponent
};
/*! Bundled license information:

keycode/index.js:
  (*!
   * Programatically add the following
   *)

@videojs/xhr/lib/index.js:
  (**
   * @license
   * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>
   * Copyright (c) 2014 David Björklund
   * Available under the MIT license
   * <https://github.com/kesla/parse-headers/blob/master/LICENCE>
   *)

m3u8-parser/dist/m3u8-parser.es.js:
  (*! @name m3u8-parser @version 4.7.1 @license Apache-2.0 *)

mpd-parser/dist/mpd-parser.es.js:
  (*! @name mpd-parser @version 0.21.1 @license Apache-2.0 *)

video.js/dist/video.es.js:
  (**
   * @license
   * Video.js 7.20.3 <http://videojs.com/>
   * Copyright Brightcove, Inc. <https://www.brightcove.com/>
   * Available under Apache License Version 2.0
   * <https://github.com/videojs/video.js/blob/main/LICENSE>
   *
   * Includes vtt.js <https://github.com/mozilla/vtt.js>
   * Available under Apache License Version 2.0
   * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>
   *)
  (*! @name @videojs/http-streaming @version 2.14.3 @license Apache-2.0 *)
  (*! @name pkcs7 @version 1.0.4 @license Apache-2.0 *)
  (*! @name aes-decrypter @version 3.1.3 @license Apache-2.0 *)

@yangkghjh/videojs-aspect-ratio-panel/dist/videojs-aspect-ratio-panel.es.js:
  (*! @name @yangkghjh/videojs-aspect-ratio-panel @version 0.0.1 @license MIT *)

videojs-contrib-quality-levels/dist/videojs-contrib-quality-levels.es.js:
  (*! @name videojs-contrib-quality-levels @version 2.2.0 @license Apache-2.0 *)
*/
